<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2016/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="ACPI_Source_Language_Reference.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 19 ACPI Source Language (ASL) Reference</TITLE></HEAD>
<BODY>
<DIV>
<H1 CLASS="Heading-1">
<A NAME="pgfId-1354531"></A><A NAME="94069"></A>ACPI Source Language (ASL) Reference<DIV>
<IMG SRC="ACPI_Source_Language_Reference-1.gif" ALT="">
</DIV>
</H1>
<P CLASS="Body">
<A NAME="pgfId-1381934"></A>This section formally defines the ACPI Source Language (ASL). ASL is a source language for defining ACPI objects including writing ACPI control methods. OEMs and platform firmware developers define objects and write control methods in ASL and then use a translator tool (compiler) to generate ACPI Machine Language (AML) versions of the control methods. For a formal definition of AML, see the <A HREF="ACPI_Machine_Language_Specification.htm#35965" CLASS="XRef">See ACPI Machine Language (AML) Specification.</A> chapter. <A NAME="marker-1563929"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357423"></A>AML and ASL are different languages though they are closely related.</P>
<P CLASS="Body">
<A NAME="pgfId-1357424"></A>Every ACPI-compatible OS must support AML. A given user can define some arbitrary source language (to replace ASL) and write a tool to translate it to AML. <A NAME="marker-1563912"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357426"></A>An OEM or platform firmware vendor needs to write ASL and be able to single-step AML for debugging. (Debuggers and similar tools are expected to be AML-level tools, not source-level tools.) An ASL translator implementer must understand how to read ASL and generate AML. An AML interpreter author must understand how to execute AML.<A NAME="marker-1357427"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357428"></A>This section has two parts:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357429"></A>The ASL grammar, which is the formal ASL specification and also serves as a quick reference.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357430"></A>A full ASL reference, which includes for each ASL operator: the operator invocation syntax, the type of each argument, and a description of the action and use of the operator.</LI>
</UL>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1552193"></A><A NAME="12623"></A>ASL 2.0 Symbolic Operators and Expressions</H2>
<P CLASS="Body">
<A NAME="pgfId-1552194"></A>For the math and logical operations, ASL supports standard symbolic operators and expressions that are similar to the C language. Compound assignment operators are also supported. The AML code that is generated from the symbolic operators and expressions is identical to the AML code generated for the equivalent legacy ASL operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1552195"></A>The table below summarizes the ASL 2.0 support for symbolic operators.</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1552197"></A>ASL 2.0 Syntax    Legacy ASL Equivalent</H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1552198"></A>       </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552199"></A>    // Math operators</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552200"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552201"></A>      Z = X + Y      Add (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552202"></A>      Z = X / Y      Divide (X, Y, , Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552203"></A>      Z = X % Y      Mod (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552204"></A>      Z = X * Y      Multiply (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552205"></A>      Z = X - Y      Subtract (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552206"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552207"></A>      Z = X &lt;&lt; Y     ShiftLeft (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552208"></A>      Z = X &gt;&gt; Y     ShiftRight (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552209"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552210"></A>      Z = X &amp; Y      And (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552211"></A>      Z = X | Y      Or (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552212"></A>      Z = X ^ Y      Xor (X, Y, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552213"></A>      Z = &#126;X	         Not (X, Z)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552214"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552215"></A>      X++	            Increment (X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552216"></A>      X--	Decrement (X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552217"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552218"></A>    // Logical operators</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552219"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552220"></A>      (X == Y)       LEqual (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552221"></A>      (X != Y)       LNotEqual (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552222"></A>      (X &lt; Y)        LLess (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552223"></A>      (X &gt; Y)        LGreater (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552224"></A>      (X &lt;= Y)       LLessEqual (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552225"></A>      (X &gt;= Y)       	LGreaterEqual (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552226"></A>      (X &amp;&amp; Y)       	LAnd (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552227"></A>      (X || Y)       	LOr (X, Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552228"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552229"></A>      !X	             LNot (X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552230"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552231"></A>    // Assignment and Compound Assignment operations</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552232"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552233"></A>      X = Y	          Store (Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552234"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552235"></A>      X += Y         Add (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552236"></A>      X /= Y         Divide (X, Y, , X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552237"></A>      X %= Y         Mod (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552238"></A>      X *= Y         Multiply (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552239"></A>      X -= Y         Subtract (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552240"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552241"></A>      X &lt;&lt;= Y        ShiftLeft (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552242"></A>      X &gt;&gt;= Y        ShiftRight (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552243"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552244"></A>      X &amp;= Y         And (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552245"></A>      X |= Y         Or (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552246"></A>      X ^= Y         Xor (X, Y, X)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552247"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552248"></A>    // Miscellaneous</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552249"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1552186"></A>      Z = X[Y]      Index (X, Y, Z)</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1357454"></A><A NAME="_Toc489272732"></A><A NAME="_Toc4819440"></A><A NAME="_Toc202341937"></A><A NAME="_Toc258262573"></A>ASL Language Grammar<A NAME="marker-1553123"></A><A NAME="marker-1553124"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1357455"></A>The purpose of this section is to state unambiguously the grammar rules used by the syntax checker of an ASL compiler. <A NAME="marker-1357456"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357457"></A>ASL statements declare objects. Each object has three parts, two of which might not be present.</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1357459"></A>Object := ObjectType  FixedList  VariableList</P>
<P CLASS="Body">
<A NAME="pgfId-1357460"></A>FixedList refers to a list, of known length, that supplies data that all instances of a given ObjectType must have. A fixed list is written as ( a , b , c , ... ) where the number of arguments depends on the specific ObjectType, and some elements can be nested objects, that is (a, b, (q, r, s, t), d). Arguments to a FixedList can have default values, in which case they can be skipped. Thus, (a,,c) will cause the default value for the second argument to be used. Some ObjectTypes can have a null FixedList, which is simply omitted. Trailing arguments of some object types can be left out of a fixed list, in which case the default value is used.<A NAME="marker-1357461"></A><A NAME="marker-1357462"></A><A NAME="marker-1357463"></A><A NAME="marker-1357464"></A><A NAME="marker-1357465"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357466"></A>VariableList refers to a list, not of predetermined length, of child objects that help define the parent. It is written as { x, y, z, aa, bb, cc } where any argument can be a nested object. ObjectType determines what terms are legal elements of the VariableList. Some ObjectTypes may have a null variable list, which is simply omitted.<A NAME="marker-1357467"></A><A NAME="marker-1357468"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357471"></A>Other rules for writing ASL statements are the following:<A NAME="marker-1357469"></A><A NAME="marker-1357470"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357472"></A>Multiple blanks are the same as one. Blank, (, ), &#8216;,&#8217; and newline are all token separators.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357473"></A>// marks the beginning of a comment, which continues from the // to the end of the line.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357474"></A>/* marks the beginning of a comment, which continues from the /* to the next */.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357476"></A>&#8220;&#8221; (quotes) surround an ASCII string.<A NAME="marker-1357475"></A></LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357482"></A>Numeric constants can be written in three ways: ordinary decimal, octal (using 0ddd) or hexadecimal, using the notation 0xdd.<A NAME="marker-1357483"></A></LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357490"></A><A NAME="marker-1357484"></A><A NAME="marker-1357485"></A><A NAME="marker-1357486"></A>Nothing indicates an empty item. For example, { Nothing } is equivalent to {}.<A NAME="marker-1357489"></A></LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357513"></A><A NAME="_Toc489272733"></A><A NAME="_Toc4819441"></A><A NAME="_Toc202341938"></A><A NAME="_Toc258262574"></A>ASL Grammar Notation<A NAME="marker-1357510"></A><A NAME="marker-1357511"></A><A NAME="marker-1357512"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1357514"></A>The notation used to express the ASL grammar is specified in the following table.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1357515"></A>ASL Grammar Notation</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1488244"></A>Notation Convention</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1488246"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1488248"></A>Example</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357525"></A>Term := Term Term ...<A NAME="marker-1568456"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357527"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357529"></A>The term to the left of := can be expanded into the sequence of terms on the right.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357531"></A>aterm := bterm cterm means that aterm can be expanded into the two-term sequence of bterm followed by cterm.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357534"></A>Angle brackets (&lt; &gt; )<A NAME="marker-1568464"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357537"></A><A NAME="marker-1568466"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357539"></A>Used to group items.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357541"></A>&lt;a b&gt; | &lt;c d&gt; means either </P>
<P CLASS="TableBody">
<A NAME="pgfId-1357542"></A>a b or c d. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357545"></A>Arrow (=&gt;)<A NAME="marker-1568474"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357547"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357549"></A>Indicates required run-time reduction of an ASL argument to an AML data type. Means &#8220;reduces to&#8221; or &#8220;evaluates to&#8221; at run-time.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357551"></A>&#8220;TermArg =&gt; Integer&#8221; means that the argument must be an ASL TermArg that must resolve to an Integer data type when it is evaluated by an AML interpreter.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357554"></A>Bar symbol ( | )<A NAME="marker-1568482"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357556"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357558"></A>Separates alternatives.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357560"></A>aterm := bterm | &lt;cterm dterm&gt; means the following constructs are possible:</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1357561"></A>   bterm </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1357562"></A>   cterm dterm</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1357563"></A>aterm := &lt;bterm | cterm&gt; dterm means the following constructs are possible:</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1357564"></A>   bterm dterm</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1357565"></A>   cterm dterm</LI>
</UL>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357567"></A>Term Term Term</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357569"></A>Terms separated from each other by spaces form an ordered list.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357571"></A>N/A</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357574"></A>Word in bold<A NAME="marker-1568501"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357576"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357578"></A>Denotes the name of a term in the ASL grammar, representing any instance of such a term. ASL terms are not case-sensitive.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357580"></A>In the following ASL term definition:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357581"></A>ThermalZone (ZoneName) {TermList}</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357582"></A>the item in bold is the name of the term.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357585"></A>Word in italics<A NAME="marker-1568511"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357587"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357589"></A>Names of arguments to objects that are replaced for a given instance.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357591"></A>In the following ASL term definition:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357592"></A>ThermalZone (ZoneName) {TermList}</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357593"></A>the italicized item is an argument. The item that is not bolded or italicized is defined elsewhere in the ASL grammar.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357596"></A>Single quotes (&#8216; &#8217;)<A NAME="marker-1568521"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357599"></A><A NAME="marker-1568523"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357601"></A>Indicate constant characters.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357603"></A>&#8216;A&#8217;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357605"></A>0xdd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357607"></A>Refers to a byte value expressed as two hexadecimal digits.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357609"></A>0x21 means a value of hexadecimal 21, or decimal 37. Notice that a value expressed in hexadecimal must start with a leading zero (0). </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357612"></A>Dash character ( - )<A NAME="marker-1568536"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357614"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357616"></A>Indicates a range.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357618"></A>1-9 means a single digit in the range 1 to 9 inclusive.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357639"></A><A NAME="_Toc489272734"></A><A NAME="_Toc4819442"></A><A NAME="_Toc202341939"></A><A NAME="_Toc258262575"></A>ASL Name and Pathname Terms<A NAME="marker-1357637"></A><A NAME="marker-1357638"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357641"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1516520"></A>// Name and path characters supported</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357642"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357643"></A>LeadNameChar :=<BR>
    &#8216;A&#8217;-&#8216;Z&#8217; | &#8216;a&#8217;-&#8216;z&#8217; | &#8216;_&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357644"></A>DigitChar :=<BR>
    &#8216;0&#8217;-&#8216;9&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357645"></A>NameChar :=<BR>
    DigitChar | LeadNameChar</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357646"></A>RootChar :=<BR>
    &#8216;&#92;&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357647"></A>ParentPrefixChar :=<BR>
    &#8216;^&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357648"></A>PathSeparatorChar :=<BR>
    &#8216;.&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357649"></A>CommaChar :=<BR>
    &#8216;,&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357650"></A>SemicolonDelimiter :=<BR>
Nothing | &#8216;;&#8217; </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357651"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357652"></A>// Names and paths</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357653"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357654"></A>NameSeg :=<BR>
    &lt;LeadNameChar&gt; |<BR>
    &lt;LeadNameChar NameChar&gt; |<BR>
    &lt;LeadNameChar NameChar NameChar&gt; |<BR>
    &lt;LeadNameChar NameChar NameChar NameChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357655"></A>NameString :=<BR>
    &lt;RootChar NamePath&gt; | &lt;ParentPrefixChar PrefixPath NamePath&gt; | NonEmptyNamePath</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357656"></A>NamePath :=<BR>
    Nothing | &lt;NameSeg NamePathTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357657"></A>NamePathTail :=<BR>
    Nothing | &lt;PathSeparatorChar NameSeg NamePathTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357658"></A>NonEmptyNamePath :=<BR>
    NameSeg | &lt;NameSeg NamePathTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357659"></A>PrefixPath :=<BR>
    Nothing | &lt;ParentPrefixChar PrefixPath&gt; </P>
<P CLASS="Body">
<A NAME="pgfId-1537929"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1537935"></A><A NAME="_Toc489272735"></A><A NAME="_Toc4819443"></A><A NAME="_Toc202341940"></A><A NAME="_Toc258262576"></A>ASL Root and Secondary Terms<A NAME="marker-1553225"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357680"></A>// Root Term</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357681"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357682"></A>ASLCode := <BR>
    DefinitionBlockList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1559865"></A>DefinitionBlockList :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1559866"></A>    DefinitionBlockTerm | &lt;DefinitionBlockTerm DefinitionBlockList&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357683"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357684"></A>// Major Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357685"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549081"></A>SuperName :=<BR>
    NameString | ArgTerm | LocalTerm | DebugTerm | Type6Opcode | MethodInvocationTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549082"></A>Target :=<BR>
    Nothing | SuperName</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549085"></A>TermArg :=<BR>
    Type2Opcode | DataObject | ArgTerm | LocalTerm | NameString | SymbolicExpression</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549086"></A>MethodInvocationTerm :=<BR>
    NameString(    // NameString =&gt; Method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1516546"></A>        ArgList<BR>
    ) =&gt; Nothing | DataRefObject</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357690"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357691"></A>// List Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357692"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357693"></A>ArgList :=<BR>
    Nothing | &lt;TermArg ArgListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357694"></A>ArgListTail :=<BR>
    Nothing | &lt;CommaChar TermArg ArgListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357695"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357696"></A>ByteList :=<BR>
    Nothing | &lt;ByteConstExpr ByteListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357697"></A>ByteListTail :=<BR>
    Nothing | &lt;CommaChar ByteConstExpr ByteListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357698"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357699"></A>DWordList :=<BR>
    Nothing | &lt;DWordConstExpr DWordListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357700"></A>DWordListTail :=<BR>
    Nothing | &lt;CommaChar DWordConstExpr DWordListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538061"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538047"></A>ExtendedAccessAttribTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538048"></A>    ExtendedAccessAttribKeyword (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538049"></A>           AccessLength         //ByteConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538050"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357701"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357702"></A>FieldUnitList :=<BR>
    Nothing | &lt;FieldUnit FieldUnitListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538009"></A>FieldUnitListTail :=<BR>
    Nothing | &lt;CommaChar FieldUnit FieldUnitListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538032"></A>FieldUnit :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538033"></A>    FieldUnitEntry | OffsetTerm | AccessAsTerm | ConnectionTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538011"></A>FieldUnitEntry :=<BR>
    &lt;Nothing | NameSeg&gt; CommaChar Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357706"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357710"></A>PackageList :=<BR>
    Nothing | &lt;PackageElement PackageListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357711"></A>PackageListTail :=<BR>
    Nothing | &lt;CommaChar PackageElement PackageListTail&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357712"></A>PackageElement :=<BR>
    DataObject | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357713"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357714"></A>ParameterTypePackage :=<BR>
    ObjectTypeKeyword | {Nothing | ParameterTypePackageList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357715"></A>ParameterTypePackageList :=<BR>
    ObjectTypeKeyword | &lt;ObjectTypeKeyword CommaChar ParameterTypePackageList&gt; </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357716"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357717"></A>ParameterTypesPackage :=<BR>
    ObjectTypeKeyword | {Nothing | ParameterTypesPackageList} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357718"></A>ParameterTypesPackageList :=<BR>
    ParameterTypePackage | &lt;ParameterTypePackage CommaChar ParameterTypesPackageList&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357719"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357720"></A>TermList :=<BR>
    Nothing | &lt;Term SemicolonDelimiter TermList&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357721"></A>Term :=<BR>
    Object | Type1Opcode | Type2Opcode | SymbolicExpression</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357708"></A>Object :=<BR>
CompilerDirective | NamedObject | NameSpaceModifier </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357722"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357723"></A>// Conditional Execution List Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357724"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357725"></A>CaseTermList :=<BR>
    Nothing | CaseTerm | DefaultTerm DefaultTermList | CaseTerm CaseTermList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357726"></A>DefaultTermList :=<BR>
    Nothing | CaseTerm | CaseTerm DefaultTermList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357727"></A>IfElseTerm :=<BR>
    IfTerm ElseTerm</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1538024"></A><A NAME="_Toc202341941"></A><A NAME="_Toc258262577"></A>ASL Data and Constant Terms<A NAME="marker-1538023"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357734"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1516560"></A>// Numeric Value Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357735"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517215"></A>LeadDigitChar :=<BR>
    &#8216;1&#8217;-&#8216;9&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517216"></A>HexDigitChar :=<BR>
    DigitChar | &#8216;A&#8217;-&#8216;F&#8217; | &#8216;a&#8217;-&#8216;f&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357738"></A>OctalDigitChar :=<BR>
    &#8216;0&#8217;-&#8216;7&#8217; </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357739"></A>NullChar :=<BR>
    0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357740"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357741"></A>// Data Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357742"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357743"></A>DataObject :=<BR>
    BufferData | PackageData | IntegerData | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357744"></A>DataRefObject :=<BR>
    DataObject | ObjectReference | DDBHandle</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357745"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357746"></A>ComputationalData :=<BR>
    BufferData | IntegerData | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357747"></A>BufferData :=<BR>
    Type5Opcode | BufferTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357748"></A>IntegerData :=<BR>
    Type3Opcode | Integer | ConstTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357749"></A>PackageData :=<BR>
    PackageTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357750"></A>StringData :=<BR>
    Type4Opcode | String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357751"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357752"></A>// Integer Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357753"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357754"></A>Integer :=<BR>
    DecimalConst | OctalConst | HexConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357755"></A>DecimalConst :=<BR>
    LeadDigitChar | &lt;DecimalConst DigitChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357756"></A>OctalConst :=<BR>
    &#8216;0&#8217; | &lt;OctalConst OctalDigitChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357757"></A>HexConst :=<BR>
    &lt;0x HexDigitChar&gt; | &lt;0X HexDigitChar&gt; | &lt;HexConst HexDigitChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357758"></A>ByteConst :=<BR>
    Integer =&gt; 0x00-0xFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357759"></A>WordConst :=<BR>
    Integer =&gt; 0x0000-0xFFFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357760"></A>DWordConst :=<BR>
    Integer =&gt; 0x00000000-0xFFFFFFFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357761"></A>QWordConst :=<BR>
    Integer =&gt; 0x0000000000000000-0xFFFFFFFFFFFFFFFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357762"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357763"></A>ByteConstExpr :=<BR>
    &lt;Type3Opcode | ConstExprTerm | Integer&gt; =&gt; ByteConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357764"></A>WordConstExpr :=<BR>
    &lt;Type3Opcode | ConstExprTerm | Integer&gt; =&gt; WordConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357765"></A>DWordConstExpr :=<BR>
    &lt;Type3Opcode | ConstExprTerm | Integer&gt; =&gt; DWordConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357766"></A>QWordConstExpr :=<BR>
    &lt;Type3Opcode | ConstExprTerm | Integer&gt; =&gt; QWordConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357767"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357768"></A>ConstTerm :=<BR>
    ConstExprTerm | Revision</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357769"></A>ConstExprTerm :=<BR>
    Zero | One | Ones</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357770"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357771"></A>// String Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357772"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357773"></A>String :=<BR>
    &#8216;&#8221;&#8217; Utf8CharList &#8216;&#8221;&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357774"></A>Utf8CharList :=<BR>
    Nothing | &lt;EscapeSequence Utf8CharList&gt; | &lt;Utf8Char Utf8CharList&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357775"></A>Utf8Char :=<BR>
    0x01-0x21 | <BR>
    0x23-0x5B | <BR>
    0x5D-0x7F |<BR>
    0xC2-0xDF 0x80-0xBF |<BR>
    0xE0 0xA0-0xBF 0x80-0xBF |<BR>
    0xE1-0xEC 0x80-0xBF 0x80-0xBF |<BR>
    0xED 0x80-0x9F 0x80-0xBF |<BR>
    0xEE-0xEF 0x80-0xBF 0x80-0xBF |<BR>
    0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF |<BR>
    0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF<BR>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357776"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357777"></A>// Escape sequences</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357778"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357779"></A>EscapeSequence :=<BR>
    SimpleEscapeSequence | OctalEscapeSequence | HexEscapeSequence</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357780"></A>HexEscapeSequence :=<BR>
    &#92;x HexDigitChar |<BR>
    &#92;x HexDigitChar HexDigitChar</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357781"></A>SimpleEscapeSequence :=<BR>
    &#92;' | &#92;&quot; | &#92;a | &#92;b | &#92;f | &#92;n | &#92;r | &#92;t | &#92;v | &#92;&#92;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1516578"></A>OctalEscapeSequence :=<BR>
    &#92; OctalDigitChar |<BR>
    &#92; OctalDigitChar OctalDigitChar |<BR>
    &#92; OctalDigitChar OctalDigitChar OctalDigitChar</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357783"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357784"></A>// Miscellaneous Data Type Terms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357785"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357786"></A>DDBHandle :=<BR>
    Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357787"></A>ObjectReference :=<BR>
    Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357788"></A>Boolean :=<BR>
    True | False</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357789"></A>True :=<BR>
    Ones</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357790"></A>False :=<BR>
    Zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553259"></A> // Symbolic Operator terms </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553260"></A>Operators :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553261"></A>     '+' | '-' | '*' | '/' | '%' | '&amp;' | '|' | '^' | '&#126;' | '&lt;' | '&gt;' | '!' | '='</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553262"></A>CompoundOperators :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553263"></A>     &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;++&quot; | &quot;-&quot; | &quot;==&quot; | &quot;!=&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;&amp;&amp;&quot; | &quot;||&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553285"></A>     &quot;/=&quot; | &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357797"></A><A NAME="_Toc202341942"></A><A NAME="_Toc258262578"></A>ASL Opcode Terms<A NAME="marker-1357795"></A><A NAME="marker-1357796"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357799"></A>CompilerDirective :=<BR>
    IncludeTerm | ExternalTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357800"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357801"></A>NamedObject :=<BR>
    BankFieldTerm | CreateBitFieldTerm | CreateByteFieldTerm | CreateDWordFieldTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517833"></A>    CreateFieldTerm | CreateQWordFieldTerm | CreateWordFieldTerm | DataRegionTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517854"></A>    DeviceTerm | EventTerm | FieldTerm | FunctionTerm | IndexFieldTerm | MethodTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517863"></A>    MutexTerm | OpRegionTerm | PowerResTerm | ProcessorTerm | ThermalZoneTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357802"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357803"></A>NameSpaceModifier :=<BR>
    AliasTerm | NameTerm | ScopeTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553431"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553302"></A>SymbolicExpressionTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553303"></A>     ( TermArg ) |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553304"></A>     AddSymbolicTerm | AndSymbolicTerm | DecSymbolicTerm | DivideSymbolicTerm | IncSymbolicTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553333"></A>     LAndSymbolicTerm | LEqualSymbolicTerm | LGreaterEqualSymbolicTerm | LGreaterSymbolicTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553340"></A>     LLessEqualSymbolicTerm | LLessSymbolicTerm | LNotEqualSymbolicTerm | LNotSymbolicTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553349"></A>     LOrSymbolicTerm | ModSymbolicTerm | MultiplySymbolicTerm | NotSymbolicTerm |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553359"></A>     OrSymbolicTerm | ShiftLeftSymbolicTerm | ShiftRightSymbolicTerm | SubtractSymbolicTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553366"></A>     XorSymbolicTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553305"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553306"></A>SymbolicAssignmentTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553296"></A>     StoreSymbolicTerm | AddCompoundTerm | AndCompoundTerm | DivideCompoundTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553378"></A>     ModCompoundTerm | MultiplyCompoundTerm | OrCompoundTerm | ShiftLeftCompoundTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553387"></A>     ShiftRightCompoundTerm | SubtractCompoundTerm | XorCompoundTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357804"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357805"></A>Type1Opcode :=<BR>
BreakTerm | BreakPointTerm | ContinueTerm | FatalTerm | ForTerm | IfElseTerm | LoadTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517884"></A>    NoOpTerm | NotifyTerm | ReleaseTerm | ResetTerm | ReturnTerm | SignalTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517903"></A>    SleepTerm | StallTerm | SwitchTerm | UnloadTerm | WhileTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357806"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357807"></A>A Type 1 opcode term does not return a value and can only be used standalone on a line of ASL code. Since these opcodes do not return a value they cannot be used as a term in an expression.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357808"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357809"></A>Type2Opcode :=<BR>
    AcquireTerm | AddTerm | AndTerm | ConcatTerm | ConcatResTerm | CondRefOfTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517936"></A>    CopyObjectTerm | DecTerm | DerefOfTerm | DivideTerm |FindSetLeftBitTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517945"></A>    FindSetRightBitTerm | FprintfTerm | FromBCDTerm | IncTerm | IndexTerm | LAndTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517954"></A>    LEqualTerm | LGreaterTerm | LGreaterEqualTerm | LLessTerm | LLessEqualTerm | LNotTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517961"></A>    LNotEqualTerm | LoadTableTerm | LOrTerm | MatchTerm | MidTerm |ModTerm | MultiplyTerm |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517975"></A>    NAndTerm | NOrTerm | NotTerm | ObjectTypeTerm | OrTerm | PrintfTerm |RefOfTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517968"></A>    ShiftLeftTerm | ShiftRightTerm | SizeOfTerm | StoreTerm | SubtractTerm | TimerTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517982"></A>    ToBCDTerm | ToBufferTerm | ToDecimalStringTerm | ToHexStringTerm | ToIntegerTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1517989"></A>    ToStringTerm | WaitTerm | XorTerm | MethodInvocationTerm | SymbolicExpressionTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553447"></A>    SymbolicAssignmentTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357810"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357811"></A>A Type 2 opcode returns a value and can be used in an expression.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357812"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357813"></A>Type3Opcode :=<BR>
    AddTerm | AndTerm | DecTerm | DerefOfTerm | DivideTerm | EISAIDTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518020"></A>    FindSetLeftBitTerm | FindSetRightBitTerm | FromBCDTerm | IncTerm | LAndTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518027"></A>    LEqualTerm | LGreaterTerm | LGreaterEqualTerm | LLessTerm | LLessEqualTerm | LNotTerm |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518050"></A>    LNotEqualTerm | LOrTerm | MatchTerm | ModTerm | MultiplyTerm | NAndTerm | NOrTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518059"></A>    NotTerm | OrTerm | ShiftLeftTerm | ShiftRightTerm | SubtractTerm | ToBCDTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518066"></A>    ToIntegerTerm | XorTerm | SymbolicExpressionTerm</P>
<P CLASS="Body">
<A NAME="pgfId-1357814"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357815"></A>The Type 3 opcodes are a subset of Type 2 opcodes that return an Integer value and can be used in an expression that evaluates to a constant. These opcodes may be evaluated at ASL compile-time. To ensure that these opcodes will evaluate to a constant, the following rules apply: The term cannot have a destination (target) operand, and must have either a Type3Opcode, Type4Opcode, Type5Opcode, ConstExprTerm, Integer, BufferTerm, Package, or String for all arguments.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357816"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357817"></A>Type4Opcode :=<BR>
    ConcatTerm | DerefOfTerm | FprintfTerm | MidTerm | PrintfTerm | ToDecimalStringTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549744"></A>    ToHexStringTerm | ToStringTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357818"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357819"></A>The Type 4 opcodes are a subset of Type 2 opcodes that return a String value and can be used in an expression that evaluates to a constant. These opcodes may be evaluated at ASL compile-time. To ensure that these opcodes will evaluate to a constant, the following rules apply: The term cannot have a destination (target) operand, and must have either a Type3Opcode, Type4Opcode, Type5Opcode, ConstExprTerm, Integer, BufferTerm, Package, or String for all arguments.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357820"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357821"></A>Type5Opcode :=<BR>
    ConcatTerm | ConcatResTerm | DerefOfTerm | MidTerm | ResourceTemplateTerm | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518097"></A>    ToBufferTerm | ToPLDTerm | ToUUIDTerm | UnicodeTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357822"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357823"></A>The Type 5 opcodes are a subset of Type 2 opcodes that return a Buffer value and can be used in an expression that evaluates to a constant. These opcodes may be evaluated at ASL compile-time. To ensure that these opcodes will evaluate to a constant, the following rules apply: The term cannot have a destination (target) operand, and must have either a Type3Opcode, Type4Opcode, Type5Opcode, ConstExprTerm, Integer, BufferTerm, Package, or String for all arguments.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357824"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1563617"></A>Type6Opcode :=<BR>
    RefOfTerm | DerefOfTerm | IndexTerm | IndexSymbolicTerm | UserTermObj</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549115"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548492"></A>The Type 6 opcodes are a subset of Type 2 opcodes that return a Reference value and can be used in an expression. They cannot be evaluated at compile time. Type 6 also includes the UserTerm, which is a control method invocation.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553298"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357830"></A><A NAME="_Toc202341943"></A><A NAME="_Toc258262579"></A>ASL Primary (Terminal) Terms<A NAME="marker-1357829"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1538085"></A>AccessAsTerm :=<BR>
    AccessAs (<BR>
        AccessType,        // AccessTypeKeyword         </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538090"></A>        AccessAttribute    // Nothing | ByteConstExpr | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538104"></A>                           // AccessAttribKeyword | ExtendedAccessAttribTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538097"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548410"></A>AcquireTerm :=<BR>
    Acquire (<BR>
        SyncObject,        // SuperName =&gt; Mutex<BR>
        TimeoutValue       // WordConstExpr<BR>
    ) =&gt; Boolean           // True means the operation timed out and the Mutex was not acquired</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548411"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553491"></A>AddCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553492"></A>    Addend1-Result         // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553493"></A>    +=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553494"></A>    Addend2                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553495"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553496"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553497"></A>AddSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553498"></A>    Addend1                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553499"></A>    +</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553500"></A>    Addend2                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553487"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357835"></A>AddTerm :=<BR>
    Add (<BR>
        Addend1,           // TermArg =&gt; Integer<BR>
        Addend2,           // TermArg =&gt; Integer<BR>
        Result             // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357836"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357837"></A>AliasTerm :=<BR>
    Alias (<BR>
        SourceObject,      // NameString<BR>
        AliasObject        // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553609"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553615"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553616"></A>AndCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553617"></A>    <EM CLASS="Italic">
Source1-Result</EM>
         // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553618"></A>    &amp;=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553619"></A>    <EM CLASS="Italic">
Source2                </EM>
// TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553620"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553621"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553622"></A>AndSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553623"></A>    <EM CLASS="Italic">
Source1</EM>
                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553624"></A>    &amp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553625"></A>    <EM CLASS="Italic">
Source2</EM>
                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553626"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553760"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357839"></A>AndTerm :=<BR>
    And (<BR>
        Source1,           // TermArg =&gt; Integer<BR>
        Source2,           // TermArg =&gt; Integer<BR>
        Result             // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357840"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357841"></A>ArgTerm :=<BR>
    Arg0 | Arg1 | Arg2 | Arg3 | Arg4 | Arg5 | Arg6</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357842"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357843"></A>BankFieldTerm :=<BR>
    BankField (<BR>
        RegionName,        // NameString =&gt; OperationRegion<BR>
        BankName,          // NameString =&gt; FieldUnit<BR>
        BankValue,         // TermArg =&gt; Integer<BR>
        AccessType,        // AccessTypeKeyword<BR>
        LockRule,          // LockRuleKeyword<BR>
        UpdateRule         // UpdateRuleKeyword<BR>
    ) {FieldUnitList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357844"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357845"></A>BreakPointTerm :=<BR>
    BreakPoint</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357846"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357847"></A>BreakTerm :=<BR>
    Break</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357848"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357849"></A>BufferTerm :=<BR>
    Buffer (<BR>
        BuffSize           // Nothing | TermArg =&gt; Integer<BR>
    ) {StringData | ByteList} =&gt; Buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357850"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357851"></A>CaseTerm :=<BR>
    Case (<BR>
        Value              // DataObject<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357852"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357853"></A>ConcatResTerm :=<BR>
    ConcatenateResTemplate (<BR>
        Source1,           // TermArg =&gt; Buffer<BR>
        Source2,           // TermArg =&gt; Buffer<BR>
        Result             // Target<BR>
    ) =&gt; Buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357854"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357855"></A>ConcatTerm :=<BR>
    Concatenate (<BR>
        Source1,           // TermArg =&gt; SuperName<BR>
        Source2,           // TermArg =&gt; SuperName<BR>
        Result             // Target<BR>
    ) =&gt; Buffer | String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357856"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538126"></A>ConnectionTerm := </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538127"></A>    Connection (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538128"></A>        ConnectionResource // NameString | ResourceMacroTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538129"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538118"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357857"></A>CondRefOfTerm :=<BR>
    CondRefOf (<BR>
        Source             // NameString | ArgTerm | LocalTerm | DerefOfTerm<BR>
        Destination        // Target<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357858"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357859"></A>ContinueTerm :=<BR>
    Continue</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518762"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1518763"></A>CopyObjectTerm :=<BR>
    CopyObject (<BR>
        Source,            // TermArg =&gt; DataRefObject<BR>
        Result,            // NameString | LocalTerm | ArgTerm<BR>
    ) =&gt; DataRefObject</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357862"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357863"></A>CreateBitFieldTerm :=<BR>
    CreateBitField (<BR>
        SourceBuffer,      // TermArg =&gt; Buffer<BR>
        BitIndex,          // TermArg =&gt; Integer<BR>
        BitFieldName       // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357864"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357865"></A>CreateByteFieldTerm :=<BR>
    CreateByteField (<BR>
        SourceBuffer,      // TermArg =&gt; Buffer<BR>
        ByteIndex,         // TermArg =&gt; Integer<BR>
        ByteFieldName      // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357866"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357867"></A>CreateDWordFieldTerm :=<BR>
    CreateDWordField (<BR>
        SourceBuffer,      // TermArg =&gt; Buffer<BR>
        ByteIndex,         // TermArg =&gt; Integer<BR>
        DWordFieldName     // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357868"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357869"></A>CreateFieldTerm :=<BR>
    CreateField (<BR>
        SourceBuffer,      // TermArg =&gt; Buffer<BR>
        BitIndex,           // TermArg =&gt; Integer<BR>
        NumBits,            // TermArg =&gt; Integer<BR>
        FieldName           // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357870"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357871"></A>CreateQWordFieldTerm :=<BR>
    CreateQWordField (<BR>
        SourceBuffer,       // TermArg =&gt; Buffer<BR>
        ByteIndex,          // TermArg =&gt; Integer<BR>
        QWordFieldName      // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357872"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357873"></A>CreateWordFieldTerm :=<BR>
    CreateWordField (<BR>
        SourceBuffer,       // TermArg =&gt; Buffer<BR>
        ByteIndex,          // TermArg =&gt; Integer<BR>
        WordFieldName       // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357874"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357875"></A>DataRegionTerm :=<BR>
    DataTableRegion (<BR>
        RegionName,         // NameString<BR>
        SignatureString,    // TermArg =&gt; String<BR>
        OemIDString,        // TermArg =&gt; String<BR>
        OemTableIDString    // TermArg =&gt; String<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357876"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357877"></A>DebugTerm :=<BR>
    Debug</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553778"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553764"></A>DecSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553765"></A>    Minuend                 // SuperName =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553766"></A>    --</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357878"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553820"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357879"></A>DecTerm :=<BR>
    Decrement (<BR>
        Minuend              // SuperName<BR>
)     =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357880"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357881"></A>DefaultTerm :=<BR>
    Default {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357882"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357883"></A><EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
DefinitionBlockTerm :=<BR>
</EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
DefinitionBlock (<BR>
    </EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
AMLFileName,         // String<BR>
    </EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
TableSignature,      // String<BR>
   </EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
 ComplianceRevision,  // ByteConst<BR>
    </EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
OEMID,               // String<BR>
   </EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
 TableID,             // String<BR>
    </EM>
    <EM CLASS="Grammar-ASL-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-Char-C-Char">
OEMRevision          // DWordConst<BR>
</EM>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357884"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1563576"></A>DerefOfTerm :=<BR>
    DerefOf (<BR>
    Source      // NameString | ArgTerm | LocalTerm | RefOfTerm | CondRefOfTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1563577"></A>                // IndexTerm | MethodInvocationTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1487882"></A>    ) =&gt; DataRefObject</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357886"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357887"></A>DeviceTerm :=<BR>
    Device (<BR>
        DeviceName           // NameString<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553823"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553829"></A>DivideCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553830"></A>    <EM CLASS="Italic">
Dividend-Result</EM>
          // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553831"></A>    /=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553832"></A>    <EM CLASS="Italic">
Divisor</EM>
                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553833"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553834"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553835"></A>DivideSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553836"></A>    <EM CLASS="Italic">
Dividend</EM>
                 // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553837"></A>    /</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553838"></A>    <EM CLASS="Italic">
Divisor</EM>
                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553839"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357888"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357889"></A>DivideTerm :=<BR>
    Divide (<BR>
        Dividend,            // TermArg =&gt; Integer<BR>
        Divisor,             // TermArg =&gt; Integer<BR>
        Remainder,           // Target<BR>
        Result               // Target<BR>
    ) =&gt; Integer             // Returns Result</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357890"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357891"></A>EISAIDTerm :=<BR>
    EISAID (<BR>
       EisaIdString         // StringData<BR>
    ) =&gt; DWordConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357892"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357893"></A>ElseIfTerm :=<BR>
    ElseIf (<BR>
        Predicate            // TermArg =&gt; Integer<BR>
    ) {TermList} ElseTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357894"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357895"></A>ElseTerm :=<BR>
    Else {TermList} | ElseIfTerm | Nothing</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357896"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357897"></A>EventTerm :=<BR>
    Event (<BR>
        EventName            // NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357898"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357899"></A>ExternalTerm :=<BR>
    External (<BR>
        ObjName,             // NameString<BR>
        ObjType,             // Nothing | ObjectTypeKeyword<BR>
        ResultType,          // Nothing | ParameterTypePackage<BR>
        ParameterTypes       // Nothing | ParameterTypesPackage<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357900"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357901"></A>FatalTerm :=<BR>
    Fatal (<BR>
        Type,                // ByteConstExpr<BR>
        Code,                // DWordConstExpr<BR>
        Arg                  // TermArg =&gt; Integer<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357902"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357903"></A>FieldTerm :=<BR>
    Field (<BR>
        RegionName,          // NameString =&gt; OperationRegion<BR>
        AccessType,          // AccessTypeKeyword<BR>
        LockRule,            // LockRuleKeyword<BR>
        UpdateRule           // UpdateRuleKeyword<BR>
    ) {FieldUnitList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357904"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357905"></A>FindSetLeftBitTerm :=<BR>
    FindSetLeftBit (<BR>
        Source,              // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357906"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357907"></A>FindSetRightBitTerm :=<BR>
    FindSetRightBit (<BR>
        Source,              // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1562274"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1562285"></A>ForTerm :=<BR>
	For (<BR>
		Initialize,		// Nothing | TermArg =&gt; ComputationalData<BR>
		Predicate,		// Nothing | TermArg =&gt; ComputationalData<BR>
		Update			// Nothing | TermArg =&gt; ComputationalData<BR>
	) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549750"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549757"></A>FprintfTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549758"></A>    Fprintf (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549759"></A>        <EM CLASS="Italic">
TermArg</EM>
,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549760"></A>        <EM CLASS="Italic">
String</EM>
,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1557234"></A>       <EM CLASS="Italic">
 PrintfArgList</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549762"></A>    ) =&gt; String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357909"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357910"></A>FromBCDTerm :=<BR>
    FromBCD (<BR>
        BCDValue,            // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357911"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357912"></A>FunctionTerm :=<BR>
    Function (<BR>
        FunctionName,        // NameString<BR>
        ReturnType,          // Nothing | ParameterTypePackage<BR>
        ParameterTypes       // Nothing | ParameterTypesPackage<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357913"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357914"></A>IfTerm :=<BR>
    If (<BR>
        Predicate            // TermArg =&gt; Integer<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357915"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357916"></A>IncludeTerm :=<BR>
    Include (<BR>
        FilePathName         // StringData<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553966"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553967"></A>IncSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553968"></A>    <EM CLASS="Italic">
Addend</EM>
                   // SuperName =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553969"></A>    ++</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1553970"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357917"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357918"></A>IncTerm := <BR>
    Increment (<BR>
        Addend               // SuperName<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357919"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357920"></A>IndexFieldTerm :=<BR>
    IndexField (<BR>
        IndexName,           // NameString =&gt; FieldUnit<BR>
        DataName,            // NameString =&gt; FieldUnit<BR>
        AccessType,          // AccessTypeKeyword<BR>
        LockRule,            // LockRuleKeyword<BR>
        UpdateRule           // UpdateRuleKeyword<BR>
    ) {FieldUnitList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554024"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554030"></A>IndexSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554031"></A>    <EM CLASS="Italic">
Source</EM>
                   // TermArg =&gt; &lt;String | Buffer | PackageTerm&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554032"></A>    [ <EM CLASS="Italic">
Index</EM>
 ]                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554033"></A>    =&gt; ObjectReference</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357921"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357922"></A>IndexTerm :=<BR>
    Index (<BR>
        Source,              // TermArg =&gt; &lt;String | Buffer | PackageTerm&gt;<BR>
        Index,               // TermArg =&gt; Integer<BR>
        Destination          // Target<BR>
    ) =&gt; ObjectReference</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554284"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554111"></A>LAndSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554112"></A>    Source1                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554113"></A>    &amp;&amp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554114"></A>    Source2                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554115"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554116"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357924"></A>LAndTerm :=<BR>
    LAnd (<BR>
        Source1,             // TermArg =&gt; Integer<BR>
        Source2              // TermArg =&gt; Integer<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554415"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554117"></A>LEqualSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554118"></A>    Source1                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554119"></A>    ==</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554120"></A>    Source2                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554121"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357925"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357926"></A>LEqualTerm :=<BR>
    LEqual (<BR>
        Source1,             // TermArg =&gt; ComputationalData<BR>
        Source2              // TermArg =&gt; ComputationalData<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554524"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554495"></A>LGreaterEqualSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554496"></A>    Source1                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554497"></A>    &gt;=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554498"></A>    Source2                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554499"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554500"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357927"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357928"></A>LGreaterEqualTerm :=<BR>
    LGreaterEqual (<BR>
        Source1,             // TermArg =&gt; ComputationalData<BR>
        Source2              // TermArg =&gt; ComputationalData<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554552"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554501"></A>LGreaterSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554502"></A>    Source1                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554503"></A>    &gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554504"></A>    Source2                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554505"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357930"></A> LGreaterTerm :=<BR>
    LGreater (<BR>
        Source1,             // TermArg =&gt; ComputationalData<BR>
        Source2              // TermArg =&gt; ComputationalData<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554613"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554614"></A>LLessEqualSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554615"></A>    <EM CLASS="Italic">
Source1</EM>
                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554616"></A>    &lt;=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554617"></A>    <EM CLASS="Italic">
Source2</EM>
                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554618"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357931"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1520727"></A>LLessEqualTerm :=<BR>
    LLessEqual (<BR>
        Source1,             // TermArg =&gt; ComputationalData<BR>
        Source2              // TermArg =&gt; ComputationalData<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554580"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554592"></A>LLessSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554593"></A><EM CLASS="Italic">
     Source1</EM>
                 // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554594"></A>     &lt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554595"></A><EM CLASS="Italic">
     Source2</EM>
                 // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554596"></A>     =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554578"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1520728"></A>LLessTerm :=<BR>
    LLess (<BR>
        Source1,             // TermArg =&gt; ComputationalData<BR>
        Source2              // TermArg =&gt; ComputationalData<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554988"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357936"></A>LNotEqualTerm :=<BR>
    LNotEqual (<BR>
        Source1,             // TermArg =&gt; ComputationalData<BR>
        Source2              // TermArg =&gt; ComputationalData<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554923"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554147"></A>LNotEqualSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554148"></A>    Source1                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554149"></A>    !=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554150"></A>    Source2                  // TermArg =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554151"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554152"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554153"></A>LNotSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554154"></A>    !</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554155"></A>    Source                   // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554156"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554157"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357938"></A>LNotTerm :=<BR>
    LNot (<BR>
        Source,              // TermArg =&gt; Integer<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555032"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554158"></A>LOrSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554159"></A>    Source1                   // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554160"></A>    ||</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554161"></A>    Source2                   // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554162"></A>    =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554163"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1487901"></A>LoadTableTerm :=<BR>
    LoadTable (<BR>
        SignatureString,     // TermArg =&gt; String<BR>
        OemIDString,         // TermArg =&gt; String<BR>
        OemTableIDString,    // TermArg =&gt; String<BR>
        RootPathString,      // Nothing | TermArg =&gt; String<BR>
        ParameterPathString, // Nothing | TermArg =&gt; String<BR>
        ParameterData        // Nothing | TermArg =&gt; DataRefObject<BR>
    ) =&gt; DDBHandle</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357941"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357942"></A>LoadTerm :=<BR>
    Load (<BR>
        Object,              // NameString<BR>
        DDBHandle            // SuperName<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357943"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357944"></A>LocalTerm :=<BR>
    Local0 | Local1 | Local2 | Local3 | Local4 | Local5 | Local6 | Local7</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357945"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1520971"></A>LOrTerm :=<BR>
    LOr (<BR>
        Source1,             // TermArg =&gt; Integer<BR>
        Source2              // TermArg =&gt; Integer<BR>
    ) =&gt; Boolean</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357947"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357948"></A>MatchTerm :=<BR>
    Match (<BR>
        SearchPackage,       // TermArg =&gt; Package<BR>
        Op1,                 // MatchOpKeyword<BR>
        MatchObject1,        // TermArg =&gt; ComputationalData<BR>
        Op2,                 // MatchOpKeyword<BR>
        MatchObject2,        // TermArg =&gt; ComputationalData<BR>
        StartIndex           // TermArg =&gt; Integer<BR>
    ) =&gt; &lt;Ones | Integer&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357949"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357950"></A>MethodTerm :=<BR>
    Method (<BR>
        MethodName,          // NameString<BR>
        NumArgs,             // Nothing | ByteConstExpr<BR>
        SerializeRule,       // Nothing | SerializeRuleKeyword<BR>
        SyncLevel,           // Nothing | ByteConstExpr<BR>
        ReturnType,          // Nothing | ParameterTypePackage<BR>
        ParameterTypes       // Nothing | ParameterTypesPackage<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357951"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357952"></A>MidTerm :=<BR>
    Mid (<BR>
        Source,              // TermArg =&gt; &lt;Buffer | String&gt;<BR>
        Index,               // TermArg =&gt; Integer<BR>
        Length,              // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; &lt;Buffer | String&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555185"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554164"></A>ModCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554165"></A>    Dividend-Result          // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554166"></A>    %=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554167"></A>    Divisor                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554168"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554169"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554170"></A>ModSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554171"></A>    Dividend                 // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554172"></A>    %</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554173"></A>    Divisor                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554174"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554175"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357954"></A>ModTerm :=<BR>
    Mod (<BR>
        Dividend,            // TermArg =&gt; Integer<BR>
        Divisor,             // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer             // Returns Result</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357955"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554176"></A>MultiplyCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554177"></A>    Multiplicand-Result      // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554178"></A>    *=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554179"></A>    Multiplier               // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554180"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554181"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554182"></A>MultiplySymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554183"></A>    Multiplicand             // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554184"></A>    *</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554185"></A>    Multiplier               // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554186"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1554187"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357956"></A>MultiplyTerm :=<BR>
    Multiply (<BR>
        Multiplicand,        // TermArg =&gt; Integer<BR>
        Multiplier,          // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357957"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357958"></A>MutexTerm :=<BR>
    Mutex (<BR>
        MutexName,           // NameString<BR>
        SyncLevel            // ByteConstExpr<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357959"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357960"></A>NameTerm :=<BR>
    Name (<BR>
        ObjectName,          // NameString<BR>
        Object               // DataObject<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357961"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357962"></A>NAndTerm :=<BR>
    NAnd (<BR>
        Source1,             // TermArg =&gt; Integer<BR>
        Source2,             // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357963"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357964"></A>NoOpTerm :=<BR>
    NoOp</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357965"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357966"></A>NOrTerm :=<BR>
    NOr (<BR>
        Source1,             // TermArg =&gt; Integer<BR>
        Source2,             // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357967"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357968"></A>NotifyTerm :=<BR>
    Notify (<BR>
        Object,              // SuperName =&gt; &lt;ThermalZone | Processor | Device&gt;<BR>
        NotificationValue    // TermArg =&gt; Integer<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555369"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555349"></A>NotSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555350"></A>    &#126;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555351"></A>    <EM CLASS="Italic">
Source</EM>
                   // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555352"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357969"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357970"></A>NotTerm :=<BR>
    Not (<BR>
        Source,              // TermArg =&gt; Integer<BR>
        Result               // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357971"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1564352"></A>ObjectTypeTerm :=<BR>
    ObjectType (<BR>
        Object               // NameString | ArgTerm | LocalTerm | DebugTerm |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1563647"></A>                             // RefOfTerm | DerefOfTerm | IndexTerm</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1563649"></A>    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548527"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357973"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357974"></A>OffsetTerm :=<BR>
    Offset (<BR>
        ByteOffset           // IntegerData<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357975"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357976"></A>OpRegionTerm :=<BR>
    OperationRegion (<BR>
        RegionName,          // NameString<BR>
        RegionSpace,         // RegionSpaceKeyword<BR>
        Offset,              // TermArg =&gt; Integer<BR>
        Length               // TermArg =&gt; Integer<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555407"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555413"></A>OrCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555414"></A>    <EM CLASS="Italic">
Source1-Result</EM>
           // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555415"></A>    |=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555416"></A>    <EM CLASS="Italic">
Source2 </EM>
                 // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555417"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555418"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555419"></A>OrSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555420"></A>   <EM CLASS="Italic">
 Source1</EM>
                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555421"></A>    |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555422"></A>   <EM CLASS="Italic">
 Source2  </EM>
                // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555423"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357977"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538186"></A>OrTerm :=<BR>
    Or (<BR>
        Source1,                // TermArg =&gt; Integer<BR>
        Source2,                // TermArg =&gt; Integer<BR>
        Result                  // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550603"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550604"></A>PackageTerm :=<BR>
    Package (<BR>
        NumElements             // Nothing | ByteConstExpr | TermArg =&gt; Integer<BR>
    ) {PackageList} =&gt; Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550480"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550484"></A>PLDKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550485"></A>     PLD_Revision | PLD_IgnoreColor | PLD_Red | PLD_Green | PLD_Blue |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550486"></A>     PLD_Width | PLD_Height | PLD_UserVisible | PLD_Dock | PLD_Lid | PLD_Panel |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550514"></A>     PLD_VerticalPosition | PLD_HorizontalPosition | PLD_Shape |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550487"></A>     PLD_GroupOrientation | PLD_GroupToken | PLD_GroupPosition | PLD_Bay</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550488"></A>     PLD_Ejectable | PLD_EjectRequired | PLD_CabinetNumber</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550489"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550490"></A>PLDKeywordList :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550491"></A>     PLDKeyword = StringData | PLDKeyword = IntegerData |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550492"></A>     PLDKeyword = StringData, PLDKeywordList, PLDKeyword = IntegerData, PLDKeywordList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357979"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357982"></A>PowerResTerm :=<BR>
    PowerResource (<BR>
        ResourceName,           // NameString<BR>
        SystemLevel,            // ByteConstExpr<BR>
        ResourceOrder           // WordConstExpr<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357983"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549818"></A>PrintfArgList := </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1557267"></A>    TermArg | TermArg , PrintfArgList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1557264"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549819"></A>PrintfTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549820"></A>    Printf (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549821"></A>         <EM CLASS="Italic">
String</EM>
,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549822"></A>         PrintfArgList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357984"></A>    ) =&gt; String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549836"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1549834"></A>ProcessorTerm :=<BR>
    Processor (<BR>
        ProcessorName,          // NameString<BR>
        ProcessorID,            // ByteConstExpr<BR>
        PBlockAddress,          // DWordConstExpr | Nothing (=0)<BR>
        PblockLength            // ByteConstExpr | Nothing (=0)<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357985"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538171"></A>RawDataBufferTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538172"></A>    RawDataBuffer (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538173"></A>        BuffSize                // Nothing | WordConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538174"></A>    ) { ByteList} =&gt; RawDataBuffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538163"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357986"></A>RefOfTerm :=<BR>
    RefOf (<BR>
         Source                 // NameString | ArgTerm | LocalTerm | DerefOfTerm<BR>
    ) =&gt; ObjectReference</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357987"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357988"></A>ReleaseTerm :=<BR>
    Release (<BR>
        SyncObject              // SuperName<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357989"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357990"></A>ResetTerm :=<BR>
    Reset (<BR>
        SyncObject              // SuperName<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357991"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357992"></A>ReturnTerm :=<BR>
    Return (<BR>
        Arg                     // Nothing | TermArg =&gt; DataRefObject<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357993"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357994"></A>ScopeTerm :=<BR>
    Scope (<BR>
        Location                // NameString<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555545"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555551"></A>ShiftLeftCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555552"></A>    <EM CLASS="Italic">
Source-Result</EM>
              // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555553"></A>    &lt;&lt;=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555554"></A>    <EM CLASS="Italic">
ShiftCount</EM>
                 // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555555"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555556"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555557"></A>ShiftLeftSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555558"></A>    <EM CLASS="Italic">
Source</EM>
                     // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555559"></A>    &lt;&lt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555560"></A>    <EM CLASS="Italic">
ShiftCount</EM>
                 // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555561"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357995"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357996"></A>ShiftLeftTerm :=<BR>
    ShiftLeft (<BR>
        Source,                 // TermArg =&gt; Integer<BR>
        ShiftCount,             // TermArg =&gt; Integer<BR>
        Result                  // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555651"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555657"></A>ShiftRightCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555658"></A>    <EM CLASS="Italic">
Source-Result</EM>
               // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555659"></A>    &gt;&gt;=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555660"></A>    <EM CLASS="Italic">
ShiftCount</EM>
                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555661"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555662"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555663"></A>ShiftRightSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555664"></A>    <EM CLASS="Italic">
Source</EM>
                      // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555665"></A>    &gt;&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555666"></A>    <EM CLASS="Italic">
ShiftCount</EM>
                  // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555667"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357997"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357998"></A>ShiftRightTerm :=<BR>
    ShiftRight (<BR>
        Source,                 // TermArg =&gt; Integer<BR>
        ShiftCount,             // TermArg =&gt; Integer<BR>
        Result                  // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357999"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358000"></A>SignalTerm :=<BR>
    Signal (<BR>
        SyncObject               // SuperName<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358001"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358002"></A>SizeOfTerm :=<BR>
    SizeOf (<BR>
        DataObject               // SuperName =&gt; &lt;String | Buffer | Package&gt;<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358003"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358004"></A>SleepTerm :=<BR>
    Sleep (<BR>
        MilliSeconds             // TermArg =&gt; Integer<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358005"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358006"></A>StallTerm :=<BR>
    Stall (<BR>
        MicroSeconds             // TermArg =&gt; Integer<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555785"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555818"></A>StoreSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555819"></A>    <EM CLASS="Italic">
Destination</EM>
                  // SuperName</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555820"></A>    =</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555821"></A>    <EM CLASS="Italic">
Source</EM>
                       // TermArg =&gt; DataRefObject</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555822"></A>    =&gt; DataRefObject</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358007"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358008"></A>StoreTerm :=<BR>
    Store (<BR>
        Source,                  // TermArg =&gt; DataRefObject<BR>
        Destination              // SuperName<BR>
    ) =&gt; DataRefObject</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555900"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555906"></A>SubtractCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555907"></A>    <EM CLASS="Italic">
Minuend-Result</EM>
               // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555908"></A>    -=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555909"></A>    <EM CLASS="Italic">
Subtrahend</EM>
                   // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555910"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555911"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555912"></A>SubtractSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555913"></A>    Minuend                      // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555914"></A>    -</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555915"></A>    Subtrahend                   // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1555916"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358009"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358010"></A>SubtractTerm :=<BR>
    Subtract (<BR>
        Minuend,                 // TermArg =&gt; Integer<BR>
        Subtrahend,              // TermArg =&gt; Integer<BR>
        Result                   // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358011"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358012"></A>SwitchTerm :=<BR>
    Switch (<BR>
        Predicate                // TermArg =&gt; ComputationalData<BR>
    ) {CaseTermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358013"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358014"></A>ThermalZoneTerm :=<BR>
    ThermalZone (<BR>
        ThermalZoneName          // NameString<BR>
    ) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358015"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358016"></A>TimerTerm :=<BR>
    Timer =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358017"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1488108"></A>ToBCDTerm :=<BR>
    ToBCD (<BR>
        Value,                   // TermArg =&gt; Integer<BR>
        Result                   // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358019"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358020"></A>ToBufferTerm :=<BR>
    ToBuffer (<BR>
        Data,                    // TermArg =&gt; ComputationalData<BR>
        Result                   // Target<BR>
    ) =&gt; ComputationalData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358021"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358022"></A>ToDecimalStringTerm :=<BR>
    ToDecimalString (<BR>
        Data,                    // TermArg =&gt; ComputationalData<BR>
        Result                   // Target<BR>
    ) =&gt; String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358023"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358024"></A>ToHexStringTerm :=<BR>
    ToHexString (<BR>
        Data,                    // TermArg =&gt; ComputationalData<BR>
        Result                   // Target<BR>
    ) =&gt; String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358025"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358026"></A>ToIntegerTerm :=<BR>
    ToInteger (<BR>
        Data,                    // TermArg =&gt; ComputationalData<BR>
        Result                   // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550541"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550545"></A>ToPLDTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550546"></A>    ToPLD (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550547"></A>        <EM CLASS="Italic">
PLDKeywordList</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550548"></A>    ) =&gt; Buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358027"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358028"></A>ToStringTerm :=<BR>
    ToString (<BR>
        Source,                  // TermArg =&gt; Buffer<BR>
        Length,                  // Nothing | TermArg =&gt; Integer<BR>
        Result                   // Target<BR>
    ) =&gt; String</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358029"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358030"></A>ToUUIDTerm :=<BR>
    ToUUID (<BR>
        String                   // StringData<BR>
    ) =&gt; Buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358031"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358032"></A>UnicodeTerm :=<BR>
    Unicode (<BR>
        String                   // StringData<BR>
    ) =&gt; Buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358033"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358034"></A>UnloadTerm :=<BR>
    Unload (<BR>
        DDBHandle                // SuperName<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358035"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358036"></A>WaitTerm :=<BR>
    Wait (<BR>
        SyncObject,              // SuperName =&gt; Event<BR>
        TimeoutValue             // TermArg =&gt; Integer<BR>
    ) =&gt; Boolean                 // True means timed-out</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358037"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358038"></A>WhileTerm :=<BR>
    While (<BR>
        Predicate                // TermArg =&gt; Integer<BR>
) {TermList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556045"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556051"></A>XorCompoundTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556052"></A>   <EM CLASS="Italic">
 Source1-Result</EM>
               // TermArg =&gt; Integer =&gt; Target</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556053"></A>    ^=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556054"></A>   <EM CLASS="Italic">
 Source2</EM>
                      // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556055"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556056"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556057"></A>XorSymbolicTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556058"></A>    <EM CLASS="Italic">
Source1</EM>
                      // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556059"></A>    ^</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556060"></A>    <EM CLASS="Italic">
Source2</EM>
                      // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1556061"></A>    =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358039"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358040"></A>XOrTerm :=<BR>
    XOr (<BR>
        Source1,                 // TermArg =&gt; Integer<BR>
        Source2,                 // TermArg =&gt; Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1541372"></A>        Result                   // Target<BR>
    ) =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1541383"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358045"></A><A NAME="_Toc202341944"></A><A NAME="_Toc258262580"></A>ASL Parameter Keyword Terms<A NAME="marker-1358044"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1538208"></A>AccessAttribKeyword :=<BR>
    AttribQuick | AttribSendReceive | AttribByte | AttribBytes (n) | AttribRawBytes (n) |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538227"></A>    AttribRawProcessBytes (n) | AttribWord | AttribBlock |AttribProcessCall |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538328"></A>    AttribBlockProcessCall //    Note: Used for SMBus and GenericSerialBus BufferAcc only | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538332"></A>AccessTypeKeyword :=<BR>
    AnyAcc | ByteAcc | WordAcc | DWordAcc | QWordAcc | BufferAcc</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538333"></A>AddressKeyword :=<BR>
    AddressRangeMemory | AddressRangeReserved | AddressRangeNVS | AddressRangeACPI</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538334"></A>AddressSpaceKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1571927"></A>RegionSpaceKeyword | FFixedHW</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538342"></A>AddressingModeKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538343"></A>    AddressingMode7Bit | AddressingMode10Bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538358"></A>ByteLengthKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538359"></A>    DataBitsFive | DataBitsSix | DataBitsSeven | DataBitsEight | DataBitsNine</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358051"></A>BusMasterKeyword :=<BR>
    BusMaster | NotBusMaster</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538374"></A>ClockPhaseKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538375"></A>    ClockPhaseFirst | ClockPhaseSecond</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538377"></A>ClockPolarityKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538378"></A>    ClockPolarityLow | ClockPolarityHigh</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358052"></A>DecodeKeyword :=<BR>
    SubDecode | PosDecode</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538397"></A>EndianKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538398"></A>    BigEndianing | LittleEndian</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538400"></A>ExtendedAccessAttribKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538401"></A>    AttribBytes | AttribRawBytes | AttribRawProcessBytes </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538427"></A>    //   Note: Used for GenericSerialBus BufferAcc only.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544580"></A>FlowControlKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538404"></A>    FlowControlNone | FlowControlXon | FlowControlHardware</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358054"></A>InterruptTypeKeyword :=<BR>
    Edge | Level</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544574"></A>InterruptLevel :=<BR>
    ActiveHigh | ActiveLow</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544575"></A>InterruptLevelKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538441"></A>    ActiveHigh | ActiveLow | ActiveBoth</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358056"></A>IODecodeKeyword :=<BR>
    Decode16 | Decode10</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548253"></A>IoRestrictionKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548254"></A>    IoRestrictionNone | IoRestrictionInputOnly | IoRestrictionOutputOnly |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548277"></A>    IoRestrictionNoneAndPreserve</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358057"></A>LockRuleKeyword :=<BR>
    Lock | NoLock</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358058"></A>MatchOpKeyword :=<BR>
    MTR | MEQ | MLE | MLT | MGE | MGT</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538305"></A>MaxKeyword :=<BR>
    MaxFixed | MaxNotFixed</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538307"></A>MemTypeKeyword :=<BR>
    Cacheable | WriteCombining | Prefetchable | NonCacheable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538310"></A>MinKeyword :=<BR>
    MinFixed | MinNotFixed</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538311"></A>ObjectTypeKeyword :=<BR>
    UnknownObj | IntObj | StrObj | BuffObj | PkgObj | FieldUnitObj | DeviceObj | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1523445"></A>    EventObj | MethodObj | MutexObj | OpRegionObj | PowerResObj | ProcessorObj | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1523452"></A>    ThermalZoneObj | BuffFieldObj | DDBHandleObj</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538463"></A>ParityKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538464"></A>    ParityTypeNone | ParityTypeSpace | ParityTypeMark | ParityTypeOdd | ParityTypeEven</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538466"></A>PinConfigKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538467"></A>    PullDefault | PullUp | PullDown | PullNone</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538470"></A>PolarityKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538471"></A>    PolarityHigh | PolarityLow</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358063"></A>RangeTypeKeyword :=<BR>
    ISAOnlyRanges | NonISAOnlyRanges | EntireRange</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358064"></A>ReadWriteKeyword :=<BR>
    ReadWrite | ReadOnly</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1523505"></A>RegionSpaceKeyword :=<BR>
    SystemIO | SystemMemory | PCI_Config | EmbeddedControl | SMBus | SystemCMOS | <BR>
    PciBarTarget | IPMI | GeneralPurposeIO | GenericSerialBus |  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1571961"></A>    PCC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1571948"></A>ResourceTypeKeyword :=<BR>
    ResourceConsumer | ResourceProducer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358067"></A>SerializeRuleKeyword :=<BR>
    Serialized | NotSerialized</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538664"></A>ShareTypeKeyword :=<BR>
    Shared | Exclusive | SharedAndWake | ExclusiveAndWake</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538683"></A>SlaveModeKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538666"></A>    ControllerInitiated | DeviceInitiated</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538521"></A>StopBitsKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538597"></A>    StopBitsZero | StopBitsOne | StopBitsOnePlusHalf | StopBitsTwo</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538612"></A>TransferWidthKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538598"></A>    Width8Bit | Width16Bit | Width32Bit | Width64Bit | Width128Bit | Width256Bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538624"></A>TranslationKeyword :=<BR>
    SparseTranslation | DenseTranslation</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358070"></A>TypeKeyword :=<BR>
    TypeTranslation | TypeStatic</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358071"></A>UpdateRuleKeyword :=<BR>
    Preserve | WriteAsOnes | WriteAsZeros</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358072"></A>UserDefRegionSpace :=<BR>
    IntegerData =&gt; 0x80 - 0xFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538601"></A>XferTypeKeyword :=<BR>
    Transfer8 | Transfer16 | Transfer8_16</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538604"></A>WireModeKeyword :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538549"></A>    ThreeWireMode | FourWireMode</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358079"></A><A NAME="GRM_TEMPLATES"></A><A NAME="_Toc202341945"></A><A NAME="_Toc258262581"></A>ASL Resource Template Terms<A NAME="marker-1358078"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1358082"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358083"></A>ResourceMacroList :=<BR>
    Nothing | &lt;ResourceMacroTerm ResourceMacroList&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1572817"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566670"></A><EM CLASS="SC-24-208904">
ResourceMacroTerm := DMATerm | DWordIOTerm | DWordMemoryTerm | DWordSpaceTerm | EndDependentFnTerm | ExtendedIOTerm | ExtendedMemoryTerm | ExtendedSpaceTerm | FixedDMATerm | FixedIOTerm | GpioIntTerm | GpioIOTerm | I2CSerialBusTerm | InterruptTerm | IOTerm | IRQNoFlagsTerm | IRQTerm | Memory24Term | Memory32FixedTerm | Memory32Term | PinConfigTerm | PinFunctionTerm | PinGroupTerm | PinGroupConfigTerm | PinGroupFunctionTerm | QWordIOTerm | QWordMemoryTerm | QWordSpaceTerm | RegisterTerm | SPISerialBusTerm | StartDependentFnTerm | StartDependentFnNoPriTerm | UARTSerialBusTerm | VendorLongTerm | VendorShortTerm | WordBusNumberTerm | WordIOTerm | WordSpaceTerm</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358085"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358086"></A>DMATerm :=<BR>
    DMA (<BR>
        DMAType,                          // DMATypeKeyword (_TYP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548792"></A>        BusMaster,                        // BusMasterKeyword (_BM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548785"></A>        XferType,                         // XferTypeKeyword (_SIZ)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548778"></A>        DescriptorName                    // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548771"></A>    ) {ByteList}                          // List of channels (0-7 bytes)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358087"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358088"></A>DWordIOTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548750"></A>    DWordIO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548757"></A>        ResourceUsage,                    // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548743"></A>        MinType,                          // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548736"></A>        MaxType,                          // Nothing (MaxNotFixed) | MaxKeyword (_MAF)<BR>
        Decode,                           // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548764"></A>        RangeType,                        // Nothing (EntireRange) | RangeTypeKeyword (_RNG)<BR>
        AddressGranularity,               // DWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548652"></A>        MinAddress,                       // DWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548659"></A>        MaxAddress,                       // DWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548666"></A>        AddressTranslation,               // DWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548673"></A>        AddressLength,                    // DWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548680"></A>        ResourceSourceIndex,              // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548687"></A>        ResourceSource,                   // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548694"></A>        DescriptorName,                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548701"></A>        TranslationType,                  // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548708"></A>        TranslationDensity                // Nothing | TranslationKeyword (_TRS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548715"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358089"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358090"></A>DWordMemoryTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548722"></A>    DWordMemory (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548729"></A>        ResourceUsage,                    // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548885"></A>        Decode,                           // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548878"></A>        MinType,                          // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548903"></A>        MaxType,                          // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548904"></A>        MemType,                          // Nothing (NonCacheable) | MemTypeKeyword (_MEM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548905"></A>        ReadWriteType,                    // ReadWriteKeyword (_RW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548606"></A>        AddressGranularity,               // DWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548613"></A>        MinAddress,                       // DWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548639"></A>        MaxAddress,                       // DWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548801"></A>        AddressTranslation,               // DWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548836"></A>        AddressLength,                    // DWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548843"></A>        ResourceSourceIndex,              // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548850"></A>        ResourceSource,                   // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548645"></A>        DescriptorName,                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548599"></A>        MemoryRangeType,                  // Nothing | AddressKeyword (_MTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548857"></A>        TranslationType                   // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546849"></A>     )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358092"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358093"></A>DWordSpaceTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546842"></A>     DWordSpace (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546835"></A>        ResourceType,                     // ByteConstExpr (_RT), 0xC0 - 0xFF<BR>
        ResourceUsage,                    // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546786"></A>        Decode,                           // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546779"></A>        MinType,                          // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546765"></A>        MaxType,                          // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546772"></A>        TypeSpecificFlags,                // ByteConstExpr (_TSF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546793"></A>        AddressGranularity,               // DWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546800"></A>        MinAddress,                       // DWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546807"></A>        MaxAddress,                       // DWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546814"></A>        AddressTranslation,               // DWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546821"></A>        AddressLength,                    // DWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546828"></A>        ResourceSourceIndex,              // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546758"></A>        ResourceSource,                   // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546751"></A>        DescriptorName                    // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546744"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358094"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358095"></A>EndDependentFnTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546737"></A>    EndDependentFn ()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358096"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358097"></A>ExtendedIOTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546730"></A>    ExtendedIO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546723"></A>        ResourceUsage,                    // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546716"></A>        MinType,                          // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546709"></A>        MaxType,                          // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546702"></A>        Decode,                           // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546695"></A>        RangeType,                        // Nothing (EntireRange) | RangeTypeKeyword (_RNG)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546688"></A>        AddressGranularity,               // QWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546681"></A>        MinAddress,                       // QWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546674"></A>        MaxAddress,                       // QWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546667"></A>        AddressTranslation,               // QWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546660"></A>        AddressLength,                    // QWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546653"></A>        TypeSpecificAttributes,           // Nothing | QWordConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546646"></A>        DescriptorName,                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546639"></A>        TranslationType,                  // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546632"></A>        TranslationDensity                // Nothing | TranslationKeyword (_TRS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546625"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358098"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358099"></A>ExtendedMemoryTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546905"></A>    ExtendedMemory (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546912"></A>        ResourceUsage,                   // Nothing (ResourceConsumer)| ResourceTypeKeyword<BR>
        Decode,                          // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546590"></A>        MinType,                         // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546597"></A>        MaxType,                         // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546604"></A>        MemType,                         // Nothing (NonCacheable) | MemTypeKeyword (_MEM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546611"></A>        ReadWriteType,                   // ReadWriteKeyword (_RW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546618"></A>        AddressGranularity,              // QWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546856"></A>        MinAddress,                      // QWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546863"></A>        MaxAddress,                      // QWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546870"></A>        AddressTranslation,              // QWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546877"></A>        AddressLength,                   // QWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546884"></A>        TypeSpecificAttributes,          // Nothing | QWordConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546891"></A>        DescriptorName,                  // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546898"></A>        MemoryRangeType,                 // Nothing | AddressKeyword (_MTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546555"></A>        TranslationType                  // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546548"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358100"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546462"></A>ExtendedSpaceTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547045"></A>    ExtendedSpace (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547052"></A>        ResourceType,                    // ByteConstExpr (_RT), 0xC0 - 0xFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546562"></A>        ResourceUsage,                   // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546569"></A>        Decode,                          // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546576"></A>        MinType,                         // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546583"></A>        MaxType,                         // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546541"></A>        TypeSpecificFlags,               // ByteConstExpr (_TSF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546534"></A>        AddressGranularity,              // QWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546527"></A>        MinAddress,                      // QWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546520"></A>        MaxAddress,                      // QWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546513"></A>        AddressTranslation,              // QWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546492"></A>        AddressLength,                   // QWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546499"></A>        TypeSpecificAttributes,          // Nothing | QWordConstExpr (_ATT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546485"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546506"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546463"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546469"></A>FixedDMATerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546464"></A>    FixedDMA (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546437"></A>        DMAReq,                          //WordConstExpr (_DMA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546438"></A>        Channel,                         //WordConstExpr (_TYP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546439"></A>        XferWidth,                       //Nothing (Width32Bit) | TransferWidthKeyword (_SIZ)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546440"></A>        DescriptorName,                  //Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546441"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358102"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358103"></A>FixedIOTerm :=<BR>
    FixedIO (<BR>
        AddressBase,                     // WordConstExpr (_BAS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546478"></A>        RangeLength,                     // ByteConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544590"></A>        DescriptorName                   // Nothing | NameString<BR>
    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1536874"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538810"></A>GpioIntTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538811"></A>    GpioInt	(</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538812"></A>        InterruptType,                 // InterruptTypeKeyword (_MOD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538813"></A>        InterruptLevel,                // InterruptLevelKeyword (_POL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538814"></A>        ShareType,                     // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538815"></A>        PinConfig,                     // PinConfigKeyword | ByteConstExpr (_PPI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538816"></A>        DeBounceTime                   // Nothing | WordConstExpr (_DBT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538817"></A>        ResourceSource,                // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538818"></A>        ResourceSourceIndex,           // Nothing (0) | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538819"></A>        ResourceUsage,                 // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538820"></A>        DescriptorName,                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538821"></A>        VendorData                     // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538822"></A>) {DWordList}                          // List of GPIO pins (_PIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547995"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548023"></A>GpioIOTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547996"></A>    GpioIO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547997"></A>        ShareType,                      // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547998"></A>        PinConfig,                      // PinConfigKeyword | ByteConstExpr (_PPIC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547999"></A>        DeBounceTime                    // Nothing | WordConstExpr (_DBT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548000"></A>        DriveStrength                   // Nothing | WordConstExpr (_DRS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548001"></A>        IORestriction                   // Nothing (None) | IORestrictionKeyword (_IOR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548002"></A>        ResourceSource,                 // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548003"></A>        ResourceSourceIndex,            // Nothing (0) | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548004"></A>        ResourceUsage,                  // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548005"></A>        DescriptorName,                 // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548006"></A>        VendorData                      // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1548007"></A>) {DWordList}                           // List of GPIO pins (_PIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538823"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538824"></A>I2CSerialBusTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538825"></A>    I2CSerialBusV2 (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539273"></A>        SlaveAddress,                  // WordConstExpr (_ADR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539274"></A>        SlaveMode,                     // Nothing (ControllerInitiated) | SlaveModeKeyword (_SLV)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539275"></A>        ConnectionSpeed,               // DWordConstExpr (_SPE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538828"></A>        AddressingMode,                  // Nothing (AddressingMode7Bit) | AddressModeKeyword (_MOD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538829"></A>        ResourceSource,                // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538830"></A>        ResourceSourceIndex,           // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538831"></A>        ResourceUsage,                 // Nothing (ResourceConsumer)| ResourceTypeKeyword  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538832"></A>        DescriptorName,                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1558284"></A>        ShareType,                     // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538833"></A>        VendorData                     // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538834"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1572874"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358105"></A>InterruptTerm :=<BR>
    Interrupt (<BR>
        ResourceType,                    // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547059"></A>        InterruptType,                   // InterruptTypeKeyword (_LL, _HE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547066"></A>        InterruptLevel,                  // InterruptLevelKeyword (_LL, _HE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547073"></A>        ShareType,                       // Nothing (Exclusive) ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547080"></A>        ResourceSourceIndex,             // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547087"></A>        ResourceSource,                  // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547094"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547101"></A>    ) {DWordList}                        // list of interrupts (_INT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358106"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358107"></A>IOTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547150"></A>    IO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547143"></A>        IODecode,                        // IODecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547108"></A>        MinAddress,                      // WordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547115"></A>        MaxAddress,                      // WordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547122"></A>        Alignment,                       // ByteConstExpr (_ALN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547129"></A>        RangeLength,                     // ByteConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547136"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547038"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358108"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358109"></A>IRQNoFlagsTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547024"></A>    IRQNoFlags (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547031"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547017"></A>    ) {ByteList}                         // list of interrupts (0-15 bytes)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358110"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358111"></A>IRQTerm :=<BR>
    IRQ (<BR>
        InterruptType,                   // InterruptTypeKeyword (_LL, _HE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547010"></A>        InterruptLevel,                  // InterruptLevelKeyword (_LL, _HE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547003"></A>        ShareType,                       // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546996"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546989"></A>    ) {ByteList}                         // list of interrupts (0-15 bytes)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358112"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358113"></A>Memory24Term :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546947"></A>    Memory24 (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546954"></A>        ReadWriteType,                   // ReadWriteKeyword (_RW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546961"></A>        MinAddress[23:8],                // WordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546968"></A>        MaxAddress[23:8],                // WordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546975"></A>        Alignment,                       // WordConstExpr (_ALN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546982"></A>        RangeLength,                     // WordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547157"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547164"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358114"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358115"></A>Memory32FixedTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546919"></A>    Memory32Fixed (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546926"></A>        ReadWriteType,                   // ReadWriteKeyword (_RW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546933"></A>        AddressBase,                     // DWordConstExpr (_BAS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1546940"></A>        RangeLength,                     // DWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547171"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547178"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358116"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358117"></A>Memory32Term :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547185"></A>    Memory32 (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547192"></A>        ReadWriteType,                   // ReadWriteKeyword (_RW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547199"></A>        MinAddress,                      // DWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547206"></A>        MaxAddress,                      // DWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547213"></A>        Alignment,                       // DWordConstExpr (_ALN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547220"></A>        RangeLength,                     // DWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547227"></A>        DescriptorName                   // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547234"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1572880"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566548"></A>PinConfigTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566549"></A>    PinConfig (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566550"></A>        ShareType, // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566551"></A>        PinConfigType, // ByteData (_TYP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566552"></A>        PinConfigValue, // ByteData (_VAL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566553"></A>        ResourceSource, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566554"></A>        ResourceSourceIndex, // Nothing (0) | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566555"></A>        ResourceUsage, // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566556"></A>        DescriptorName, // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566557"></A>        VendorData // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358118"></A>    ) {DWordList} (_PIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566578"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566582"></A>PinFunctionTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566583"></A>    PinFunction (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566584"></A>        ShareType, // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566585"></A>        PinPullConfiguration, // PinConfigKeyword | ByteConstExpr (_PPI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566586"></A>        FunctionNumber, // WordData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566587"></A>        ResourceSource, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566588"></A>        ResourceSourceIndex, // Nothing (0) | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566589"></A>        ResourceUsage, // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566590"></A>        DescriptorName, // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566591"></A>        VendorData // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566592"></A>    ) {DWordList} (_PIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566593"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566594"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566595"></A>PinGroupTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566596"></A>    PinGroup (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566597"></A>        ResourceLabel, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566598"></A>        ResourceUsage, // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566599"></A>        DescriptorName, // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566600"></A>        VendorData // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566601"></A>    ) {DWordList} (_PIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566602"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566603"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566604"></A>PinGroupConfigTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566605"></A>    PinGroupConfig (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566606"></A>        ShareType, // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566607"></A>        PinConfigType, // ByteData (_TYP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566608"></A>        PinConfigValue, // ByteData (_VAL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566609"></A>        ResourceSource, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566610"></A>        ResourceSourceIndex, // Nothing (0) | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566611"></A>        ResourceSourceLabel, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566612"></A>        ResourceUsage, // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566613"></A>        DescriptorName, // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566614"></A>        VendorData // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566615"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566616"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566617"></A>PinGroupFunctionTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566618"></A>    PinGroupFunction (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566619"></A>        ShareType, // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566620"></A>        FunctionNumber, // WordData (_FUN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566621"></A>        ResourceSource, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566622"></A>        ResourceSourceIndex, // Nothing (0) | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566623"></A>        ResourceSourceLabel, // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566624"></A>        ResourceUsage, // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566625"></A>        DescriptorName, // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566576"></A>        VendorData // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1566544"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358119"></A>QWordIOTerm :=<BR>
    QWordIO (<BR>
        ResourceUsage,                   // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547276"></A>        MinType,                         // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547283"></A>        MaxType,                         // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547290"></A>        Decode,                          // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547297"></A>        RangeType,                       // Nothing (EntireRange) | RangeTypeKeyword (_RNG)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547304"></A>        AddressGranularity,              // QWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547311"></A>        MinAddress,                      // QWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547318"></A>        MaxAddress,                      // QWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547325"></A>        AddressTranslation,              // QWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547332"></A>        AddressLength,                   // QWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547339"></A>        ResourceSourceIndex,             // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547346"></A>        ResourceSource,                  // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547353"></A>        DescriptorName,                  // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547360"></A>        TranslationType,                 // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547367"></A>        TranslationDensity               // Nothing | TranslationKeyword (_TRS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547374"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358120"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358121"></A>QWordMemoryTerm :=<BR>
    QWordMemory (<BR>
         ResourceUsage,                  // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547381"></A>         Decode,                         // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547388"></A>         MinType,                        // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547395"></A>         MaxType,                        // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547402"></A>         MemType,                        // Nothing (NonCacheable) | MemTypeKeyword (_MEM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547409"></A>         ReadWriteType,                  // ReadWriteKeyword (_RW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547416"></A>         AddressGranularity,             // QWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547423"></A>         MinAddress,                     // QWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547430"></A>         MaxAddress,                     // QWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547437"></A>         AddressTranslation,             // QWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547444"></A>         AddressLength,                  // QWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547451"></A>         ResourceSourceIndex,            // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547458"></A>         ResourceSource,                 // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547465"></A>         DescriptorName,                 // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547472"></A>         MemoryRangeType,                // Nothing | AddressKeyword (_MTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547479"></A>         TranslationType                 // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547486"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358122"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358123"></A>QWordSpaceTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547493"></A>     QWordSpace (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547500"></A>        ResourceType,                    // ByteConstExpr (_RT), 0xC0 - 0xFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547507"></A>        ResourceUsage,                   // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547241"></A>        Decode,                          // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547248"></A>        MinType,                         // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547255"></A>        MaxType,                         // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547262"></A>        TypeSpecificFlags,               // ByteConstExpr (_TSF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547269"></A>        AddressGranularity,              // QWordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547514"></A>        MinAddress,                   // QWordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547521"></A>        MaxAddress,                   // QWordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547528"></A>        AddressTranslation,           // QWordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547535"></A>        AddressLength,                // QWordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547542"></A>        ResourceSourceIndex,          // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547549"></A>        ResourceSource,               // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547556"></A>        DescriptorName                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547563"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358124"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538772"></A>RawDataBufferTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538773"></A>    RawDataBuffer (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538774"></A>        (BuffSize)                    // Nothing | Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538775"></A>) {ByteList} =&gt; ByteList</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1538787"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358125"></A>RegisterTerm :=<BR>
     Register (<BR>
        AddressSpaceID,               // AddressSpaceKeyword (_ASI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547983"></A>        RegisterBitWidth,             // ByteConstExpr (_RBW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547976"></A>        RegisterOffset,               // ByteConstExpr (_RBO)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547969"></A>        RegisterAddress,              // QWordConstExpr (_ADR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358126"></A>        AccessSize,                   // ByteConstExpr (_ASZ)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358127"></A>        DescriptorName                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547605"></A>)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539312"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539285"></A>SPISerialBusTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539286"></A>    SPISerialBusV2 (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539287"></A>        DeviceSelection,              // WordConstExpr (_ADR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539288"></A>        DeviceSelectionPolarity,      // Nothing (PolarityLow) | DevicePolarityKeyword (_DPL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539289"></A>        WireMode,                     // Nothing (FourWireMode) | WireModeKeyword (_MOD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539290"></A>        DataBitLength,                // ByteConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539291"></A>        SlaveMode,                    // Nothing (ControllerInitiated) | SlaveModeKeyword (_SLV)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539292"></A>        ConnectionSpeed,              // DWordConstExpr (_SPE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539293"></A>        ClockPolarity,                // ClockPolarityKeyword (_POL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539294"></A>        ClockPhase,                   // ClockPhaseKeyword (_PHA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539295"></A>        ResourceSource,               // StringData </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539296"></A>        ResourceSourceIndex,          // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539297"></A>        ResourceUsage,                // Nothing (ResourceConsumer)| ResourceTypeKeyword </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539298"></A>        DescriptorName,               // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539299"></A>        ShareType,                    // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1558346"></A>        VendorData                    // Nothing | RawDataBuffer (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539300"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358128"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358129"></A>StartDependentFnNoPriTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547570"></A>    StartDependentFnNoPri () {ResourceMacroList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358130"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358131"></A>StartDependentFnTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547577"></A>    StartDependentFn (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547584"></A>        CompatPriority,               // ByteConstExpr (0-2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547591"></A>        PerfRobustPriority            // ByteConstExpr (0-2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547598"></A>    ) {ResourceMacroList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358132"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539490"></A>UARTSerialBusTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539491"></A>    UARTSerialBusV2(</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539492"></A>        Initial BaudRate,             // DwordConstExpr (_SPE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539493"></A>        BitsPerByte,                  // Nothing (DataBitsEight) | DataBitsKeyword (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539494"></A>        StopBits,                     // Nothing (StopBitsOne) | StopBitsKeyword (_STB)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539495"></A>        LinesInUse,                   // ByteConstExpr (_LIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539496"></A>        IsBigEndian,                  // Nothing (LittleEndian) | EndianessKeyword (_END)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539638"></A>        Parity,                       // Nothing (ParityTypeNone) | ParityTypeKeyword (_PAR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539639"></A>        FlowControl,                  // Nothing (FlowControlNone) | FlowControlKeyword (_FLC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539640"></A>        ReceiveBufferSize,            // WordConstExpr (_RXL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539610"></A>        TransmitBufferSize,           // WordConstExpr (_TXL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539501"></A>        ResourceSource,               // StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539502"></A>        ResourceSourceIndex,          // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539643"></A>        ResourceUsage,                // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539644"></A>        DescriptorName,               // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539645"></A>        ShareType,                    // Nothing (Exclusive) | ShareTypeKeyword (_SHR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1558378"></A>        VendorData                    // Nothing | Object (_VEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539506"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1539482"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358133"></A>VendorLongTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547612"></A>    VendorLong (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547619"></A>        DescriptorName                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547626"></A>    ) {ByteList}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358134"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358135"></A>VendorShortTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547633"></A>    VendorShort (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547640"></A>        DescriptorName                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547647"></A>    ) {ByteList}                      // Up to 7 bytes</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358136"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358137"></A>WordBusNumberTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547654"></A>    WordBusNumber (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547661"></A>        ResourceUsage,                // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547668"></A>        MinType,                      // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547675"></A>        MaxType,                      // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547682"></A>        Decode,                       // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547689"></A>        AddressGranularity,           // WordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547696"></A>        MinAddress,                   // WordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547703"></A>        MaxAddress,                   // WordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547710"></A>        AddressTranslation,           // WordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547717"></A>        AddressLength,                // WordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547724"></A>        ResourceSourceIndex,          // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547731"></A>        ResourceSource,               // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547738"></A>        DescriptorName                // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547745"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358138"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358139"></A>WordIOTerm :=<BR>
    WordIO (<BR>
        ResourceUsage,                // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547752"></A>        MinType,                      // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547759"></A>        MaxType,                      // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547766"></A>        Decode,                       // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547773"></A>        RangeType,                    // Nothing (EntireRange) | RangeTypeKeyword (_RNG)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547780"></A>        AddressGranularity,           // WordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547787"></A>        MinAddress,                   // WordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547794"></A>        MaxAddress,                   // WordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547801"></A>        AddressTranslation,           // WordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547808"></A>        AddressLength,                // WordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547815"></A>        ResourceSourceIndex,          // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547822"></A>        ResourceSource,               // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547829"></A>        DescriptorName,               // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547836"></A>        TranslationType,              // Nothing | TypeKeyword (_TTP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547843"></A>        TranslationDensity            // Nothing | TranslationKeyword (_TRS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547850"></A>    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358151"></A><A NAME="_Toc374114899"></A><A NAME="_Toc374761376"></A><A NAME="_Toc375244535"></A><A NAME="_Toc375924931"></A><A NAME="_Toc423760156"></A><A NAME="_Toc423760506"></A><A NAME="_Toc465246040"></A><A NAME="_Toc469218357"></A><A NAME="_Toc486665618"></A><A NAME="_Toc489267408"></A><A NAME="_Toc489267762"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544597"></A>WordSpaceTerm :=</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547857"></A>    WordSpace (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547864"></A>        ResourceType,                // ByteConstExpr (_RT), 0xC0 - 0xFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547871"></A>        ResourceUsage,               // Nothing (ResourceConsumer)| ResourceTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547878"></A>        Decode,                      // Nothing (PosDecode) | DecodeKeyword (_DEC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547885"></A>        MinType,                     // Nothing (MinNotFixed) | MinKeyword (_MIF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547892"></A>        MaxType,                     // Nothing (MaxNotFixed) | MaxKeyword (_MAF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547899"></A>        TypeSpecificFlags,           // ByteConstExpr (_TSF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547906"></A>        AddressGranularity,          // WordConstExpr (_GRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547913"></A>        MinAddress,                  // WordConstExpr (_MIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547920"></A>        MaxAddress,                  // WordConstExpr (_MAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547927"></A>        AddressTranslation,          // WordConstExpr (_TRA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547934"></A>        AddressLength,               // WordConstExpr (_LEN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547941"></A>        ResourceSourceIndex,         // Nothing | ByteConstExpr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547948"></A>        ResourceSource,              // Nothing | StringData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547955"></A>        DescriptorName               // Nothing | NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1547962"></A>    )</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1366199"></A><A NAME="26663"></A>ASL Concepts</H2>
<P CLASS="Body">
<A NAME="pgfId-1366201"></A>This reference section is for developers who are writing ASL code while developing definition blocks for platforms. <A NAME="marker-1366200"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358183"></A><A NAME="_Toc489272737"></A><A NAME="_Toc4819445"></A><A NAME="_Toc202341947"></A><A NAME="_Toc258262583"></A>ASL Names<A NAME="marker-1358180"></A><A NAME="marker-1358181"></A><A NAME="marker-1358182"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1358184"></A>This section describes how to encode object names using ASL.</P>
<P CLASS="Body">
<A NAME="pgfId-1358185"></A>The following table lists the characters legal in any position in an ASL object name. ASL names are not case-sensitive and will be converted to upper case.<A NAME="marker-1358186"></A><A NAME="marker-1358187"></A><A NAME="marker-1358188"></A></P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1358189"></A>Named Object Reference Encodings</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358192"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358194"></A>Description</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358196"></A>Title</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358198"></A>0x41-0x5A, 0x5F, 0x61-0x7A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358200"></A>Lead character of name </P>
<P CLASS="TableBody">
<A NAME="pgfId-1358201"></A>(&#8216;A&#8217;-&#8216;Z&#8217;, &#8216;_&#8217; , &#8216;a&#8217;-&#8216;z&#8217;)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358203"></A>LeadNameChar</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358205"></A>0x30-0x39, 0x41-0x5A, 0x5F, 0x61-0x7A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358207"></A>Non-lead (trailing) character of name (&#8216;A&#8217;-&#8216;Z&#8217;, &#8216;_&#8217;, &#8216;a&#8217;-&#8216;z&#8217;, &#8216;0&#8217;-&#8216;9&#8217;) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358209"></A>NameChar</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1358215"></A>The following table lists the name modifiers that can be prefixed to an ASL name.<A NAME="marker-1358213"></A><A NAME="marker-1358214"></A></P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1366240"></A>Definition Block Name Modifier Encodings</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358219"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358221"></A>Description</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358223"></A>NamePrefix :=</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1358225"></A>Followed by ...</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358227"></A>0x5C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358229"></A>Namespace root (&#8216;&#92;&#8217;)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358231"></A>RootPrefix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358233"></A>Name</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358235"></A>0x5E</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358237"></A>Parent namespace (&#8216;^&#8217;)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358239"></A>ParentPrefix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358241"></A>ParentPrefix or Name</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358264"></A>_<A NAME="RSVD_Tx"></A>T_x Reserved Object Names<A NAME="marker-1358261"></A><A NAME="marker-1358262"></A><A NAME="marker-1358263"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1358265"></A>The ACPI specification reserves object names with the prefix _T_ for internal use by the ASL compiler. The ASL compiler may, for example, use these objects to store temporary values when implementing translation of complicated control structures into AML. The ASL compiler must declare _T_x objects normally (using Name) and must not define them more than once within the same scope.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358269"></A><A NAME="_Toc202341948"></A><A NAME="_Toc258262584"></A>ASL Literal Constants</H6>
<P CLASS="Body">
<A NAME="pgfId-1544668"></A>This section describes how to encode integer and string constants using ASL.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1544674"></A><A NAME="_Toc465246145"></A><A NAME="_Toc469218453"></A><A NAME="_Toc489267525"></A><A NAME="ASL_Integers"></A>Integers<A NAME="marker-1544673"></A></H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1358279"></A>DigitChar       := &#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0</EM>
&#8217;-&#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
9</EM>
&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358280"></A>LeadDigitChar   := &#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
1</EM>
&#8217;-&#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
9</EM>
&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358281"></A>OctalDigitChar  := &#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0</EM>
&#8217;-&#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
7</EM>
&#8217; </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358282"></A>HexDigitChar    := DigitChar | &#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
A</EM>
&#8217;-&#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
F</EM>
&#8217; | &#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
a</EM>
&#8217;-&#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
f</EM>
&#8217;</P>
<P CLASS="Body">
<A NAME="pgfId-1358283"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358284"></A>Integer         := DecimalConst | OctalConst | HexConst</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358285"></A>DecimalConst    := LeadDigitChar | &lt;DecimalConst DigitChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358286"></A>OctalConst      := &#8216;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0</EM>
&#8217; | &lt;OctalConst OctalDigitChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358287"></A>HexConst        := &lt;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0x </EM>
HexDigitChar&gt; | &lt;<EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0X </EM>
HexDigitChar&gt; | &lt;HexConst HexDigitChar&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358288"></A>ByteConst       := Integer =&gt; <EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0x00-0xFF</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358289"></A>WordConst       := Integer =&gt; <EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0x0000-0xFFFF</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358290"></A>DWordConst      := Integer =&gt; <EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0x00000000-0xFFFFFFFF</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544648"></A>QWordConst      := Integer =&gt; 0x0000000000000000-0xFFFFFFFFFFFFFFFF</P>
<P CLASS="Body">
<A NAME="pgfId-1544690"></A>Numeric constants can be specified in decimal, octal, or hexadecimal. Octal constants are preceded by a leading zero (0), and hexadecimal constants are preceded by a leading zero and either a lower or upper case &#8216;x&#8217;. In some cases, the grammar specifies that the number must evaluate to an integer within a limited range, such as 0x00-0xFF, and so on. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1544691"></A>   Strings</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1544692"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544634"></A><A NAME="marker-1544633"></A> String          := &#8216;&#8221;&#8217; Utf8CharList &#8216;&#8221;&#8217; </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544635"></A>Utf8CharList     := Nothing | &lt;EscapeSequence Utf8CharList&gt; | &lt;Utf8Char Utf8CharList&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1488226"></A>Utf8Char         := 0x01-0x21 | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358307"></A>                 0x23-0x5B | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358308"></A>                 0x5D-0x7F |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358309"></A>                 0xC2-0xDF 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358310"></A>                 0xE0 0xA0-0xBF 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358311"></A>                 0xE1-0xEC 0x80-0xBF 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358312"></A>                 0xED 0x80-0x9F 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358313"></A>                 0xEE-0xEF 0x80-0xBF 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358314"></A>                 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358315"></A>                 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358316"></A>                 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358317"></A>EscapeSeq        := SimpleEscapeSeq | OctalEscapeSeq | HexEscapeSeq</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358318"></A>SimpleEscapeSeq  := &#92;' | &#92;&quot; | &#92;a | &#92;b | &#92;f | &#92;n | &#92;r | &#92;t | &#92;v | &#92;&#92;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358319"></A>OctalEscapeSeq   := &#92; OctalDigitChar | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358320"></A>            &#92; OctalDigitChar OctalDigitChar | </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358321"></A>            &#92; OctalDigitChar OctalDigitChar OctalDigitChar</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358322"></A>HexEscapeSeq     := &#92;x HexDigitChar |</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544663"></A>            &#92;x HexDigitChar HexDigitChar</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544664"></A>NullChar         := <EM CLASS="Style-Grammar-Char-Char-Bold-Char-Char">
0x00</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1358325"></A>String literals consist of zero or more ASCII characters surrounded by double quotation marks (&quot;). A string literal represents a sequence of characters that, taken together, form a null-terminated string. After all adjacent strings in the constant have been concatenated, a null character is appended. </P>
<P CLASS="Body">
<A NAME="pgfId-1358326"></A>Strings in the source file may be encoded using the UTF-8 encoding scheme as defined in the Unicode 4.0 specification. UTF-8 is a byte-oriented encoding scheme, where some characters take a single byte and others take multiple bytes. The ASCII character values 0x01-0x7F take up exactly one byte.</P>
<P CLASS="Body">
<A NAME="pgfId-1358327"></A>However, only one operator currently supports UTF-8 strings: Unicode. Since string literals are defined to contain only non-null character values, both Hex and Octal escape sequence values must be non-null values in the ASCII range 0x01 through 0xFF. For arbitrary byte data (outside the range of ASCII values), the Buffer object should be used instead.</P>
<P CLASS="Body">
<A NAME="pgfId-1358328"></A>Since the backslash is used as the escape character and also the namespace root prefix, any string literals that are to contain a fully qualified namepath from the root of the namespace must use the double backslash to indicate this:    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544638"></A>    Name (_EJD, &#8221;&#92;&#92;_SB.PCI0.DOCK1&#8221;)</P>
<P CLASS="Body">
<A NAME="pgfId-1544640"></A>The double backslash is only required within quoted string literals.</P>
<P CLASS="Body">
<A NAME="pgfId-1358332"></A>Since double quotation marks are used close a string, a special escape sequence (&#92;&quot;) is used to allow quotation marks within strings. Other escape sequences are listed in the table below:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1358334"></A>ASL Escape Sequences</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1488258"></A>Escape Sequence</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1488260"></A>ASCII Character</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358341"></A>&#92;a</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358343"></A>0x07 (BEL)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358345"></A>&#92;b</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358347"></A>0x08 (BS)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358349"></A>&#92;f</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358351"></A>0x0C (FF)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358353"></A>&#92;n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358355"></A>0x0A (LF)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358357"></A>&#92;r</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358359"></A>0x0D (CR)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358361"></A>&#92;t</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358363"></A>0x09 (TAB)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358365"></A>&#92;v</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358367"></A>0x0B (VT)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358369"></A>&#92;&quot;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358371"></A>0x22 (&quot;)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358373"></A>&#92;'</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358375"></A>0x27 (')</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358377"></A>&#92;&#92;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358379"></A>0x5C (&#92;)</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1358382"></A>Since literal strings are read-only constants, the following ASL statement (for example) is not supported:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358384"></A>    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524252"></A>Store (&#8220;ABC&#8221;, &#8221;DEF&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524259"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1358385"></A>However, the following sequence of statements is supported:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358387"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524266"></A>Name (STR, &#8221;DEF&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358388"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358389"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358390"></A>Store (&#8220;ABC&#8221;, STR)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524273"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358396"></A><A NAME="_Toc202341949"></A><A NAME="_Toc258262585"></A>ASL Resource Templates</H6>
<P CLASS="Body">
<A NAME="pgfId-1358397"></A>ASL includes some macros for creating resource descriptors. The ResourceTemplate macro creates a Buffer in which resource descriptor macros can be listed. The ResourceTemplate macro automatically generates an End descriptor and calculates the checksum for the resource template. The format for the ResourceTemplate macro is as follows:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358399"></A>    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524280"></A>ResourceTemplate ()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358400"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358401"></A>        // List of resource macros</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358402"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524287"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1358403"></A>The following is an example of how these macros can be used to create a resource template that can be returned from a _PRS control method:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358405"></A>    Name (PRS0, ResourceTemplate ()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358406"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358407"></A>        StartDependentFn (1, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358408"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358409"></A>            IRQ (Level, ActiveLow, Shared) {10, 11}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358410"></A>            DMA (TypeF, NotBusMaster, Transfer16) {4}    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358411"></A>            IO (Decode16, 0x1000, 0x2000, 0, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358412"></A>            IO (Decode16, 0x5000, 0x6000, 0, 0x100, IO1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358413"></A>        }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358414"></A>        StartDependentFn (1, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358415"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358416"></A>            IRQ (Level, ActiveLow, Shared) {}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358417"></A>            DMA (TypeF, NotBusMaster, Transfer16){5}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358418"></A>            IO (Decode16, 0x3000, 0x4000, 0, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358419"></A>            IO (Decode16, 0x5000, 0x6000, 0, 0x100, IO2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358420"></A>        }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358421"></A>        EndDependentFn ()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358422"></A>    })</P>
<P CLASS="Body">
<A NAME="pgfId-1358423"></A>Occasionally, it is necessary to change a parameter of a descriptor in an existing resource template at run-time (i.e., during a method execution.) To facilitate this, the descriptor macros optionally include a name declaration that can be used later to refer to the descriptor. When a name is declared with a descriptor, the ASL compiler will automatically create field names under the given name to refer to individual fields in the descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1358424"></A>The offset returned by a reference to a resource descriptor field name is either in units of bytes (for 8-, 16-, 32-, and 64-bit field widths) or in bits (for all other field widths). In all cases, the returned offset is the integer offset (in either bytes or bits) of the name from the first byte (offset 0) of the parent resource template.</P>
<P CLASS="Body">
<A NAME="pgfId-1358425"></A>For example, given the above resource template, the following code changes the minimum and maximum addresses for the I/O descriptor named IO2:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358427"></A>    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524301"></A>    CreateWordField (PRS0, IO2._MIN, IMIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358428"></A>    Store (0xA000, IMIN)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358429"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358430"></A>    CreateWordField (PRS0, IO2._MAX, IMAX)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358431"></A>    Store (0xB000, IMAX)</P>
<P CLASS="Body">
<A NAME="pgfId-1358432"></A>The resource template macros for each of the resource descriptors are listed below, after the table that defines the resource descriptor. The resource template macros are formally defined in <A HREF="Device_Configuration.htm#_Toc202341496" CLASS="XRef">See ASL Macros for Resource Descriptors.</A>, &#8220;ASL Macros for Resource Descriptors.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1358433"></A>The reserved names (such as _MIN and _MAX) for the fields of each resource descriptor are defined in the appropriate table entry of the table that defines that resource descriptor. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358458"></A><A NAME="_Toc489256024"></A><A NAME="_Toc489267948"></A><A NAME="_Toc489272501"></A><A NAME="_Ref42574572"></A><A NAME="_Toc202341950"></A><A NAME="_Toc258262586"></A>ASL Macros<A NAME="marker-1558492"></A><A NAME="marker-1558493"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1558538"></A>ASL compilers support built in macros to assist in various ASL coding operations. These macros do not have a corresponding AML opcode, but are instead fully processed by the compiler itself, and may result in the generation of AML opcodes for other ASL/AML operators. The following table lists some of the supported directives and an explanation of their function. </P>
<P CLASS="Body">
<A NAME="pgfId-1558539"></A>The ASL language provides a wide variety of data types and operators that manipulate data. It also provides mechanisms for both explicit and implicit conversion between the data types when used with ASL operators. </P>
<P CLASS="Body">
<A NAME="pgfId-1558540"></A>Each of the available ASL macros are described below. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558720"></A>EISAID (TextID)</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558721"></A>Converts and compresses the 7-character text argument into its corresponding 4-byte numeric EISA ID encoding (Integer). This can be used when declaring IDs for devices that are EISA IDs. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1562346"></A>For (Initialize, Predicate, Update) {TermList}</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1562325"></A>Converts a format string to a series of string Concatenate operations and stores the result to a Named Object (Target). </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558722"></A>Fprintf (Target, FormatString, FormatArgs)</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558723"></A>Implements a standard For() loop by converting the For() arguments and TermList into an AML While loop.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558724"></A>Printf (FormatString, FormatArgs)</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558725"></A>Converts a format string to a series of string Concatenate operations and automatically stores the result to the Debug Object. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558726"></A>ResourceTemplate ()</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558727"></A>Used to supply Plug and Play resource descriptor information in human readable form, which is then translated into the appropriate binary Plug and Play resource descriptor encodings in a Resource Template Buffer object. For more information about resource descriptor encodings, see Section 6.4, &quot;Resource Data Types for ACPI.&quot; </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558728"></A>ToPLD (PLDKeywordList)</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558729"></A>Converts a PLD (Physical Location of Device) Keyword List into a _PLD Buffer object. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558730"></A>ToUUID (<EM CLASS="Italic">
AsciiString</EM>
)</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558731"></A>Converts an ASCII UUID or GUID string to an encoded 128-bit Buffer object. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558732"></A>Unicode (StringData)</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558733"></A>Converts a standard ASCII string to a Unicode string returned in a Buffer object.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358502"></A><A NAME="_Toc4819446"></A><A NAME="_Toc202341951"></A><A NAME="_Toc258262587"></A>ASL Data Type<A NAME="marker-1558883"></A><A NAME="marker-1558884"></A>s</H6>
<P CLASS="Body">
<A NAME="pgfId-1358503"></A>ASL provides a wide variety of data types and operators that manipulate data. It also provides mechanisms for both explicit and implicit conversion between the data types when used with ASL operators. <A NAME="marker-1558713"></A><A NAME="marker-1558714"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1358506"></A>The table below describes each of the available data types.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1516605"></A>Summary of ASL Data Types</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1526525"></A>ASL Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1526527"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526530"></A>[Uninitialized]<A NAME="marker-1526529"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526532"></A>No assigned type or value. This is the type of all control method LocalX variables and unused ArgX variables at the beginning of method execution, as well as all uninitialized Package elements. Uninitialized objects must be initialized (via Store or CopyObject) before they may be used as source operands in ASL expressions.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526535"></A>Buffer<A NAME="marker-1526534"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526537"></A>An array of bytes. Uninitialized elements are zero by default.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526540"></A>Buffer Field<A NAME="marker-1526539"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526542"></A>Portion of a buffer created using CreateBitField, CreateByteField, CreateWordField, CreateQWordField, CreateField, or returned by the Index operator.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526545"></A>DDB Handle<A NAME="marker-1526544"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526547"></A>Definition block handle returned by the Load operator</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526550"></A>Debug Object<A NAME="marker-1526549"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526552"></A>Debug output object. Formats an object and prints it to the system debug port. Has no effect if debugging is not active.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526555"></A>Device<A NAME="marker-1526554"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526557"></A>Device or bus object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526560"></A>Event<A NAME="marker-1526559"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526562"></A>Event synchronization object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526564"></A>Field Unit (within an Operation Region)<A NAME="marker-1526565"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526567"></A>Portion of an address space, bit-aligned and of one-bit granularity. Created using Field, BankField, or IndexField.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526570"></A>Integer<A NAME="marker-1526569"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526572"></A>An <EM CLASS="Style-Table-Italic-Char-Char">
n</EM>
-bit little-endian unsigned integer. In ACPI 1.0 this was 32 bits. In ACPI 2.0 and later, this is 64 bits. The Integer (DWORD) designation indicates that only the lower 32 bits have meaning and the upper 32 bits of 64-bit integers must be zero (masking of upper bits is not required).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526575"></A>Integer Constant<A NAME="marker-1526574"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526577"></A>Created by the ASL terms &#8220;Zero&#8221;, &#8220;One&#8221;, &#8220;Ones&#8221;, and &#8220;Revision&#8221;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526580"></A>Method<A NAME="marker-1526579"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526582"></A>Control Method (Executable AML function)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526585"></A>Mutex<A NAME="marker-1526584"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1526586"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526588"></A>Mutex synchronization object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526591"></A>Object Reference<A NAME="marker-1526590"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526593"></A>Reference to an object created using the RefOf, Index, or CondRefOf operators</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526596"></A>Operation Region<A NAME="marker-1526595"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526598"></A>Operation Region (A region within an Address Space)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526601"></A>Package<A NAME="marker-1526600"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526603"></A>Collection of ASL objects with a fixed number of elements (up to 255).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526606"></A>Power Resource<A NAME="marker-1526605"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526608"></A>Power Resource description object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526611"></A>Processor<A NAME="marker-1526610"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526613"></A>Processor description object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526625"></A>RawDataBuffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526627"></A>An array of bytes. Uninitialized elements are zero by default. RawDataBuffer does not contain any AML encoding bytes, only the raw bytes.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526616"></A>String<A NAME="marker-1526615"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526618"></A>Null-terminated ASCII string.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526621"></A>Thermal Zone<A NAME="marker-1526620"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1526623"></A>Thermal Zone description object</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1358653"></A>(Compatibility Note) The ability to store and manipulate object references was first introduced in ACPI 2.0. In ACPI 1.0 references could not be stored in variables, passed as parameters or returned from functions.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358654"></A>Data Type Conversion Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1358655"></A>ASL provides two mechanisms to convert objects from one data type to another data type at run-time (during execution of the AML interpreter). The first mechanism, Explicit Data Type Conversion, allows the use of explicit ASL operators to convert an object to a different data type. The second mechanism, Implicit Data Type Conversion, is invoked by the AML interpreter when it is necessary to convert a data object to an expected data type before it is used or stored.</P>
<P CLASS="Body">
<A NAME="pgfId-1358656"></A>The following general rules apply to data type conversions:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1358657"></A>Input parameters are always subject to implicit data type conversion (also known as implicit source operand conversion) whenever the operand type does not match the expected input type.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358658"></A>Output (target) parameters for all operators except the explicit data conversion operators are subject to implicit data type conversion (also known as implicit result object conversion) whenever the target is an existing named object or named field that is of a different type than the object to be stored.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358659"></A>Output parameters for the explicit data conversion operators, as well as output parameters that refer to a method local or argument (LocalX or ArgX) are not subject to implicit type conversion.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1358660"></A>Both of these mechanisms (explicit and implicit conversion) are described in detail in the sections that follow.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358661"></A><A NAME="13652"></A>Explicit Data Type Conversions</H6>
<P CLASS="Body">
<A NAME="pgfId-1358662"></A>The following ASL operators are provided to explicitly convert an object from one data type to another:</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558900"></A>ToBuffer</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558901"></A>Convert an Integer, String, or Buffer to an object of type Buffer </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558902"></A>ToDecimalString</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558903"></A>Convert an Integer, String, or Buffer to an object of type String. The string contains the ASCII representation of the decimal value of the source operand. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558904"></A>ToHexString</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558905"></A>Convert an Integer, String, or Buffer to an object of type String. The string contains the ASCII representation of the hexadecimal value of the source operand.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558906"></A>ToInteger</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558907"></A>Convert an Integer, String, or Buffer to an object of type Integer. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558908"></A>ToString</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558909"></A>Copy directly and convert a Buffer to an object of type String.</P>
<P CLASS="Body">
<A NAME="pgfId-1558911"></A>The following ASL operator is provided to copy and transfer objects with an explicit result conversion of the type of the target to match the type of the source object:</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558913"></A>CopyObject </H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558914"></A>Explicitly store a copy of the operand object to the target name. No implicit type conversion is performed. (This operator is used to avoid the implicit conversion inherent in the ASL Store operator.) </P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558893"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358676"></A><A NAME="54087"></A>Implicit Data Type Conversions</H6>
<P CLASS="Body">
<A NAME="pgfId-1358677"></A>Automatic or Implicit type conversions can take place at two different times during the execution of an ASL operator. First, it may be necessary to convert one or more of the source operands to the data type(s) expected by the ASL operator. Second, the result of the operation may require conversion before it is stored into the destination. (Many of the ASL operators can store their result optionally into an object specified by the last parameter. In these operators, if the destination is specified, the action is exactly as if a Store operator had been used to place the result in the destination.)<A NAME="marker-1358678"></A><A NAME="marker-1358679"></A><A NAME="marker-1358680"></A><A NAME="marker-1358681"></A><A NAME="marker-1358682"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1358683"></A>Such data conversions are performed by an AML interpreter during execution of AML code and are known collectively as Implicit Operand Conversions. As described briefly above, there are two different types of implicit operand conversion: </P>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1358684"></A>Conversion of a source operand from a mismatched data type to the correct data type required by an ASL operator, called Implicit Source Conversion. This conversion occurs when a source operand must be converted to the operand type expected by the operator. Any or all of the source operands may be converted in this manner before the execution of the ASL operator can proceed.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1358685"></A>Conversion of the result of an operation to the existing type of a target operand before it is stored into the target operand, called Implicit Result Conversion. This conversion occurs when the target is a fixed type such as a named object or a field. When storing to a method Local or Arg, no conversion is performed or required because these data types are of variable type (the store simply overwrites any existing object and the existing type).</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1558972"></A>The following ASL operator is provided to copy and transfer objects with an implicit result conversion to the existing type of the target object:</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1558974"></A>Store </H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1558975"></A>Store a copy of the operand object to the target name. Implicit result conversion is performed if the target name is of a fixed data type (see above). However, Stores to method locals and arguments do not perform implicit conversion and are therefore the same as using CopyObject.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358686"></A><A NAME="88653"></A>Implicit Source Operand Conversion</H6>
<P CLASS="ACPINormal">
<A NAME="pgfId-1358687"></A>During the execution of an ASL operator, each source operand is processed by the AML interpreter as follows:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1358688"></A>If the operand is of the type expected by the operator, no conversion is necessary.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358689"></A>If the operand type is incorrect, attempt to convert it to the proper type.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358690"></A>For the Concatenate operator and logical operators (LEqual, LGreater, LGreaterEqual, LLess, LLessEqual, and LNotEqual), the data type of the first operand dictates the required type of the second operand, and for Concatenate only, the type of the result object. (The second operator is implicitly converted, if necessary, to match the type of the first operand.)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358691"></A>If conversion is impossible, abort the running control method and issue a fatal error.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1358692"></A>An implicit source conversion will be attempted anytime a source operand contains a data type that is different that the type expected by the operator. For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358693"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524329"></A>Store (&#8220;5678&#8221;, Local1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358694"></A>Add (0x1234, Local1, BUF1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524336"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1358695"></A>In the Add statement above, Local1 contains a String object and must undergo conversion to an Integer object before the Add operation can proceed. </P>
<P CLASS="Body">
<A NAME="pgfId-1358696"></A>In some cases, the operator may take more than one type of operand (such as Integer and String). In this case, depending on the type of the operand, the highest priority conversion is applied. The table below describes the source operand conversions available. For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358697"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524343"></A>Store (Buffer (1) {}, Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358698"></A>Name (ABCD, Buffer (10) {1, 2, 3, 4, 5, 6, 7, 8, 9, 0})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358699"></A>CreateDWordField (ABCD, 2, XYZ)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358700"></A>Name (MNOP, &#8221;1234&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358701"></A>Concatenate (XYZ, MNOP, Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524350"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1548549"></A>The Concatenate operator can take an Integer, Buffer or String for its first two parameters and the type of the first parameter determines how the second parameter will be converted. In this example, the first parameter is of type Buffer Field (from the CreateDWordField operator). What should it be converted to: Integer, Buffer or String? According to <A HREF="ACPI_Source_Language_Reference.htm#62921" CLASS="XRef">See Object Conversion Rules.</A>, the highest priority conversion is to Integer. Therefore, both of the following objects will be converted to Integers:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358703"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524357"></A>XYZ (0x05040302) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358704"></A>MNOP (0x31, 0x32, 0x33, 0x34) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524364"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1358705"></A>And will then be joined together and the resulting type and value will be:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358706"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524371"></A>Buffer (0x02, 0x03, 0x04, 0x05, 0x31, 0x32, 0x33, 0x34)</P>
<P CLASS="Body">
<A NAME="pgfId-1524378"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358707"></A>Implicit Result Object Conversion</H6>
<P CLASS="Body">
<A NAME="pgfId-1358708"></A>For all ASL operators that generate and store a result value (including the Store operator), the result object is processed and stored by the AML interpreter as follows:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1358709"></A>If the ASL operator is one of the explicit conversion operators (ToString, ToInteger, etc., and the CopyObject operator), no conversion is performed. (In other words, the result object is stored directly to the target and completely overwrites any existing object already stored at the target.)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358710"></A>If the target is a method local or argument (LocalX or ArgX), no conversion is performed and the result is stored directly to the target.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358711"></A>If the target is a fixed type such as a named object or field object, an attempt is made to convert the source to the existing target type before storing.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1358712"></A>If conversion is impossible, abort the running control method and issue a fatal error.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1358713"></A>An implicit result conversion can occur anytime the result of an operator is stored into an object that is of a fixed type. For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358714"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524385"></A>Name (BUF1, Buffer (10))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1358715"></A>Add (0x1234, 0x789A, BUF1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524392"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1358716"></A>Since BUF1 is a named object of fixed type Buffer, the Integer result of the Add operation must be converted to a Buffer before it is stored into BUF1.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358717"></A>Data Types and Type Conversions</H6>
<P CLASS="Body">
<A NAME="pgfId-1494757"></A>The following table lists the available ASL data types and the available data type conversions (if any) for each. The entry for each data type is fully cross-referenced, showing both the types to which the object may be converted as well as all other types that may be converted to the data type.</P>
<P CLASS="Body">
<A NAME="pgfId-1530095"></A>The allowable conversions apply to both explicit and implicit conversions.</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<H6 CLASS="TableTitle">
<A NAME="pgfId-1529899"></A>Data Types and Type Conversions</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529907"></A>ASL Data Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529909"></A>Can be implicitly or explicitly converted to these Data Types: (In priority order)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529911"></A>Can be implicitly or explicitly converted from these Data Types:</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529913"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529916"></A>[Uninitialized]<A NAME="marker-1529915"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1529917"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529919"></A>None. Causes a fatal error when used as a source operand in any ASL statement.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529921"></A>Integer, String, Buffer, Package, DDB Handle, Object Reference</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529923"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529926"></A>Buffer<A NAME="marker-1529925"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529928"></A>Integer, String, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529930"></A>Integer, String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529932"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529935"></A>Buffer Field<A NAME="marker-1529934"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529937"></A>Integer, Buffer, String, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529939"></A>Integer, Buffer, String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529941"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529944"></A>DDB Handle<A NAME="marker-1529943"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529946"></A>Integer, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529948"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529950"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529953"></A>Debug Object<A NAME="marker-1529952"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529955"></A>None. Causes a fatal error when used as a source operand in any ASL statement.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529957"></A>Integer, String, Buffer, Package, Field Unit, Buffer Field, DDB Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529959"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529962"></A>Device<A NAME="marker-1529961"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529964"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529966"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529968"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529971"></A>Event<A NAME="marker-1529970"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529974"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529976"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529978"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529980"></A>Field Unit (within an Operation Region)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529983"></A>Integer, Buffer, String, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529985"></A>Integer, Buffer, String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529987"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529990"></A>Integer<A NAME="marker-1529989"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529992"></A>Buffer, Buffer Field, DDB Handle, Field Unit, String, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529994"></A>Buffer, String </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1529996"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1529999"></A>Integer Constant<A NAME="marker-1529998"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530001"></A>Integer, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530003"></A>None. Also, storing any object to a constant is a no-op, not an error.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530005"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530008"></A>Method<A NAME="marker-1530007"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530010"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530012"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530014"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530017"></A>Mutex<A NAME="marker-1530016"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530019"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530021"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530023"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530026"></A>Object Reference<A NAME="marker-1530025"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530028"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530030"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530032"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530035"></A>Operation Region<A NAME="marker-1530034"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530037"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530039"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530041"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530044"></A>Package<A NAME="marker-1530043"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530046"></A>Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530048"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530050"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530053"></A>String<A NAME="marker-1530052"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530055"></A>Integer, Buffer, Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530057"></A>Integer, Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530059"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530062"></A>Power Resource<A NAME="marker-1530061"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530064"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530066"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530068"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530071"></A>Processor<A NAME="marker-1530070"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530073"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530075"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530077"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530104"></A>RawDataBuffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530118"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530130"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530085"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530088"></A>Thermal Zone<A NAME="marker-1530087"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530090"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1530092"></A>None</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="caption-Caption-Char1-Caption-Char-Char-fighead2-Char-Char-fighead21-Char-Char-fighead22-Char-Char-fighead211-Char-Char-table-caption-Char-Char-Table-Caption-Char-Char-Table-caption-Char-Char-fig-and-tbl-Char-Char-fighead23-Char-Char-fighead2-fighead21">
<A NAME="pgfId-1530094"></A>&nbsp;</H6>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1530097"></A><A NAME="85702"></A>Data Type Conversion Rules</H6>
<P CLASS="Body">
<A NAME="pgfId-1530098"></A>The following table presents the detailed data conversion rules for each of the allowable data type conversions. These conversion rules are implemented by the AML Interpreter and apply to all conversion types -- explicit conversions, implicit source conversions, and implicit result conversions.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1491931"></A><A NAME="62921"></A>Object Conversion Rules</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1491952"></A>To convert from an object of this Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1491954"></A>To an object of this Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1491956"></A>&nbsp;</P>
<P CLASS="TableHeading">
<A NAME="pgfId-1491957"></A>This action is performed by the AML Interpreter:</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491786"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491788"></A>Buffer Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491790"></A>The contents of the buffer are copied to the Buffer Field. If the buffer is smaller than the size of the buffer field, it is zero extended. If the buffer is larger than the size of the buffer field, the upper bits are truncated.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1491791"></A>Compatibility Note: This conversion was first introduced in ACPI 2.0. The behavior in ACPI 1.0 was undefined.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491795"></A>Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491797"></A>Each buffer byte is displayed as a hexadecimal integer, delimited by spaces and/or commas.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491801"></A>Field Unit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491803"></A>The entire contents of the buffer are copied to the Field Unit. If the buffer is larger (in bits) than the size of the Field Unit, it is broken into pieces and completely written to the Field Unit, lower chunks first. If the buffer (or the last piece of the buffer, if broken up) is smaller than the size of the Field Unit, it is zero extended before being written.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491807"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491809"></A>If no integer object exists, a new integer is created. The contents of the buffer are copied to the Integer, starting with the least-significant bit and continuing until the buffer has been completely copied -- up to the maximum number of bits in an Integer. The size of an Integer is indicated by the Definition Block table header&#8217;s Revision field. A Revision field value less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. If the buffer is smaller than the size of an integer, it is zero extended. If the buffer is larger than the size of an integer, it is truncated. Conversion of a zero-length buffer to an integer is not allowed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491813"></A>String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491815"></A>If no string object exists, a new string is created. If the string already exists, it is completely overwritten and truncated or extended to accommodate the converted buffer exactly.The entire contents of the buffer are converted to a string of two-character hexadecimal numbers, each separated by a space. A zero-length buffer will be converted to a null (zero-length) string.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491817"></A>Buffer Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491819"></A>[See the Integer and Buffer Rules]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491821"></A>If the Buffer Field is smaller than or equal to the size of an Integer (in bits), it will be treated as an Integer. Otherwise, it will be treated as a Buffer. The size of an Integer is indicated by the Definition Block table header&#8217;s Revision field. A Revision field value less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. (See the conversion rules for the Integer and Buffer data types.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491823"></A>DDB Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491825"></A>[See the Integer Rule]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491827"></A>The object is treated as an Integer (See conversion rules for the Integer data type.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491829"></A>Field Unit </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491831"></A>[See the Integer and Buffer Rules]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491833"></A>If the Field Unit is smaller than or equal to the size of an Integer (in bits), it will be treated as an Integer. If the Field Unit is larger than the size of an Integer, it will be treated as a Buffer. The size of an Integer is indicated by the Definition Block table header&#8217;s Revision field. A Revision field value less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. (See the conversion rules for the Integer and Buffer data types.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491835"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491837"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491839"></A>If no buffer object exists, a new buffer object is created based on the size of the integer (4 bytes for 32-bit integers and 8 bytes for 64-bit integers). If a buffer object already exists, the Integer overwrites the entire Buffer object. If the integer requires more bits than the size of the Buffer, then the integer is truncated before being copied to the Buffer. If the integer contains fewer bits than the size of the buffer, the Integer is zero-extended to fill the entire buffer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491843"></A>Buffer Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491845"></A>The Integer overwrites the entire Buffer Field. If the integer is smaller than the size of the buffer field, it is zero-extended. If the integer is larger than the size of the buffer field, the upper bits are truncated.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1491846"></A>Compatibility Note: This conversion was first introduced in ACPI 2.0. The behavior in ACPI 1.0 was undefined.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491850"></A>Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491852"></A>The integer is displayed as a hexadecimal value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491856"></A>Field Unit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491858"></A>The Integer overwrites the entire Field Unit. If the integer is smaller than the size of the buffer field, it is zero-extended. If the integer is larger than the size of the buffer field, the upper bits are truncated.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491862"></A>String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491864"></A>If no string object exists, a new string object is created based on the size of the integer (8 characters for 32-bit integers and 16 characters for 64-bit integers). If the string already exists, it is completely overwritten and truncated or extended to accommodate the converted integer exactly. In either case, the entire integer is converted to a string of hexadecimal ASCII characters.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491866"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491868"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491870"></A>If no package object exists, a new package object is created. If the package already exists, it is completely overwritten and truncated or extended to accommodate the source package exactly. Any and all existing valid (non-null) package elements of the target package are deleted, and the entire contents of the source package are copied into the target package.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491874"></A>Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491876"></A>Each element of the package is displayed based on its type.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491878"></A>String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491880"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491882"></A>If no buffer object exists, a new buffer object is created. If a buffer object already exists, it is completely overwritten. If the string is longer than the buffer, the string is truncated before copying. If the string is shorter than the buffer, the remaining buffer bytes are set to zero. In either case, the string is treated as a buffer, with each ASCII string character copied to one buffer byte, including the null terminator. A null (zero-length) string will be converted to a zero-length buffer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491886"></A>Buffer Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491888"></A>The string is treated as a buffer. If this buffer is smaller than the size of the buffer field, it is zero extended. If the buffer is larger than the size of the buffer field, the upper bits are truncated.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1491889"></A>Compatibility Note: This conversion was first introduced in ACPI 2.0. The behavior in ACPI 1.0 was undefined.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491893"></A>Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491895"></A>Each string character is displayed as an ASCII character.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491899"></A>Field Unit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491901"></A>Each character of the string is written, starting with the first, to the Field Unit. If the Field Unit is less than eight bits, then the upper bits of each character are lost. If the Field Unit is greater than eight bits, then the additional bits are zeroed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491905"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1491907"></A>If no integer object exists, a new integer is created. The integer is initialized to the value zero and the ASCII string is interpreted as a hexadecimal constant. Each string character is interpreted as a hexadecimal value (&#8216;0&#8217;-&#8216;9&#8217;, &#8216;A&#8217;-&#8216;F&#8217;, &#8216;a&#8217;-&#8216;f&#8217;), starting with the first character as the most significant digit, and ending with the first non-hexadecimal character, end-of-string, or when the size of an integer is reached (8 characters for 32-bit integers and 16 characters for 64-bit integers). Note: the first non-hex character terminates the conversion without error, and a &#8220;0x&#8221; prefix is not allowed. Conversion of a null (zero-length) string to an integer is not allowed.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359092"></A><A NAME="11668"></A>Rules for Storing and Copying Objects</H6>
<P CLASS="Body">
<A NAME="pgfId-1359093"></A>The table below lists the actions performed when storing objects to different types of named targets. ASL provides the following types of &#8220;store&#8221; operations:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1359094"></A>The Store operator is used to explicitly store an object to a location, with implicit conversion support of the source object.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1359095"></A>Many of the ASL operators can store their result optionally into an object specified by the last parameter. In these operators, if the destination is specified, the action is exactly as if a Store operator had been used to place the result in the destination.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1359096"></A>The CopyObject operator is used to explicitly store a copy of an object to a location, with no implicit conversion support.</LI>
</UL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359097"></A><A NAME="93789"></A>Object Storing and Copying Rules</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359100"></A>When Storing an object of any data type to this type of Target location</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359102"></A>This action is performed by the Store operator or any ASL operator with a Target operand:</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359104"></A>This action is performed by the CopyObject operator:</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359106"></A>Method ArgX variable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1359108"></A>The object is copied to the destination with no conversion applied, with one exception. If the ArgX contains an Object Reference, an automatic de-reference occurs and the object is copied to the target of the Object Reference instead of overwriting the contents of ArgX</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359112"></A>Method LocalX variable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1359114"></A>The object is copied to the destination with no conversion applied. Even if LocalX contains an Object Reference, it is overwritten.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359118"></A>Field Unit or Buffer Field </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359120"></A>The object is copied to the destination after implicit result conversion is applied</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359122"></A>Fields permanently retain their type and cannot be changed. Therefore, CopyObject can only be used to copy an object of type Integer or Buffer to fields.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359124"></A> Named data object </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359126"></A>The object is copied to the destination after implicit result conversion is applied to match the existing type of the named location</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359128"></A>The object and type are copied to the named location. </P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359147"></A>Rules for Reading and Writing Objects</H6>
<P CLASS="Body">
<A NAME="pgfId-1359148"></A>In the descriptions below, read operations always return the actual object, not a copy of the object in order that constructs of the form: </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359149"></A>    Add (Local1, Local2, Local3)</P>
<P CLASS="Body">
<A NAME="pgfId-1359150"></A>do not create unnecessary copies of Local1 or Local2. Also, this behavior enables the call-by-reference semantics of control method invocation.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1359151"></A>ArgX Objects</H6>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1359152"></A> Read from ArgX parameters</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359153"></A>ObjectReference - Automatic dereference, return the target of the reference. Use of DeRefOf returns the same.</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359154"></A>Buffer - Return the Buffer. Can create an Index, Field, or Reference to the buffer.</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359155"></A>Package - Return the Package. Can create an Index or Reference to the package. </LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359156"></A>All other object types - Return the object. </LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1359158"></A>Example method invocation for the table below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359159"></A>   </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524399"></A> MTHD (RefOf (Obj), Buf, Pkg, Obj)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524406"></A>&nbsp;</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359161"></A>Reading from ArgX Objects<A NAME="marker-1359160"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1494967"></A>Parameter</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1494969"></A>MTHD ArgX Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1494971"></A>Read operation on ArgX</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1494973"></A>Result of read</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359172"></A>RefOf (Obj),</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359174"></A>Reference to object Obj</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359176"></A>Store (Arg0, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359177"></A>CopyObject (Arg0, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359178"></A>DeRefOf (Arg0)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359180"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359181"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359182"></A>Obj</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359184"></A>Buf,</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359186"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359188"></A>Store (Arg1, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359189"></A>CopyObject (Arg1, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359190"></A>Index (Arg1, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359191"></A>Field (Arg1, ...)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359193"></A>Buf</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359194"></A>Buf</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359195"></A>Index (Buf)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359196"></A>Field (Buf)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359198"></A>Pkg</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359200"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359202"></A>Store (Arg2, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359203"></A>CopyObject (Arg2, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359204"></A>Index (Arg2, ...)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359206"></A>Pkg</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359207"></A>Pkg</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359208"></A>Index (Pkg)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359210"></A>Obj</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359212"></A>All other object types</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359214"></A>Store (Arg3, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359215"></A>CopyObject (Arg3, ...) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359217"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359218"></A>Obj</P>
</TD>
</TR>
</TABLE>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1359221"></A>Store to ArgX parameters</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359222"></A>ObjectReference objects - Automatic dereference, copy the object and overwrite the final target.</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359223"></A>All other object types- Copy the object and overwrite the ArgX variable. (Direct writes to buffer or package ArgX parameters will also simply overwrite ArgX)</LI>
</OL>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1366835"></A>Writing to ArgX Objects<A NAME="marker-1366803"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1366806"></A>Current type of ArgX</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1366808"></A>Object to be written</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1366810"></A>Write operation on ArgX</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1366812"></A>Result of write (in ArgX)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366814"></A>RefOf (OldObj)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366816"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1366817"></A>(Any type)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366819"></A>Store (..., ArgX) </P>
<P CLASS="TableBody">
<A NAME="pgfId-1366820"></A>CopyObject (..., ArgX)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366822"></A>RefOf (copy of Obj)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1366823"></A>RefOf (copy of Obj)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366825"></A>All other object types</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366827"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1366828"></A>(Any type)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366830"></A>Store (..., ArgX) </P>
<P CLASS="TableBody">
<A NAME="pgfId-1366831"></A>CopyObject (..., ArgX)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1366833"></A>Copy of Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1366834"></A>Copy of Obj</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1366836"></A>RefOf (ArgX) returns a reference to ArgX.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1366837"></A>LocalX Objects</H6>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1359261"></A> Read from LocalX variables</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359262"></A>ObjectReference - If performing a DeRefOf return the target of the reference. Otherwise, return the reference. </LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359263"></A>All other object types - Return a the object</LI>
</OL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359265"></A>Reading from LocalX Objects<A NAME="marker-1359264"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359268"></A>Current LocalX Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359270"></A>Read operation on LocalX</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359272"></A>Result of read</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359274"></A>RefOf (Obj)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359276"></A>Store (LocalX, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359277"></A>CopyObject (LocalX, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359278"></A>DeRefOf (LocalX)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359280"></A>RefOf (Obj)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359281"></A>RefOf (Obj)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359282"></A>Obj</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359284"></A>Obj (All other types)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359286"></A>Store (LocalX, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359287"></A>CopyObject (LocalX, ...)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359289"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359290"></A>Obj</P>
</TD>
</TR>
</TABLE>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1359293"></A> Store to LocalX variables</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359294"></A>All object types - Delete any existing object in LocalX first, then store a copy of the object. </LI>
</OL>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359296"></A>Writing to LocalX Objects<A NAME="marker-1359295"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359299"></A>Current LocalX Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359301"></A>Object to be written</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359303"></A>Write operation on LocalX</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359305"></A>Result of write (in LocalX)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359307"></A>All object types</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359309"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359310"></A>(Any type)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359312"></A>Store (..., LocalX)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359313"></A>CopyObject (..., LocalX)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359315"></A>Copy of Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359316"></A>Copy of Obj</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1359319"></A>Named Objects</H6>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1359320"></A>Read from Named object</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359321"></A>ObjectReference - If performing a DeRefOf return the target of the reference. Otherwise, return the reference. </LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359322"></A>All other object types - Return the object</LI>
</OL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359324"></A>Reading from Named Objects<A NAME="marker-1359323"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359327"></A>Current NAME Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359329"></A>Read operation on NAME</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359331"></A>Result of read</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359333"></A>RefOf (Obj)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359335"></A>Store (NAME, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359336"></A>CopyObject (NAME, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359337"></A>DeRefOf (NAME)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359339"></A>RefOf (Obj)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359340"></A>RefOf (Obj)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359341"></A>Obj</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359343"></A>Obj (All other types)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359345"></A>Store (NAME, ...)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359346"></A>CopyObject (NAME, ...)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359348"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359349"></A>Obj</P>
</TD>
</TR>
</TABLE>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1359352"></A> Store to Named object</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1359353"></A>All object types - Delete any existing object in NAME first, then store a copy of the object. The Store operator will perform an implicit conversion to the existing type in NAME. CopyObject does not perform an implicit store.</LI>
</OL>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359355"></A>Writing to Named Objects<A NAME="marker-1359354"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359358"></A>Current NAME Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359360"></A>Object to be written</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359362"></A>Write operation on NAME</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359364"></A>Result of write (in NAME)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359366"></A>Any</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359367"></A>(Any Type)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359369"></A>Obj</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359370"></A>(Any type)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359372"></A>Store (..., NAME)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359373"></A>CopyObject (..., NAME)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359375"></A>Copy of Obj (converted to match existing type of NAME)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359376"></A>Copy of Obj (No conversion)</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1359383"></A><A NAME="89259"></A>ASL Operator Summary <A NAME="marker-1359381"></A><A NAME="marker-1359382"></A></H2>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1545072"></A>Operator Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1545074"></A>Location</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1545076"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545078"></A>AccessAs</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545083"></A><A HREF="ACPI_Source_Language_Reference.htm#79248" CLASS="XRef">AccessAs (Change Field Unit Access)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545085"></A>Change Field Access</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545087"></A>Acquire </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545092"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341955" CLASS="XRef">Acquire (Acquire a Mutex)</A>   </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545094"></A>Acquire a mutex </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545096"></A>Add </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545101"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267470" CLASS="XRef">Add (Integer Add)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545103"></A>Integer Add</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545105"></A>Alias </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545110"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267470" CLASS="XRef">Add (Integer Add)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545112"></A> Define a name alias </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545114"></A>And </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545119"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267471" CLASS="XRef">And (Integer Bitwise And)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545121"></A>Integer Bitwise And </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545123"></A>ArgX </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545128"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267471" CLASS="XRef">And (Integer Bitwise And)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545130"></A>Method argument data objects </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545132"></A>BankField</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545137"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267471" CLASS="XRef">And (Integer Bitwise And)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545139"></A>Declare fields in a banked configuration object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545141"></A>Break</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545146"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267450" CLASS="XRef">Break (Break from While)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545148"></A>Continue following the innermost enclosing While</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545150"></A>BreakPoint </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545155"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267450" CLASS="XRef">Break (Break from While)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545157"></A>Used for debugging, stops execution in the debugger </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545159"></A>Buffer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545164"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267450" CLASS="XRef">Break (Break from While)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545166"></A>Declare Buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545168"></A>Case</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545173"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Case" CLASS="XRef">Case (Expression for Conditional Execution)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545175"></A>Expression for conditional execution </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545177"></A>Concatenate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545182"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Concatenate" CLASS="XRef">Concatenate (Concatenate Data)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545184"></A>Concatenate two strings, integers or buffers </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545186"></A>ConcatenateResTemplate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545191"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_ConcatenateResTemplate" CLASS="XRef">ConcatenateResTemplate (Concatenate Resource Templates)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545193"></A>Concatenate two resource templates </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545195"></A>CondRefOf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545200"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267475" CLASS="XRef">CondRefOf (Create Object Reference Conditionally)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545202"></A>Conditional reference to an object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546382"></A>Connection</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546376"></A><A HREF="ACPI_Source_Language_Reference.htm#29686" CLASS="XRef">Connection (Declare Field Connection Attributes)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546415"></A>Declare Field Connection Attributes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545204"></A>Continue</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545209"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267452" CLASS="XRef">Continue (Continue Innermost Enclosing While)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545211"></A>Continue innermost enclosing While loop </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545213"></A>CopyObject</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545218"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267476" CLASS="XRef">CopyObject (Copy and Store Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545220"></A>Copy and existing object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545222"></A>CreateBitField</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545227"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267420" CLASS="XRef">CreateBitField (Create 1-Bit Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545229"></A>Declare a bit field object of a buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545231"></A>CreateByteField </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545236"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267421" CLASS="XRef">CreateByteField (Create 8-Bit Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545238"></A>Declare a byte field object of a buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545240"></A>CreateDWordField</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545245"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267422" CLASS="XRef">CreateDWordField (Create 32-Bit Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545247"></A>Declare a DWord field object of a buffer object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545249"></A>CreateField</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545254"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267423" CLASS="XRef">CreateField (Create Arbitrary Length Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545256"></A>Declare an arbitrary length bit field of a buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545258"></A>CreateQWordField</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545263"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267424" CLASS="XRef">CreateQWordField (Create 64-Bit Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545265"></A>Declare a QWord field object of a buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545267"></A>CreateWordField</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545272"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267425" CLASS="XRef">CreateWordField (Create 16-Bit Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545274"></A>Declare a Word field object of a buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545276"></A>DataTableRegion</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545281"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267426" CLASS="XRef">DataTableRegion (Create Data Table Operation Region)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545283"></A>Declare a Data Table Region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545285"></A>Debug</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545290"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Debug" CLASS="XRef">Debug (Debugger Output)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545292"></A>Debugger output</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545294"></A>Decrement </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545299"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267477" CLASS="XRef">Decrement (Integer Decrement)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545301"></A>Decrement an Integer </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545303"></A>Default </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545308"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Default" CLASS="XRef">Default (Default Execution Path in Switch)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545310"></A>Default execution path in Switch()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545312"></A>DefinitionBlock</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545317"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341980" CLASS="XRef">DefinitionBlock (Declare Definition Block)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545319"></A>Declare a Definition Block </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545321"></A>DerefOf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545326"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267479" CLASS="XRef">DerefOf (Dereference an Object Reference)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545328"></A>Dereference an object reference </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545330"></A>Device</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545335"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267427" CLASS="XRef">Device (Declare Device Package)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545337"></A>Declare a bus/device object  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545339"></A>Divide </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545344"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267480" CLASS="XRef">Divide (Integer Divide)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545346"></A>Integer Divide</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545348"></A>DMA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545353"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267646" CLASS="XRef">DMA (DMA Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545355"></A>DMA Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545357"></A>DWordIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545362"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267657" CLASS="XRef">DWordIO (DWord IO Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545364"></A>DWord IO Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545366"></A>DWordMemory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545371"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_DWORDMemory" CLASS="XRef">DWordMemory (DWord Memory Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545373"></A>DWord Memory Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545375"></A>DWordSpace</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545380"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_DWordSpace" CLASS="XRef">DWordSpace (DWord Space Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545382"></A>DWord Space Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545384"></A>EisaId</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545389"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267533" CLASS="XRef">EISAID (EISA ID String To Integer Conversion Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545391"></A>EISA ID String to Integer conversion macro  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545393"></A>Else</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545398"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267453" CLASS="XRef">Else (Alternate Execution)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545400"></A>Alternate conditional execution</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545402"></A>ElseIf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545407"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_ElseIf" CLASS="XRef">ElseIf (Alternate/Conditional Execution)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545409"></A>Conditional execution</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545411"></A>EndDependentFn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545416"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_EndDependentFn" CLASS="XRef">EndDependentFn (End Dependent Function Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545418"></A>End Dependent Function</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545420"></A>Event</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545425"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267428" CLASS="XRef">Event (Declare Event Synchronization Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545427"></A>Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545429"></A>ExtendedIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545434"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341993" CLASS="XRef">ExtendedIO (Extended IO Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545436"></A>Declare an event synchronization object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545438"></A>ExtendedMemory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545443"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341994" CLASS="XRef">ExtendedMemory (Extended Memory Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545445"></A>Extended IO Resource Descriptor macro </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545447"></A>ExtendedSpace</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545452"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341995" CLASS="XRef">ExtendedSpace (Extended Address Space Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545454"></A>Extended Space Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545456"></A>External</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545461"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_External" CLASS="XRef">External (Declare External Objects)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545463"></A>Declare external objects  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545465"></A>Fatal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545470"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267454" CLASS="XRef">Fatal (Fatal Error Check)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545472"></A>Fatal error check</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545474"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545479"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">Field (Declare Field Objects)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545481"></A>Declare fields of an operation region object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545483"></A>FindSetLeftBit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545488"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc465246069" CLASS="XRef">FindSetLeftBit (Find First Set Left Bit)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545490"></A>Index of first least significant bit set </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545492"></A>FindSetRightBit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545497"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267482" CLASS="XRef">FindSetRightBit (Find First Set Right Bit)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545499"></A>Index of first most significant bit set</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545501"></A>FixedDMA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545506"></A><A HREF="ACPI_Source_Language_Reference.htm#68627" CLASS="XRef">GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545508"></A>Fixed DMA Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545510"></A>FixedIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545515"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_FixedIO" CLASS="XRef">FixedIO (Fixed IO Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545517"></A>Fixed I/O Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550017"></A><EM CLASS="Bold">
Fprintf</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550019"></A><A HREF="ACPI_Source_Language_Reference.htm#45077" CLASS="XRef">Fprintf (Create and Store formatted string)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550021"></A>Stores formatted string to a Named Object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545519"></A>FromBCD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545524"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267483" CLASS="XRef">FromBCD (Convert BCD To Integer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545526"></A>Convert from BCD to numeric</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545528"></A>Function </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545533"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Function" CLASS="XRef">The FromBCD operation <EM CLASS="fontstyle41">
converts BCDValue to a numeric format, and optionally stores the numeric value</EM>
 <EM CLASS="fontstyle41">
into Result.</EM>
</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545535"></A>Declare control method</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545537"></A>GpioInt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545542"></A><A HREF="ACPI_Source_Language_Reference.htm#19522" CLASS="XRef">GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545544"></A>GPIO Interrupt Connection Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545546"></A>GpioIo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545551"></A><A HREF="ACPI_Source_Language_Reference.htm#13947" CLASS="XRef">GpioIo (GPIO Connection IO Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545553"></A>GPIO I0 Connection Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545555"></A>I2CSerialBusV2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545560"></A><A HREF="ACPI_Source_Language_Reference.htm#98349" CLASS="XRef">I2CSerialBusV2 (I2C Serial Bus Connection Resource Descriptor (Version 2) Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545562"></A>I2C Serialbus Connection Resource Descriptor (Version 2) macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545564"></A>If </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545569"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267455" CLASS="XRef">If (Conditional Execution)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545571"></A>Conditional execution </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545573"></A>Include</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545578"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Include" CLASS="XRef">Include (Include Additional ASL File)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545580"></A>Include another ASL file </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545582"></A>Increment</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545587"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267486" CLASS="XRef">Index (Indexed Reference To Member Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545589"></A>Increment a Integer </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545591"></A>Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545596"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267437" CLASS="XRef">IndexField (Declare Index/Data Fields)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545598"></A>Indexed Reference to member object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545600"></A>IndexField </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545605"></A><A HREF="ACPI_Source_Language_Reference.htm#_Ref369783633" CLASS="XRef">Interrupt (Interrupt Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545607"></A>Declare Index/Data Fields </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545609"></A>Interrupt </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545614"></A><A HREF="ACPI_Source_Language_Reference.htm#_Ref369783633" CLASS="XRef">Interrupt (Interrupt Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545616"></A>Interrupt Resource Descriptor macro </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545618"></A>IO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545623"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267541" CLASS="XRef">IRQ (Interrupt Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545625"></A>IO Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545627"></A>IRQ</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545632"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_IRQNoFlags" CLASS="XRef">IRQNoFlags (Interrupt Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545634"></A>Interrupt Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545636"></A>IRQNoFlags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545641"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267491" CLASS="XRef">LAnd (Logical And)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545643"></A>Short Interrupt Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545645"></A>LAnd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545650"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267492" CLASS="XRef">LEqual (Logical Equal)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545652"></A>Logical And</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545654"></A>LEqual</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545659"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267493" CLASS="XRef">LGreater (Logical Greater)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545661"></A>Logical Equal</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545663"></A>LGreater</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545668"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_LGreaterEqual" CLASS="XRef">LGreaterEqual (Logical Greater Than Or Equal)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545670"></A>Logical Greater</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545672"></A>LGreaterEqual</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545677"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267495" CLASS="XRef">LLess (Logical Less)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545679"></A>Logical Not less</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545681"></A>LLess</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545686"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267496" CLASS="XRef">LLessEqual (Logical Less Than Or Equal)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545688"></A>Logical Less </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545690"></A>LLessEqual</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545695"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267497" CLASS="XRef">LNot (Logical Not)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545697"></A>Logical Not greater</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545699"></A>LNot</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545704"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267498" CLASS="XRef">LNotEqual (Logical Not Equal) )</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545706"></A>Logical Not</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545708"></A>LNotEqual</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545713"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267498" CLASS="XRef">LNotEqual (Logical Not Equal) )</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545715"></A>Logical Not equal </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545717"></A>Load </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545722"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267456" CLASS="XRef">Load (Load Definition Block)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545724"></A>Load differentiating definition block </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545726"></A>LoadTable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545731"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267499" CLASS="XRef">LoadTable (Load Definition Block From XSDT)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545733"></A>Load Table from RSDT/XSDT</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545735"></A>LocalX</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545740"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267539" CLASS="XRef">Localx (Method Local Data Objects)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545742"></A>Method local data objects</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545744"></A>LOr</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545749"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267500" CLASS="XRef">LOr (Logical Or)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545751"></A>Logical Or </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545753"></A>Match</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545758"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267501" CLASS="XRef">Match (Find Object Match)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545760"></A>Search for match in package array </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545762"></A>Memory24 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545767"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Memory24" CLASS="XRef">Memory24 (Memory Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545769"></A>Memory Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545771"></A>Memory32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545776"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Memory32" CLASS="XRef">Memory32 (Memory Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545778"></A>Memory Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545780"></A>Memory32Fixed</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545785"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Memory32Fixed" CLASS="XRef">Memory32Fixed (Memory Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545787"></A>Memory Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545789"></A>Method </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545794"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267438" CLASS="XRef">Method (Declare Control Method)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545796"></A>Declare a control method </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545798"></A>Mid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545803"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267502" CLASS="XRef">Mid (Extract Portion of Buffer or String)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545805"></A>Return a portion of buffer or string </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545807"></A>Mod</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545812"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267503" CLASS="XRef">Mod (Integer Modulo)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545814"></A>Integer Modulo</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545816"></A>Multiply</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545821"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267504" CLASS="XRef">Multiply (Integer Multiply)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545823"></A>Integer Multiply</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545825"></A>Mutex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545830"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267439" CLASS="XRef">Mutex (Declare Synchronization/Mutex Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545832"></A>Declare a mutex synchronization object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545834"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545839"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267446" CLASS="XRef">Name (Declare Named Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545841"></A>Declare a Named object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545843"></A>NAnd </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545848"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc465246088" CLASS="XRef">NAnd (Integer Bitwise Nand)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545850"></A>Integer Bitwise Nand </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545852"></A>NoOp </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545857"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267457" CLASS="XRef">NoOp Code (No Operation)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545859"></A>No operation</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545861"></A>NOr</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545866"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267506" CLASS="XRef">NOr (Integer Bitwise Nor)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545868"></A>Integer Bitwise Nor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545870"></A>Not</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545875"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267507" CLASS="XRef">Not (Integer Bitwise Not)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545877"></A>Integer Bitwise Not</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545879"></A>Notify</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545884"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267458" CLASS="XRef">Notify (Notify Object of Event)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545886"></A>Notify Object of event</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545888"></A>ObjectType</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545893"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267508" CLASS="XRef">ObjectType (Get Object Type)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545895"></A>Type of object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545897"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545902"></A><A HREF="ACPI_Source_Language_Reference.htm#19034" CLASS="XRef">Offset (Change Current Field Unit Offset)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545904"></A>Set Field Offset within operation range</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545906"></A>One </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545911"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267529" CLASS="XRef">One (Constant One Integer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545913"></A>Constant One Object (1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545915"></A>Ones</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545920"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267530" CLASS="XRef">Ones (Constant Ones Integer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545922"></A>Constant Ones Object (-1) </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545924"></A>OperationRegion </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545929"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">OperationRegion (Declare Operation Region)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545931"></A>Declare an operational region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545933"></A>Or</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545938"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc465246073" CLASS="XRef">Or (Integer Bitwise Or)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545940"></A>Integer Bitwise Or</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545942"></A>Package </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545947"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Package" CLASS="XRef">Package (Declare Package Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545949"></A>Declare a package object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545951"></A>PowerResource </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545956"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267441" CLASS="XRef">PowerResource (Declare Power Resource)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545958"></A>Declare a power resource object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550057"></A><EM CLASS="Bold">
Printf</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550059"></A><A HREF="ACPI_Source_Language_Reference.htm#61765" CLASS="XRef">Printf (Create and Store formatted string)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550061"></A>Stores formatted string to Debug Object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545960"></A>Processor</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545965"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267442" CLASS="XRef">Processor (Declare Processor)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545967"></A>Declare a processor package</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545969"></A>QWordIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545974"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_QWordIO" CLASS="XRef">QWordIO (QWord IO Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545976"></A>QWord IO Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545978"></A>QWordMemory </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545983"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_QWordMemory" CLASS="XRef">QWordMemory (QWord Memory Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545985"></A>QWord Memory Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545987"></A>QWordSpace</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545992"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_QWordSpace" CLASS="XRef">QWordSpace (QWord Space Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545994"></A>Qword Space Resource Descriptor macro  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1545996"></A>RawDataBuffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546001"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267510" CLASS="XRef">RawDataBuffer</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546003"></A>Declare a RawDataBuffer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546005"></A>RefOf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546010"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267510" CLASS="XRef">RawDataBuffer</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546012"></A>Create Reference to an object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546014"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546019"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Register" CLASS="XRef">Register (Generic Register Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546021"></A>Generic register Resource Descriptor macro </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546023"></A>Release</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546028"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267459" CLASS="XRef">Release (Release a Mutex Synchronization Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546030"></A>Release a synchronization object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546032"></A>Reset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546037"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267460" CLASS="XRef">Reset (Reset an Event Synchronization Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546039"></A>Reset a synchronization object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546041"></A>ResourceTemplate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546046"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546048"></A>Resource to buffer conversion macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546050"></A>Return</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546055"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267461" CLASS="XRef">Return (Return from Method Execution)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546057"></A>Return from method execution</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546059"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546064"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267459" CLASS="XRef">Release (Release a Mutex Synchronization Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546066"></A>Constant revision object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546068"></A>Scope</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546073"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267447" CLASS="XRef">Scope (Open Named Scope)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546075"></A>Open named scope</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546077"></A>ShiftLeft</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546082"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc465246093" CLASS="XRef">ShiftLeft (Integer Shift Left)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546084"></A>Integer shift value left</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546086"></A>ShiftRight</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546091"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267512" CLASS="XRef">ShiftRight (Integer Shift Right)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546093"></A>Integer shift value right</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546095"></A>Signal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546100"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267462" CLASS="XRef">Signal (Signal a Synchronization Event)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546102"></A>Signal a synchronization object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546104"></A>SizeOf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546109"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267513" CLASS="XRef">SizeOf (Get Data Object Size)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546111"></A>Get the size of a buffer, string, or package </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546113"></A>Sleep</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546118"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267463" CLASS="XRef">Sleep (Milliseconds Sleep)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546120"></A>Sleep n milliseconds (yields the processor) </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546122"></A>SPISerialbusV2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546127"></A><A HREF="ACPI_Source_Language_Reference.htm#98115" CLASS="XRef">SPISerialBusV2 (SPI Serial Bus Connection Resource Descriptor (Version 2) Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546129"></A>SPI Serialbus Connection Resource Descritor (Version 2) macro </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546131"></A>Stall</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546136"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267464" CLASS="XRef">Stall (Stall for a Short Time)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546138"></A>Delay n microseconds (does not yield the processor)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546140"></A>StartDependentFn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546145"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFn" CLASS="XRef">StartDependentFn (Start Dependent Function Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546147"></A>Start Dependent Function Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546149"></A>StartDependentFnNoPri</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546154"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFnNoPri" CLASS="XRef">StartDependentFnNoPri (Start Dependent Function Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546156"></A>Start Dependent Function Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546158"></A>Store</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546163"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267514" CLASS="XRef">Store (Store an Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546165"></A>Store object Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546167"></A>Subtract</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546172"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267516" CLASS="XRef">Subtract (Integer Subtract)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546174"></A>Subtract</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546176"></A>Switch</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546181"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267465" CLASS="XRef">Switch (Select Code To Execute Based On Expression)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546183"></A>Select code to execute based on expression value </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546185"></A>ThermalZone</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546190"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267443" CLASS="XRef">ThermalZone (Declare Thermal Zone)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546192"></A>Declare a thermal zone package.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546194"></A>Timer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546199"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Timer" CLASS="XRef">Timer (Get 64-Bit Timer Value)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546201"></A>Get 64-bit timer value</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546203"></A>ToBCD  </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546208"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267517" CLASS="XRef">ToBCD (Convert Integer to BCD)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546210"></A>Convert Integer to BCD</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546212"></A>ToBuffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546217"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267472" CLASS="XRef">ToBuffer (Convert Data to Buffer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546219"></A>Convert data type to buffer </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546221"></A>ToDecimalString</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546226"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267478" CLASS="XRef">ToDecimalString (Convert Data to Decimal String)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546228"></A>Convert data type to decimal string</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546230"></A>ToHexString</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546235"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267484" CLASS="XRef">ToHexString (Convert Data to Hexadecimal String)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546237"></A>Convert data type to hexadecimal string </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546239"></A>ToInteger</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546244"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267472" CLASS="XRef">ToBuffer (Convert Data to Buffer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546246"></A>Convert data type to integer </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550684"></A><EM CLASS="Bold">
ToPLD</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550678"></A><A HREF="ACPI_Source_Language_Reference.htm#51336" CLASS="XRef">ToPLD (Creates a _PLD Buffer Object)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1550680"></A>Converts a PLD Keyword List into a _PLD buffer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546248"></A>ToString</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546253"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267515" CLASS="XRef">ToString (Convert Buffer To String)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546255"></A>Copy ASCII string from buffer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546257"></A>ToUUID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546262"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_UUID" CLASS="XRef">ToUUID (Convert String to UUID Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546264"></A>Convert ASCII string to UUID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546266"></A>Unicode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546271"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267535" CLASS="XRef">Unicode (String To Unicode Conversion Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546273"></A>String to Unicode conversion macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546284"></A>UARTSerialBusV2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546289"></A><A HREF="ACPI_Source_Language_Reference.htm#41859" CLASS="XRef">UARTSerialBusV2 (UART Serial Bus Connection Resource Descriptor (Version 2) Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546291"></A>UART SerialBus Connection Resource Descriptor (version2) macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546293"></A>VendorLong </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546298"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_VendorLong" CLASS="XRef">VendorLong (Long Vendor Resource Descriptor)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546300"></A>Vendor Resource Descriptor </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546302"></A>VendorShort</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546307"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_VendorShort" CLASS="XRef">VendorShort (Short Vendor Resource Descriptor)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546309"></A>Vendor Resource Descriptor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546311"></A>Wait </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546316"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267518" CLASS="XRef">Wait (Wait for a Synchronization Event)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546318"></A>Wait on an Event</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546320"></A>While</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546325"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267467" CLASS="XRef">While (Conditional Loop)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546327"></A>Conditional loop</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546329"></A>WordBusNumber</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546334"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_WordBusNumber" CLASS="XRef">WordBusNumber (Word Bus Number Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546336"></A>Word Bus number Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546338"></A>WordIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546343"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_WordIO" CLASS="XRef">WordIO (Word IO Resource Descriptor Macro)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546345"></A>Word IO Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546347"></A>WordSpace</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546352"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc64957499" CLASS="XRef">WordSpace (Word Space Resource Descriptor Macro) )</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546354"></A>Word Space Resource Descriptor macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546356"></A> Xor </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546361"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_XOr" CLASS="XRef">XOr (Integer Bitwise Xor)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546363"></A> Integer Bitwise Xor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546365"></A>Zero</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546370"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267528" CLASS="XRef">Zero (Constant Zero Integer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1546372"></A>Constant Zero object 0</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1450991"></A><A NAME="_Toc202341953"></A><A NAME="_Toc258262589"></A>ASL Operator Summary by Type <A NAME="marker-1450989"></A><A NAME="marker-1450990"></A></H2>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473446"></A>// ASL compiler controls </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473454"></A>External </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473455"></A>Include </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473464"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_External" CLASS="XRef">External (Declare External Objects)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Include" CLASS="XRef">Include (Include Additional ASL File)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473467"></A>Declare external objects </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473468"></A>Include another ASL file </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473470"></A>// ACPI table management </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473478"></A>DefinitionBlock </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473485"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341980" CLASS="XRef">DefinitionBlock (Declare Definition Block)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473487"></A>Declare a Definition Block </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473489"></A>Load </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473496"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267499" CLASS="XRef">LoadTable (Load Definition Block From XSDT)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473498"></A>Load definition block </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473500"></A>LoadTable </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473510"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267539" CLASS="XRef">Localx (Method Local Data Objects)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473513"></A>Load Table from RSDT/XSDT </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473516"></A>// Miscellaneous named object creation </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473524"></A>Alias</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473525"></A>Buffer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473526"></A>Device </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473527"></A>Function </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473528"></A>Method </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473529"></A>Name </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473530"></A>Package </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473531"></A>PowerResource </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473532"></A>Processor </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473533"></A>RawDataBuffer</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535652"></A>Scope </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473534"></A>ThermalZone </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473539"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Alias" CLASS="XRef">Alias (Declare Name Alias)</A> </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473543"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Buffer" CLASS="XRef">Buffer (Declare Buffer Object)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1473547"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267427" CLASS="XRef">Device (Declare Device Package)</A> </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473553"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Function" CLASS="XRef">The FromBCD operation <EM CLASS="fontstyle41">
converts BCDValue to a numeric format, and optionally stores the numeric value</EM>
 <EM CLASS="fontstyle41">
into Result.</EM>
</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267438" CLASS="XRef">Method (Declare Control Method)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267446" CLASS="XRef">Name (Declare Named Object)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1473561"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Package" CLASS="XRef">Package (Declare Package Object)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1473567"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267441" CLASS="XRef">PowerResource (Declare Power Resource)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267442" CLASS="XRef">Processor (Declare Processor)</A> </P>
<P CLASS="TableBody">
<A NAME="pgfId-1535663"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267510" CLASS="XRef">RawDataBuffer</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535670"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267447" CLASS="XRef">Scope (Open Named Scope)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267443" CLASS="XRef">ThermalZone (Declare Thermal Zone)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473578"></A>Define a name alias </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473579"></A>Declare Buffer object</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473580"></A>Declare a bus/device object</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473581"></A>Declare a control method </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473582"></A>Declare a control method </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473583"></A>Declare a Named object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473584"></A>Declare a package object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473585"></A>Declare a power resource object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473586"></A>Declare a processor package </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473587"></A>Declare a RawDataBuffer</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535677"></A>Open named scope </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473588"></A>Declare a thermal zone package. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473590"></A>// Operation Regions and Fields </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473598"></A>AccessAs</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536997"></A>BankField </P>
<P CLASS="TableBody">
<A NAME="pgfId-1542855"></A>Connection</P>
<P CLASS="TableBody">
<A NAME="pgfId-1542866"></A>DataTableRegion </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473599"></A>Field </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473600"></A>IndexField </P>
<P CLASS="TableBody">
<A NAME="pgfId-1537034"></A>Offset</P>
<P CLASS="TableBody">
<A NAME="pgfId-1537041"></A>OperationRegion </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473605"></A><A HREF="ACPI_Source_Language_Reference.htm#79248" CLASS="XRef">AccessAs (Change Field Unit Access)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1542938"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267419" CLASS="XRef">BankField (Declare Bank/Data Field)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1542939"></A><A HREF="ACPI_Source_Language_Reference.htm#29686" CLASS="XRef">Connection (Declare Field Connection Attributes)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1542945"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267426" CLASS="XRef">DataTableRegion (Create Data Table Operation Region)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">Field (Declare Field Objects)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267437" CLASS="XRef">IndexField (Declare Index/Data Fields)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1537747"></A><A HREF="ACPI_Source_Language_Reference.htm#19034" CLASS="XRef">Offset (Change Current Field Unit Offset)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1537077"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">OperationRegion (Declare Operation Region)</A> </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473622"></A>Change Field Access</P>
<P CLASS="TableBody">
<A NAME="pgfId-1537015"></A>Declare fields in a banked configuration object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473623"></A>Declare Field Connection Attributes</P>
<P CLASS="TableBody">
<A NAME="pgfId-1542880"></A>Declare a Data Table Region </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473624"></A>Declare fields of an operation region object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473625"></A>Declare Index/Data Fields </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473626"></A>Set Field offset within operation region</P>
<P CLASS="TableBody">
<A NAME="pgfId-1537084"></A>Declare an operational region </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1473628"></A>// Buffer Fields </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1473630"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1473634"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473636"></A>CreateBitField CreateByteField CreateDWordField CreateField CreateQWordField CreateWordField </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473641"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267420" CLASS="XRef">CreateBitField (Create 1-Bit Buffer Field)</A> </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473647"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267421" CLASS="XRef">CreateByteField (Create 8-Bit Buffer Field)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267422" CLASS="XRef">CreateDWordField (Create 32-Bit Buffer Field)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267423" CLASS="XRef">CreateField (Create Arbitrary Length Buffer Field)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267424" CLASS="XRef">CreateQWordField (Create 64-Bit Buffer Field)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267425" CLASS="XRef">CreateWordField (Create 16-Bit Buffer Field)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473661"></A>Declare a bit field object of a buffer object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473662"></A>Declare a byte field object of a buffer object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473663"></A>Declare a DWord field object of a buffer object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473664"></A>Declare an arbitrary length bit field of a buffer object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473665"></A>Declare a QWord field object of a buffer object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473666"></A>Declare a Word field object of a buffer object </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1473668"></A>// Synchronization </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1473670"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1473674"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473676"></A>Acquire </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473677"></A>Event </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473678"></A>Mutex </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473679"></A>Notify </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473680"></A>Release </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473681"></A>Reset </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473682"></A>Signal </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473683"></A>Wait </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473690"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341955" CLASS="XRef">Acquire (Acquire a Mutex)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267428" CLASS="XRef">Event (Declare Event Synchronization Object)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267439" CLASS="XRef">Mutex (Declare Synchronization/Mutex Object)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267458" CLASS="XRef">Notify (Notify Object of Event)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267459" CLASS="XRef">Release (Release a Mutex Synchronization Object)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267460" CLASS="XRef">Reset (Reset an Event Synchronization Object)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267462" CLASS="XRef">Signal (Signal a Synchronization Event)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267518" CLASS="XRef">Wait (Wait for a Synchronization Event)</A> </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473713"></A>Acquire a mutex </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473714"></A>Declare an event synchronization object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473715"></A>Declare a mutex synchronization object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473716"></A>Notify Object of event </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473717"></A>Release a synchronization object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473718"></A>Reset a synchronization object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473719"></A>Signal a synchronization object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473720"></A>Wait on an Event </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473722"></A>// Object references </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473730"></A>CondRefOf </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473731"></A>DerefOf </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473732"></A>RefOf </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473739"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267475" CLASS="XRef">CondRefOf (Create Object Reference Conditionally)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267479" CLASS="XRef">DerefOf (Dereference an Object Reference)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267510" CLASS="XRef">RawDataBuffer</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473747"></A>Conditional reference to an object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473748"></A>Dereference an object reference </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473749"></A>Create Reference to an ob ect </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473751"></A>// Integer arithmetic </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473759"></A>Add </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473760"></A>And </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473761"></A>Decrement </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473762"></A>Divide </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473763"></A>FindSetLeftBit </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473764"></A>FindSetRightBit </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473765"></A>Increment </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473766"></A>Mod </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473767"></A>Multiply </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473768"></A>NAnd </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473769"></A>NOr </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473770"></A>Not </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473771"></A>Or </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473772"></A>ShiftLeft </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473773"></A>ShiftRight </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473774"></A>Subtract</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473775"></A> Xor </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473784"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267470" CLASS="XRef">Add (Integer Add)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267471" CLASS="XRef">And (Integer Bitwise And)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267477" CLASS="XRef">Decrement (Integer Decrement)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267480" CLASS="XRef">Divide (Integer Divide)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc465246069" CLASS="XRef">FindSetLeftBit (Find First Set Left Bit)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267482" CLASS="XRef">FindSetRightBit (Find First Set Right Bit)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267486" CLASS="XRef">Index (Indexed Reference To Member Object)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267503" CLASS="XRef">Mod (Integer Modulo)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267504" CLASS="XRef">Multiply (Integer Multiply)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc465246088" CLASS="XRef">NAnd (Integer Bitwise Nand)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267506" CLASS="XRef">NOr (Integer Bitwise Nor)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267507" CLASS="XRef">Not (Integer Bitwise Not)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc465246073" CLASS="XRef">Or (Integer Bitwise Or)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc465246093" CLASS="XRef">ShiftLeft (Integer Shift Left)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267512" CLASS="XRef">ShiftRight (Integer Shift Right)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267516" CLASS="XRef">Subtract (Integer Subtract)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_XOr" CLASS="XRef">XOr (Integer Bitwise Xor)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473832"></A>Integer Add </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473833"></A>Integer Bitwise And </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473834"></A>Decrement an Integer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473835"></A>Integer Divide </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473836"></A>Index of first least significant bit set</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473837"></A>Index of first most significant bit set </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473838"></A>Increment a Integer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473839"></A>Integer Modulo </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473840"></A>Integer Multiply </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473841"></A>Integer Bitwise Nand </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473842"></A>Integer Bitwise Nor </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473843"></A>Integer Bitwise Not </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473844"></A>Integer Bitwise Or </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473845"></A>Integer shift value left </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473846"></A>Integer shift value right I</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473847"></A>Integer Subtract </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473848"></A>Integer Bitwise Xor </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473850"></A>// Logical operators </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473858"></A>LAnd </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473859"></A>LEqual </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473860"></A>LGreater </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473861"></A>LGreaterEqual </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473862"></A>LLess </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473863"></A>LLessEqual </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473864"></A>LNot </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473865"></A>LNotEqual </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473866"></A>LOr </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473875"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267492" CLASS="XRef">LEqual (Logical Equal)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267493" CLASS="XRef">LGreater (Logical Greater)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_LGreaterEqual" CLASS="XRef">LGreaterEqual (Logical Greater Than Or Equal)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267495" CLASS="XRef">LLess (Logical Less)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267496" CLASS="XRef">LLessEqual (Logical Less Than Or Equal)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267497" CLASS="XRef">LNot (Logical Not)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267498" CLASS="XRef">LNotEqual (Logical Not Equal) )</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267498" CLASS="XRef">LNotEqual (Logical Not Equal) )</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1473898"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267500" CLASS="XRef">LOr (Logical Or)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473900"></A>Logical And</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473901"></A>Logical Equal</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473902"></A>Logical Greater </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473903"></A>Logical Not less </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473904"></A>Logical Less </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473905"></A>Logical Not greater </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473906"></A>Logical Not </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473907"></A>Logical Not equal </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473908"></A>Logical Or </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1473910"></A>// Method execution control </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1473918"></A>Break </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473919"></A>BreakPoint </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473920"></A>Case </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473921"></A>Continue </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473922"></A>Default </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473923"></A>Else </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473924"></A>ElseIf </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473925"></A>Fatal </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473926"></A>If </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473927"></A>NoOp </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473928"></A>Return </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473929"></A>Sleep </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473930"></A>Stall </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473931"></A>Switch </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473932"></A>While </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473941"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267450" CLASS="XRef">Break (Break from While)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267450" CLASS="XRef">Break (Break from While)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Case" CLASS="XRef">Case (Expression for Conditional Execution)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267452" CLASS="XRef">Continue (Continue Innermost Enclosing While)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Default" CLASS="XRef">Default (Default Execution Path in Switch)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267453" CLASS="XRef">Else (Alternate Execution)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_ElseIf" CLASS="XRef">ElseIf (Alternate/Conditional Execution)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267454" CLASS="XRef">Fatal (Fatal Error Check)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1473966"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267455" CLASS="XRef">If (Conditional Execution)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267457" CLASS="XRef">NoOp Code (No Operation)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267461" CLASS="XRef">Return (Return from Method Execution)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267463" CLASS="XRef">Sleep (Milliseconds Sleep)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267464" CLASS="XRef">Stall (Stall for a Short Time)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267465" CLASS="XRef">Switch (Select Code To Execute Based On Expression)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267467" CLASS="XRef">While (Conditional Loop)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1473984"></A>Continue following the innermost enclosingWhile </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473985"></A>Used for debugging, stops execution in the debugger</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473986"></A>Expression for conditional execution </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473987"></A>Continue innermost enclosing While loop </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473988"></A>Default execution path in Switch() </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473989"></A>Alternate conditional execution</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473990"></A>Conditional execution  </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473991"></A>Fatal error check</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473992"></A>Conditional execution</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473993"></A>No operation </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473994"></A>Return from method execution </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473995"></A>Sleep n milliseconds (yields the processor) </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473996"></A>Delay in microseconds (does not yield the processor) </P>
<P CLASS="TableBody">
<A NAME="pgfId-1473997"></A>Select code to execute based on expression value</P>
<P CLASS="TableBody">
<A NAME="pgfId-1473998"></A>Conditional loop </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1474000"></A>// Data type conversion and manipulation </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474008"></A>Concatenate </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474009"></A>CopyObject </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474010"></A>Debug </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474011"></A>EisaId </P>
<P CLASS="TableBody">
<A NAME="pgfId-1550133"></A>Fprintf</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474012"></A>FromBCD </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1474019"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Concatenate" CLASS="XRef">Concatenate (Concatenate Data)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267476" CLASS="XRef">CopyObject (Copy and Store Object)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Debug" CLASS="XRef">Debug (Debugger Output)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267533" CLASS="XRef">EISAID (EISA ID String To Integer Conversion Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1550141"></A><A HREF="ACPI_Source_Language_Reference.htm#45077" CLASS="XRef">Fprintf (Create and Store formatted string)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1550139"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267483" CLASS="XRef">FromBCD (Convert BCD To Integer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474033"></A>Concatenate two strings,integers or buffers</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474034"></A>Copy and existing object</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474035"></A>Debugger output </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474036"></A>EISA ID String to Integer conversion macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1550136"></A>Stores formatted string to a Named Object</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474037"></A>Convert from BCD to numeric </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474039"></A>Index </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474040"></A>Match </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474041"></A>Mid </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474042"></A>ObjectType </P>
<P CLASS="TableBody">
<A NAME="pgfId-1550091"></A>Printf</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474043"></A>SizeOf </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474044"></A>Store </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474045"></A>Timer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1474052"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267437" CLASS="XRef">IndexField (Declare Index/Data Fields)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267501" CLASS="XRef">Match (Find Object Match)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267502" CLASS="XRef">Mid (Extract Portion of Buffer or String)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267508" CLASS="XRef">ObjectType (Get Object Type)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1550094"></A><A HREF="ACPI_Source_Language_Reference.htm#61765" CLASS="XRef">Printf (Create and Store formatted string)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1474065"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267513" CLASS="XRef">SizeOf (Get Data Object Size)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267514" CLASS="XRef">Store (Store an Object)</A> </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474070"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Timer" CLASS="XRef">Timer (Get 64-Bit Timer Value)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474074"></A>Indexed Reference to member object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474075"></A>Search for match in package array</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474076"></A>Return a portion of buffer or string </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474077"></A>Type of object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1550097"></A>Stores formatted string to Debug Object</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474078"></A>Get the size of a buffer, string, or package </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474079"></A>Store object </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474080"></A>Get 64-bit timer value </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474082"></A>ToBCD </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474083"></A>ToBuffer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474084"></A>ToDecimalString ToHexString </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474085"></A>ToInteger</P>
<P CLASS="TableBody">
<A NAME="pgfId-1550744"></A>ToPLD</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474086"></A>ToString </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474087"></A>ToUUID</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474088"></A>Unicode </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1474095"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267517" CLASS="XRef">ToBCD (Convert Integer to BCD)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267472" CLASS="XRef">ToBuffer (Convert Data to Buffer)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267478" CLASS="XRef">ToDecimalString (Convert Data to Decimal String)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267484" CLASS="XRef">ToHexString (Convert Data to Hexadecimal String)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267472" CLASS="XRef">ToBuffer (Convert Data to Buffer)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1550749"></A><A HREF="ACPI_Source_Language_Reference.htm#51336" CLASS="XRef">ToPLD (Creates a _PLD Buffer Object)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1550747"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267515" CLASS="XRef">ToString (Convert Buffer To String)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_UUID" CLASS="XRef">ToUUID (Convert String to UUID Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267535" CLASS="XRef">Unicode (String To Unicode Conversion Macro)</A> </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474118"></A>Convert Integer to BCD </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474119"></A>Convert data type to buffer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474120"></A>Convert data type to decimal string </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474121"></A>Convert data type to hexadecimal string </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474122"></A>Convert data type to integer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1550752"></A>Converts a PLD Keyword List into a _PLD buffer</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474123"></A>Copy ASCII string from buffer </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474124"></A>Convert ASCII string to UUID </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474125"></A>String to Unicode conversion macro </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1474127"></A>// Resource Descriptor macros</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474135"></A>ConcatenateResTemplate </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474136"></A>DMA </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474137"></A>DWordIO </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474138"></A>DWordMemory </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474139"></A>DWordSpace </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474140"></A>EndDependentFn </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474141"></A>ExtendedIO </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474142"></A>ExtendedMemory ExtendedSpace </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474143"></A>FixedDMA</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535994"></A>FixedIO </P>
<P CLASS="TableBody">
<A NAME="pgfId-1536002"></A>GpioInt</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536003"></A>GpioIO</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536004"></A>I2CSerialBusV2</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535847"></A>Interrupt </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474145"></A>IO </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474146"></A>IRQ</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474147"></A>IRQNoFlags </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474148"></A>Memory24 </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474149"></A>Memory32 </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474150"></A>Memory32Fixed </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474151"></A>QWordIO </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474152"></A>QWordMemory </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474153"></A>QWordSpace </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474154"></A>Register </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474155"></A>ResourceTemplate</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535903"></A>SPISerialBusV2</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474156"></A>StartDependentFn StartDependentFnNoPri </P>
<P CLASS="TableBody">
<A NAME="pgfId-1535924"></A>UARTSerialBusV2</P>
<P CLASS="TableBody">
<A NAME="pgfId-1558438"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535931"></A>VendorLong </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474157"></A>VendorShort </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474158"></A>WordBusNumber </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474159"></A>WordIO </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474160"></A>WordSpace </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474162"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1535715"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_ConcatenateResTemplate" CLASS="XRef">ConcatenateResTemplate (Concatenate Resource Templates)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267646" CLASS="XRef">DMA (DMA Resource Descriptor Macro)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267657" CLASS="XRef">DWordIO (DWord IO Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_DWORDMemory" CLASS="XRef">DWordMemory (DWord Memory Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_DWordSpace" CLASS="XRef">DWordSpace (DWord Space Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_EndDependentFn" CLASS="XRef">EndDependentFn (End Dependent Function Resource Descriptor Macro)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341993" CLASS="XRef">ExtendedIO (Extended IO Resource Descriptor Macro)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341994" CLASS="XRef">ExtendedMemory (Extended Memory Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc202341995" CLASS="XRef">ExtendedSpace (Extended Address Space Resource Descriptor Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535812"></A><A HREF="ACPI_Source_Language_Reference.htm#68627" CLASS="XRef">GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535819"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_FixedIO" CLASS="XRef">FixedIO (Fixed IO Resource Descriptor Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535854"></A><A HREF="ACPI_Source_Language_Reference.htm#19522" CLASS="XRef">GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535861"></A><A HREF="ACPI_Source_Language_Reference.htm#13947" CLASS="XRef">GpioIo (GPIO Connection IO Resource Descriptor Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535875"></A><A HREF="ACPI_Source_Language_Reference.htm#98349" CLASS="XRef">I2CSerialBusV2 (I2C Serial Bus Connection Resource Descriptor (Version 2) Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#_Ref369783633" CLASS="XRef">Interrupt (Interrupt Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267541" CLASS="XRef">IRQ (Interrupt Resource Descriptor Macro)</A> <A HREF="ACPI_Source_Language_Reference.htm#ASL_IRQNoFlags" CLASS="XRef">IRQNoFlags (Interrupt Resource Descriptor Macro)</A> <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267491" CLASS="XRef">LAnd (Logical And)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Memory24" CLASS="XRef">Memory24 (Memory Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Memory32" CLASS="XRef">Memory32 (Memory Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Memory32Fixed" CLASS="XRef">Memory32Fixed (Memory Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_QWordIO" CLASS="XRef">QWordIO (QWord IO Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_QWordMemory" CLASS="XRef">QWordMemory (QWord Memory Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_QWordSpace" CLASS="XRef">QWordSpace (QWord Space Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_Register" CLASS="XRef">Register (Generic Register Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535910"></A><A HREF="ACPI_Source_Language_Reference.htm#98115" CLASS="XRef">SPISerialBusV2 (SPI Serial Bus Connection Resource Descriptor (Version 2) Macro)</A> <A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFn" CLASS="XRef">StartDependentFn (Start Dependent Function Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFnNoPri" CLASS="XRef">StartDependentFnNoPri (Start Dependent Function Resource Descriptor Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1535938"></A><A HREF="ACPI_Source_Language_Reference.htm#41859" CLASS="XRef">UARTSerialBusV2 (UART Serial Bus Connection Resource Descriptor (Version 2) Macro)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1558441"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535945"></A><A HREF="ACPI_Source_Language_Reference.htm#ASL_VendorLong" CLASS="XRef">VendorLong (Long Vendor Resource Descriptor)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_VendorShort" CLASS="XRef">VendorShort (Short Vendor Resource Descriptor)</A> <A HREF="ACPI_Source_Language_Reference.htm#ASL_WordBusNumber" CLASS="XRef">WordBusNumber (Word Bus Number Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#ASL_WordIO" CLASS="XRef">WordIO (Word IO Resource Descriptor Macro)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc64957499" CLASS="XRef">WordSpace (Word Space Resource Descriptor Macro) )</A> </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474253"></A>Concatenate two resource templates </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474254"></A>DMA Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474255"></A>DWord IO Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474256"></A>DWord Memory Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474257"></A>DWord Space Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474258"></A>End Dependent Function Resource Descriptor macro Extended I/O Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474259"></A>Extended Memory Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474260"></A>Extended Space Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474261"></A>Fixed DMA resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535826"></A>Fixed I/O Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1536023"></A>GPIO Interrupt Connection Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536024"></A>GPIO IO Connection Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536025"></A>I2C SerialBus Connection Resource Descriptor (Version 2) macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1535896"></A>Interrupt Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474263"></A>IO Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474264"></A>Interrupt Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474265"></A>Short Interrupt Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474266"></A>Memory Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474267"></A>Memory Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474268"></A>Memory Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474269"></A>QWord IO Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474270"></A>QWord Memory Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474271"></A>Qword Space Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474272"></A>Generic register Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474273"></A>Resource to buffer conversion macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1535917"></A>SPI SerialBus Connection Resource Descriptor (Version 2) macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474274"></A>Start Dependent Function Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1536086"></A>Start Dependent Function Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536087"></A>UART SerialBus Connection Resource Descriptor (Version 2) macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1536088"></A>Vendor Resource Descriptor </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474277"></A>Vendor Resource Descriptor </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474278"></A>Word Bus number Resource Descriptor macro </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474279"></A>Word IO Resource Descriptor macro</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474280"></A>Word Space Resource Descriptor macro </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1474282"></A>// Constants</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474290"></A>One </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474291"></A>Ones </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474292"></A>Revision</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474293"></A>Zero </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474295"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474302"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267529" CLASS="XRef">One (Constant One Integer)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267530" CLASS="XRef">Ones (Constant Ones Integer)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267459" CLASS="XRef">Release (Release a Mutex Synchronization Object)</A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267528" CLASS="XRef">Zero (Constant Zero Integer)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474311"></A>Constant One Object (1) </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474312"></A>Constant Ones Object (-1) </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474313"></A>Constant revision object</P>
<P CLASS="TableBody">
<A NAME="pgfId-1474314"></A> Constant Zero object (0) </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1474316"></A>// Control method objects </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474324"></A>ArgX </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474325"></A>LocalX </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474327"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474332"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267538" CLASS="XRef">Argx (Method Argument Data Objects)</A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1474338"></A><A HREF="ACPI_Source_Language_Reference.htm#_Toc489267539" CLASS="XRef">Localx (Method Local Data Objects)</A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1474334"></A>Method argument data objects </P>
<P CLASS="TableBody">
<A NAME="pgfId-1474335"></A>Method local data ob ects </P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1448558"></A><A NAME="_Toc202341954"></A><A NAME="_Toc258262590"></A>ASL Operator Reference <A NAME="marker-1360662"></A><A NAME="marker-1360663"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1360665"></A>This section describes each of the ASL operators. The syntax for each operator is given, with a description of each argument and an overall description of the operator behavior. Example ASL code is provided for the more complex operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1360666"></A>ASL operators can be categorized as follows:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1360667"></A>Named Object creation</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1360668"></A>Method execution control (If, Else, While, etc.)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1360669"></A>Integer math</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1360670"></A>Logical operators</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1360671"></A>Resource Descriptor macros</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1360672"></A>Object conversion</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1541515"></A>Utility/Miscellaneous</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1537223"></A><A NAME="79248"></A>AccessAs (Change Field Unit Access)</H6>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1537282"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1537225"></A>AccessAs (AccessType, AccessAttribute)</P>
<P CLASS="Body">
<A NAME="pgfId-1537226"></A>AccessAs (AccessType, AccessAttribute (AccessLength))</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1537270"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1537228"></A>AccessType is an AccessTypeKeyword that specifies the type of access desired (ByteAcc, WordAcc, etc.).  AccessAttribute is an optional argument of type AccessAttributeKeyword that specifies additional protocols to be used, such as AttribQuick, AttribSendReceive, etc. AccessLength is a required argument for some of the Access Attributes.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1537230"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1537305"></A>The AccessAs operator is used within a FieldList to specify the Access Type, Access Attributes, and Access Length for the remaining FieldUnits within the list (or until another AccessAs operator  is encountered.) It allows FieldUnits to have different access types within a single Field definition.</P>
<P CLASS="Body">
<A NAME="pgfId-1544739"></A>Supported AccessTypes:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1544740"></A>AnyAcc</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1544741"></A>ByteAcc</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1537234"></A>WordAcc</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1537235"></A>DwordAcc</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1537236"></A>QWordAcc</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548213"></A>BufferAcc</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1548214"></A>Supported simple <EM CLASS="Italic">
AccessAttributes</EM>
 (with SMBus synonyms): </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1548215"></A>AttribQuick (<EM CLASS="Italic">
SMBQuick</EM>
)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548154"></A>AttribSendReceive (<EM CLASS="Italic">
SMBSendReceive</EM>
)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548155"></A>AttribByte (<EM CLASS="Italic">
SMBByte</EM>
)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548156"></A>AttribWord (<EM CLASS="Italic">
SMBWord</EM>
)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548157"></A>AttribBlock (<EM CLASS="Italic">
SMBBlock</EM>
)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548158"></A>AttribProcessCall (<EM CLASS="Italic">
SMBProcessCall</EM>
)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1548159"></A>AttribBlockProcessCall (<EM CLASS="Italic">
SMBBlockProcessCall</EM>
)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1537248"></A>Access Attributes that require an AccessLength argument:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1537249"></A>AttribBytes (AccessLength)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1537250"></A>AttribRawBytes (AccessLength)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1537251"></A> AttribRawProcessBytes (AccessLength)</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1537257"></A><A NAME="_Toc202341955"></A><A NAME="_Toc258262591"></A>Acquire (Acquire a Mutex)<A NAME="marker-1537256"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360688"></A><A NAME="_Toc465246100"></A><A NAME="_Toc469218408"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1524463"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Acquire </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SyncObject, TimeoutValue</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360690"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360691"></A>SynchObject must be a mutex synchronization object. TimeoutValue is evaluated as an Integer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360692"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360693"></A>Ownership of the Mutex is obtained. If the Mutex is already owned by a different invocation, the current execution thread is suspended until the owner of the Mutex releases it or until at least TimeoutValue milliseconds have elapsed. A Mutex can be acquired more than once by the same invocation. <A NAME="marker-1360694"></A></P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1548377"></A>For Mutex objects referenced by a _DLM object, the host OS may also contend for ownership.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1360695"></A>This operation returns True if a timeout occurred and the mutex ownership was not acquired. A TimeoutValue of 0xFFFF (or greater) indicates that there is no timeout and the operation will wait indefinitely.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360702"></A><A NAME="_Toc489267470"></A><A NAME="ASL_Add"></A><A NAME="_Toc202341956"></A><A NAME="_Toc258262592"></A>Add (Integer Add)<A NAME="marker-1360701"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360704"></A><A NAME="_Toc489267445"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360705"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Add </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Addend1, Addend2, Result</EM>
) =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556196"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Addend1</EM>
 + <EM CLASS="Italic">
Addend2</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556197"></A><EM CLASS="Italic">
Result</EM>
 += Addend =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360706"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360707"></A>Addend1 and Addend2 are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360708"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360709"></A>The operands are added and the result is optionally stored into Result. Overflow conditions are ignored and the result of overflows simply loses the most significant bits.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360715"></A><A NAME="ASL_Alias"></A><A NAME="_Toc202341957"></A><A NAME="_Toc258262593"></A>Alias (Declare Name Alias)<A NAME="marker-1360714"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360718"></A><A NAME="_Toc465246101"></A><A NAME="_Toc469218409"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360719"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Alias </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceObject, AliasObject</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360720"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360721"></A>SourceObject is any named object. AliasObject is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360722"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360723"></A>Creates a new object named AliasObject that refers to and acts exactly the same as SourceObject.</P>
<P CLASS="Body">
<A NAME="pgfId-1360724"></A>AliasObject is created as an alias of SourceObject in the namespace. The SourceObject name must already exist in the namespace. If the alias is to a name within the same definition block, the SourceObject name must be logically ahead of this definition in the block.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360725"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1360726"></A>The following example shows the use of an Alias term:</P>
<P CLASS="Code">
<A NAME="pgfId-1360727"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360728"></A>Alias (&#92;SUS.SET.EVEN, SSE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524477"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360735"></A><A NAME="_Toc489267471"></A><A NAME="ASL_And"></A><A NAME="_Toc202341958"></A><A NAME="_Toc258262594"></A>And (Integer Bitwise And)<A NAME="marker-1360734"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360739"></A><A NAME="_Ref369783734"></A><A NAME="_Toc465246157"></A><A NAME="_Toc469218465"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360740"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
And </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1, Source2, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556219"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Source1</EM>
 &amp; <EM CLASS="Italic">
Source2</EM>
  =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556220"></A><EM CLASS="Italic">
Result</EM>
 &amp;= Source =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360741"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360742"></A>Source1 and Source2 are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360743"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360744"></A>A bitwise AND is performed and the result is optionally stored into Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360751"></A><A NAME="_Toc489267538"></A><A NAME="ASL_Argx"></A><A NAME="_Toc202341959"></A><A NAME="_Toc258262595"></A>Argx (Method Argument Data Objects)<A NAME="marker-1360750"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360752"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360753"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg0</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg1</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg2</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg3</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg4</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg5</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Arg6</EM>
 </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360754"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360755"></A>Up to 7 argument-object references can be passed to a control method. On entry to a control method, only the argument objects that are passed are usable.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360762"></A><A NAME="_Toc489267419"></A><A NAME="ASL_BankField"></A><A NAME="_Toc202341960"></A><A NAME="_Toc258262596"></A>BankField (Declare Bank/Data Field)<A NAME="marker-1360761"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360767"></A><A NAME="_Toc465246051"></A><A NAME="_Toc469218368"></A><A NAME="_Toc465246082"></A><A NAME="_Toc469218390"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360768"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
BankField </EM>
(RegionName, BankName, BankValue, AccessType, LockRule, UpdateRule) {FieldUnitList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360769"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360770"></A>RegionName is evaluated as a Namestring, and is the name of the host Operation Region. </P>
<P CLASS="Body">
<A NAME="pgfId-1572309"></A>BankName is evaluated as a Namestring, and is the name of the bank selection register.</P>
<P CLASS="Body">
<A NAME="pgfId-1572422"></A>BankValue is the bank selection ID (Integer) that is written to the BankName register before the FieldUnitList is accessed.</P>
<P CLASS="Body">
<A NAME="pgfId-1360772"></A>The AccessType, LockRule, UpdateRule, and FieldUnitList are the same format as the Field operator.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360773"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360774"></A>Accessing the contents of a banked field data object will occur automatically through the proper bank setting, with synchronization occurring on the operation region that contains the BankName data variable, and on the Global Lock if specified by the LockRule.</P>
<P CLASS="Body">
<A NAME="pgfId-1572457"></A>This operator creates data field objects. The contents of the created objects are obtained by a reference to a bank selection register.</P>
<P CLASS="Body">
<A NAME="pgfId-1360775"></A>This encoding is used to define named data field objects whose data values are fields within a larger object selected by a bank-selected register. </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360776"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1360777"></A>The following is a block of ASL sample code using BankField:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1360778"></A>Creates a 4-bit bank-selected register in system I/O space.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1360779"></A>Creates overlapping fields in the same system I/O space that are selected via the bank register.</LI>
</UL>
<P CLASS="CodeExample">
<A NAME="pgfId-1360781"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524500"></A>//</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360782"></A>// Define a 256-byte operational region in SystemIO space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360783"></A>// and name it GIO0 </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360784"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360785"></A>OperationRegion (GIO0, SystemIO, 0x125, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360786"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360787"></A>// Create some fields in GIO including a 4-bit bank select register </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360788"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360789"></A>Field (GIO0, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360790"></A>    GLB1, 1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360791"></A>    GLB2, 1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360792"></A>    Offset (1),            // Move to offset for byte 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360793"></A>    BNK1, 4</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360794"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360795"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360796"></A>// Create FET0 &amp; FET1 in bank 0 at byte offset 0x30</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360797"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360798"></A>BankField (GIO0, BNK1, 0, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360799"></A>    Offset (0x30),        </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360800"></A>    FET0, 1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360801"></A>    FET1, 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360802"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1360803"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360804"></A>    // Create BLVL &amp; BAC in bank 1 at the same offset</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360805"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360806"></A>BankField (GIO0, BNK1, 1, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360807"></A>    Offset (0x30),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360808"></A>    BLVL, 7,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360809"></A>    BAC,  1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360810"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360817"></A><A NAME="_Toc489267450"></A><A NAME="ASL_Break"></A><A NAME="_Toc202341961"></A><A NAME="_Toc258262597"></A>Break (Break from While)<A NAME="marker-1360816"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360818"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360819"></A>Break </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360820"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360821"></A>Break causes execution to continue immediately following the innermost enclosing While or Switch scope, in the current Method. If there is no enclosing While or Switch within the current Method, a fatal error is generated.</P>
<P CLASS="Body">
<A NAME="pgfId-1360822"></A>Compatibility Note: In ACPI 1.0, the Break operator continued immediately following the innermost &#8220;code package.&#8221; Starting in ACPI 2.0, the Break operator was changed to exit the innermost &#8220;While&#8221; or &#8220;Switch&#8221; package. This should have no impact on existing code, since the ACPI 1.0 definition was, in practice, useless.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360832"></A><A NAME="_Toc489267451"></A><A NAME="ASL_BreakPoint"></A><A NAME="_Toc202341962"></A><A NAME="_Toc258262598"></A>BreakPoint (Execution Break Point)<A NAME="marker-1360831"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360833"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360834"></A>BreakPoint </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360835"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360836"></A>Used for debugging, the Breakpoint opcode stops the execution and enters the AML debugger. In the non-debug version of the AML interpreter, BreakPoint is equivalent to Noop.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360849"></A><A NAME="ASL_Buffer"></A><A NAME="_Toc202341963"></A><A NAME="_Toc258262599"></A>Buffer (Declare Buffer Object)<A NAME="marker-1360847"></A><A NAME="marker-1360848"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360850"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360851"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Buffer </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
BufferSize</EM>
) {Initializer}<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360852"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360853"></A>Declares a Buffer of optional size BufferSize and an optional initial value of Initializer. The Initializer is must be either a ByteList or a String.</P>
<P CLASS="Element-Hdr">
<A NAME="pgfId-1360854"></A>Description</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1561436"></A>The optional BufferSize argument specifies the size of the buffer and an optional initial value of the buffer is specified via the Initializer. The initial value can be either an ASCII String or a list of byte values separated by commas. Strings are automatically null terminated with a single zero byte.</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1561437"></A>&nbsp;</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1561438"></A>The relationship between the BufferSize and the Initializer is summarized by the rules below.</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561439"></A>&nbsp;</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561440"></A>In the typical case, the BufferSize is identical to the length of the Initializer:</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561441"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561442"></A>    Name (BUF0, Buffer(4) {0x01,0x02,0x03,0x04}) // Length = 4</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561443"></A>&nbsp;</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561444"></A>If the BufferSize is not specified, the length of the Initializer is used as the buffer size:</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561445"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561446"></A>    Name (BUF1, Buffer() {0,1,2,3,4,5})	// Length = 6</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561447"></A>    Name (BUF2, Buffer() {&quot;abcde&quot;}) 		// Length = 6</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561448"></A>&nbsp;</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561449"></A>If the BufferSize is larger than the length of the Initializer, the BufferSize is used as the final buffer size. At runtime, the AML interpreter will automatically pad zeros to the Initializer to match the BufferSize:</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561450"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561451"></A>    Name (BUF3, Buffer(1024) {4,5,6,7,8})	// Length = 1024</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561452"></A>    Name (BUF4, Buffer(1024) {&quot;abcde&quot;})	// Length = 1024</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561453"></A>&nbsp;</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561454"></A>If the BufferSize is smaller than the length of the Initializer, the length of the Initializer is used as the buffer size:</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561455"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561456"></A>    Name (BUF5, Buffer(1) {5,4,3,2,1}) 	// Length = 5</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561457"></A>&nbsp;</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561458"></A>If the Initializer is not specified, the AML interpreter creates a buffer containing all zeros, the length of which matches the BufferSize:</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561459"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1561460"></A>    Name (BUF6, Buffer(32} {}) 		// Length = 32</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561461"></A>&nbsp;</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561462"></A>If neither the BufferSize nor the Initializer are specified, a buffer of zero length is created:</P>
<P CLASS="Plain-Text">
<A NAME="pgfId-1561463"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1360860"></A>    Name (BUF7, Buffer() {}) 		// Length = 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524507"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360866"></A><A NAME="ASL_Case"></A><A NAME="_Toc202341964"></A><A NAME="_Toc258262600"></A>Case (Expression for Conditional Execution)<A NAME="marker-1360865"></A></H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360867"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360868"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Case</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Value</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360869"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360870"></A>Value specifies an Integer, Buffer, String or Package object. TermList is a sequence of executable ASL expressions.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360871"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360872"></A>Execute code based upon the value of a Switch statement.</P>
<P CLASS="Body">
<A NAME="pgfId-1360873"></A>If the Case Value is an Integer, Buffer or String, then control passes to the statement that matches the value of the enclosing Switch (Value). If the Case value is a Package, then control passes if any member of the package matches the Switch (Value). The Switch CaseTermList can include any number of Case instances, but no two Case Values (or members of a Value, if Value is a Package) within the same Switch statement can contain the same value.</P>
<P CLASS="Body">
<A NAME="pgfId-1360874"></A>Execution of the statement body begins at the start of the TermList and proceeds until the end of the TermList body or until a Break or Continue operator transfers control out of the body. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360882"></A><A NAME="ASL_Concatenate"></A><A NAME="_Toc202341965"></A><A NAME="_Toc258262601"></A>Concatenate (Concatenate Data<A NAME="marker-1360880"></A>) </H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360883"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360884"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Concatenate </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Buffer or String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360885"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360886"></A>Source1 and Source2 must each evaluate to any valid ACPI object. For the basic data object types (Integer, String, or Buffer), the value of the object is used in the concatenation. For all other object types (see table 19-378 below), a string object is created that contains the name (type) of the object. This string object is then concatenated according to the rules in <A HREF="ACPI_Source_Language_Reference.htm#87095" CLASS="XRef">See Concatenate Data Types.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1559949"></A>The data type of <EM CLASS="Italic">
Source1</EM>
 dictates the required type of <EM CLASS="Italic">
Source2</EM>
 and the type of the result object. <EM CLASS="Italic">
Source2</EM>
 is implicitly converted if necessary (and possible) to match the type of <EM CLASS="Italic">
Source1</EM>
.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360887"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360888"></A>Source2 is concatenated to Source1 and the result data is optionally stored into Result.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360890"></A><A NAME="87095"></A>Concatenate Data Types<A NAME="marker-1360889"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360893"></A>Source1 Data Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360895"></A>Source2 Data Type (&#61669; Converted Type)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360897"></A>Result Data Type</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360899"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360901"></A>Integer/String/Buffer &#61669; Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360903"></A>Buffer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360905"></A>String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360907"></A>Integer/String/Buffer/All other types  &#61669; String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360909"></A>String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360911"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360913"></A>Integer/String/Buffer/All other types &#61669; Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360915"></A>Buffer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560001"></A>All other types &#61669;String	</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560041"></A>Integer/String/Buffer/All other types  &#61669; String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560005"></A>String</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1560066"></A>For the <EM CLASS="Italic">
Source1</EM>
/Integer case, a String or Buffer that cannot be implicitly converted to an Integer will generate a fatal error.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1560086"></A>Concatenate Object Types</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1560101"></A>Data Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1560103"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1560312"></A>Resolved to Value</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560107"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560109"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560111"></A>Integer value of the object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560113"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560115"></A>String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560117"></A>String value of the object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560119"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560121"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560123"></A>Buffer value of the object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560536"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560538"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560540"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1560125"></A>Other Object Types</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1560127"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1560129"></A>Resolved to String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560131"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560133"></A>Uninitialized</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560135"></A>&quot;[Uninitialized Object]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560149"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560151"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560153"></A>&quot;[Package]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560155"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560157"></A>Field Unit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560159"></A>&quot;[Field]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560161"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560163"></A>Device</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560165"></A>&quot;[Device]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560167"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560169"></A>Event</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560171"></A>&quot;[Event]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560173"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560175"></A>Control Method	</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560177"></A>&quot;[Control Method]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560179"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560181"></A>Mutex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560183"></A>&quot;[Mutex]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560185"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560187"></A>Operation Region</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560189"></A>&quot;[Operation Region]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560191"></A>11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560193"></A>Power Resource</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560195"></A>&quot;[Power Resource]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560197"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560199"></A>Processor</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560201"></A>&quot;[Processor]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560203"></A>13</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560205"></A>Thermal Zone</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560207"></A>&quot;[Thermal Zone]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560209"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560211"></A>Buffer Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560213"></A>&quot;[Buffer Field]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560215"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560217"></A>DDB Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560219"></A>&quot;[DDB Handle]&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560221"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560223"></A>Debug Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1560225"></A>&quot;[Debug Object]&quot;</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1560846"></A>Examples</H3>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560848"></A>Device (DEVX) {}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560849"></A>Name (PKGX, Package () {1,2,3,&quot;Battery1&quot;})</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560850"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560851"></A>Method (MTHX, 2)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560852"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560853"></A>    Concatenate (&quot;My Object: &quot;, DEVX, Debug) // MyObject: Device</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560854"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560855"></A>    Printf (&quot;PKGX %o contains %o elements&#92;n&quot;, PKGX, SizeOf (PKGX))</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560856"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560857"></A>    Printf (&quot;Arg0: %o&#92;n&quot;, Arg0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1560858"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360925"></A><A NAME="ASL_ConcatenateResTemplate"></A><A NAME="_Toc202341966"></A><A NAME="_Toc258262602"></A>ConcatenateResTemplate (Concatenate Resource Templates<A NAME="marker-1360923"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360928"></A><A NAME="_Toc465246104"></A><A NAME="_Toc469218412"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360929"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ConcatenateResTemplate </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
) =&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360930"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360931"></A>Source1 and Source2 are evaluated as Resource Template buffers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360932"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360933"></A>The resource descriptors from Source2 are appended to the resource descriptors from Source1. Then a new end tag and checksum are appended and the result is stored in Result, if specified. If either Source1 or Source2 is exactly 1 byte in length, a run-time error occurs. An empty buffer is treated as a resource template with only an end tag.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360940"></A><A NAME="_Toc489267475"></A><A NAME="ASL_CondRefOf"></A><A NAME="_Toc202341967"></A><A NAME="_Toc258262603"></A>CondRefOf (Create Object Reference Conditionally)<A NAME="marker-1360939"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360941"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360942"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CondRefOf </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360943"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360944"></A>Attempts to create a reference to the Source object. The Source of this operation can be any object type (for example, data package, device object, and so on), and the result data is optionally stored into Result.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360945"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360946"></A>On success, the Destination object is set to refer to Source and the execution result of this operation is the value True. On failure, Destination is unchanged and the execution result of this operation is the value False. This can be used to reference items in the namespace that may appear dynamically (for example, from a dynamically loaded definition block).</P>
<P CLASS="Body">
<A NAME="pgfId-1539976"></A>CondRefOf is equivalent to RefOf except that if the Source object does not exist, it is fatal for RefOf but not for CondRefOf.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1539995"></A><A NAME="29686"></A>Connection (Declare Field Connection Attributes)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1540054"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1539997"></A>Connection (ConnectionResourceObj)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540066"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1539999"></A>ConnectionResourceObj is a GPIO or Serial Bus Connection Descriptor depending on the Operation Region type, or a named object containing the Descriptor </P>
<P CLASS="Body">
<A NAME="pgfId-1540000"></A>See <A HREF="Device_Configuration.htm#98626" CLASS="XRef">See GenericSerialBus Connection Descriptors.</A>, &quot;Connection Resource Descriptors&quot; and <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">See Field (Declare Field Objects).</A> &quot;Field (Declare Field Objects)&quot; for more information.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1540078"></A>Examples</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1540002"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)// GenericSerialBus device at command value offset zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540003"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540004"></A>Name (I2C, ResourceTemplate(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540005"></A>    I2CSerialBusV2(0x5a,,100000,, &quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540006"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540007"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540008"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540156"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540157"></A>    Connection(I2C)                                 // Specify connection resource information</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540158"></A>    AccessAs(BufferAcc, AttribWord)                 // Use the GenericSerialBus </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540163"></A>                                                    // Read/Write Word protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540172"></A>    FLD0, 8,                                        // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540173"></A>    FLD1, 8,                                        // Virtual register at command value 1.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540174"></A>    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540015"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540016"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540017"></A>    Connection(I2CSerialBusV2(0x5b,,100000,, &quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){3,9}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540018"></A>    AccessAs(BufferAcc, AttribBytes (16))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540019"></A>    FLD2, 8                                         // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540020"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540021"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540022"></A> // Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540023"></A>Name(BUFF, Buffer(34){})                           // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540024"></A>CreateByteField(BUFF, 0x00, STAT)                  // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1540025"></A>CreateWordField(BUFF, 0x02, DATA)                  // DATA = Data (Word)</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1540042"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1540028"></A>The Connection macro declares the connection attributes for subsequent fields defined within the Field declaration. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1539983"></A><A NAME="_Toc489267452"></A><A NAME="ASL_Continue"></A><A NAME="_Toc202341968"></A><A NAME="_Toc258262604"></A>Continue (Continue Innermost Enclosing While<A NAME="marker-1539982"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360955"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360956"></A>Continue </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360957"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360958"></A>Continue causes execution to continue at the start of the innermost enclosing While scope, in the currently executing Control Method, at the point where the condition is evaluated. If there is no enclosing While within the current Method, a fatal error is generated.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360965"></A><A NAME="_Toc489267476"></A><A NAME="ASL_CopyObject"></A><A NAME="_Toc202341969"></A><A NAME="_Toc258262605"></A>CopyObject (Copy and Store Object)<A NAME="marker-1360964"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360966"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360967"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CopyObject </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Destination</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 =&gt; </EM>
DataRefObject</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360968"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360969"></A>Converts the contents of the Source to a DataRefObject using the conversion rules in 18.2.5 and then copies the results without conversion to the object referred to by Destination. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360970"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360971"></A>If Destination is already an initialized object of type DataRefObject, the original contents of Destination are discarded and replaced with Source. Otherwise, a fatal error is generated.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1360972"></A>(Compatibility Note) The CopyObject operator was first introduced new in ACPI 2.0.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360979"></A><A NAME="_Toc489267420"></A><A NAME="ASL_CreateBitField"></A><A NAME="_Toc202341970"></A><A NAME="_Toc258262606"></A>CreateBitField (Create 1-Bit Buffer Field) <A NAME="marker-1360978"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360980"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360981"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CreateBitField</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceBuffer, BitIndex, BitFieldName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360982"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360983"></A>SourceBuffer is evaluated as a buffer. BitIndex is evaluated as an integer. BitFieldName is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360984"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1360985"></A>A new buffer field object named BitFieldName is created for the bit of SourceBuffer at the bit index of BitIndex. The bit-defined field within SourceBuffer must exist.BitFieldName is created for the bit of SourceBuffer at the bit index of BitIndex. The bit-defined field within SourceBuffer must exist.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1360995"></A><A NAME="_Toc489267421"></A><A NAME="ASL_CreateByteField"></A><A NAME="_Toc202341971"></A><A NAME="_Toc258262607"></A>CreateByteField (Create 8-Bit Buffer Field)<A NAME="marker-1360994"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1360996"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1360997"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CreateByteField </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceBuffer, ByteIndex, ByteFieldName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1360998"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1360999"></A>SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. ByteFieldName is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361000"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361001"></A>A new buffer field object named ByteFieldName is created for the byte of SourceBuffer at the byte index of ByteIndex. The byte-defined field within SourceBuffer must exist.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361011"></A><A NAME="_Toc489267422"></A><A NAME="ASL_CreateDWordField"></A><A NAME="_Toc202341972"></A><A NAME="_Toc258262608"></A>CreateDWordField (Create 32-Bit Buffer Field)<A NAME="marker-1361010"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361012"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361013"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CreateDWordField </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceBuffer, ByteIndex, DWordFieldName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361014"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361015"></A>SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. DWordFieldName is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361016"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361017"></A>A new buffer field object named DWordFieldName is created for the DWord of SourceBuffer at the byte index of ByteIndex. The DWord-defined field within SourceBuffer must exist.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361027"></A><A NAME="_Toc489267423"></A><A NAME="ASL_CreateField"></A><A NAME="_Toc202341973"></A><A NAME="_Toc258262609"></A>CreateField (Create Arbitrary Length Buffer Field)<A NAME="marker-1361026"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361028"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361029"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CreateField </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceBuffer, BitIndex, NumBits, FieldName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361030"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361031"></A>SourceBuffer is evaluated as a buffer. BitIndex and NumBits are evaluated as integers. FieldName is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361032"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361033"></A>A new buffer field object named FieldName is created for the bits of SourceBuffer at BitIndex for NumBits. The entire bit range of the defined field within SourceBuffer must exist. If NumBits evaluates to zero, a fatal exception is generated.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361043"></A><A NAME="_Toc489267424"></A><A NAME="ASL_CreateQWordField"></A><A NAME="_Toc202341974"></A><A NAME="_Toc258262610"></A>CreateQWordField (Create 64-Bit Buffer Field)<A NAME="marker-1361042"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361044"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361045"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CreateQWordField </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceBuffer, ByteIndex, QWordFieldName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361046"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361047"></A>SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. QWordFieldName is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361048"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361049"></A>A new buffer field object named QWordFieldName is created for the QWord of SourceBuffer at the byte index of ByteIndex. The QWord-defined field within SourceBuffer must exist.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361059"></A><A NAME="_Toc489267425"></A><A NAME="ASL_CreateWordField"></A><A NAME="_Toc202341975"></A><A NAME="_Toc258262611"></A>CreateWordField (Create 16-Bit Buffer Field) <A NAME="marker-1361058"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361060"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361061"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
CreateWordField </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SourceBuffer, ByteIndex, WordFieldName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361062"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361063"></A>SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. WordFieldName is a NameString.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361064"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361065"></A>A new bufferfield object named WordFieldName is created for the word of SourceBuffer at the byte index of ByteIndex. The word-defined field within SourceBuffer must exist.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361072"></A><A NAME="_Toc489267426"></A><A NAME="ASL_DataTableRegion"></A><A NAME="_Toc202341976"></A><A NAME="_Toc258262612"></A>DataTableRegion (Create Data Table Operation Region)<A NAME="marker-1361071"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361073"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361074"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DataTableRegion </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RegionName, SignatureString, OemIDString, OemTableIDString</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361075"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361076"></A>Creates a new region named RegionName. SignatureString, OemIDString and OemTableIDString are evaluated as strings.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361077"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361078"></A>A Data Table Region is a special Operation Region whose RegionSpace is SystemMemory. Any table referenced by a Data Table Region must be in memory marked by AddressRangeReserved or AddressRangeNVS.</P>
<P CLASS="Body">
<A NAME="pgfId-1361079"></A>The memory referred to by the Data Table Region is the memory that is occupied by the table referenced in XSDT that is identified by SignatureString, OemIDString and OemTableIDString. Any Field object can reference RegionName </P>
<P CLASS="Body">
<A NAME="pgfId-1361080"></A>The base address of a Data Table region is the address of the first byte of the header of the table identified by SignatureString, OemIDString and OemTableIDString. The length of the region is the length of the table.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361103"></A><A NAME="ASL_Debug"></A><A NAME="_Toc202341977"></A><A NAME="_Toc258262613"></A>Debug (Debugger Output)<A NAME="marker-1361101"></A><A NAME="marker-1361102"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361104"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361105"></A>Debug </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361106"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361107"></A>The debug data object is a virtual data object. Writes to this object provide debugging information. On at least debug versions of the interpreter, any writes into this object are appropriately displayed on the system&#8217;s native kernel debugger. All writes to the debug object are otherwise benign. If the system is in use without a kernel debugger, then writes to the debug object are ignored. The following table relates the ASL term types that can be written to the Debug object to the format of the information on the kernel debugger display. </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361108"></A>Debug Object Display Formats</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361111"></A>ASL Term Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361113"></A>Display Format</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361115"></A>Numeric data object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361117"></A>All digits displayed in hexadecimal format.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361119"></A>String data object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361121"></A>String is displayed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361123"></A>Object reference</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361125"></A>Information about the object is displayed (for example, object type and object name), but the object is not evaluated.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1361128"></A>The Debug object is a write-only object; attempting to read from the debug object is not supported.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361135"></A><A NAME="_Toc489267477"></A><A NAME="ASL_Decrement"></A><A NAME="_Toc202341978"></A><A NAME="_Toc258262614"></A>Decrement (Integer Decrement)<A NAME="marker-1361134"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361136"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361137"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Decrement </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Minuend</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1557063"></A><EM CLASS="Italic">
Minuend</EM>
-- =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361138"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361139"></A><EM CLASS="Italic">
Minuend</EM>
 is evaluated as an Integer. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361140"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361141"></A>This operation decrements the Minuend by one and the result is stored back to Minuend. Equivalent to Subtract (Minuend, 1, Minuend). Underflow conditions are ignored and the result is Ones.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361147"></A><A NAME="ASL_Default"></A><A NAME="_Toc202341979"></A><A NAME="_Toc258262615"></A>Default (Default Execution Path in Switch) <A NAME="marker-1361146"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361148"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361149"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Default</EM>
 {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
TermList</EM>
}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361150"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361151"></A>TermList is a sequence of executable ASL expressions.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361152"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361153"></A>Within the body of a Switch (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267465" CLASS="XRef">Switch (Select Code To Execute Based On Expression)</A>) statement, the statements specified by TermList will be executed if no Case (<A HREF="ACPI_Source_Language_Reference.htm#ASL_Case" CLASS="XRef">Case (Expression for Conditional Execution)</A>) statement value matches the Switch statement value. If Default is omitted and no Case match is found, none of the statements in the Switch body are executed. There can be at most one Default statement in the immediate scope of the parent Switch statement. The Default statement can appear anywhere in the body of the Switch statement.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361161"></A><A NAME="_Toc202341980"></A><A NAME="_Toc258262616"></A>DefinitionBloc<A NAME="marker-1361158"></A><A NAME="marker-1361159"></A>k (Declare Definition Block)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361162"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361163"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DefinitionBlock </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AMLFileName, TableSignature, ComplianceRevision, OEMID, TableID, OEMRevision)</EM>
 {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361164"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361165"></A>AMLFileName is a string that specifies the desired name of the translated output AML file. If the AMLFileName is a NULL (zero length) string, the ASL compiler will automatically create the filename (typically generated from the input filename/pathname).TableSignature is a string that contains the 4-character ACPI signature. ComplianceRevision is an 8-bit value. OEMID is a 6-character string, TableId  is an 8-character string, and OEMRevision is a 32-bit value. TermList is a sequence of executable ASL expressions.</P>
<P CLASS="Body">
<A NAME="pgfId-1559780"></A>If multiple DefinitionBlocks are defined in the same ASL file, the first DefinitionBlock defines the output <EM CLASS="Italic">
AMLFileName</EM>
 as per the rule above.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361166"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361167"></A>The DefinitionBlock term specifies the unit of data and/or AML code that the OS will load as part of the Differentiated Definition Block or as part of an additional Definition Block. </P>
<P CLASS="Body">
<A NAME="pgfId-1361168"></A>This unit of data and/or AML code describes either the base system or some large extension (such as a docking station). The entire DefinitionBlock will be loaded and compiled by the OS as a single unit.</P>
<P CLASS="Body">
<A NAME="pgfId-1560957"></A>System software loads a definition block by referencing the objects in the TermList package in order. The object list is encoded as TermList, so that rather than describing a static object list, it is possible to describe a dynamic object list according to the system settings. See &quot;<A HREF="ACPI_Software_Programming_Model.htm#36467" CLASS="XRef">See Definition Block Loading.</A>, Definition Block Loading.&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-1361169"></A>Note: For compatibility with ACPI versions before ACPI 2.0, the bit width of Integer objects is dependent on the ComplianceRevision of the DSDT. If the ComplianceRevision is less than 2, all integers are restricted to 32 bits. Otherwise, full 64-bit integers are used. The version of the DSDT sets the global integer width for all integers, including integers in SSDTs.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361179"></A><A NAME="_Toc489267479"></A><A NAME="ASL_DerefOf"></A><A NAME="_Toc202341981"></A><A NAME="_Toc258262617"></A>DerefOf (Dereference an Object Reference)<A NAME="marker-1361178"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361180"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361181"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DerefOf </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Object</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361182"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361183"></A>Returns the object referred by the Source object reference. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361184"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361185"></A>If the Source evaluates to an object reference, the actual contents of the object referred to are returned. If the Source evaluates to a string, the string is evaluated as an ASL name (relative to the current scope) and the contents of that object are returned. If the object specified by Source does not exist then a fatal error is generated. If the object specified is a reference generated by the Index() operator and refers to an uninitialized package element, then a fatal error is generated.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1361186"></A>(Compatibility Note) The use of a String with DerefOf was first introduced in ACPI 2.0.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361193"></A><A NAME="_Toc489267427"></A><A NAME="ASL_Device"></A><A NAME="_Toc202341982"></A><A NAME="_Toc258262618"></A>Device (Declare Device Package)<A NAME="marker-1361192"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361194"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361195"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Device </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DeviceName</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361196"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1537322"></A>Creates a Device object of name DeviceName, which represents a processor, a bus or a device, or any other similar hardware. Device opens a name scope.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1537323"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1537324"></A>A Device Package is one of the basic ways the Differentiated Definition Block describes the hardware devices in the system to the operating software. Each Device Package is defined somewhere in the hierarchical namespace corresponding to that device&#8217;s location in the system. Within the namespace of the device are other names that provide information and control of the device, along with any sub-devices that in turn describe sub-devices, and so on.<A NAME="marker-1537325"></A><A NAME="marker-1537326"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1361202"></A>For any device, the platform runtime firmware provides only information that is added to the device in a non-hardware standard manner. This type of value-added function is expressible in the ACPI Definition Block such that operating software can use the function. <A NAME="marker-1361203"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1361204"></A>The platform runtime firmware supplies Device Objects only for devices that are obtaining some system-added function outside the device&#8217;s normal capabilities and for any Device Object required to fill in the tree for such a device. For example, if the system includes a PCI device (integrated or otherwise) with no additional functions such as power management, the platform runtime firmware would not report such a device; however, if the system included an integrated ISA device below the integrated PCI device (device is an IS bridge), then the system would include a Device Package for the ISA device with the minimum feature being added being the ISA device&#8217;s ID and configuration information and the parent PCI device, because it is required to get the ISA Device Package placement in the namespace correct.<A NAME="marker-1361205"></A><A NAME="marker-1361206"></A><A NAME="marker-1361207"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1561031"></A>The device object list is encoded as <EM CLASS="Italic">
TermList</EM>
, so that rather than describing a static device object list, it is possible to describe a dynamic device object list according to the system settings. See &quot;<A HREF="ACPI_Software_Programming_Model.htm#36467" CLASS="XRef">See Definition Block Loading.</A>, Definition Block Loading.&quot;</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361208"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1361209"></A>The following block of ASL sample code shows a nested use of Device objects to describe an IDE controller connected to the root PCI bus. </P>
<P CLASS="spacing">
<A NAME="pgfId-1361210"></A>	</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361211"></A>    Device (IDE0) {                    // primary controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361212"></A>        Name (_ADR, 0)                 // put PCI Address (device/function) here</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361213"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361214"></A>        // define region for IDE mode register</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361215"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361216"></A>        OperationRegion (PCIC, PCI_Config, 0x50, 0x10)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361217"></A>        Field (PCIC, AnyAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361218"></A>            ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361219"></A>        }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361220"></A>        Device (PRIM) {                // Primary adapter</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361221"></A>            Name (_ADR, 0)             // Primary adapter = 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361222"></A>            ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361223"></A>            Method (_STM, 2) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361224"></A>                ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361225"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361226"></A>            Method (_GTM) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361227"></A>                ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361228"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361229"></A>            Device (MSTR) {            // master channel</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361230"></A>                Name (_ADR, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361231"></A>                Name (_PR0, Package () {0, PIDE})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361232"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361233"></A>                Name (_GTF) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361234"></A>                    ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361235"></A>                }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361236"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361237"></A>            Device (SLAV) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361238"></A>                Name (_ADR, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361239"></A>                Name (_PR0, Package () {0, PIDE})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361240"></A>                Name (_GTF) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361241"></A>                    ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361242"></A>                }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361243"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361244"></A>        }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361245"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361252"></A><A NAME="_Toc465246058"></A><A NAME="_Toc469218375"></A><A NAME="_Toc465246084"></A><A NAME="_Toc469218392"></A><A NAME="_Toc465246108"></A><A NAME="_Toc469218416"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361259"></A><A NAME="_Toc489267480"></A><A NAME="ASL_Divide"></A><A NAME="_Toc202341983"></A><A NAME="_Toc258262619"></A>Divide (Integer Divide)<A NAME="marker-1361258"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361260"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361261"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Divide </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Dividend, Divisor, Remainder, Result</EM>
) =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1557105"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Dividend</EM>
 / <EM CLASS="Italic">
Divisor</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1557106"></A><EM CLASS="Italic">
Result</EM>
 /= <EM CLASS="Italic">
Divisor</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361262"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361263"></A>Dividend and Divisor are evaluated as Integers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361264"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361265"></A>Dividend is divided by Divisor, then the resulting remainder is optionally stored into Remainder and the resulting quotient is optionally stored into Result. Divide-by-zero exceptions are fatal.</P>
<P CLASS="Body">
<A NAME="pgfId-1361266"></A>The function return value is the Result (quotient).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361274"></A><A NAME="_Toc489267646"></A><A NAME="ASL_DMA"></A><A NAME="_Toc202341984"></A><A NAME="_Toc258262620"></A>DMA (DMA Resource Descriptor<A NAME="marker-1361272"></A><A NAME="marker-1361273"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361275"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361276"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DMA </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DmaType</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsBusMaster</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DmaTransferSize</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
) {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DmaChannelList</EM>
} =&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361277"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361278"></A>DmaType specifies the type of DMA cycle: ISA compatible (Compatibility), EISA Type A (TypeA), EISA Type B (TypeB) or EISA Type F (TypeF). The 2-bit field DescriptorName._TYP is automatically created to refer to this portion of the resource descriptor, where &#8216;0&#8217; is Compatibility, &#8216;1&#8217; is TypeA, &#8216;2&#8217; is TypeB and &#8216;3&#8217; is TypeF.</P>
<P CLASS="Body">
<A NAME="pgfId-1361279"></A>IsBusMaster specifies whether this device can generate DMA bus master cycles (BusMaster) or not (NotBusMaster). If nothing is specified, then BusMaster is assumed. The 1-bit field DescriptorName._BM is automatically created to refer to this portion of the resource descriptor, where &#8216;0&#8217; is NotBusMaster and &#8216;1&#8217; is BusMaster.</P>
<P CLASS="Body">
<A NAME="pgfId-1361280"></A>DmaTransferSize specifies the size of DMA cycles the device is capable of generating: 8-bit (Transfer8), 16-bit (Transfer16) or both 8 and 16-bit (Transfer8_16). The 2-bit field DescriptorName._SIZ is automatically created to refer to this portion of the resource descriptor, where &#8216;0&#8217; is Transfer8, &#8216;1&#8217; is Transfer8_16 and &#8216;2&#8217; is Transfer16.</P>
<P CLASS="Body">
<A NAME="pgfId-1361281"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1361282"></A>DmaChannelList is a comma-delimited list of integers in the range 0 through 7 that specify the DMA channels used by the device. There may be no duplicates in the list.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361283"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361284"></A>The DMA macro evaluates to a buffer which contains a DMA resource descriptor. The format of the DMA resource descriptor can be found in &#8220;DMA Descriptor&#8221; (<A HREF="Device_Configuration.htm#AML_DMA" CLASS="XRef">DMA Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361295"></A><A NAME="_Toc489267657"></A><A NAME="ASL_DWordIO"></A><A NAME="_Toc202341985"></A><A NAME="_Toc258262621"></A>DWordIO (DWord IO Resource Descriptor Macro)<A NAME="marker-1361293"></A><A NAME="marker-1361294"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361296"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361297"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DWordIO </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, IsMinFixed, IsMaxFixed, Decode, ISARanges, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName, TranslationType, TranslationDensity)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361298"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361299"></A>ResourceUsage specifies whether the I/O range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361300"></A>IsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361301"></A>IsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361302"></A>Decode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1361303"></A>ISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2-bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is NonISAOnly, &#8216;2&#8217; is ISAOnly and &#8216;0&#8217; is EntireRange.</P>
<P CLASS="Body">
<A NAME="pgfId-1361304"></A>AddressGranularity evaluates to a 32-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 32-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361305"></A>AddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361306"></A>AddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361307"></A>AddressTranslation evaluates to a 32-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 32-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361308"></A>RangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the I/O range. The 32-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361309"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1361310"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a value of zero is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1361311"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1361312"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName._TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#37693" CLASS="XRef">Memory Resource Flag (Resource Type = 0) Definitions</A>) for more information</P>
<P CLASS="Body">
<A NAME="pgfId-1361313"></A>TranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName._TRS is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SparseTranslation and &#8216;0&#8217; is DenseTranslation. See _TRS (<A HREF="Device_Configuration.htm#51978" CLASS="XRef">I/O Resource Flag (Resource Type = 1) Definitions</A>) for more information. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361314"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361315"></A>The DWordIO macro evaluates to a buffer which contains a 32-bit I/O range resource descriptor. The format of the 32-bit I/O range resource descriptor can be found in &#8220;DWord Address Space Descriptor &#8221; (<A HREF="Device_Configuration.htm#14334" CLASS="XRef">DWORD Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361322"></A><A NAME="ASL_DWORDMemory"></A><A NAME="_Toc202341986"></A><A NAME="_Toc258262622"></A>DWordMemory (DWord Memory Resource Descriptor Macro)<A NAME="marker-1361320"></A><A NAME="marker-1361321"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361323"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361324"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DWordMemory </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, Decode, IsMinFixed, IsMaxFixed, Cacheable, ReadAndWrite, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName, MemoryRangeType, TranslationType)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361325"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361326"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361327"></A>Decode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1361328"></A>IsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361329"></A>IsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361330"></A>Cacheable specifies whether or not the memory region is cacheable (Cacheable), cacheable and write-combining (WriteCombining), cacheable and prefetchable (Prefetchable) or uncacheable (NonCacheable). If nothing is specified, then NonCacheable is assumed. The 2-bit field DescriptorName._MEM is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Cacheable, &#8216;2&#8217; is WriteCombining, &#8216;3&#8217; is Prefetchable and &#8216;0&#8217; is NonCacheable.</P>
<P CLASS="Body">
<A NAME="pgfId-1361331"></A>ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ReadWrite and &#8216;0&#8217; is ReadOnly.</P>
<P CLASS="Body">
<A NAME="pgfId-1361332"></A>AddressGranularity evaluates to a 32-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 32-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361333"></A>AddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361334"></A>AddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361335"></A>AddressTranslation evaluates to a 32-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 32-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361336"></A>RangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the Memory range. The 32-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361337"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1361338"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1361339"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1361340"></A>MemoryRangeType is an optional argument that specifies the memory usage. The memory can be marked as normal (AddressRangeMemory), used as ACPI NVS space (AddressRangeNVS), used as ACPI reclaimable space (AddressRangeACPI) or as system reserved (AddressRangeReserved). If nothing is specified, then AddressRangeMemory is assumed. The 2-bit field DescriptorName._MTP is automatically created in order to refer to this portion of the resource descriptor, where &#8216;0&#8217; is AddressRangeMemory, &#8216;1&#8217; is AddressRangeReserved, &#8216;2&#8217; is AddressRangeACPI and &#8216;3&#8217; is AddressRangeNVS.</P>
<P CLASS="Body">
<A NAME="pgfId-1361341"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is I/O. If TypeStatic is specified, then the primary side of the bus is Memory. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName._TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#37693" CLASS="XRef">Memory Resource Flag (Resource Type = 0) Definitions</A>) for more information.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361342"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361343"></A>The DWordMemory macro evaluates to a buffer which contains a 32-bit memory resource descriptor. The format of the 32-bit memory resource descriptor can be found in &#8220;DWord Address Space Descriptor &#8221; (<A HREF="Device_Configuration.htm#14334" CLASS="XRef">DWORD Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361350"></A><A NAME="ASL_DWordSpace"></A><A NAME="_Toc202341987"></A><A NAME="_Toc258262623"></A>DWordSpace (DWord Space Resource Descriptor Macro)<A NAME="marker-1361348"></A><A NAME="marker-1361349"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361351"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361352"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
DWordSpace </EM>
(ResourceType, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361353"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361354"></A>ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.</P>
<P CLASS="Body">
<A NAME="pgfId-1361355"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361356"></A>Decode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1361357"></A>IsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361358"></A>IsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361359"></A>TypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.</P>
<P CLASS="Body">
<A NAME="pgfId-1361360"></A>AddressGranularity evaluates to a 32-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 32-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361361"></A>AddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361362"></A>AddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361363"></A>AddressTranslation evaluates to a 32-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 32-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361364"></A>RangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the Memory range. The 32-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361365"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1361366"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1361367"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361368"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361369"></A>The DWordSpace macro evaluates to a buffer which contains a 32-bit Address Space resource descriptor. The format of the 32-bit Address Space resource descriptor can be found in &#8220;DWord Address Space Descriptor &#8221; (<A HREF="Device_Configuration.htm#14334" CLASS="XRef">DWORD Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361377"></A><A NAME="_Toc489267533"></A><A NAME="ASL_EISAID"></A><A NAME="_Toc202341988"></A><A NAME="_Toc258262624"></A>EISAID (EISA ID String To Integer Conversion Macro)<A NAME="marker-1361375"></A><A NAME="marker-1361376"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361378"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361379"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
EISAID </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
EisaIdString</EM>
) =&gt; DWordConst</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361380"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361381"></A>The EisaIdString must be a String object of the form &#8220;UUUNNNN&#8221;, where &#8220;U&#8221; is an uppercase letter and &#8220;N&#8221; is a hexadecimal digit. No asterisks or other characters are allowed in the string.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361382"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361383"></A>Converts EisaIdString, a 7-character text string argument, into its corresponding 4-byte numeric EISA ID encoding. It can be used when declaring IDs for devices that have EISA IDs. </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361384"></A>Example</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1361385"></A>    EISAID (&#8220;PNP0C09&#8221;)     // This is a valid invocation of the macro.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361392"></A><A NAME="_Toc489267453"></A><A NAME="ASL_Else"></A><A NAME="_Toc202341989"></A><A NAME="_Toc258262625"></A>Else <A NAME="marker-1361391"></A>(Alternate Execution)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361393"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361394"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Else </EM>
{TermList} </P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361395"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361398"></A>TermList is a sequence of executable ASL statements.<A NAME="marker-1361396"></A><A NAME="marker-1361397"></A></P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361399"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361400"></A>If Predicate evaluates to 0 in an If statement, then control is transferred to the Else portion, which can consist of zero or more ElseIf statements followed by zero or one Else statements. If the Predicate of any ElseIf statement evaluates to non-zero, the statements in its term list are executed and then control is transferred past the end of the final Else term. If no Predicate evaluates to non-zero, then the statements in the Else term list are executed.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361401"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1361402"></A>The following example checks Local0 to be zero or non-zero. On non-zero, CNT is incremented; otherwise, CNT is decremented.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361404"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524521"></A>If (LGreater (Local0, 5) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361405"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361406"></A>    Increment (CNT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361407"></A>} Else If (Local0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361408"></A>    Add (CNT, 5, CNT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361409"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361410"></A>Else </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361411"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361412"></A>    Decrement (CNT)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361413"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361419"></A><A NAME="ASL_ElseIf"></A><A NAME="_Toc202341990"></A><A NAME="_Toc258262626"></A>ElseIf (Alternate/Conditional Execution)<A NAME="marker-1361418"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361420"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361421"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ElseIf </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Predicate</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361422"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361423"></A>Predicate is evaluated as an Integer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361424"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361425"></A>If the Predicate of any ElseIf statement evaluates to non-zero, the statements in its term list are executed and then control is transferred past the end of the final Else. If no Predicate evaluates to non-zero, then the statements in the Else term list are executed.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1361426"></A>(Compatibility Note) The ElseIf operator was first introduced in ACPI 2.0, but is backward compatible with the ACPI 1.0 specification. An ACPI 2.0 and later ASL compiler must synthesize ElseIf from the If. and Else opcodes available in 1.0. For example:</LI>
</UL>
<P CLASS="CodeExample">
<A NAME="pgfId-1524535"></A>If (predicate1) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361429"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361430"></A>    ...statements1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361431"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361432"></A>ElseIf (predicate2) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361433"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361434"></A>    ...statements2...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361435"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361436"></A>Else </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361437"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361438"></A>    ...statements3...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361439"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1361440"></A>is translated to the following:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361442"></A>If (predicate1) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361443"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361444"></A>    ...statements1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361445"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361446"></A>Else </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361447"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361448"></A>    If (predicate2) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361449"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361450"></A>        ...statements2...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361451"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361452"></A>    Else </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361453"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361454"></A>        ...statements3...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361455"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361456"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361463"></A><A NAME="ASL_EndDependentFn"></A><A NAME="_Toc202341991"></A><A NAME="_Toc258262627"></A>EndDependentFn (End Dependent Function Resource Descriptor<A NAME="marker-1361461"></A><A NAME="marker-1361462"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361464"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361465"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
EndDependentFn () </EM>
=&gt; Buffer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361466"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361467"></A>The EndDependentFn macro generates an end-of-dependent-function resource descriptor buffer inside of an ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>). It must be matched with a StartDependentFn (<A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFn" CLASS="XRef">StartDependentFn (Start Dependent Function Resource Descriptor Macro)</A>) or StartDependentFnNoPri (<A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFnNoPri" CLASS="XRef">StartDependentFnNoPri (Start Dependent Function Resource Descriptor Macro)</A>) macro.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361474"></A><A NAME="_Toc489267428"></A><A NAME="ASL_Event"></A><A NAME="_Toc202341992"></A><A NAME="_Toc258262628"></A>Event (Declare Event Synchronization Object)<A NAME="marker-1361473"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361475"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361476"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Event </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
EventName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361477"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361478"></A>Creates an event synchronization object named EventName.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361479"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361480"></A>For more information about the uses of an event synchronization object, see the ASL definitions for the Wait, Signal, and Reset function operators.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361493"></A><A NAME="_Toc202341993"></A><A NAME="_Toc258262629"></A>ExtendedIO (Extended IO Resource Descriptor Macro)<A NAME="marker-1361491"></A><A NAME="marker-1361492"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361494"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361495"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ExtendedIO </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, IsMinFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMaxFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Decode</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ISARanges</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressGranularity, AddressMinimum, AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressTranslation</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, TypeSpecificAttributes, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName, TranslationType, TranslationDensity)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361496"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361497"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361498"></A>IsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361499"></A>IsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361500"></A>Decode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1361501"></A>ISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2-bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is NonISAOnly, &#8216;2&#8217; is ISAOnly and &#8216;0&#8217; is EntireRange.</P>
<P CLASS="Body">
<A NAME="pgfId-1361502"></A>AddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 64-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361503"></A>AddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361504"></A>AddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361505"></A>AddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361506"></A>RangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the I/O range. The 64-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361509"></A>TypeSpecificAttributes is an optional argument that specifies attributes specific to this resource type. See <A HREF="Device_Configuration.htm#20294" CLASS="XRef">See Type Specific Attributes.</A>,&#8221;Type Specific Attributes&#8221;.</P>
<P CLASS="Body">
<A NAME="pgfId-1361510"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operatorsDescription</P>
<P CLASS="Body">
<A NAME="pgfId-1361511"></A>The ExtendedIO macro evaluates to a buffer which contains a 64-bit I/O resource descriptor, which describes a range of I/O addresses. The format of the 64-bit I/O resource descriptor can be found in &#8220;Extended Address Space Descriptor&#8221; (<A HREF="Device_Configuration.htm#96311" CLASS="XRef">Large Resource Items</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1548437"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#37693" CLASS="XRef">Memory Resource Flag (Resource Type = 0) Definitions</A>) for more information</P>
<P CLASS="Body">
<A NAME="pgfId-1548441"></A>TranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName._TRS is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SparseTranslation and &#8216;0&#8217; is DenseTranslation. See _TRS (<A HREF="Device_Configuration.htm#51978" CLASS="XRef">I/O Resource Flag (Resource Type = 1) Definitions</A>) for more information. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361519"></A><A NAME="_Toc202341994"></A><A NAME="_Toc258262630"></A>ExtendedMemory (Extended Memory Resource Descriptor Macro) <A NAME="marker-1361517"></A><A NAME="marker-1361518"></A></H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361520"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361521"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ExtendedMemory </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, Decode, IsMinFixed, IsMaxFixed, Cacheable, ReadAndWrite, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, TypeSpecificAttributes, DescriptorName, MemoryRangeType, TranslationType)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361522"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361523"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361524"></A>Decode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1361525"></A>IsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361526"></A>IsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361527"></A>Cacheable specifies whether or not the memory region is cacheable (Cacheable), cacheable and write-combining (WriteCombining), cacheable and prefetchable (Prefetchable) or uncacheable (NonCacheable). If nothing is specified, then NonCacheable is assumed. The 2-bit field DescriptorName._MEM is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Cacheable, &#8216;2&#8217; is WriteCombining, &#8216;3&#8217; is Prefetchable and &#8216;0&#8217; is NonCacheable.</P>
<P CLASS="Body">
<A NAME="pgfId-1361528"></A>ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ReadWrite and &#8216;0&#8217; is ReadOnly.</P>
<P CLASS="Body">
<A NAME="pgfId-1361529"></A>AddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361530"></A>AddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName ._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361531"></A>AddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName ._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361532"></A>AddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 64-bit field DescriptorName. _TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1549070"></A>RangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1549071"></A>TypeSpecificAttributes is an optional argument that specifies attributes specific to this resource type. See <A HREF="Device_Configuration.htm#20294" CLASS="XRef">See Type Specific Attributes.</A>,&#8221;Type Specific Attributes&#8221;.</P>
<P CLASS="Body">
<A NAME="pgfId-1549075"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1361535"></A>MemoryRangeType is an optional argument that specifies the memory usage. The memory can be marked as normal (AddressRangeMemory), used as ACPI NVS space (AddressRangeNVS), used as ACPI reclaimable space (AddressRangeACPI) or as system reserved (AddressRangeReserved). If nothing is specified, then AddressRangeMemory is assumed. The 2-bit field DescriptorName. _MTP is automatically created in order to refer to this portion of the resource descriptor, where &#8216;0&#8217; is AddressRangeMemory, &#8216;1&#8217; is AddressRangeReserved, &#8216;2&#8217; is AddressRangeACPI and &#8216;3&#8217; is AddressRangeNVS.</P>
<P CLASS="Body">
<A NAME="pgfId-1361536"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is I/O. If TypeStatic is specified, then the primary side of the bus is Memory. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#37693" CLASS="XRef">Memory Resource Flag (Resource Type = 0) Definitions</A>) for more information.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361538"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361539"></A>The ExtendedMemory macro evaluates to a buffer which contains a 64-bit memory resource descriptor, which describes a range of memory addresses. The format of the 64-bit memory resource descriptor can be found in &#8220;Extended Address Space Descriptor&#8221; (<A HREF="Device_Configuration.htm#16148" CLASS="XRef">Extended Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361547"></A><A NAME="_Toc202341995"></A><A NAME="_Toc258262631"></A>ExtendedSpace (Extended Address Space Resource Descriptor Macro)<A NAME="marker-1361545"></A><A NAME="marker-1361546"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361548"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361549"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ExtendedSpace </EM>
(ResourceType, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, TypeSpecificAttributes, DescriptorName)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361550"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361551"></A>ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.</P>
<P CLASS="Body">
<A NAME="pgfId-1361552"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361553"></A>Decode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1361554"></A>IsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361555"></A>IsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361556"></A>TypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.</P>
<P CLASS="Body">
<A NAME="pgfId-1361557"></A>AddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361558"></A>AddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361559"></A>AddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361560"></A>AddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361561"></A>RangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361562"></A>TypeSpecificAttributes is an optional argument that specifies attributes specific to this resource type. See <A HREF="Device_Configuration.htm#20294" CLASS="XRef">See Type Specific Attributes.</A>,&#8221;Type Specific Attributes&#8221;.</P>
<P CLASS="Body">
<A NAME="pgfId-1361563"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361564"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361565"></A>The ExtendedSpace macro evaluates to a buffer which contains a 64-bit Address Space resource descriptor, which describes a range of addresses. The format of the 64-bit AddressSpace descriptor can be found in &#8220;Extended Address Space Descriptor&#8221; (<A HREF="Device_Configuration.htm#16148" CLASS="XRef">Extended Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361571"></A><A NAME="ASL_External"></A><A NAME="_Toc202341996"></A><A NAME="_Toc258262632"></A>External (Declare External Objects)<A NAME="marker-1361570"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361572"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361573"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
External </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ObjectName, ObjectType, ReturnType, ParameterTypes</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361574"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361575"></A>ObjectName is a NameString.</P>
<P CLASS="Body">
<A NAME="pgfId-1361576"></A>ObjectType is an optional ObjectTypeKeyword (e.g. IntObj, PkgObj, etc.). If not specified, &#8220;UnknownObj&#8221; type is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1361577"></A>ReturnType is optional. If the specified ObjectType is MethodObj, then this specifies the type or types of object returned by the method. If the method does not return an object, then nothing is specified or UnknownObj is specified. To specify a single return type, simply use the ObjectTypeKeyword. To specify multiple possible return types, enclose the comma-separated ObjectTypeKeywords with braces. For example: {IntObj, BuffObj}.</P>
<P CLASS="Body">
<A NAME="pgfId-1361578"></A>ParameterTypes is optional. If the specified ObjectType is MethodObj, this specifies both the number and type of the method parameters. It is a comma-separated, variable-length list of the expected object type or types for each of the method parameters, enclosed in braces. For each parameter, the parameter type consists of either an ObjectTypeKeyword or a comma-separated sub-list of ObjectTypeKeywords enclosed in braces. There can be no more than seven parameters in total.Description</P>
<P CLASS="Body">
<A NAME="pgfId-1361579"></A>The External directive informs the ASL compiler that the object is declared external to this table so that no errors will be generated for an undeclared object. The ASL compiler will create the external object at the specified place in the namespace (if a full path of the object is specified), or the object will be created at the current scope of the External term.</P>
<P CLASS="Body">
<A NAME="pgfId-1361580"></A>For external control methods, the ASL compiler can emit an External AML opcode that contains the name of the method and the number of required arguments. This information may be used by AML disassemblers to properly disassemble the AML to the correct ASL code.</P>
<P CLASS="Body">
<A NAME="pgfId-1552176"></A>External is especially useful for use in secondary SSDTs, when the required scopes and objects are declared in the main DSDT.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361581"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1361582"></A>This example shows the use of External in conjunction with Scope within an SSDT:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361584"></A>DefinitionBlock (&quot;ssdt.aml&quot;, &quot;SSDT&quot;, 2, &quot;X&quot;, &quot;Y&quot;, 0x00000001)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361585"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361586"></A>    External (&#92;_SB.PCI0, DeviceObj)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361587"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361588"></A>    Scope (&#92;_SB.PCI0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361589"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361590"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361591"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361595"></A><A NAME="_Toc202341997"></A><A NAME="_Toc465246085"></A><A NAME="_Toc469218393"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361602"></A><A NAME="_Toc489267454"></A><A NAME="ASL_Fatal"></A><A NAME="_Toc202341998"></A><A NAME="_Toc258262633"></A>Fatal (Fatal Error Check)<A NAME="marker-1361601"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361603"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361604"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Fatal </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Type, Code, Arg</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361605"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361606"></A>This operation is used to inform the OS that there has been an OEM-defined fatal error. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361607"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361610"></A>In response, the OS must log the fatal event and perform a controlled OS shutdown in a timely fashion.<A NAME="marker-1361608"></A><A NAME="marker-1361609"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361618"></A><A NAME="_Toc489267429"></A><A NAME="ASL_Field"></A><A NAME="_Toc202341999"></A><A NAME="_Toc258262634"></A>Field (Declare Field Objects)<A NAME="marker-1361616"></A><A NAME="marker-1361617"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361619"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361620"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Field </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RegionName, AccessType, LockRule, UpdateRule</EM>
) {FieldUnitList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361621"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361622"></A>RegionName is evaluated as a Namestring that refers to the host operation region.</P>
<P CLASS="Body">
<A NAME="pgfId-1361623"></A>AccessType is optional and defines the default access width of the field definition and is any one of the following: AnyAcc, ByteAcc, WordAcc, DWordAcc, or QWordAcc. In general, accesses within the parent object are performed naturally aligned. If desired, AccessType set to a value other than AnyAcc can be used to force minimum access width. Notice that the parent object must be able to accommodate the AccessType width. For example, an access type of WordAcc cannot read the last byte of an odd-length operation region. The exceptions to natural alignment are the access types used for a non-linear SMBus device. These will be discussed in detail below. Not all access types are meaningful for every type of operational region. If not specified, the default is AnyAcc.</P>
<P CLASS="Body">
<A NAME="pgfId-1361624"></A>LockRule is optional and indicates whether the Global Lock is to be used when accessing this field and is one of the following: Lock or NoLock. If LockRule is set to Lock, accesses to modify the component data objects will acquire and release the Global Lock. If both types of locking occur, the Global Lock is acquired after the parent object Mutex. On Hardware-reduced ACPI platforms, Lock is not supported. If not specified, the default is NoLock.</P>
<P CLASS="Body">
<A NAME="pgfId-1539666"></A>UpdateRule is optional and specifieas how the unmodified bits of a field are treated, and can be any one of the following: Preserve, WriteAsOnes, or WriteAsZeros. For example, if a field defines a component data object of 4 bits in the middle of a WordAcc region, when those 4 bits are modified the UpdateRule specifies how the other 12 bits are treated. If not specified, the default is Preserve.</P>
<P CLASS="Body">
<A NAME="pgfId-1361626"></A>FieldUnitList is a variable-length list of individual field unit definitions, separated by commas. Each entry in the field unit list is one of the following:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361635"></A>Field Unit list entires</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361630"></A>FieldUnitName, BitLength</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361632"></A>Offset (ByteOffset)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361634"></A>AccessAs (AccessType, AccessAttribute)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539675"></A>Connection (ConnectionResourceObj)</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1361638"></A>FieldUnitName is the ACPI name for the field unit (1 to 4 characters), and BitLength is the length of the field unit in bits. Offset is used to specify the byte offset of the next defined field unit. This can be used instead of defining the bit lengths that need to be skipped. AccessAs is used to define the access type and attributes for the remaining field units within the list. Connection is used to identify the connection resource of the field access. This is necessary for GenericSerialBus and GeneralPurposeIO operation region address spaces only.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361639"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361640"></A>Declares a series of named data objects whose data values are fields within a larger object. The fields are parts of the object named by RegionName, but their names appear in the same scope as the Field term.</P>
<P CLASS="Body">
<A NAME="pgfId-1361641"></A>For example, the field operator allows a larger operation region that represents a hardware register to be broken down into individual bit fields that can then be accessed by the bit field names. Extracting and combining the component field from its parent is done automatically when the field is accessed. </P>
<P CLASS="Body">
<A NAME="pgfId-1361642"></A>When reading from a FieldUnit, returned values are normalized (shifted and masked to the proper length.) The data type of an individual FieldUnit can be either a Buffer or an Integer, depending on the bit length of the FieldUnit. If the FieldUnit is smaller than or equal to the size of an Integer (in bits), it will be treated as an Integer. If the FieldUnit is larger than the size of an Integer, it will be treated as a Buffer. The size of an Integer is indicated by the DSDT header&#8217;s Revision field. A revision less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. For more information about data types and FieldUnit type conversion rules, see <A HREF="ACPI_Source_Language_Reference.htm#85702" CLASS="XRef">See Data Type Conversion Rules.</A>, &#8220;Data Type Conversion Rules&#8221;.</P>
<P CLASS="Body">
<A NAME="pgfId-1361643"></A>Accessing the contents of a field data object provides access to the corresponding field within the parent object. If the parent object supports Mutex synchronization, accesses to modify the component data objects will acquire and release ownership of the parent object around the modification. </P>
<P CLASS="Body">
<A NAME="pgfId-1361644"></A>The following table relates region types declared with an OperationRegion term to the different access types supported for each region.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361648"></A>OperationRegion Address Spaces and Access Types</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1544816"></A>Address Space</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1544818"></A>Permitted Access Type(s)</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1544820"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361657"></A>SystemMemory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361659"></A>ByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361661"></A>All access allowed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361663"></A>SystemIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361665"></A>ByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361667"></A>All access allowed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361669"></A>PCI_Config</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361671"></A>ByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361673"></A>All access allowed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361675"></A>EmbeddedControl </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361677"></A>ByteAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361679"></A>Byte access only</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361681"></A>SMBus</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361683"></A>BufferAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361685"></A>Reads and writes to this operation region involve the use of a region specific data buffer. (See below.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361687"></A>SystemCMOS </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361689"></A>ByteAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361691"></A>Byte access only</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361693"></A>PciBarTarget</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361695"></A>ByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361697"></A>All access allowed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361699"></A>IPMI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361701"></A>BufferAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361703"></A>Reads and writes to this operation region involve the use of a region specific data buffer. (See below.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539719"></A>GeneralPurposeIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539779"></A>ByteAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539723"></A>Byte access only</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539713"></A>GenericSerialBus</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539767"></A>BufferAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1539717"></A>Reads and writes to this operation region involve the use of a region-specific data buffer. (See below.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1572090"></A>PCC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1572092"></A>ByteAcc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1572094"></A>Reads and writes to this operation region are performed in units of bytes.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1361706"></A>The named FieldUnit data objects are provided in the FieldList as a series of names and bit widths. Bits assigned no name (or NULL) are skipped. The ASL compiler supports the Offset (ByteOffset) macro within a FieldList to skip to the bit position of the supplied byte offset, and the AccessAs macro to change access within the field list.</P>
<P CLASS="Body">
<A NAME="pgfId-1539869"></A>GenericSerialBus, SMBus and IPMI regions are inherently non-linear, where each offset within the respective address space represents a variable sized (0 to 32 bytes) field. Given this uniqueness, these operation regions include restrictions on their field definitions and require the use of  a region-specific data buffer when initiating transactions. For more information on the SMBus data buffer format, see <A HREF="ACPI_Sys_Mgmt_Bus_Interface_Specification.htm#78977" CLASS="XRef">See ACPI System Management Bus Interface Specification.</A>, &#8220;ACPI System Management Bus Interface Specification,&#8221;. For more information on the IPMI data buffer format, see <A HREF="ACPI_Software_Programming_Model.htm#23886" CLASS="XRef">See Declaring IPMI Operation Regions.</A>, &#8220;Declaring IPMI Operation Regions&quot;. For more information on the Generic Serial Bus data buffer format, see <A HREF="ACPI_Software_Programming_Model.htm#10758" CLASS="XRef">See Declaring GenericSerialBus Operation Regions.</A> &quot;Declaring Generic Serial Bus Operation Regions.&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-1539895"></A>For restrictions on the use of Fields with GeneralPurposeIO OpRegions, see <A HREF="ACPI_Software_Programming_Model.htm#69535" CLASS="XRef">See Declaring GeneralPurposeIO Operation Regions.</A>, &quot;Declaring General PurposeIO Operation Regions&quot;.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361708"></A>Example</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1524549"></A>OperationRegion (MIOC, PCI_Config, Zero, 0xFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361710"></A>Field (MIOC, AnyAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361711"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361712"></A>        Offset  (0x58), <BR>
        HXGB,   32, <BR>
        HXGT,   32, <BR>
        GAPE,   8, <BR>
        MR0A,   4, <BR>
        MR0B,   4</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381642"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1381658"></A><A NAME="_Toc465246069"></A><A NAME="_Toc469218377"></A><A NAME="_Toc465246046"></A><A NAME="_Toc469218363"></A><A NAME="_Toc489267415"></A><A NAME="_Toc465246086"></A><A NAME="_Toc469218394"></A><A NAME="_Toc465246109"></A><A NAME="_Toc469218417"></A><A NAME="_Toc489267481"></A><A NAME="ASL_FindSetLeftBit"></A><A NAME="_Toc202342000"></A><A NAME="_Toc258262635"></A>FindSetLeftBit (Find First Set Left Bit)<A NAME="marker-1381657"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361731"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361732"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
FindSetLeftBit </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361733"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361734"></A>Source is evaluated as an Integer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361735"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361736"></A>The one-based bit location of the first MSb (most significant set bit) is optionally stored into Result. The result of 0 means no bit was set, 1 means the left-most bit set is the first bit, 2 means the left-most bit set is the second bit, and so on.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361746"></A><A NAME="_Toc489267482"></A><A NAME="ASL_FindSetRightBit"></A><A NAME="_Toc202342001"></A><A NAME="_Toc258262636"></A>FindSetRightBit (Find First Set Right Bit)<A NAME="marker-1361745"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361747"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361748"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
FindSetRightBit </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361749"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361750"></A>Source is evaluated as an Integer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361751"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361752"></A>The one-based bit location of the most LSb (least significant set bit) is optionally stored in Result. The result of 0 means no bit was set, 32 means the first bit set is the thirty-second bit, 31 means the first bit set is the thirty-first bit, and so on.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1548048"></A>FixedDMA (DMA Resource Descriptor<A NAME="marker-1548046"></A><A NAME="marker-1548047"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1548049"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1548050"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
FixedDMA </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DmaRequestLine, Channel</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DmaTransferWidth</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
) <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
 </EM>
 =&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1548051"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1548052"></A>DmaRequestLine is a system-relative number uniquely identifying the request line statically assigned to the device.. The bit field name _DMA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1548053"></A>Channel is a controller-relative number uniquely identifying the channel statically assigned to this DMARequestLine.  Channels can be shared by reusing Channel numbers across descriptors. The bit field name _TYP is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1548054"></A>DmaTransferWidth is an optional argument specifying the width of data transfer for which the device is configured. Valid values are Width8Bit, Width16Bit, Width32Bit,Width64Bit, Width 128Bit or Width256Bit. If not specified, Width32Bit is assumed. The bit field name _SIZ is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1548055"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1548056"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1548060"></A>The FixedDMA macro evaluates to a buffer that contains a Fixed DMA Descriptor (<A HREF="Device_Configuration.htm#82840" CLASS="XRef">See Large Resource Data Type.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361762"></A><A NAME="ASL_FixedIO"></A><A NAME="_Toc202342002"></A><A NAME="_Toc258262637"></A>FixedIO (Fixed IO Resource Descriptor Macro)<A NAME="marker-1361760"></A><A NAME="marker-1361761"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361763"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361764"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
FixedIO </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressBase, RangeLength, DescriptorName</EM>
) =&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361765"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361766"></A>AddressBase evaluates to a 16-bit integer. It describes the starting address of the fixed I/O range. The field DescriptorName. _BAS is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1361767"></A>RangeLength evaluates to an 8-bit integer. It describes the length of the fixed I/O range. The field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor. </P>
<P CLASS="Body">
<A NAME="pgfId-1361768"></A>DescriptorName evaluates to a name string which refers to the entire resource descriptor.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361769"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361770"></A>The FixedIO macro evaluates to a buffer which contains a fixed I/O resource descriptor. The format of the fixed I/O resource descriptor can be found in &#8220;Fixed Location I/O Port Descriptor &#8221; (<A HREF="Device_Configuration.htm#AML_FixedIO" CLASS="XRef">Fixed Location I/O Port Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1561847"></A><A NAME="29080"></A>For (Conditional Loop)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1561848"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1561849"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
For </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Initialize, Predicate, Update</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1561850"></A>Arguments</H4>
<P CLASS="Body-Text">
<A NAME="pgfId-1562046"></A>Initialize. This optional expression is evaluated once before the loop is entered. If not specified, no initialization takes place.</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1562047"></A>Predicate. The list of terms within the TermList are executed until the predicate evaluates to zero (FALSE). If this argument is not specified, the For macro is equivalent to <EM CLASS="CodeCharacter">
While(1)</EM>
.</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1561990"></A>Update. This optional expression is evaluated once per execution of the loop, after all other terms within the TermList have been executed.</P>
<P CLASS="Body">
<A NAME="pgfId-1561853"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1561854"></A>Description</H4>
<P CLASS="Body">
<A NAME="pgfId-1561838"></A><EM CLASS="CodeCharacter">
For</EM>
 is a macro that creates a loop by converting the input arguments to the equivalent ASL <EM CLASS="CodeCharacter">
While</EM>
 loop.</P>
<P CLASS="Body">
<A NAME="pgfId-1562160"></A><EM CLASS="Note">
Note:</EM>
 Creation of a named object more than once in a given scope is not allowed. As such, unconditionally creating named objects within a For loop must be avoided. A fatal error will be generated on the second iteration of the loop, during the attempt to create the same named object a second time.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1562191"></A>Example</H4>
<P CLASS="Body">
<A NAME="pgfId-1562213"></A>The following example shows the use of the <EM CLASS="CodeCharacter">
For</EM>
 macro to create a loop, followed by the equivalent <EM CLASS="CodeCharacter">
While</EM>
 loop that is actually emitted by the ASL compiler:</P>
<P CLASS="Body">
<A NAME="pgfId-1562215"></A><EM CLASS="CodeExampleCharacter">
        for (local0 = 0, local0 &lt; 8, local0++)</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562216"></A><EM CLASS="CodeExampleCharacter">
        {</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562217"></A><EM CLASS="CodeExampleCharacter">
        }</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562218"></A><EM CLASS="CodeExampleCharacter">
</EM>
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1562219"></A><EM CLASS="CodeExampleCharacter">
        Local0 = 0</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562220"></A><EM CLASS="CodeExampleCharacter">
        While (Local0 &lt; 8)</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562221"></A><EM CLASS="CodeExampleCharacter">
        {</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562222"></A><EM CLASS="CodeExampleCharacter">
            Local0++</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1562187"></A><EM CLASS="CodeExampleCharacter">
        }</EM>
</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1550167"></A><A NAME="45077"></A>Fprintf (Create and Store formatted string)</H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1550168"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1550169"></A><EM CLASS="Bold">
Fprintf</EM>
 (<EM CLASS="Italic">
Destination, FormatString, FormatArgs</EM>
) =&gt; String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1550170"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1550171"></A>Fprintf is a macro that converts the evaluated <EM CLASS="Italic">
FormatString</EM>
 into a series of string <EM CLASS="Bold">
Concatenate</EM>
 operations, storing the result in <EM CLASS="Italic">
Destination</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-1550172"></A><EM CLASS="Italic">
FormatString</EM>
 is a string literal which may contain one or more uses of the format specifier, %o, to indicate locations in the string where an object may be inserted. %o is the only format specifier supported since the resulting object is a string and type conversion is handled automatically by Concatenate.</P>
<P CLASS="Body">
<A NAME="pgfId-1550173"></A><EM CLASS="Italic">
FormatArgs</EM>
 is a comma separated list of Named Objects, Locals, or Args that can be evaluated to a string. Each argument is added to the <EM CLASS="Italic">
FormatString</EM>
 using the <EM CLASS="Bold">
Concatenate</EM>
 operation at the location specified by %o in order of appearance.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1550174"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1550175"></A>Fprintf is a macro that converts the evaluated FormatString into a series of string Concatenate operations, storing the result in Destination</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1550176"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1550177"></A>The following ASL example uses <EM CLASS="Bold">
Fprintf</EM>
 to write a formatted string of Arg0 and Arg1 to the Named Object STR1.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550179"></A>    Fprintf (STR1, &quot;%o: %o Successful&quot;, Arg1, Arg0)</P>
<P CLASS="Body">
<A NAME="pgfId-1550282"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1550181"></A>This Fprintf macro expression evaluates to the following ASL operation.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550182"></A>    Store (Concatenate (Concatenate (Concatenate (Concatenate</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550163"></A>          (&quot;&quot;, Arg1), &quot;: &quot;), Arg0), &quot; Successful&quot;), STR1)</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361771"></A><A NAME="_Toc489267483"></A><A NAME="ASL_FromBCD"></A><A NAME="_Toc202342003"></A><A NAME="_Toc258262638"></A>FromBCD (Convert BCD To Integer)<A NAME="marker-1361776"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361778"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361779"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
FromBCD </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
BCDValue,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361780"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361781"></A>BCDValue is evaluated as an Integer in Binary Coded Decimal format.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361782"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1544898"></A>The FromBCD operation <EM CLASS="fontstyle41">
converts BCDValue to a numeric format, and optionally stores the numeric value</EM>
 <EM CLASS="fontstyle41">
into Result.</EM>
<A NAME="ASL_Function"></A><A NAME="_Toc202342004"></A><A NAME="_Toc258262639"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1570961"></A><A NAME="74939"></A>Function (Declare Control Method)<A NAME="marker-1570943"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1544904"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361791"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Function </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
FunctionName, ReturnType, ParameterTypes</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361792"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1570974"></A><EM CLASS="fontstyle31">
</EM>
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1361793"></A>ReturnType is optional and specifies the type(s) of the object(s) returned by the method. If the method does not return an object, then nothing is specified or UnknownObj is specified. To specify a single return type, simply use the ObjectTypeKeyword (e.g. IntObj, PkgObj, etc.). To specify multiple possible return types, enclose the comma-separated ObjectTypeKeywords with braces. For example: <EM CLASS="CodeCharacter">
{IntObj, BuffObj}</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-1361794"></A>ParameterTypes is optional and specifies both the number and type of the method parameters. It is a comma-separated, variable-length list of the expected object type or types for each of the method parameters, enclosed in braces. For each parameter, the parameter type consists of either an ObjectTypeKeyword or a comma-separated sub-list of ObjectTypeKeywords enclosed in braces. There can be no more than seven parameters in total.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361795"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361796"></A>Function declares a named package containing a series of terms that collectively represent a control method. A control method is a procedure that can be invoked to perform computation. Function opens a name scope.</P>
<P CLASS="Body">
<A NAME="pgfId-1361797"></A>System software executes a control method by executing the terms in the package in order. For more information on method execution, see <A HREF="ACPI_Software_Programming_Model.htm#75986" CLASS="XRef">See Control Method Execution.</A>, &#8220;Control Method Execution.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1361798"></A>The current namespace location used during name creation is adjusted to be the current location on the namespace tree. Any names created within this scope are &#8220;below&#8221; the name of this package. The current namespace location is assigned to the method package, and all namespace references that occur during control method execution for this package are relative to that location. <A NAME="marker-1361799"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1361800"></A>Functions are equivalent to a Method that specifies NotSerialized. As such, a function should not create any named objects, since a second thread that might re-enter the function will cause a fatal error if an attempt is made to create the same named object twice.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1361801"></A>(Compatibility Note) New for ACPI 3.0</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1368347"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1368348"></A>The following block of ASL sample code shows the use of Function for defining a control method:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1368349"></A>Function (EXAM, IntObj, {StrObj, {IntObj, StrObj}})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361806"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361807"></A>    Name (Temp,&#8221;&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361808"></A>    Store (Arg0, Temp)                // could have used Arg1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361809"></A>    Return (SizeOf (Concatenate (Arg1, Temp)))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361810"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524563"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1361811"></A>This declaration is equivalent to:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361813"></A>Method (EXAM, 2, NotSerialized, 0, IntObj, {StrObj, {IntObj, StrObj}})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361814"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361815"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361816"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361817"></A><A NAME="68627"></A><A NAME="19522"></A>GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)</H6>
<P CLASS="Body">
<A NAME="pgfId-1536293"></A>GpioInt (EdgeLevel, ActiveLevel, Shared, PinConfig, DebounceTimeout, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, VendorData) {PinList}</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1536295"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1536417"></A>EdgeLevel can be either Edge or Level. The bit field name _MOD is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536296"></A>ActiveLevel can be one of ActiveHigh, ActiveLow or ActiveBoth. ActiveBoth can be specified only if EdgeLevel is Edge. The bit field name _POL is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536297"></A>Shared is an optional argument and can be one of Shared, Exclusive, SharedAndWake or ExclusiveAndWake. If not specified, Exclusive is assumed. The &quot;Wake&quot; designation indicates that the interrupt is capable of waking the system from a low-power idle state or a system sleep state. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536298"></A>PinConfig can be one of PullDefault, PullUp, PullDown, PullNone or a vendor-supplied value in the range 128-255. The bit field name _PPI is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536299"></A>DebounceTimeout is an optional argument specifying the debounce wait time, in hundredths of milliseconds. The bit field name _DBT is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536300"></A>ResourceSource is a string which uniquely identifies the GPIO controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules. </P>
<P CLASS="Body">
<A NAME="pgfId-1536301"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1536302"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1536303"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1536304"></A>VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536305"></A>PinList is a list of (zero-based) pin numbers on the ResourceSource that are described by this descriptor. For interrupt pin descriptors, only one pin is allowed. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536306"></A>Description</P>
<P CLASS="Body">
<A NAME="pgfId-1544909"></A>The GpioInt macro evaluates to a buffer that contains a GPIO Interrupt Connection resource descriptor. The format of the GPIO Interrupt Connection resource descriptor can be found in &quot;GPIO Connection Descriptor&quot; (<A HREF="Device_Configuration.htm#93488" CLASS="XRef">See GPIO Connection Descriptor.</A>). The macro is designed to be used inside of a Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1544917"></A><A NAME="13947"></A>GpioIo (GPIO Connection IO Resource Descriptor Macro)</H6>
<P CLASS="Body">
<A NAME="pgfId-1544918"></A>GpioIo (Shared, PinConfig, DebounceTimeout, DriveStrength, IORestriction, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, VendorData) {PinList}</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1536373"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1536314"></A>Shared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536315"></A>PinConfig can be one of PullDefault, PullUp, PullDown, PullNone or a vendor-supplied value in the range 128-255. The bit field name _PPI is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536316"></A>DebounceTimeout is an optional argument specifying the hardware debounce wait time, in hundredths of milliseconds. The bit field name _DBT is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536317"></A>DriveStrength is an optional argument specifying the output drive capability of the pin, in hundredths of milliamperes. The bit field name _DRS is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536318"></A>IORestriction is an optional argument and can be IoRestrictionInputOnly, IoRestrictionOutputOnly, IoRestrictionNone, or IORestrictionNoneAndPreserve. IORestrictions limit the mode in which the pin can be accessed (Input or Output). They also ensure that the pin configuration is preserved during periods when the driver is unloaded or the resource has been disconnected by the driver. If not specified, IoRestrictionNone is assumed. The bit field name _IOR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536319"></A>ResourceSource is a string which uniquely identifies the GPIO controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules. </P>
<P CLASS="Body">
<A NAME="pgfId-1536320"></A>ResourceSourceIndex is an optional argument and is always 0 for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1536321"></A>ResourceUsage is an optional argument and is always ResourceConsumer for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1536322"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1536323"></A>VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1536324"></A>PinList is a list of pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1536355"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1536326"></A>The GpioIo macro evaluates to a buffer that contains a GPIO IO Connection resource descriptor. The format of the GPIO  IO Connection resource descriptor can be found in &quot;GPIO Connection Descriptor&quot; (<A HREF="Device_Configuration.htm#93488" CLASS="XRef">See GPIO Connection Descriptor.</A>). The macro is designed to be used inside of a Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1541440"></A><A NAME="98349"></A>I2CSerialBusV2 (I2C Serial Bus Connection Resource Descriptor  (Version 2) Macro)</H6>
<P CLASS="Body">
<A NAME="pgfId-1541441"></A>Syntax</P>
<P CLASS="Body">
<A NAME="pgfId-1541442"></A>I2CSerialBusV2 (SlaveAddress, SlaveMode, ConnectionSpeed, AddressingMode, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, Shared, VendorData)</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540247"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1540211"></A>SlaveAddress is the I2C bus address for this connection. The bit field name _ADR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540212"></A>SlaveMode is an optional argument and can be either ControllerInitiated or DeviceInitiated. ControllerInitiated is the default. The bit field name _SLV is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540213"></A>ConnectionSpeed is the maximum connection speed supported by this connection, in hertz. The bit field name _SPE is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540214"></A>AddressingMode is an optional argument and can be either AddressingMode7Bit or AddressingMode10Bit. AddressingMode7Bit is the default. The bit field name _MOD is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540215"></A>ResourceSource is a string which uniquely identifies the I2C bus controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules. </P>
<P CLASS="Body">
<A NAME="pgfId-1540216"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1540217"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1540218"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1540219"></A>Shared is an optional argument and can be either <EM CLASS="Bold">
Shared</EM>
 or <EM CLASS="Bold">
Exclusive</EM>
. If not specified, <EM CLASS="Bold">
Exclusive</EM>
 is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1558065"></A>VendorData is an optional argument that specifies an object to be decoded by the OS driver. It is a RawDataBuffer. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1540259"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1544923"></A>The I2CSerialBusV2 macro evaluates to a buffer that contains an I2C Serial Bus resource descriptor (Version 2). The macro is designed to be used inside of a ResourceTemplate (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1544929"></A><A NAME="_Toc489267455"></A><A NAME="ASL_If"></A><A NAME="_Toc202342005"></A><A NAME="_Toc258262640"></A>If (Conditional Execution)<A NAME="marker-1544928"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1544930"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361825"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
If </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Predicate</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361826"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361827"></A>Predicate is evaluated as an Integer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361828"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361829"></A>If the Predicate is non-zero, the term list of the If term is executed.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361830"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1361831"></A>The following examples all check for bit 3 in Local0 being set, and clear it if set.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524584"></A>// example 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361834"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361835"></A>If (And (Local0, 4)) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361836"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361837"></A>    XOr (Local0, 4, Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361838"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361839"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361840"></A>// example 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361841"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361842"></A>Store (4, Local2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361843"></A>If (And (Local0, Local2)) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361844"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361845"></A>    XOr (Local0, Local2, Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361846"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361852"></A><A NAME="ASL_Include"></A><A NAME="_Toc202342006"></A><A NAME="_Toc258262641"></A>Include (Include Additional ASL File)<A NAME="marker-1361851"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361853"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361854"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Include </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
FilePathName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361855"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361856"></A>FilePathname is a StringData data type that contains the full OS file system path.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361857"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361858"></A>Include another file that contains ASL terms to be inserted in the current file of ASL terms. The file must contain elements that are grammatically correct in the current scope.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361859"></A>Example</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1361860"></A>    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1544939"></A>    Include (&quot;dataobj.asl&quot;)<A NAME="_Toc465246113"></A><A NAME="_Toc469218421"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1544941"></A><A NAME="79414"></A>Increment (Integer Increment)<A NAME="marker-1544940"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1544942"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361872"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Increment </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Addend</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556266"></A>Destination = Source [Index] =&gt; ObjectReference</P>
<P CLASS="Body">
<A NAME="pgfId-1556251"></A><EM CLASS="Italic">
Addend</EM>
++ =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361873"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361874"></A>Addend is evaluated as an Integer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361875"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361876"></A>Add one to the Addend and place the result back in Addend. Equivalent to Add (Addend, 1, Addend). Overflow conditions are ignored and the result of an overflow is zero.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361886"></A><A NAME="_Toc489267486"></A><A NAME="ASL_Index"></A><A NAME="_Toc202342008"></A><A NAME="_Toc258262643"></A>Index (Indexed Reference To Member Object)<A NAME="marker-1361885"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361887"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361888"></A>Index (Source, Index, Destination) =&gt; ObjectReference</P>
<P CLASS="Body">
<A NAME="pgfId-1556281"></A><EM CLASS="Italic">
Destination</EM>
 = <EM CLASS="Italic">
Source</EM>
 [<EM CLASS="Italic">
Index</EM>
] =&gt; ObjectReference</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361889"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1361890"></A>Source is evaluated to a buffer, string, or package data type. Index is evaluated to an integer. The reference to the nth object (where n = Index) within Source is optionally stored as a reference into Destination. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361891"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361892"></A>When Source evaluates to a Buffer, Index returns a reference to a Buffer Field containing the nth byte in the buffer. When Source evaluates to a String, Index returns a reference to a Buffer Field containing the nth character in the string. When Source evaluates to a Package, Index returns a reference to the nth object in the package.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1361893"></A>   I<A NAME="_Toc489267487"></A>ndex with Packages<A NAME="marker-1361896"></A><A NAME="marker-1361897"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1381713"></A>The following example ASL code shows a way to use the Index term to store into a local variable the sixth element of the first package of a set of nested packages:<A NAME="marker-1381714"></A><A NAME="marker-1381715"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381716"></A>    Name (IO0D, Package () { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381717"></A>         Package () { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381710"></A>             0x01, 0x03F8, 0x03F8, 0x01, 0x08, 0x01, 0x25, 0xFF, 0xFE, 0x00, 0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381700"></A>         }, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381701"></A>         Package () { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381696"></A>             0x01, 0x02F8, 0x02F8, 0x01, 0x08, 0x01, 0x25, 0xFF, 0xBE, 0x00, 0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381686"></A>         }, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381687"></A>         Package () { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381682"></A>             0x01, 0x03E8, 0x03E8, 0x01, 0x08, 0x01, 0x25, 0xFF, 0xFA, 0x00, 0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361911"></A>         }, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361912"></A>         Package () { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361913"></A>             x01, 0x02E8, 0x02E8, 0x01, 0x08, 0x01, 0x25, 0xFF, 0xBA, 0x00, 0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361914"></A>         }, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361915"></A>         Package() { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361916"></A>             0x01, 0x0100, 0x03F8, 0x08, 0x08, 0x02, 0x25, 0x20, 0x7F, 0x00, 0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361917"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361918"></A>    }) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361919"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361920"></A>    // Get the 6th element of the first package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361921"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361922"></A>    Store (DeRefOf (Index (DeRefOf (Index (IO0D, 0)), 5)), Local0)</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1361923"></A> DeRefOf is necessary in the first operand of the Store operator in order to get the actual object, rather than just a reference to the object. If DeRefOf were not used, then Local0 would contain an object reference to the sixth element in the first package rather than the number 1.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1361928"></A>I<A NAME="_Toc489267488"></A>ndex with Buffers<A NAME="marker-1361927"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1381729"></A>The following example ASL code shows a way to store into the third byte of a buffer:<A NAME="marker-1381728"></A>		</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381731"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524614"></A>    Name (BUFF, Buffer () {0x01, 0x02, 0x03, 0x04, 0x05})<BR>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361933"></A>    // Store 0x55 into the third byte of the buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361934"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361935"></A>    Store (0x55, Index (BUFF, 2))</P>
<P CLASS="Body">
<A NAME="pgfId-1361936"></A>The Index operator returns a reference to an 8-bit Buffer Field (similar to that created using CreateByteField). </P>
<P CLASS="Body">
<A NAME="pgfId-1361937"></A>If Source is evaluated to a buffer data type, the ObjectReference refers to the byte at Index within Source. If Source is evaluated to a buffer data type, a Store operation will only change the byte at Index within Source.</P>
<P CLASS="Body">
<A NAME="pgfId-1361938"></A>The following example ASL code shows the results of a series of Store operations:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361940"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524649"></A>Name (SRCB, Buffer () {0x10, 0x20, 0x30, 0x40})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361941"></A>    Name (BUFF, Buffer () {0x1, 0x2, 0x3, 0x4})</P>
<P CLASS="Body">
<A NAME="pgfId-1361942"></A>The following will store 0x78 into the 3rd byte of the destination buffer:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361944"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524642"></A>Store (0x12345678, Index (BUFF, 2))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524663"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1361945"></A>The following will store 0x10 into the 2nd byte of the destination buffer:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361947"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524635"></A>Store (SRCB, Index (BUFF, 1))</P>
<P CLASS="Body">
<A NAME="pgfId-1361948"></A>The following will store 0x41 (an &#8216;A&#8217;) into the 4th byte of the destination buffer:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361950"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524628"></A>Store (&#8220;ABCDEFGH&#8221;, Index (BUFF, 3))</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1361951"></A>(Compatibility Note) First introduced in ACPI 2.0. In ACPI 1.0, the behavior of storing data larger than 8-bits into a buffer using Index was undefined.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1361956"></A>I<A NAME="_Toc489267489"></A>ndex with Strings<A NAME="marker-1361955"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1361957"></A>The following example ASL code shows a way to store into the 3rd character in a string:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361958"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361959"></A>    Name (STR, &#8220;ABCDEFGHIJKL&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361960"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361961"></A>    // Store &#8216;H&#8217; (0x48) into the third character to the string</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361962"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361963"></A>    Store (&#8220;H&#8221;, Index (STR, 2))</P>
<P CLASS="Body">
<A NAME="pgfId-1361964"></A>The Index operator returns a reference to an 8-bit Buffer Field (similar to that created using CreateByteField).</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1361965"></A>(Compatibility Note) First introduced in ACPI 2.0.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361966"></A><A NAME="28093"></A><A NAME="_Toc489267437"></A><A NAME="ASL_IndexField"></A><A NAME="_Toc202342009"></A><A NAME="_Toc258262644"></A>IndexField (Declare Index/Data Fields)<A NAME="marker-1361971"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361973"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1361974"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
IndexField </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IndexName, DataName, AccessType, LockRule, UpdateRule</EM>
) {FieldUnitList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1361975"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1572464"></A>IndexName is evaluated as a Namestring and refers to a Field Unit object.</P>
<P CLASS="Body">
<A NAME="pgfId-1572465"></A>DataName is evaluated as a Namestring and refers to a Field Unit object. </P>
<P CLASS="Body">
<A NAME="pgfId-1572466"></A>AccessType, LockRule, UpdateRule, and FieldList are the same format as the Field term. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361977"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1361978"></A>Creates a series of named data objects whose data values are fields within a larger object accessed by an index/data-style reference to IndexName and DataName.</P>
<P CLASS="Body">
<A NAME="pgfId-1361979"></A>This encoding is used to define named data objects whose data values are fields within an index/data register pair. This provides a simple way to declare register variables that occur behind a typical index and data register pair. </P>
<P CLASS="Body">
<A NAME="pgfId-1361980"></A>Accessing the contents of an indexed field data object will automatically occur through the DataName object by using an IndexName object aligned on an AccessType boundary, with synchronization occurring on the operation region that contains the index data variable, and on the Global Lock if specified by LockRule.</P>
<P CLASS="Body">
<A NAME="pgfId-1361981"></A>The value written to the IndexName register is defined to be a byte offset that is aligned on an AccessType boundary. For example, if AccessType is DWordAcc, valid index values are 0, 4, 8, etc. This value is always a byte offset and is independent of the width or access type of the DataName register.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1361982"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1361983"></A>The following is a block of ASL sample code using IndexField:</P>
<P CLASS="Body">
<A NAME="pgfId-1361984"></A>Creates an index/data register in system I/O space made up of 8-bit registers.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1361985"></A>Creates a FET0 field within the indexed range.</LI>
</UL>
<P CLASS="CodeExample">
<A NAME="pgfId-1361987"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524691"></A>Method (EX1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361988"></A>    // Define a 256-byte operational region in SystemIO space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361989"></A>    // and name it GIO0 </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361990"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361991"></A>    OperationRegion (GIO0, 1, 0x125, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361992"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361993"></A>    // Create a field named Preserve structured as a sequence</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361994"></A>    // of index and data bytes </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361995"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361996"></A>    Field (GIO0, ByteAcc, NoLock, WriteAsZeros) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361997"></A>        IDX0, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361998"></A>        DAT0, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361999"></A>            .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362000"></A>            .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362001"></A>            .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362002"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362003"></A>    // Create an IndexField within IDX0 &amp; DAT0 which has</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362004"></A>    // FETs in the first two bits of indexed offset 0, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362005"></A>    // and another 2 FETs in the high bit on indexed </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362006"></A>    // 2F and the low bit of indexed offset 30</P>
<P CLASS="Body">
<A NAME="pgfId-1362007"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362008"></A>    IndexField (IDX0, DAT0, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362009"></A>        FET0, 1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362010"></A>        FET1, 1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362011"></A>        Offset (0x2f),        // skip to byte offset 2f</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362012"></A>        , 7,                  // skip another 7 bits</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362013"></A>        FET3, 1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362014"></A>        FET4, 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362015"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362016"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362017"></A>    // Clear FET3 (index 2F, bit 7)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362018"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362019"></A>    Store (Zero, FET3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362020"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362021"></A>} // End EX1</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362039"></A><A NAME="_Ref369783633"></A><A NAME="_Toc465246070"></A><A NAME="_Toc469218378"></A><A NAME="_Toc423760165"></A><A NAME="_Toc423760510"></A><A NAME="_Toc465246087"></A><A NAME="_Toc469218395"></A><A NAME="_Toc465246116"></A><A NAME="_Toc469218424"></A><A NAME="_Toc489267659"></A><A NAME="ASL_Interrupt"></A><A NAME="_Toc202342010"></A><A NAME="_Toc258262645"></A>Interrupt (Interrupt Resource Descriptor Macro)<A NAME="marker-1362037"></A><A NAME="marker-1362038"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362040"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362041"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Interrupt </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, EdgeLevel, ActiveLevel, Shared, ResourceSourceIndex, ResourceSource, DescriptorName</EM>
) <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
{</EM>
InterruptList<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
} </EM>
=&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362042"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362043"></A>ResourceUsage describes whether the device consumes the specified interrupt (ResourceConsumer) or produces it for use by a child device (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1362044"></A>EdgeLevel describes whether the interrupt is edge triggered (Edge) or level triggered (Level). The field DescriptorName. _HE is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Edge and &#8216;0&#8217; is Level.</P>
<P CLASS="Body">
<A NAME="pgfId-1362045"></A>ActiveLevel describes whether the interrupt is active-high (ActiveHigh) or active-low (ActiveLow). The field DescriptorName. _LL is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ActiveHigh and &#8216;0&#8217; is ActiveLow.</P>
<P CLASS="Body">
<A NAME="pgfId-1362046"></A>Shared describes whether the interrupt can be shared with other devices (Shared) or not (Exclusive), and whether it is capable of waking the system from a low-power idle or system sleep state (SharedAndWake or ExclusiveAndWake). The field DescriptorName. _SHR is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Shared and &#8216;0&#8217; is Exclusive. If nothing is specified, then Exclusive is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1362047"></A>ResourceSourceIndex evaluates to an integer between 0x00 and 0xFF and describes the resource source index. If it is not specified, then it is not generated. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1362048"></A>ResourceSource evaluates to a string which uniquely identifies the resource source. If it is not specified, it is not generated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1362049"></A>DescriptorName evaluates to a name string which refers to the entire resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362050"></A>InterruptList is a comma-delimited list on integers, at least one value is required. Each integer represents a 32-bit interrupt number. At least one interrupt must be defined, and there may be no duplicates in the list. The field &#8220;DescriptorName. _INT&#8221; is automatically created to refer to this portion of the resource descriptor.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362051"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362052"></A>The Interrupt macro evaluates to a buffer that contains an interrupt resource descriptor. The format of the interrupt resource descriptor can be found in <A HREF="Device_Configuration.htm#10216" CLASS="XRef">See Extended Interrupt Descriptor.</A>, Extended Interrupt Descriptor. The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362053"></A><A NAME="32564"></A>IO (IO Resource Descriptor<A NAME="marker-1362057"></A><A NAME="marker-1362058"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362060"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362061"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
IO </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Decode</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressMin</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressMax</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressAlignment</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
) =&gt; Buffer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362062"></A>Argument</H3>
<P CLASS="Body">
<A NAME="pgfId-1362063"></A>Decode describes whether the I/O range uses 10-bit decode (Decode10) or 16-bit decode (Decode16). The field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Decode16 and &#8216;0&#8217; is Decode10.</P>
<P CLASS="Body">
<A NAME="pgfId-1362064"></A>AddressMin evaluates to a 16-bit integer that specifies the minimum acceptable starting address for the I/O range. It must be an even multiple of AddressAlignment. The field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362065"></A>AddressMax evaluates to a 16-bit integer that specifies the maximum acceptable starting address for the I/O range. It must be an even multiple of AddressAlignment. The field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362066"></A>AddressAlignment evaluates to an 8-bit integer that specifies the alignment granularity for the I/O address assigned. The field DescriptorName. _ALN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362067"></A>RangeLength evaluates to an 8-bit integer that specifies the number of bytes in the I/O range. The field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362068"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362069"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1544949"></A>The IO macro evaluates to a buffer which contains an IO resource descriptor. The format of the IO descriptor can be found in &#8220;I/O Port Descriptor&#8221; (<A HREF="Device_Configuration.htm#RSVD_INT" CLASS="XRef">IRQ Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1544962"></A><A NAME="_Toc489267541"></A><A NAME="ASL_IRQ"></A><A NAME="_Toc202342012"></A><A NAME="_Toc258262647"></A>IRQ (Interrupt Resource Descriptor<A NAME="marker-1544960"></A><A NAME="marker-1544961"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1544963"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362080"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
IRQ</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
EdgeLevel, ActiveLevel, Shared, DescriptorName</EM>
) {InterruptList} =&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362081"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362082"></A>EdgeLevel describes whether the interrupt is edge triggered (Edge) or level triggered (Level). The field DescriptorName. _HE is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Edge and ActiveHigh and &#8216;0&#8217; is Level and ActiveLow.</P>
<P CLASS="Body">
<A NAME="pgfId-1362083"></A>ActiveLevel describes whether the interrupt is active-high (ActiveHigh) or active-low (ActiveLow). The field DescriptorName. _LL is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Edge and ActiveHigh and &#8216;0&#8217; is Level and ActiveLow.</P>
<P CLASS="Body">
<A NAME="pgfId-1362084"></A>Shared describes whether the interrupt can be shared with other devices (Shared) or not (Exclusive), and whether it is capable of waking the system from a low-power idle or system sleep state (SharedAndWake or ExclusiveAndWake). The field DescriptorName. _SHR is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Shared and &#8216;0&#8217; is Exclusive. If nothing is specified, then Exclusive is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1362085"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1362086"></A>InterruptList is a comma-delimited list of integers in the range 0 through 15, at least one value is required. There may be no duplicates in the list.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362087"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362088"></A>The IRQ macro evaluates to a buffer that contains an IRQ resource descriptor. The format of the IRQ descriptor can be found in &#8220;IRQ Descriptor&#8221; ((<A HREF="Device_Configuration.htm#RSVD_INT" CLASS="XRef">IRQ Descriptor</A>). The macro produces the three-byte form of the descriptor. The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362089"></A><A NAME="ASL_IRQNoFlags"></A><A NAME="_Toc202342013"></A><A NAME="_Toc258262648"></A>IRQNoFlags (Interrupt Resource Descriptor Macro) <A NAME="marker-1362093"></A><A NAME="marker-1362094"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362096"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362097"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
IRQNoFlags </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
) {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
InterruptList</EM>
} =&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362098"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362099"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. </P>
<P CLASS="Body">
<A NAME="pgfId-1362100"></A>InterruptList is a comma-delimited list of integers in the range 0 through 15, at least one value is required. There may be no duplicates in the list Description</P>
<P CLASS="Body">
<A NAME="pgfId-1444071"></A>The IRQNoFlags macro evaluates to a buffer which contains an active-high, edge-triggered IRQ resource descriptor. The format of the IRQ descriptor can be found in IRQ Descriptor (<A HREF="Device_Configuration.htm#RSVD_INT" CLASS="XRef">IRQ Descriptor</A>). The macro produces the two-byte form of the descriptor. The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362102"></A><A NAME="_Toc489267491"></A><A NAME="ASL_LAnd"></A><A NAME="_Toc202342014"></A><A NAME="_Toc258262649"></A>LAnd (Logical And)<A NAME="marker-1362107"></A></H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362109"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362110"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LAnd </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556296"></A><EM CLASS="Italic">
Source1</EM>
 &amp;&amp; <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362111"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362112"></A>Source1 and <EM CLASS="Italic">
So</EM>
urce2 are evaluated as integers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362113"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362114"></A>If both values are non-zero, True is returned: otherwise, False is returned.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362121"></A><A NAME="_Toc489267492"></A><A NAME="ASL_LEqual"></A><A NAME="_Toc202342015"></A><A NAME="_Toc258262650"></A>LEqual (Logical Equal)<A NAME="marker-1362120"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362122"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362123"></A>LEqual (Source1, Source2) =&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556311"></A><EM CLASS="Italic">
Source1</EM>
 == <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362124"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362125"></A>Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362126"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362127"></A>If the values are equal, True is returned; otherwise, False is returned. For integers, a numeric compare is performed. For strings and buffers, True is returned only if both lengths are the same and the result of a byte-wise compare indicates exact equality.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362139"></A><A NAME="_Toc489267493"></A><A NAME="ASL_LGreater"></A><A NAME="_Toc202342017"></A><A NAME="_Toc258262651"></A>LGreater (Logical Greater)<A NAME="marker-1362138"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1525633"></A><A NAME="_Toc465246118"></A><A NAME="_Toc469218426"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1525634"></A>LGreater (Source1, Source2) =&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556326"></A><EM CLASS="Italic">
Source1</EM>
 &gt; <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1525635"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362145"></A>Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362146"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362147"></A>If Source1 is greater than Source2, True is returned; otherwise, False is returned. For integers, a numeric comparison is performed. For strings and buffers, a lexicographic comparison is performed. True is returned if a byte-wise (unsigned) compare discovers at least one byte in Source1 that is numerically greater than the corresponding byte in Source2. False is returned if at least one byte in Source1 is numerically less than the corresponding byte in Source2. In the case of byte-wise equality, True is returned if the length of Source1 is greater than Source2, False is returned if the length of Source1 is less than or equal to Source2.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362158"></A><A NAME="ASL_LGreaterEqual"></A><A NAME="_Toc202342019"></A><A NAME="_Toc258262652"></A>LGreaterEqual (Logical Greater Than Or Equal<A NAME="marker-1362156"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362159"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362160"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LGreaterEqual </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1557139"></A><EM CLASS="Italic">
Source1</EM>
 &gt;= <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362161"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362162"></A>Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362163"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1544968"></A>If Source1 is greater than or equal to Source2, True is returned; otherwise, False is returned. Equivalent to LNot(LLess()). See the description of the LLess operator.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1544974"></A><A NAME="_Toc489267495"></A><A NAME="ASL_LLess"></A><A NAME="_Toc202342020"></A><A NAME="_Toc258262653"></A>LLess (Logical Less)<A NAME="marker-1544973"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1544975"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362176"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LLess </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556341"></A><EM CLASS="Italic">
Source1</EM>
 &lt; <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362177"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362178"></A>Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362179"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362180"></A>If Source1 is less than Source2, True is returned; otherwise, False is returned. For integers, a numeric comparison is performed. For strings and buffers, a lexicographic comparison is performed. True is returned if a byte-wise (unsigned) compare discovers at least one byte in Source1 that is numerically less than the corresponding byte in Source2. False is returned if at least one byte in Source1 is numerically greater than the corresponding byte in Source2. In the case of byte-wise equality, True is returned if the length of Source1 is less than Source2, False is returned if the length of Source1 is greater than or equal to Source2.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362190"></A><A NAME="_Toc489267496"></A><A NAME="ASL_LLessEqual"></A><A NAME="_Toc202342021"></A><A NAME="_Toc258262654"></A>LLessEqual (Logical Less Than Or Equal)<A NAME="marker-1362189"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362191"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362192"></A>LLessEqual (Source1, Source2) =&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556356"></A><EM CLASS="Italic">
Source1</EM>
 &lt;= <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362193"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362194"></A>Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362195"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362196"></A>If Source1 is less than or equal to Source2, True is returned; otherwise False is returned. Equivalent to LNot(LGreater()). See the description of the LGreater operator.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362208"></A><A NAME="_Toc489267497"></A><A NAME="ASL_LNot"></A><A NAME="_Toc202342023"></A><A NAME="_Toc258262655"></A>LNot (Logical Not)<A NAME="marker-1362207"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362211"></A><A NAME="_Toc465246122"></A><A NAME="_Toc469218430"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362212"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LNot </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556371"></A>!<EM CLASS="Italic">
Source</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362213"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362214"></A>Source is evaluated as an integer. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362215"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362216"></A>If the value is zero True is returned; otherwise, False is returned.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362217"></A><A NAME="_Toc489267498"></A><A NAME="ASL_LNotEqual"></A><A NAME="_Toc202342024"></A><A NAME="_Toc258262656"></A>LNotEqual (Logical Not Equal) )<A NAME="marker-1362222"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362224"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362225"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LNotEqual </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556420"></A><EM CLASS="Italic">
Source1</EM>
 != <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362226"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362227"></A>Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362228"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362229"></A>If Source1 is not equal to Source2, True is returned; otherwise False is returned. Equivalent to LNot(LEqual()).See the description of the LEqual operator.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362230"></A><A NAME="_Toc489267456"></A><A NAME="ASL_Load"></A><A NAME="_Toc202342025"></A><A NAME="_Toc258262657"></A>Load (Load Definition Block)<A NAME="marker-1362235"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362237"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362238"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Load </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Object, DDBHandle</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362239"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1572623"></A>The Object parameter can refer to one of the following object types:</P>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1572624"></A>An operation region field</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1572625"></A>An operation region directly</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1362240"></A>An ASL Buffer object</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1572619"></A>If the object is an operation region, the operation region must be in SystemMemory space. The Definition Block should contain an ACPI DESCRIPTION_HEADER of type SSDT. </P>
<P CLASS="Body">
<A NAME="pgfId-1572616"></A>The Definition Block must be totally contained within the supplied operation region, operation region field, or Buffer object. OSPM reads this table into memory, the checksum is verified, and then it is loaded into the ACPI namespace.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362243"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362244"></A>Performs a run-time load of a Definition Block. Any table loaded via an operation region must be in memory marked as AddressRangeReserved or AddressRangeNVS. The OS can also check the OEM Table ID and Revision ID against a database for a newer revision Definition Block of the same OEM Table ID and load it instead. </P>
<P CLASS="Body">
<A NAME="pgfId-1362246"></A>The default namespace location to load the Definition Block is relative to the root of the namespace. The new Definition Block can override this by specifying absolute names or by adjusting the namespace location using the Scope operator.</P>
<P CLASS="Body">
<A NAME="pgfId-1544980"></A>Loading a Definition Block is a synchronous operation. Upon completion of the operation, the Definition Block has been loaded. The control methods defined in the Definition Block are not executed during load time.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1544989"></A><A NAME="_Toc489267499"></A><A NAME="ASL_LoadTable"></A><A NAME="_Toc202342026"></A><A NAME="_Toc258262658"></A>LoadTable (Load Definition Block From XSDT)<A NAME="marker-1544985"></A><A NAME="marker-1544986"></A><A NAME="marker-1544987"></A><A NAME="marker-1544988"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1544995"></A><A NAME="_Toc465246123"></A><A NAME="_Toc469218431"></A><A NAME="_Ref369783868"></A><A NAME="_Toc465246158"></A><A NAME="_Toc469218466"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362264"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LoadTable </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SignatureString, OEMIDString, OEMTableIDString, RootPathString, ParameterPathString, ParameterData</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; DDBHandle</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362265"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362266"></A>The XSDT is searched for a table where the Signature field matches SignatureString, the OEM ID field matches OEMIDString, and the OEM Table ID matches OEMTableIDString. All comparisons are case sensitive. If the SignatureString is greater than four characters, the OEMIDString is greater than six characters, or the OEMTableID is greater than eight characters, a run-time error is generated. The OS can also check the OEM Table ID and Revision ID against a database for a newer revision Definition Block of the same OEM Table ID and load it instead. </P>
<P CLASS="Body">
<A NAME="pgfId-1362267"></A>The RootPathString specifies the root of the Definition Block. It is evaluated using normal scoping rules, assuming that the scope of the LoadTable instruction is the current scope. The new Definition Block can override this by specifying absolute names or by adjusting the namespace location using the Scope operator. If RootPathString is not specified, &#8220;&#92;&#8221; is assumed</P>
<P CLASS="Body">
<A NAME="pgfId-1362268"></A>If ParameterPathString and ParameterData are specified, the data object specified by ParameterData is stored into the object specified by ParameterPathString after the table has been added into the namespace. If the first character of ParameterPathString is a backslash (&#8216;&#92;&#8217;) or caret (&#8216;^&#8217;) character, then the path of the object is ParameterPathString. Otherwise, it is RootPathString.ParameterPathString. If the specified object does not exist, a run-time error is generated.</P>
<P CLASS="Body">
<A NAME="pgfId-1362269"></A>The handle of the loaded table is returned. If no table matches the specified signature, then 0 is returned.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362270"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362271"></A>Performs a run-time load of a Definition Block from the XSDT. Any table referenced by LoadTable must be in memory marked by AddressRangeReserved or AddressRangeNVS.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1381770"></A>OSPM loads the DSDT and all SSDTs during initialization. As such, Definition Blocks to be conditionally loaded via LoadTable must contain signatures other than &#8220;SSDT&#8221;.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1362272"></A>Loading a Definition Block is a synchronous operation. Upon completion of the operation, the Definition Block has been loaded. The control methods defined in the Definition Block are not executed during load time.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362273"></A>Example</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1362274"></A>    Store (LoadTable (&#8220;OEM1&#8221;, &#8221;MYOEM&#8221;, &#8221;TABLE1&#8221;, &#8221;&#92;&#92;_SB.PCI0&#8221;,&#8221;MYD&#8221;,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362275"></A>                         Package () {0,&#8221;&#92;&#92;_SB.PCI0&#8221;}), Local0)</P>
<P CLASS="Body">
<A NAME="pgfId-1362276"></A>This operation would search through the RSDT or XSDT for a table with the signature &#8220;OEM1,&#8221; the OEM ID of &#8220;MYOEM,&#8221; and the table ID of &#8220;TABLE1.&#8221; If not found, it would store Zero in Local0. Otherwise, it will store a package containing 0 and &#8220;&#92;&#92;_SB.PCI0&#8221; into the variable at &#92;_SB.PCI0.MYD.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362283"></A><A NAME="_Toc489267539"></A><A NAME="ASL_Localx"></A><A NAME="_Toc202342027"></A><A NAME="_Toc258262659"></A>Localx (Method Local Data Objects<A NAME="marker-1362282"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362284"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362285"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local0</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local1</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local2</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local3</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local4 </EM>
| <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local5</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local6</EM>
 | <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Local7</EM>
</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362286"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362287"></A>Up to 8 local objects can be referenced in a control method. On entry to a control method, these objects are uninitialized and cannot be used until some value or reference is stored into the object. Once initialized, these objects are preserved in the scope of execution for that control method. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362294"></A><A NAME="_Toc489267500"></A><A NAME="ASL_LOr"></A><A NAME="_Toc202342028"></A><A NAME="_Toc258262660"></A>LOr (Logical Or)<A NAME="marker-1362293"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362295"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362296"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
LOr </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<P CLASS="Body">
<A NAME="pgfId-1556435"></A><EM CLASS="Italic">
Source1</EM>
 || <EM CLASS="Italic">
Source2</EM>
 =&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362297"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362298"></A>Source1 and Source2 are evaluated as integers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362299"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362300"></A>If either value is non-zero, True is returned; otherwise, False is returned.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362304"></A><A NAME="_Toc489267501"></A><A NAME="ASL_Match"></A><A NAME="_Toc202342029"></A><A NAME="_Toc258262661"></A>Match (Find Object Match)<A NAME="marker-1362309"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362311"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362312"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Match </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SearchPackage, Op1, MatchObject1, Op2, MatchObject2, StartIndex</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; <EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Ones</EM>
 | Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362313"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362314"></A>SearchPackage is evaluated to a package object and is treated as a one-dimension array. Each package element must evaluate to either an integer, a string, or a buffer. Uninitialized package elements and elements that do not evaluate to integers, strings, or buffers are ignored. Op1 and Op2 are match operators. MatchObject1 and MatchObject2 are the objects to be matched and must each evaluate to either an integer, a string, or a buffer. StartIndex is the starting index within the SearchPackage.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362315"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362316"></A>A comparison is performed for each element of the package, starting with the index value indicated by StartIndex (0 is the first element). If the element of SearchPackage being compared against is called P[i], then the comparison is:</P>
<P CLASS="Body">
<A NAME="pgfId-1362317"></A>If (P[i] Op1 MatchObject1) and (P[i] Op2 MatchObject2) then Match =&gt; i is returned.</P>
<P CLASS="Body">
<A NAME="pgfId-1362318"></A>If the comparison succeeds, the index of the element that succeeded is returned; otherwise, the constant object Ones is returned. The data type of the MatchObject dictates the required type of the package element. If necessary, the package element is implicitly converted to match the type of the MatchObject. If the implicit conversion fails for any reason, the package element is ignored (no match.)</P>
<P CLASS="Body">
<A NAME="pgfId-1362319"></A>Op1 and Op2 have the values and meanings listed in the following table.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362320"></A>Match Term Operator Meanings</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1494993"></A>Operator</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1494995"></A>Encoding</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1494997"></A>Macro</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362329"></A>TRUE - A don&#8217;t care, always returns TRUE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362331"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362333"></A>MTR</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362335"></A>EQ - Returns TRUE if P[i] == MatchObject</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362337"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362339"></A>MEQ</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362341"></A>LE - Returns TRUE if P[i] &lt;= MatchObject</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362343"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362345"></A>MLE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362347"></A>LT - Returns TRUE if P[i] &lt; MatchObject</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362349"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362351"></A>MLT</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362353"></A>GE - Returns TRUE if P[i] &gt;= MatchObject</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362355"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362357"></A>MGE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362359"></A>GT - Returns TRUE if P[i] &gt; MatchObject</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362361"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362363"></A>MGT</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362366"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1362367"></A>Following are some example uses of Match:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362369"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524705"></A>Name (P1, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362370"></A>    Package () {1981, 1983, 1985, 1987, 1989, 1990, 1991, 1993, 1995, 1997, 1999, 2001}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362371"></A>)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362372"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362373"></A>// match 1993 == P1[i]</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362374"></A>Match (P1, MEQ, 1993, MTR, 0, 0)        // -&gt; 7, since P1[7] == 1993</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362375"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362376"></A>// match 1984 == P1[i]</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362377"></A>Match (P1, MEQ, 1984, MTR, 0, 0)        // -&gt; ONES (not found)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362378"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362379"></A>// match P1[i] &gt; 1984 and P1[i] &lt;= 2000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362380"></A>Match (P1, MGT, 1984, MLE, 2000, 0)     // -&gt; 2, since P1[2]&gt;1984 and P1[2]&lt;=2000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362381"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362382"></A>// match P1[i] &gt; 1984 and P1[i] &lt;= 2000, starting with 3rd element</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362383"></A>Match (P1, MGT, 1984, MLE, 2000, 3)     // -&gt; 3, first match at or past Start</P>
<P CLASS="Body">
<A NAME="pgfId-1544869"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362392"></A><A NAME="_Toc489267652"></A><A NAME="ASL_Memory24"></A><A NAME="_Toc202342030"></A><A NAME="_Toc258262662"></A>Memory24 (Memory Resource Descriptor Macro)<A NAME="marker-1362390"></A><A NAME="marker-1362391"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362393"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362394"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Memory24 </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ReadAndWrite</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressMinimum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressAlignment</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362395"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362396"></A>ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ReadWrite and &#8216;0&#8217; is ReadOnly.</P>
<P CLASS="Body">
<A NAME="pgfId-1362397"></A>AddressMinimum evaluates to a 16-bit integer that specifies bits [8:23] of the lowest possible base address of the memory range. All other bits are assumed to be zero. The value must be an even multiple of AddressAlignment. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362398"></A>AddressMaximum evaluates to a 16-bit integer that specifies bits [8:23] of the highest possible base address of the memory range. All other bits are assumed to be zero. The value must be an even multiple of AddressAlignment. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362399"></A>AddressAlignment evaluates to a 16-bit integer that specifies bits [0:15] of the required alignment for the memory range. All other bits are assumed to be zero. The address selected must be an even multiple of this value. The 16-bit field DescriptorName. _ALN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362400"></A>RangeLength evaluates to a 16-bit integer that specifies the total number of bytes decoded in the memory range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor. The range length provides the length of the memory range in 256 byte blocks.</P>
<P CLASS="Body">
<A NAME="pgfId-1362401"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362402"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362403"></A>The Memory24 macro evaluates to a buffer which contains an 24-bit memory descriptor. The format of the 24-bit memory descriptor can be found in &#8220;24-Bit Memory Range Descriptor &#8221; (<A HREF="Device_Configuration.htm#AML_Memory24" CLASS="XRef">24-Bit Memory Range Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1362404"></A>The use of Memory24 is deprecated and should not be used in new designs.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362413"></A><A NAME="ASL_Memory32"></A><A NAME="_Toc202342031"></A><A NAME="_Toc258262663"></A>Memory32 (Memory Resource Descriptor Macro) <A NAME="marker-1362411"></A><A NAME="marker-1362412"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362414"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362415"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Memory32 </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ReadAndWrite</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressMinimum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressAlignment</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362416"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362417"></A>ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ReadWrite and &#8216;0&#8217; is ReadOnly.</P>
<P CLASS="Body">
<A NAME="pgfId-1362418"></A>AddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the memory range. The value must be an even multiple of AddressAlignment. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362419"></A>AddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the memory range. The value must be an even multiple of AddressAlignment. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362420"></A>AddressAlignment evaluates to a 32-bit integer that specifies the required alignment for the memory range. The address selected must be an even multiple of this value. The 32-bit field DescriptorName. _ALN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362421"></A>RangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the memory range. The 32-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor. The range length provides the length of the memory range in 1 byte blocks.</P>
<P CLASS="Body">
<A NAME="pgfId-1362422"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362423"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362424"></A>The Memory32 macro evaluates to a buffer which contains a 32-bit memory descriptor, which describes a memory range with a minimum, a maximum and an alignment. The format of the 32-bit memory descriptor can be found in &#8220;32-Bit Memory Range Descriptor &#8221; (<A HREF="Device_Configuration.htm#AML_Memory32" CLASS="XRef">32-Bit Memory Range Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362432"></A><A NAME="ASL_Memory32Fixed"></A><A NAME="_Toc202342032"></A><A NAME="_Toc258262664"></A>Memory32Fixed (Memory Resource Descriptor Macro)<A NAME="marker-1362429"></A><A NAME="marker-1362430"></A><A NAME="marker-1362431"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362433"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362434"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Memory32Fixed </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ReadAndWrite</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressBase</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362435"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362436"></A>ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ReadWrite and &#8216;0&#8217; is ReadOnly.</P>
<P CLASS="Body">
<A NAME="pgfId-1362437"></A>AddressBase evaluates to a 32-bit integer that specifies the base address of the memory range. The 32-bit field DescriptorName. _BAS is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362438"></A>RangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the memory range. The 32-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362439"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362440"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362441"></A>The Memory32Fixed macro evaluates to a buffer which contains a 32-bit memory descriptor, which describes a fixed range of memory addresses. The format of the fixed 32-bit memory descriptor can be found in 32-Bit Fixed Memory Range Descriptor (<A HREF="Device_Configuration.htm#AML_Memory32Fixed" CLASS="XRef">32-Bit Fixed Memory Range Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362448"></A><A NAME="_Toc489267438"></A><A NAME="ASL_Method"></A><A NAME="_Toc202342033"></A><A NAME="_Toc258262665"></A>Method (Declare Control Method)<A NAME="marker-1362447"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362449"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362450"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Method </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
MethodName, NumArgs, SerializeRule, SyncLevel, ReturnType, ParameterTypes</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362451"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362452"></A>MethodName is evaluated as a Namestring data type.</P>
<P CLASS="Body">
<A NAME="pgfId-1362453"></A>NumArgs is optional and is the required number of arguments to be passed to the method, evaluated as an Integer data type. If not specified, the default value is zero arguments. Up to 7 arguments may be passed to a method. These arguments may be referenced from within the method as Arg0 through Arg6.</P>
<P CLASS="Body">
<A NAME="pgfId-1362454"></A>SerializeRule is optional and is a flag that defines whether the method is serialized or not and is one of the following: Serialized or NotSerialized. A method that is serialized cannot be reentered by additional threads. If not specified, the default is NotSerialized.</P>
<P CLASS="Body">
<A NAME="pgfId-1362455"></A>SyncLevel is optional and specifies the synchronization level for the method (0 - 15). If not specified, the default sync level is zero.</P>
<P CLASS="Body">
<A NAME="pgfId-1362456"></A>ReturnType is optional and specifies the type(s) of the object(s) returned by the method. If the method does not return an object, then nothing is specified or UnknownObj is specified. To specify a single return type, simply use the ObjectTypeKeyword (e.g. IntObj, PkgObj, etc.). To specify multiple possible return types, enclose the comma-separated ObjectTypeKeywords with braces. For example: {IntObj, BuffObj}.</P>
<P CLASS="Body">
<A NAME="pgfId-1362457"></A>ParameterTypes is optional and specifies the type of the method parameters. It is a comma-separated, variable-length list of the expected object type or types for each of the method parameters, enclosed in braces. For each parameter, the parameter type consists of either an ObjectTypeKeyword or a comma-separated sub-list of ObjectTypeKeywords enclosed in braces. If ParameterTypes is specified, the number of parameters must match NumArgs.</P>
<P CLASS="Body">
<A NAME="pgfId-1362458"></A>TermList is a variable-length list of executable ASL statements representing the body of the control method.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362459"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362460"></A>Creates a new control method of name MethodName. This is a named package containing a series of object references that collectively represent a control method, which is a procedure that can be invoked to perform computation. Method opens a name scope.</P>
<P CLASS="Body">
<A NAME="pgfId-1362461"></A>System software executes a control method by referencing the objects in the package in order. For more information on method execution, see <A HREF="ACPI_Software_Programming_Model.htm#75986" CLASS="XRef">See Control Method Execution.</A>, &#8220;Control Method Execution.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1362462"></A>The current namespace location used during name creation is adjusted to be the current location on the namespace tree. Any names created within this scope are &#8220;below&#8221; the name of this package. The current namespace location is assigned to the method package, and all namespace references that occur during control method execution for this package are relative to that location.</P>
<P CLASS="Body">
<A NAME="pgfId-1362463"></A>If a method is declared as Serialized, an implicit mutex associated with the method object is acquired at the specified SyncLevel. If no SyncLevel is specified, SyncLevel 0 is assumed. The serialize rule can be used to prevent reentering of a method. This is especially useful if the method creates namespace objects. Without the serialize rule, the reentering of a method will fail when it attempts to create the same namespace object.</P>
<P CLASS="Body">
<A NAME="pgfId-1362464"></A>There are eight local variables automatically available for each method, referenced as Local0 through Local7. These locals may be used to store any type of ASL object.</P>
<P CLASS="Body">
<A NAME="pgfId-1362465"></A>Also notice that all namespace objects created by a method have temporary lifetime. When method execution exits, the created objects will be destroyed.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362466"></A>Examples</H3>
<P CLASS="Body">
<A NAME="pgfId-1362468"></A><A NAME="marker-1362467"></A>The following block of ASL sample code shows a use of Method for defining a control method that turns on a power resource. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362470"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524719"></A>Method (_ON) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362471"></A>    Store (One, GIO.IDEP)          // assert power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362472"></A>    Sleep (10)                     // wait 10ms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362473"></A>    Store (One, GIO.IDER)          // de-assert reset#</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362474"></A>    Stall (10)                     // wait 10us</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362475"></A>    Store (Zero, GIO.IDEI)         // de-assert isolation</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362476"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1362477"></A>This method is an implementation of _SRS (Set Resources). It shows the use of a method argument and two method locals. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524733"></A>Method (_SRS, 1, NotSerialized) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362480"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362481"></A>    CreateWordField (Arg0, One, IRQW) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362482"></A>    Store (&#92;_SB.PCI0.PID1.IENA, Local1) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362483"></A>    Or (IRQW, Local1, Local1) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362484"></A>    Store (Local1, &#92;_SB.PCI0.PID1.IENA)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362485"></A>    FindSetRightBit (IRQW, Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362486"></A>    If (Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362487"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362488"></A>        Decrement (Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362489"></A>        Store (Local0, &#92;_SB.PCI0.PID1.IN01)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381801"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381802"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524740"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362498"></A><A NAME="_Toc489267502"></A><A NAME="ASL_Mid"></A><A NAME="_Toc202342035"></A><A NAME="_Toc258262666"></A>Mid (Extract Portion of Buffer or String<A NAME="marker-1362503"></A>) </H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362505"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362506"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Mid </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Index,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Length,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
) </EM>
=&gt; Buffer or String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362507"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362508"></A>Source is evaluated as either a Buffer or String. Index and Length are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362509"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362510"></A>If Source is a buffer, then Length bytes, starting with the Indexth byte (zero-based) are optionally copied into Result. If Index is greater than or equal to the length of the buffer, then the result is an empty buffer. Otherwise, if Index + Length is greater than or equal to the length of the buffer, then only bytes up to and including the last byte are included in the result. </P>
<P CLASS="Body">
<A NAME="pgfId-1362511"></A>If Source is a string, then Length characters, starting with the Indexth character (zero-based) are optionally copied into Result. If Index is greater than or equal to the length of the buffer, then the result is an empty string. Otherwise, if Index + Length is greater than or equal to the length of the string, then only bytes up to an including the last character are included in the result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362518"></A><A NAME="_Toc489267503"></A><A NAME="ASL_Mod"></A><A NAME="_Toc202342036"></A><A NAME="_Toc258262667"></A>Mod (Integer Modulo)<A NAME="marker-1362517"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362521"></A><A NAME="_Toc465246125"></A><A NAME="_Toc469218433"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362522"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Mod </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Dividend, Divisor, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556454"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Dividend</EM>
 % <EM CLASS="Italic">
Divisor</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556455"></A><EM CLASS="Italic">
Result</EM>
 %= <EM CLASS="Italic">
Divisor</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362523"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362524"></A>Dividend and Divisor are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362525"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362526"></A>The Dividend is divided by Divisor, and then the resulting remainder is optionally stored into Result. If Divisor evaluates to zero, a fatal exception is generated.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362533"></A><A NAME="_Toc489267504"></A><A NAME="ASL_Multiply"></A><A NAME="_Toc202342037"></A><A NAME="_Toc258262668"></A>Multiply (Integer Multiply)<A NAME="marker-1362532"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362534"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362535"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Multiply </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Multiplicand, Multiplier, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556473"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Multiplicand</EM>
 * <EM CLASS="Italic">
Multiplier</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556474"></A><EM CLASS="Italic">
Result</EM>
 *= <EM CLASS="Italic">
Multiplier</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362536"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362537"></A>Multiplicand and Multiplier are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362538"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362539"></A>The Multiplicand is multiplied by Multiplier and the result is optionally stored into Result. Overflow conditions are ignored and results are undefined.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362546"></A><A NAME="_Toc489267439"></A><A NAME="ASL_Mutex"></A><A NAME="_Toc202342038"></A><A NAME="_Toc258262669"></A>Mutex (Declare Synchronization/Mutex Object)<A NAME="marker-1362545"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362547"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362548"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Mutex </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
MutexName, SyncLevel</EM>
)</P>
<P CLASS="Body">
<A NAME="pgfId-1572494"></A>Arguments</P>
<P CLASS="Body">
<A NAME="pgfId-1572495"></A>The MutexName is evaluated as a Namestring data type.</P>
<P CLASS="Body">
<A NAME="pgfId-1572496"></A>The SyncLevel is optional and specifies the logical nesting level of the Mutex synchronization object. The current sync level is maintained internally for a thread, and represents the greatest SyncLevel among mutex objects that are currently acquired by the thread. The SyncLevel of a thread, before acquiring any mutexes, is zero. The SyncLevel of the Global Lock (&#92;_GL) is zero. If not specified, the default sync level value is zero.</P>
<P CLASS="Body">
<A NAME="pgfId-1572497"></A>Description</P>
<P CLASS="Body">
<A NAME="pgfId-1572498"></A>Creates a data mutex synchronization object named MutexName, with a synchronization level from 0 to 15 as specified by the Integer SyncLevel.</P>
<P CLASS="Body">
<A NAME="pgfId-1362552"></A>A mutex synchronization object provides a control method with a mechanism for waiting for certain events. To prevent deadlocks, wherever more than one synchronization object must be owned, the synchronization objects must always be released in the order opposite the order in which they were acquired. </P>
<P CLASS="Body">
<A NAME="pgfId-1362553"></A>The SyncLevel parameter declares the logical nesting level of the synchronization object. The current sync level is maintained internally for a thread, and represents the greatest SyncLevel among mutex objects that are currently acquired by the thread. The SyncLevel of a thread before acquiring any mutexes is zero. The SyncLevel of the Global Lock (&#92;_GL) is zero.</P>
<P CLASS="Body">
<A NAME="pgfId-1362554"></A>All Acquire terms must refer to a synchronization object with a SyncLevel that is equal or greater than the current level, and all Release terms must refer to a synchronization object with a SyncLevel that is equal to the current level.<A NAME="marker-1362555"></A><A NAME="marker-1362556"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1362557"></A>Mutex synchronization provides the means for mutually exclusive ownership. Ownership is acquired using an Acquire term and is released using a Release term. Ownership of a Mutex must be relinquished before completion of any invocation. For example, the top-level control method cannot exit while still holding ownership of a Mutex. Acquiring ownership of a Mutex can be nested (can be acquired multiple times by the same thread). </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362569"></A><A NAME="_Toc489267446"></A><A NAME="ASL_Name"></A><A NAME="_Toc202342039"></A><A NAME="_Toc258262670"></A>Name (Declare Named Object)<A NAME="marker-1562474"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362570"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362571"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Name</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ObjectName, Object</EM>
)</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362572"></A>Arguments</H3>
<P CLASS="Body">
<A NAME="pgfId-1562668"></A><EM CLASS="SC-24-208901">
Creates a new object named ObjectName. Attaches Object to ObjectName in the Global ACPI namespace. </EM>
</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362574"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362575"></A>Creates ObjectName in the namespace, which references the Object. </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362576"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1362577"></A>The following example creates the name PTTX in the root of the namespace that references a package.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362579"></A>Name (&#92;PTTX,                    // Port to Port Translate Table</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362580"></A>    Package () {Package () {0x43, 0x59}, Package) {0x90, 0xFF}}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362581"></A>)</P>
<P CLASS="Body">
<A NAME="pgfId-1362582"></A>The following example creates the name CNT in the root of the namespace that references an integer data object with the value 5.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362584"></A>Name (&#92;CNT, 5)</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362596"></A><A NAME="_Toc465246088"></A><A NAME="_Toc469218396"></A><A NAME="_Toc465246126"></A><A NAME="_Toc469218434"></A><A NAME="_Toc489267505"></A><A NAME="ASL_NAnd"></A><A NAME="_Toc202342040"></A><A NAME="_Toc258262671"></A>NAnd (Integer Bitwise Nand)<A NAME="marker-1563279"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362597"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362598"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
NAnd </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source2</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
) =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362599"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362600"></A>Source1 and Source2 are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362601"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362602"></A>A bitwise NAND is performed and the result is optionally stored in Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362603"></A><A NAME="_Toc489267457"></A><A NAME="ASL_Noop"></A><A NAME="_Toc202342041"></A><A NAME="_Toc258262672"></A>NoOp Code (No Operation)<A NAME="marker-1362608"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362610"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362611"></A>NoOp</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362612"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362613"></A>This operation has no effect.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362626"></A><A NAME="_Toc489267506"></A><A NAME="ASL_NOr"></A><A NAME="_Toc202342042"></A><A NAME="_Toc258262673"></A>NOr (Integer Bitwise Nor)<A NAME="marker-1362625"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362627"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362628"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
NOr </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1, Source2, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362629"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362630"></A>Source1 and Source2 are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362631"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362632"></A>A bitwise NOR is performed and the result is optionally stored in Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362642"></A><A NAME="_Toc489267507"></A><A NAME="ASL_Not"></A><A NAME="_Toc202342043"></A><A NAME="_Toc258262674"></A>Not (Integer Bitwise Not)<A NAME="marker-1362641"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362643"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362644"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Not </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556505"></A><EM CLASS="Italic">
Result</EM>
 = &#126;<EM CLASS="Italic">
Source</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362645"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362646"></A>Source is evaluated as an integer data type.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362647"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362648"></A>A bitwise NOT is performed and the result is optionally stored in Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362655"></A><A NAME="_Toc489267458"></A><A NAME="ASL_Notify"></A><A NAME="_Toc202342044"></A><A NAME="_Toc258262675"></A>Notify (Notify Object of Event)<A NAME="marker-1362654"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362656"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362657"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Notify </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Object, NotificationValue</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362658"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362659"></A>Notifies the OS that the NotificationValue for the Object has occurred. Object must be a reference to a device, processor, or thermal zone object. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362660"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362661"></A>Object type determines the notification values. For example, the notification values for a thermal zone object are different from the notification values used for a device object. Undefined notification values are treated as reserved and are ignored by the OS.</P>
<P CLASS="Body">
<A NAME="pgfId-1362662"></A>For lists of defined Notification values, see <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256030" CLASS="XRef">See Device Object Notifications.</A>, &#8220;Device Object Notifications.&#8221;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1537625"></A><A NAME="19034"></A>Offset (Change Current Field Unit Offset)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1537686"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1537627"></A>Offset (ByteOffset)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1537674"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1537629"></A>ByteOffset is the new offset (in bytes) for the next FieldUnit within a FieldList.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1537719"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1537666"></A>The Offset operator is used within a FieldList to specify the byteOffset of the next defined field within its parent operation region. This can be used instead of defining the bit lengths that need to be skipped. All offsets are defined starting from zero, based at the starting address of the parent region.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362666"></A><A NAME="_Toc489267508"></A><A NAME="ASL_ObjectType"></A><A NAME="_Toc202342045"></A><A NAME="_Toc258262676"></A>ObjectType (Get Object Type)<A NAME="marker-1362671"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1537698"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362676"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ObjectType </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Object</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362677"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362678"></A>Object is any valid object.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362679"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362680"></A>The execution result of this operation is an integer that has the numeric value of the object type for Object. </P>
<P CLASS="Body">
<A NAME="pgfId-1362681"></A>The object type codes are listed in Table 18-20. Notice that if this operation is performed on an object reference such as one produced by the Alias, Index, or RefOf statements, the object type of the base object is returned. For typeless objects such as predefined scope names (in other words, &#92;_SB, &#92;_GPE, etc.), the type value 0 (Uninitialized) is returned.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362682"></A>TValues Returned By the ObjectType Operator</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1362685"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1362687"></A>Object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362689"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362691"></A>Uninitialized</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362693"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362695"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362697"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362699"></A>String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362701"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362703"></A>Buffer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362705"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362707"></A>Package</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362709"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362711"></A>Field Unit</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362713"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362715"></A>Device</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362717"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362719"></A>Event</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362721"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362723"></A>Method</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362725"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362727"></A>Mutex</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362729"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362731"></A>Operation Region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362733"></A>11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362735"></A>Power Resource</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362737"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362739"></A>Processor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362741"></A>13</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362743"></A>Thermal Zone</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362745"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362747"></A>Buffer Field</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362749"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362751"></A>DDB Handle</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362753"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362755"></A>Debug Object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362757"></A>&gt;16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362759"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362763"></A><A NAME="_Toc489267529"></A><A NAME="ASL_One"></A><A NAME="_Toc202342046"></A><A NAME="_Toc258262677"></A>One (Constant One Integer<A NAME="marker-1362767"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362772"></A><A NAME="_Toc465246150"></A><A NAME="_Toc469218458"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1526246"></A>One=&gt; Integer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1526377"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1526378"></A>The One operator returns an Integer with the value 1. Writes to this object are not allowed. The use of this operator can reduce AML code size, since it is represented by a one-byte AML opcode.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1526384"></A><A NAME="_Toc489267530"></A><A NAME="ASL_Ones"></A><A NAME="_Toc202342047"></A><A NAME="_Toc258262678"></A>Ones (Constant Ones Integer)<A NAME="marker-1526383"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362783"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1526405"></A>Ones=&gt; Integer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1526332"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1526333"></A>The Ones operator returns an Integer with all bits set to 1. Writes to this object are not allowed. The use of this operator can reduce AML code size, since it is represented by a one-byte AML opcode.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1526320"></A>The actual value of the integer returned by the Ones operator depends on the integer width of the DSDT. If the revision of the DSDT is 1 or less, the integer width is 32 bits and Ones returns 0xFFFFFFFF. If the revision of the DSDT is 2 or greater, the integer width is 64 bits and Ones returns 0xFFFFFFFFFFFFFFFF. This difference must be considered when performing comparisons against the Ones Integer.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362793"></A><A NAME="_Toc489267440"></A><A NAME="ASL_OperationRegion"></A><A NAME="_Toc202342048"></A><A NAME="_Toc258262679"></A>OperationRegion (Declare Operation Region)<A NAME="marker-1362792"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362794"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362795"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
OperationRegion</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RegionName, RegionSpace, Offset, Length</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362796"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362797"></A>Declares an operation region named RegionName. Offset is the offset within the selected RegionSpace at which the region starts (byte-granular), and Length is the length of the region in bytes.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362798"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362799"></A>An Operation Region is a type of data object where read or write operations to the data object are performed in some hardware space. For example, the Definition Block can define an Operation Region within a bus, or system I/O space. Any reads or writes to the named object will result in accesses to the I/O space.</P>
<P CLASS="Body">
<A NAME="pgfId-1362800"></A>Operation regions are regions in some space that contain hardware registers for exclusive use by ACPI control methods. In general, no hardware register (at least byte-granular) within the operation region accessed by an ACPI control method can be shared with any accesses from any other source, with the exception of using the Global Lock to share a region with the firmware. The entire Operation Region can be allocated for exclusive use to the ACPI subsystem in the host OS.</P>
<P CLASS="Body">
<A NAME="pgfId-1362801"></A>Operation Regions that are defined within the scope of a method are the exception to this rule. These Operation Regions are known as &#8220;Dynamic&#8221; since the OS has no idea that they exist or what registers they use until the control method is executed. Using a Dynamic SystemIO or SystemMemory Operation Region is not recommended since the OS cannot guarantee exclusive access. All other types of Operation Regions may be Dynamic.<A NAME="marker-1362802"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1362803"></A>Operation Regions define the overall base address and length of a hardware region, but they cannot be accessed directly by AML code. A Field object containing one or more FieldUnits is used to overlay the Operation Region in order to access individual areas of the Region. An individual FieldUnit within an Operation Region may be as small as one bit, or as large as the length of the entire Region. FieldUnit values are normalized (shifted and masked to the proper length.) The data type of a FieldUnit can be either a Buffer or an Integer, depending on the bit length of the FieldUnit. If the FieldUnit is smaller than or equal to the size of an Integer (in bits), it will be treated as an Integer. If the FieldUnit is larger than the size of an Integer, it will be treated as a Buffer. The size of an Integer is indicated by the DSDT header&#8217;s Revision field. A revision less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. For more information about data types and FieldUnit type conversion rules, see <A HREF="ACPI_Source_Language_Reference.htm#85702" CLASS="XRef">See Data Type Conversion Rules.</A>, &#8220;Data Type Conversion Rules&#8221;.</P>
<P CLASS="Body">
<A NAME="pgfId-1362804"></A>An Operation Region object implicitly supports Mutex synchronization. Updates to the object, or a Field data object for the region, will automatically synchronize on the Operation Region object; however, a control method may also explicitly synchronize to a region to prevent other accesses to the region (from other control methods). Notice that according to the control method execution model, control method execution is non-preemptive. Because of this, explicit synchronization to an Operation Region needs to be done only in cases where a control method blocks or yields execution and where the type of register usage requires such synchronization.</P>
<P CLASS="Body">
<A NAME="pgfId-1369592"></A>The predefined Operation Region types specified in ACPI are shown in the <A HREF="ACPI_Software_Programming_Model.htm#46346" CLASS="XRef">Table 5-160</A>.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362851"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1362852"></A>The following example ASL code shows the use of OperationRegion combined with Field to describe IDE 0 and 1 controlled through general I/O space, using one FET. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362854"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524747"></A>OperationRegion (GIO, SystemIO, 0x125, 0x1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362855"></A>Field (GIO, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362856"></A>    IDEI,    1,        // IDEISO_EN    - isolation buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362857"></A>    IDEP,    1,        // IDE_PWR_EN   - power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362858"></A>    IDER,    1         // IDERST#_EN   - reset#</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362859"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524754"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362865"></A><A NAME="_Toc465246073"></A><A NAME="_Toc469218381"></A><A NAME="_Toc465246130"></A><A NAME="_Toc469218438"></A><A NAME="_Toc489267509"></A><A NAME="ASL_Or"></A><A NAME="_Toc202342049"></A><A NAME="_Toc258262680"></A>Or (Integer Bitwise Or)<A NAME="marker-1362870"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362872"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362873"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Or </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1, Source2, Result</EM>
) =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556559"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Source1</EM>
 | <EM CLASS="Italic">
Source2</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556560"></A><EM CLASS="Italic">
Result</EM>
 |= <EM CLASS="Italic">
Source1</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1362874"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362875"></A>Source1 and Source2 are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362876"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362877"></A>A bitwise OR is performed and the result is optionally stored in Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362889"></A><A NAME="ASL_Package"></A><A NAME="_Toc202342050"></A><A NAME="_Toc258262681"></A>Package (Declare Package Object<A NAME="marker-1362886"></A><A NAME="marker-1362887"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362890"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362891"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Package </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
NumElements</EM>
) {PackageList} =&gt; Package</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540468"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362893"></A>NumElements is evaluated as an Integer. PackageList is an initializer list of objects. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362894"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1559002"></A>Declares an unnamed aggregation of named data items, constants, and/or references to  non-data namespace objects. The size of the package is <EM CLASS="Italic">
NumElements</EM>
. The <EM CLASS="Italic">
PackageList</EM>
 contains the data items, constants, and/or object references used to initialize the package.</P>
<P CLASS="Body">
<A NAME="pgfId-1526080"></A>If <EM CLASS="Italic">
NumElements</EM>
 is absent, it is automatically set by the ASL compiler to match the number of elements in the PackageList. If <EM CLASS="Italic">
NumElements</EM>
 is present and greater than the number of elements in the <EM CLASS="Italic">
PackageList</EM>
, the default entry of type Uninitialized  (see ObjectType) is used to initialize the package elements beyond those initialized from the <EM CLASS="Italic">
PackageList</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-1559040"></A>There are three types of package elements allowed in the PackageList: ConstantData Objects(Integers, Strings, Buffers, and Packages), named references that resolve to Data Objects (Integers, Strings, Buffers, and Packages), and named references to objects other than Data Objects. </P>
<P CLASS="Body">
<A NAME="pgfId-1559042"></A>These constant terms are resolved at ASL compile time:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1559043"></A>Integer Constant</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559062"></A>String Constant</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559063"></A>Buffer Constant</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559064"></A>Package Constant</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1559066"></A>These Named References to Data Objects are resolved to actual data by the AML Interpreter at runtime:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1559067"></A>Integer reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559068"></A>String reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559069"></A>Buffer reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559070"></A>Buffer Field reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559071"></A>Field Unit reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559072"></A>Package reference</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1559073"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1559074"></A>These Named References to non-Data Objects cannot be resolved to values. They are instead returned in the package as references:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1559075"></A>Device reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559076"></A>Event reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559077"></A>Method reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559078"></A>Mutex reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559079"></A>Operation Region reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559080"></A>Power Resource reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559081"></A>Processor reference</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559082"></A>Thermal Zone reference</LI>
<LI CLASS="Note">
<A NAME="pgfId-1526086"></A>For Package elements of type Package (defining a subpackage), individual elements of the subpackage are resolved according to the rules above, both compile-time and runtime.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1559125"></A>Evaluating an uninitialized element will yield a runtime error, but elements can be assigned values at runtime to define them (via the Index operator). It is a compile time error for <EM CLASS="Italic">
NumElements</EM>
 to be less than the number of elements defined in the <EM CLASS="Italic">
PackageList</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-1559126"></A>The ASL compiler can emit two different AML opcodes for a Package declaration, either <EM CLASS="Italic">
PackageOp</EM>
 or <EM CLASS="Italic">
VarPackageOp</EM>
. For small, fixed-length packages, the <EM CLASS="Italic">
PackageOp</EM>
 is used and this opcode is compatible with ACPI 1.0. A <EM CLASS="Italic">
VarPackageOp</EM>
 will be emitted if any of the following conditions are true: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1559127"></A>The <EM CLASS="Italic">
NumElements</EM>
 argument is a TermArg that can only be resolved at runtime.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559128"></A>At compile time, <EM CLASS="Italic">
NumElements</EM>
 resolves to a constant that is larger than 255. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1559129"></A>The <EM CLASS="Italic">
PackageList</EM>
 contains more than 255 initializer elements.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362899"></A>Example</H3>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559174"></A>Name (INT1, 0x1234)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559175"></A>Processor (CPU0, 0, 0x1010, 6) {}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559176"></A>PowerResource (PWR1, 0, 0) {}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559177"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559178"></A>Name (PKG1, Package () {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559179"></A>    0x3400,      // Integer Constant, resolved at compile time</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559180"></A>    &quot;Processor	&quot;  // String Constant, resolved at compile time</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559181"></A>    &#92;INT1        // Integer Reference, resolved to value at</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559383"></A>                 // runtime</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559182"></A>    &#92;CPU0        // Object Reference, returned as a reference</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559455"></A>                 // object</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559183"></A>    Package () { // Package Constant. Elements are resolved at</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559405"></A>                 // both compile time and runtime</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559184"></A>        0x4321,  // Integer Constant, resolved at compile time</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559185"></A>        &#92;INT1,   // Integer Reference, resolved to value at</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559430"></A>                 // runtime</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559186"></A>        &#92;PWR1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559187"></A>    })</P>
<P CLASS="Body">
<A NAME="pgfId-1559189"></A>The runtime values of the parent package and subpackages are:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559191"></A>Package [Contains 0x05 Elements]</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559192"></A>    (00) Integer 0x0000000000003400</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559193"></A>    (01) String [0x09] &quot;Processor&quot;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559194"></A>    (02) Integer 0x0000000000001234</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559195"></A>    (03) Reference [Named Object] [CPU0] Processor</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559196"></A>    (04) Package [Contains 0x03 Elements]</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559197"></A>        (00) Integer 0x0000000000004321</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559198"></A>        (01) Integer 0x0000000000001234</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559199"></A>        (02) Reference [Named Object] [PWR1] Power</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1559200"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1564447"></A>Pin Configuration</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1564677"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1564689"></A>Macro:</P>
<P CLASS="Body">
<A NAME="pgfId-1564690"></A>PinConfig (Shared/Exclusive, PinConfigType, PinConfigValue, ResourceSource,</P>
<P CLASS="Body">
<A NAME="pgfId-1564691"></A>ResourceSourceIndex, ResourceUsage, DescriptorName, VendorData) {Pin List}</P>
<P CLASS="Body">
<A NAME="pgfId-1564692"></A>Arguments</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1564693"></A>Shared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564697"></A>PinConfigType can be one of the configuration types described below in <A HREF="ACPI_Source_Language_Reference.htm#50124" CLASS="XRef">See Pin Configuration Types and Values.</A>. The bit field _TYP is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564701"></A>PinConfigValue is one of the configurations values described below in <A HREF="ACPI_Source_Language_Reference.htm#50124" CLASS="XRef">See Pin Configuration Types and Values.</A>. The bit field _VAL is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564702"></A>ResourceSource is a string which uniquely identifies the pin controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564703"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564704"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1567039"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564705"></A>VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564706"></A>PinList is a list of pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.</LI>
</UL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1564811"></A><A NAME="50124"></A>Pin Configuration Types and Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1569703"></A>Pin Configuration Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1569705"></A>Pin Configuration Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1569707"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564716"></A>0x00 = Default</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564718"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564720"></A>Default configuration. No configuration is applied.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564722"></A>0x01 = Bias Pull-Up</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564724"></A>Pull up resistance, in Ohms.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564726"></A>This means the pin is pulled up with a certain number of Ohms to an implicitly supplied VDD rail.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564728"></A>0x02 = Bias Pull-down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564730"></A>Pull down resistance, in Ohms.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564732"></A>This means the pin is pulled down with a certain number of Ohms, toward the GND rail.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564734"></A>0x03 = Bias Default</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564736"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564738"></A>If the silicon has a default biasing mode, reset the pin to this mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564740"></A>0x04 = Bias Disable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564742"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564744"></A>Any software-selectable bias settings on the pin will be disabled.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564746"></A>0x05 = Bias High Impedance</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564748"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564750"></A>This means that the pin is configured into a high impedance mode and essentially shut off from the outside world. It will not influence the signal state if a rail is connected to the pin, hence a good default mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564752"></A>0x06 = Bias Bus Hold</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564754"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564756"></A>This will make the pin in a weak latch state where it weakly drives the last value on a tristate bus.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564758"></A>0x07 = Drive Open Drain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564760"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564762"></A>This will configure the pin into open drain (open collector) state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564764"></A>0x08 = Drive Open Source</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564766"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564768"></A>This will configure the pin into open source (open emitter) state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564770"></A>0x09 = Drive Push Pull</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564772"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564774"></A>This will configure the pin into explicit push-pull state. This is useful if the power-on default state is e.g. open drain or high impedance state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564776"></A>0x0A = Drive Strength</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564778"></A>Drive strength in milliamperes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564780"></A>This will set the output driver of the pin to supply a certain number of milliamperes, usually by activating several driver stages.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564782"></A>0x0B = Slew Rate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564784"></A>Custom format</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564786"></A>This controls the slew rate of the pin, affecting speed but also sharpness of edges and thus noisiness on the board. The hardware-specific argument tells what slew rate to configure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564788"></A>0x0C = Input Debounce</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564790"></A>Debounce time in microseconds.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564792"></A>This will enable debouncing (for e.g. key inputs) of the pin signal.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564794"></A>0x0D = Input Schmitt Trigger</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564796"></A>Enabled = 1, Disabled = 0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564798"></A>This will enable Schmitt trigger support for the line.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564800"></A>0x0E - 0x7F = Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564802"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564804"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564806"></A>0x80 - 0xFF = Vendor defined values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564808"></A>Custom base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1564810"></A>From this point, vendor and Hardware-specific configurations are listed.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1564812"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1564813"></A>The PinConfig macro evaluates to a buffer that contains a Pin Configuration resource descriptor. The format of the Pin Configuration resource descriptor can be found in <A HREF="Device_Configuration.htm#29001" CLASS="XRef">See Pin Configuration Descriptor.</A>. The macro is designed to be used inside of an ASL Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1564820"></A>Note: There is some overlap between the properties set by GpioIo/GpioInt/ PinFunction and PinConfig descriptors.  For example, both are setting properties such as pull-ups. If the same property is specified by multiple descriptors for the same pins, the order in which these properties are applied is undetermined. To avoid any conflicts, GpioInt/GpioIo/PinFunction should provide a default value for these properties when PinConfig is used. If PinConfig is used to set pin bias, PullDefault should be used for GpioIo/GpioInt/ PinFunction. If PinConfig is used to set debounce timeout, 0 should be used for GpioIo/GpioInt. If PinConfig is used to set drive strength, 0 should be used for GpioIo.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1564821"></A>Example</H3>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564822"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564823"></A>// Description: GPIO</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564824"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564825"></A>Device (GPI0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564826"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564827"></A>    Name (_HID, &quot;PNPFFFE&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564828"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564829"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564830"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564831"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564832"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564833"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564834"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564835"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564836"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564837"></A>            Memory32Fixed(ReadWrite, 0x4FE00000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564838"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x54}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564839"></A>       })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564840"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564841"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564842"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564843"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564844"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564845"></A>// Description: I2C controller 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564846"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564847"></A>Device (I2C1)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564848"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564849"></A>    Name (_HID, &quot;PNPFFFF&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564850"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564851"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564852"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564853"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564854"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564855"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564856"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564857"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564858"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564859"></A>            Memory32Fixed(ReadWrite, 0x4F800000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564860"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x55}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564861"></A>            PinFunction(Exclusive, PullDefault, 0x5, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, )  {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564862"></A>	       // Configure 10k Pull up for I2C SDA/SCL pins</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564863"></A>	       PinConfig(Exclusive, 0x01, 10000, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, ) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564864"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564865"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564866"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564867"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564868"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564869"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564870"></A>// Description: Physical display panel</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564871"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564872"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564873"></A>Device (SDIO)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564874"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564875"></A>    Name (_HID, &quot;PNPFFFD&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564876"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564877"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564878"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564879"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564880"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564881"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564882"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564883"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564884"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564885"></A>            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564886"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x57}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564887"></A>            GpioIo(Shared, PullDefault, 0, 0, IoRestrictionNone, &quot;&#92;&#92;_SB.GPI0&quot;,) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564888"></A>	       // Configure 20k Pull down</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564889"></A>	       PinConfig(Exclusive, 0x02, 20000, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, ) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564890"></A>	       // Enable Schmitt-trigger</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564891"></A>	       PinConfig(Exclusive, 0x0D, 1, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, ) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564892"></A>	       // Set slew rate to custom value 3</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564893"></A>	       PinConfig(Exclusive, 0x0B, 3, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, ) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564894"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564895"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564896"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564897"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1564390"></A><A NAME="23454"></A>Pin Function</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1564652"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1564510"></A>Macro:</P>
<P CLASS="Body">
<A NAME="pgfId-1564511"></A>PinFunction(Shared/Exclusive, PinPullConfiguration, FunctionNumber, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, VendorData) {Pin List}</P>
<P CLASS="Body">
<A NAME="pgfId-1564512"></A>Arguments</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1564513"></A>Shared is an optional argument and can be one of Shared, Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564514"></A>PinPullConfiguration can be one of PullDefault, PullUp, PullDown, PullNone or a vendor-supplied value in the range 128-255.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564515"></A>FunctionNumber is a provider-specific integer that designates which function is being described.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564516"></A>ResourceSource is a string which uniquely identifies the GPIO controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564517"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564518"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1567054"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564519"></A>VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1564520"></A>PinList is a non-empty list of (zero-based) pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1564521"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1564522"></A>The PinFunction macro evaluates to a buffer that contains a Pin Function resource descriptor, as described in this section. The macro is designed to be used inside of a Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1564526"></A>Note: PinFunction macro allows for maximum flexibility to define the desired function of each pin individually. It is the responsibility of the firmware writer to take into account any platform-level restrictions where pin function must be applied at a coarser granularity. Thus, if the platform design requires the functions for a set of pins to be configured as group, the firmware writer must ensure this is done in the corresponding PinFunction description by specifying all relevant pins in a single PinFunction.  In the multi-pin scenario, the OSPM must honor the PinFunction requirements for all of the specified pins on an &#8220;all-or-nothing&#8221; basis.</P>
<P CLASS="Body">
<A NAME="pgfId-1564527"></A>Note: The Pin Function descriptor is intended for scenarios where non-GPIO functions are desired. For GPIO-based functionalities, the firmware should always specify the appropriate GpioIo or Gpioint descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1564528"></A>Example:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564529"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564530"></A>// Description: GPIO</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564531"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564532"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564533"></A>Device (GPI0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564534"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564535"></A>    Name (_HID, &quot;PNPFFFE&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564536"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564537"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564538"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564539"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564540"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564541"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564542"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564543"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564544"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564545"></A>            Memory32Fixed(ReadWrite, 0x4FE00000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564546"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x54}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564547"></A>       })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564548"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564549"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564550"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564551"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564552"></A>// Description: I2C controller 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564553"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564554"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564555"></A>Device (I2C1)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564556"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564557"></A>    Name (_HID, &quot;PNPFFFF&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564558"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564559"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564560"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564561"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564562"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564563"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564564"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564565"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564566"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564567"></A>            Memory32Fixed(ReadWrite, 0x4F800000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564568"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x55}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564569"></A>            PinFunction(Exclusive, PullUp, 0x5, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, )  {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564570"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564571"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564572"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564573"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564574"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564575"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564576"></A>// Description: I2C controller 2</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564577"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564578"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564579"></A>Device (I2C2)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564580"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564581"></A>    Name (_HID, &quot;PNPFFFF&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564582"></A>    Name (_UID, 0x1)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564583"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564584"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564585"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564586"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564587"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564588"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564589"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564590"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564591"></A>            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564592"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x56}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564593"></A>            PinFunction(Exclusive, PullUp, 0x0, 0x4, &quot;&#92;&#92;_SB.GPI0&quot;, 0, ResourceConsumer, )  {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564594"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564595"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564596"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564597"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564598"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564599"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564600"></A>// Description: Physical display panel</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564601"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564602"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564603"></A>Device (DISP)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564604"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564605"></A>    Name (_HID, &quot;PNPFFFD&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564606"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564607"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564608"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564609"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564610"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564611"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564612"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564613"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564614"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564615"></A>            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564616"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x57}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564617"></A>            GpioIo(Shared, PullDefault, 0, 0, IoRestrictionNone, &quot;&#92;&#92;_SB.GPI0&quot;,) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564618"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564619"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564620"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1564621"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1564479"></A><A NAME="78365"></A>Pin Group</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1564944"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1565269"></A>Macro:</P>
<P CLASS="Body">
<A NAME="pgfId-1565270"></A>PinGroup (ResourceLabel, ResourceUsage, DescriptorName, VendorData) { Pin List }</P>
<P CLASS="Body">
<A NAME="pgfId-1565271"></A>Arguments</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1565272"></A>ResourceUsage is an optional argument and is assumed to be ResourceProducer for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565273"></A>ResourceLabel is an arbitrary, non-empty string that uniquely identifies this particular PinGroup resource from others within a resource template buffer. This label is used by resource consumers to refer to this resource.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565274"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565275"></A>VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565276"></A>PinList is a non-empty list of (zero-based) pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1565277"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1565278"></A>The PinGroup macro evaluates to a buffer that contains a Pin Group resource descriptor. The format of the Pin Group resource descriptor can be found in &quot;Pin Group Descriptor&quot; (<A HREF="Device_Configuration.htm#27571" CLASS="XRef">See Pin Group Descriptor.</A>). The macro is designed to be used inside of a Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>). </P>
<P CLASS="Body">
<A NAME="pgfId-1565285"></A>PinGroup resource descriptors must be declared within the scope of the pin controller device to which the pins belong.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1565307"></A>Pin Group Configuration</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1565413"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1565500"></A>Macro:</P>
<P CLASS="Body">
<A NAME="pgfId-1565501"></A>PinGroupConfig (Shared/Exclusive, PinConfigType, PinConfigValue, ResourceSource,</P>
<P CLASS="Body">
<A NAME="pgfId-1565502"></A>ResourceSourceIndex, ResourceSourceLabel, ResourceUsage, DesriptorName, VendorData)</P>
<P CLASS="Body">
<A NAME="pgfId-1565503"></A>Arguments:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1565504"></A>Shared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565508"></A>PinConfigType can be one of the configuration types described below in <A HREF="ACPI_Source_Language_Reference.htm#80468" CLASS="XRef">See Pin Group Configuration Types and Values.</A>. The bit field name _TYP is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565512"></A>PinConfigValue is one of the configurations values described below in <A HREF="ACPI_Source_Language_Reference.htm#80468" CLASS="XRef">See Pin Group Configuration Types and Values.</A>. The bit field name _VAL is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565513"></A>ResourceSource is a string that uniquely identifies the GPIO controller which includes the PinGroup resource referenced by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565514"></A>ResourceSourceLabel is a non-empty string argument that matches ResourceLabel of the PinGroup resource in the current resource template buffer of the GPIO controller referenced in ResourceSource.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565515"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565516"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565517"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565519"></A><A HREF="file:///&#92;&#92;_SB.GPI0" CLASS="URL"><A HREF="file:///&#92;&#92;_SB.GPI0" CLASS="URL">VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</A></A></LI>
</UL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1565625"></A><A NAME="80468"></A>Pin Group Configuration Types and Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1565524"></A>Pin Configuration Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1565526"></A>Pin Configuration Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1565528"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565530"></A>0x00 = Default</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565532"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565534"></A>Default configuration. No configuration is applied).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565536"></A>0x01 = Bias Pull-Up</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565538"></A>Pull up resistance, in Ohms.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565540"></A>This means the pin is pulled up with a certain number of Ohms to an implicitly supplied VDD rail.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565542"></A>0x02 = Bias Pull-down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565544"></A>Pull down resistance, in Ohms.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565546"></A>This means the pin is pulled down with a certain number of Ohms, toward the GND rail.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565548"></A>0x03 = Bias Default</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565550"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565552"></A>If the silicon has a default biasing mode, reset the pin to this mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565554"></A>0x04 = Bias Disable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565556"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565558"></A>Any software-selectable bias settings on the pin will be disabled.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565560"></A>0x05 = Bias High Impedance</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565562"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565564"></A>This means that the pin is configured into a high impedance mode and essentially shut off from the outside world. It will not influence the signal state if a rail is connected to the pin, hence a good default mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565566"></A>0x06 = Bias Bus Hold</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565568"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565570"></A>This will make the pin in a weak latch state where it weakly drives the last value on a tristate bus.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565572"></A>0x07 = Drive Open Drain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565574"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565576"></A>This will configure the pin into open drain (open collector) state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565578"></A>0x08 = Drive Open Source</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565580"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565582"></A>This will configure the pin into open source (open emitter) state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565584"></A>0x09 = Drive Push Pull</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565586"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565588"></A>This will configure the pin into explicit push-pull state. This is useful if the power-on default state is e.g. open drain or high impedance state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565590"></A>0x0A = Drive Strength</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565592"></A>Drive strength in milliamperes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565594"></A>This will set the output driver of the pin to supply a certain number of milliamperes, usually by activating several driver stages.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565596"></A>0x0B = Slew Rate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565598"></A>Custom format</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565600"></A>This controls the slew rate of the pin, affecting speed but also sharpness of edges and thus noisiness on the board. The hardware-specific argument tells what slew rate to configure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565602"></A>0x0C = Input Debounce</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565604"></A>Debounce time in microseconds.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565606"></A>This will enable debouncing (for e.g. key inputs) of the pin signal.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565608"></A>0x0D = Input Schmitt Trigger</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565610"></A>Enabled = 1, Disabled = 0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565612"></A>This will enable Schmitt trigger support for the line.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565614"></A>0x0E - 0x7F = Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565616"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565618"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565620"></A>0x80 - 0xFF = Vendor defined values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565622"></A>Custom base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1565624"></A>From this point, vendor and Hardware-specific configurations are listed.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1565626"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1565627"></A>The PinGroupConfig macro evaluates to a buffer that contains a Pin Group Configuration resource descriptor. The format of the Pin Group Configuration resource descriptor can be found in &quot;Pin Group Configuration Descriptor&quot; (<A HREF="Device_Configuration.htm#89036" CLASS="XRef">See Pin Group Configuration Descriptor.</A>). The macro is designed to be used inside of a Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1565634"></A>Example</H3>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565635"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565636"></A>// Description: GPIO</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565637"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565638"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565639"></A>Device (GPI0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565640"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565641"></A>    Name (_HID, &quot;PNPFFFE&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565642"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565643"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565644"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565645"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565646"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565647"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565648"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565649"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565650"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565651"></A>            Memory32Fixed(ReadWrite, 0x4FE00000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565652"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x54}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565653"></A>            PinGroup(&#8220;group1&#8221;, ResourceProducer) {2, 3}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565654"></A>       })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565655"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565656"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565657"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565658"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565659"></A>// Description: I2C controller 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565660"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565661"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565662"></A>Device (I2C1)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565663"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565664"></A>    Name (_HID, &quot;PNPFFFF&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565665"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565666"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565667"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565668"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565669"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565670"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565671"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565672"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565673"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565674"></A>            Memory32Fixed(ReadWrite, 0x4F800000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565675"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x55}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565676"></A>            // Set function I2C1 for SDA/SCL pins              </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565677"></A>            PinGroupFunction(Exclusive, 0x5, &quot;&#92;&#92;_SB.GPI0, 0, &#8220;group1&#8221;, ResourceConsumer, ) </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565678"></A>            // Configure 10k Pull up for SDA/SCL pins</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565679"></A>            PinGroupConfig(Exclusive, 0x01, 10000, &quot;&#92;&#92;_SB.GPI0 &quot;,  0, &#8220;group1&#8221;, ResourceConsumer, )</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565680"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565681"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565682"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565683"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565684"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565685"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565686"></A>// Description: I2C controller 2</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565687"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565688"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565689"></A>Device (I2C2)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565690"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565691"></A>    Name (_HID, &quot;PNPFFFF&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565692"></A>    Name (_UID, 0x1)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565693"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565694"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565695"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565696"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565697"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565698"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565699"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565700"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565701"></A>            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565702"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x56}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565703"></A>            // Set function I2C2 for SDA/SCL pins            </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565704"></A>            PinGroupFunction(Exclusive, 0x4, &quot;&#92;&#92;_SB.GPI0 &quot;, 0, &#8220;group1&#8221;, ResourceConsumer, ) </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565705"></A>            // Configure 10k Pull up for SDA/SCL pins</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565706"></A>            PinGroupConfig(Exclusive, 0x01, 10000, &quot;&#92;&#92;_SB.GPI0 &quot;, 0, &#8220;group1&#8221;, ResourceConsumer,)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565707"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565708"></A>        Return(RBUF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565709"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565710"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565711"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565712"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565713"></A>// Description: Physical display panel</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565714"></A>//</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565715"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565716"></A>Device (DISP)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565717"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565718"></A>    Name (_HID, &quot;PNPFFFD&quot;)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565719"></A>    Name (_UID, 0x0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565720"></A>    Method (_STA)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565721"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565722"></A>        Return(0xf)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565723"></A>    }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565724"></A>    Method (_CRS, 0x0, NotSerialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565725"></A>    {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565726"></A>        Name (RBUF, ResourceTemplate()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565727"></A>        {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565728"></A>            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565729"></A>            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x57}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565730"></A>            // Set function GPIO for pin group group1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565731"></A>            PinGroupFunction(Exclusive, 0x1, &quot;&#92;&#92;_SB.GPI0 &quot;, 0, &#8220;group1&#8221;, ResourceConsumer, )</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565732"></A>            // Configure 20k Pull down</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565733"></A>            PinGroupConfig (Exclusive, 0x02, 20000, &quot;&#92;&#92;_SB.GPI0 &quot;, 0, &#8220;group1&#8221;, ResourceConsumer, )</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565734"></A>            //Enable Schmitt-trigger</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565735"></A>            PinGroupConfig (Exclusive, 0x0D, 1, &quot;&#92;&#92;_SB.GPI0 &quot;, 0, &#8220;group1&#8221;, ResourceConsumer, )</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565736"></A>            //Set slew rate to custom value 3</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565737"></A>            PinGroupConfig (Exclusive, 0x0B, 3, &quot;&#92;&#92;_SB.GPI0 &quot;, 0, &#8220;group1&#8221;, ResourceConsumer, )</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565738"></A>        })</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565739"></A>        Return(RBUF)}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565740"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1565741"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1565405"></A>Pin Group Function</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1565430"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1565482"></A>Macro:</P>
<P CLASS="Body">
<A NAME="pgfId-1565431"></A>PinGroupFunction (Shared/Exclusive, FunctionNumber, ResourceSource, ResourceSourceIndex, ResourceSourceLabel, ResourceUsage, DescriptorName, VendorData)</P>
<P CLASS="Body">
<A NAME="pgfId-1565432"></A>Arguments</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1565433"></A>Shared is an optional argument and can be one of Shared, Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565434"></A>FunctionNumber is a provider-specific integer which designates which function is being described. The bit field name _FUN is automatically created to refere to this portion of the resource descriptor.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565435"></A>ResourceSource is a string that uniquely identifies the GPIO controller which includes the PinGroup resource referenced by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565436"></A>ResourceSourceLabel is a non-empty string argument that matches ResourceLabel of a PinGroup resource in the current resource template buffer of the GPIO controller referenced in ResourceSource.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565437"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565438"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565439"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1565440"></A>VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1565441"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1565442"></A>The PinGroupFunction macro evaluates to a buffer that contains a Pin Function resource descriptor. The format of the Pin Function resource descriptor can be found in <A HREF="Device_Configuration.htm#63258" CLASS="XRef">See Pin Function Descriptor.</A>. The macro is designed to be used inside of an ASL Resource Template (<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1526205"></A><A NAME="_Toc489267441"></A><A NAME="ASL_PowerResource"></A><A NAME="_Toc202342051"></A><A NAME="_Toc258262682"></A>PowerResource (Declare Power Resource)<A NAME="marker-1564985"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362929"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362930"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
PowerResource </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceName, SystemLevel, ResourceOrder</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540480"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362932"></A>Declares a power resource named ResourceName. PowerResource opens a name scope. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362933"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362934"></A>For a definition of the PowerResource term, see <A HREF="Power_and_Performance_Mgmt.htm#_Toc489256079" CLASS="XRef">See Declaring a Power Resource Object.</A>, &#8220;Declaring a Power Resource Object.&#8221; </P>
<P CLASS="Body">
<A NAME="pgfId-1561058"></A>The power management object list is encoded as TermList, so that rather than describing a static power management object list, it is possible to describe a dynamic power management object list according to the system settings. See &quot;<A HREF="ACPI_Software_Programming_Model.htm#36467" CLASS="XRef">See Definition Block Loading.</A>, Definition Block Loading.&quot;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1550296"></A><A NAME="61765"></A>Printf (Create and Store formatted string)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1550297"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1550298"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Printf</EM>
 (<EM CLASS="Italic">
FormatString</EM>
, <EM CLASS="Italic">
FormatArgs</EM>
) =&gt; String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1550299"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1550300"></A><EM CLASS="Bold">
Printf</EM>
 is a macro that converts the evaluated <EM CLASS="Italic">
FormatString</EM>
 into a series of string <EM CLASS="Bold">
Concatenate</EM>
 operations, storing the result in the Debug object.</P>
<P CLASS="Body">
<A NAME="pgfId-1550301"></A>FormatString is a string literal which may contain one or more uses of the format specifier, %o, to indicate locations in the string where an object may be inserted. %o is the only format specifier supported since the resulting object is a string and type conversion is handled automatically by <EM CLASS="Bold">
Concatenate</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-1550302"></A><EM CLASS="Italic">
FormatArgs</EM>
 is a comma separated list of Named Objects, Locals, or Args that can be evaluated to a string. Each argument is added to the <EM CLASS="Italic">
FormatString</EM>
 using the <EM CLASS="Bold">
Concatenate</EM>
 operation at the location specified by %o in order of appearance.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1550303"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1550304"></A>The <EM CLASS="Bold">
Printf</EM>
 macro converts a format string into a series of cascading string <EM CLASS="Bold">
Concatenate</EM>
 operations, and stores the result in the Debug object</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1550305"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1550306"></A>The following ASL example uses <EM CLASS="Bold">
Printf</EM>
 to write a formatted string with the values of Arg0, Arg1, Arg2, and Arg3 to the Debug Object.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550308"></A>    Printf (&quot;%o: Unexpected value for %o, %o at line %o&quot;,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550309"></A>            Arg0, Arg1, Arg2, Arg3)</P>
<P CLASS="Body">
<A NAME="pgfId-1550419"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1550311"></A>This <EM CLASS="Bold">
Printf</EM>
 macro expression evaluates to the following ASL operation.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550312"></A>    Store (Concatenate (Concatenate (Concatenate (Concatenate</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550313"></A>          (Concatenate (Concatenate (Concatenate (&quot;&quot;, Arg0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550314"></A>           &quot;: Unexpected value for &quot;), Arg1), &quot;, &quot;), Arg2),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1550285"></A>           &quot; at line &quot;), Arg3), Debug)</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362945"></A><A NAME="_Toc489267442"></A><A NAME="ASL_Processor"></A><A NAME="_Toc202342052"></A><A NAME="_Toc258262683"></A>Processor (Declare Processor)<A NAME="marker-1362944"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1556724"></A>This Operator is deprecated. </P>
<P CLASS="Body">
<A NAME="pgfId-1556750"></A>Declare Processors using the Device operator. See <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267427" CLASS="XRef">See Device (Declare Device Package).</A>, &quot;Device (Declare Device Package)&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId-1556725"></A>Note that this Operator may be required for compatibility with some legacy OSes, and can be used for that purpose.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362955"></A><A NAME="_Toc465246075"></A><A NAME="_Toc469218383"></A><A NAME="_Toc465246079"></A><A NAME="_Toc469218387"></A><A NAME="_Toc465246090"></A><A NAME="_Toc469218398"></A><A NAME="_Toc465246131"></A><A NAME="_Toc469218439"></A><A NAME="_Toc489267656"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362956"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Processor </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ProcessorName, ProcessorID, PBlockAddress, PblockLength</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540492"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362958"></A>Declares a named processor object named ProcessorName. Processor opens a name scope. Each processor is required to have a unique ProcessorID value that is unique from any other ProcessorID value.</P>
<P CLASS="Body">
<A NAME="pgfId-1362959"></A>For each processor in the system, the ACPI system firmware declares one processor object in the namespace anywhere within the &#92;_SB scope. For compatibility with operating systems implementing ACPI 1.0, the processor object may also be declared under the &#92;_PR scope. An ACPI-compatible namespace may define Processor objects in either the &#92;_SB or &#92;_PR scope but not both.</P>
<P CLASS="Body">
<A NAME="pgfId-1362960"></A>PBlockAddress provides the system I/O address for the processors register block. Each processor can supply a different such address. PBlockLength is the length of the processor register block, in bytes and is either 0 (for no P_BLK) or 6. With one exception, all processors are required to have the same PBlockLength. The exception is that the boot processor can have a non-zero PBlockLength when all other processors have a zero PBlockLength. It is valid for every processor to have a PBlockLength of 0.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362961"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362962"></A>The following block of ASL sample code shows a use of the Processor term. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362964"></A>  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524803"></A>        Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362965"></A>            &#92;_PR.CPU0,        // Namespace name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362966"></A>            1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362967"></A>            0x120,            // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362968"></A>      6                // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362969"></A>        ) {ObjectList}</P>
<P CLASS="Body">
<A NAME="pgfId-1362970"></A>The TermList is an optional list that may contain an arbitrary number of ASL Objects. Processor-specific objects that may be included in the TermList include _PTC, _CST, _PCT, _PSS, _PPC, _PSD, _TSD, _CSD, _PDC, _TPC, _TSS, and _OSC. These processor-specific objects can only be specified when the processor object is declared within the &#92;_SB scope. For a full definition of these objects, see <A HREF="Processor_Configuration_and_Control.htm#48288" CLASS="XRef">See Processor Configuration and Control.</A>, &#8220;Processor Configuration and Control.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1561097"></A>The optional processor object list is encoded as TermList, so that rather than describing a static processor object list, it is possible to describe a dynamic processor object list according to the system settings. See &quot;<A HREF="ACPI_Software_Programming_Model.htm#36467" CLASS="XRef">See Definition Block Loading.</A>, Definition Block Loading.&quot;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362977"></A><A NAME="ASL_QWordIO"></A><A NAME="_Toc202342053"></A><A NAME="_Toc258262684"></A>QWordIO (QWord IO Resource Descriptor Macro)<A NAME="marker-1362975"></A><A NAME="marker-1362976"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362978"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1362979"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
QWordIO </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMinFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMaxFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Decode</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ISARanges</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressGranularity, AddressMinimum, AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressTranslation</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceSourceIndex, ResourceSource, DescriptorName, TranslationType, TranslationDensity)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540504"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1362981"></A>ResourceUsage specifies whether the I/O range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1362982"></A>IsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1362983"></A>IsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1362984"></A>Decode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1362985"></A>ISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2-bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is NonISAOnly, &#8216;2&#8217; is ISAOnly and &#8216;0&#8217; is EntireRange.</P>
<P CLASS="Body">
<A NAME="pgfId-1362986"></A>AddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362987"></A>AddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362988"></A>AddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362989"></A>AddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362990"></A>RangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the I/O range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1362991"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1362992"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1548460"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1362993"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#21740" CLASS="XRef">Resource Type Specific Flags</A>) for more information</P>
<P CLASS="Body">
<A NAME="pgfId-1362994"></A>TranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName. _TRS is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SparseTranslation and &#8216;0&#8217; is DenseTranslation. See _TRS (<A HREF="Device_Configuration.htm#51978" CLASS="XRef">I/O Resource Flag (Resource Type = 1) Definitions</A>) for more information. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1362996"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1362997"></A>The QWordIO macro evaluates to a buffer which contains a 64-bit I/O resource descriptor, which describes a range of I/O addresses. The format of the 64-bit I/O resource descriptor can be found in QWord Address Space Descriptor <A NAME="marker-1362998"></A><A NAME="marker-1362999"></A> (<A HREF="Device_Configuration.htm#44657" CLASS="XRef">QWord Address Space Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363006"></A><A NAME="ASL_QWordMemory"></A><A NAME="_Toc202342054"></A><A NAME="_Toc258262685"></A>QWordMemory (QWord Memory Resource Descriptor Macro) <A NAME="marker-1363004"></A><A NAME="marker-1363005"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363007"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363008"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
QWordMemory </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, Decode, IsMinFixed, IsMaxFixed, Cacheable, ReadAndWrite, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName, MemoryRangeType, TranslationType)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540516"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363010"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363011"></A>Decode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1363012"></A>IsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363013"></A>IsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363014"></A>Cacheable specifies whether or not the memory region is cacheable (Cacheable), cacheable and write-combining (WriteCombining), cacheable and prefetchable (Prefetchable) or uncacheable (NonCacheable). If nothing is specified, then NonCacheable is assumed. The 2-bit field DescriptorName. _MEM is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is Cacheable, &#8216;2&#8217; is WriteCombining, &#8216;3&#8217; is Prefetchable and &#8216;0&#8217; is NonCacheable.</P>
<P CLASS="Body">
<A NAME="pgfId-1363015"></A>ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is ReadWrite and &#8216;0&#8217; is ReadOnly.</P>
<P CLASS="Body">
<A NAME="pgfId-1363016"></A>AddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363017"></A>AddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363018"></A>AddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363019"></A>AddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363020"></A>RangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363021"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1363022"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1363023"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1363024"></A>MemoryRangeType is an optional argument that specifies the memory usage. The memory can be marked as normal (AddressRangeMemory), used as ACPI NVS space (AddressRangeNVS), used as ACPI reclaimable space (AddressRangeACPI) or as system reserved (AddressRangeReserved). If nothing is specified, then AddressRangeMemory is assumed. The 2-bit field DescriptorName. _MTP is automatically created in order to refer to this portion of the resource descriptor, where &#8216;0&#8217; is AddressRangeMemory, &#8216;1&#8217; is AddressRangeReserved, &#8216;2&#8217; is AddressRangeACPI and &#8216;3&#8217; is AddressRangeNVS.</P>
<P CLASS="Body">
<A NAME="pgfId-1363025"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is I/O. If TypeStatic is specified, then the primary side of the bus is Memory. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#21740" CLASS="XRef">Resource Type Specific Flags</A>) for more information.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363026"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363027"></A>The QWordMemory macro evaluates to a buffer which contains a 64-bit memory resource descriptor, which describes a range of memory addresses. The format of the 64-bit memory resource descriptor can be found in &#8220;QWord Address Space Descriptor <A NAME="marker-1363028"></A><A NAME="marker-1363029"></A>&#8221; (<A HREF="Device_Configuration.htm#44657" CLASS="XRef">QWord Address Space Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363036"></A><A NAME="ASL_QWordSpace"></A><A NAME="_Toc202342055"></A><A NAME="_Toc258262686"></A>QWordSpace (QWord Space Resource Descriptor Macro)<A NAME="marker-1363034"></A><A NAME="marker-1363035"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363037"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363038"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
QWordSpace </EM>
(ResourceType, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540528"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363040"></A>ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.</P>
<P CLASS="Body">
<A NAME="pgfId-1363041"></A>ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363042"></A>Decode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1363043"></A>IsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363044"></A>IsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363045"></A>TypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.</P>
<P CLASS="Body">
<A NAME="pgfId-1363046"></A>AddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363047"></A>AddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363048"></A>AddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the Memory range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363049"></A>AddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363050"></A>RangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363051"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1363052"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1363053"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363054"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363055"></A>The QWordSpace macro evaluates to a buffer which contains a 64-bit Address Space resource descriptor, which describes a range of addresses. The format of the 64-bit AddressSpace descriptor can be found in &#8220;QWord Address Space Descriptor <A NAME="marker-1363056"></A><A NAME="marker-1363057"></A>&#8221; (<A HREF="Device_Configuration.htm#44657" CLASS="XRef">QWord Address Space Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363064"></A><A NAME="_Toc489267510"></A><A NAME="ASL_RefOf"></A><A NAME="_Toc202342056"></A><A NAME="_Toc258262687"></A>RawDataBuffer</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1536177"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1536178"></A>RawDataBuffer (RDBufferSize) {ByteList} =&gt; RawDataBuffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540540"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1536134"></A>Declares a RawDataBuffer of size RDBufferSize and optional initial value of ByteList.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1536135"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1536251"></A>The optional RDBufferSize parameter specifies the size of the buffer and must be a word constant. The initial value is specified in Initializer ByteList. If RDBufferSize is not specified, it defaults to the size of initializer. If the count is too small to hold the value specified by initializer, the initializer size is used.</P>
<P CLASS="Body">
<A NAME="pgfId-1536252"></A>Note that a RawDataBuffer is not encoded as a Buffer (Opcode, Package length bytes, etc), but rather contains only the raw bytes specified.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1536105"></A>RefOf (Create Object Reference)<A NAME="marker-1363063"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363066"></A><A NAME="_Toc489267660"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363067"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
RefOf </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Object</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; ObjectReference</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540552"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363069"></A>Object can be any object type (for example, a package, a device object, and so on).</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363070"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363071"></A>Returns an object reference to Object. If the Object does not exist, the result of a RefOf operation is fatal. Use the CondRefOf term in cases where the Object might not exist. </P>
<P CLASS="Body">
<A NAME="pgfId-1363072"></A>The primary purpose of RefOf() is to allow an object to be passed to a method as an argument to the method without the object being evaluated at the time the method was loaded.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363079"></A><A NAME="ASL_Register"></A><A NAME="_Toc202342057"></A><A NAME="_Toc258262688"></A>Register (Generic Register Resource Descriptor<A NAME="marker-1363077"></A><A NAME="marker-1363078"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363080"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363081"></A>Register (AddressSpaceKeyword, RegisterBitWidth, RegisterBitOffset, RegisterAddress, AccessSize, DescriptorName)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540564"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363083"></A>AddressSpaceKeyword specifies the address space where the register exists. The register can be one of the following:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1571092"></A>I/O space (SystemIO)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571119"></A>System Memory (SystemMemory)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571149"></A>PCI configuration space (PCI_Config)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571188"></A>Embedded controller space (EmbeddedControl)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571233"></A>SMBus (SMBus)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571251"></A>CMOS (SystemCMOS)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571272"></A>PCI Bar target (PciBarTarget)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571306"></A>IPMI (IPMI)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571323"></A>General purpose I/O (GeneralPurposeIO)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571363"></A>Generic serial bus (GenericSerialBus)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571405"></A>Platform Communications Channel (PCC)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1571444"></A>Fixed-feature hardware (FFixedHW)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1571065"></A>The 8-bit field DescriptorName. _ASI is automatically created in order to refer to this portion of the resource descriptor. See the Address Space ID definition in <A HREF="Device_Configuration.htm#95646" CLASS="XRef">See Generic Register Descriptor Definition.</A> for more information, including a list of valid values and their meanings.</P>
<P CLASS="Body">
<A NAME="pgfId-1363084"></A>RegisterBitWidth evaluates to an 8-bit integer that specifies the number of bits in the register. The 8-bit field DescriptorName. _RBW is automatically created in order to refer to this portion of the resource descriptor. See the _RBW definition in <A HREF="Device_Configuration.htm#95646" CLASS="XRef">See Generic Register Descriptor Definition.</A> for more information.</P>
<P CLASS="Body">
<A NAME="pgfId-1363085"></A>RegisterBitOffset evaluates to an 8-bit integer that specifies the offset in bits from the start of the register indicated by RegisterAddress. The 8-bit field DescriptorName. _RBO is automatically created in order to refer to this portion of the resource descriptor. See the _RBO definition in <A HREF="Device_Configuration.htm#95646" CLASS="XRef">See Generic Register Descriptor Definition.</A> for more information.</P>
<P CLASS="Body">
<A NAME="pgfId-1444293"></A>RegisterAddress evaluates to a 64-bit integer that specifies the register address. The 64-bit field DescriptorName. _ADR is automatically created in order to refer to this portion of the resource descriptor. See the _ADR definition in <A HREF="Device_Configuration.htm#95646" CLASS="XRef">See Generic Register Descriptor Definition.</A> for more information.</P>
<P CLASS="Body">
<A NAME="pgfId-1444294"></A>AccessSize evaluates to an 8-bit integer that specifies the size of data values used when accessing the address space as follows:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1363088"></A>0 - Undefined (legacy)</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1363089"></A>1 - Byte access</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1363090"></A>2 - Word access</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1363091"></A>3 - DWord access</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1363092"></A>4 - QWord access</P>
<P CLASS="Body">
<A NAME="pgfId-1363093"></A>The 8-bit field DescriptorName. _ASZ is automatically created in order to refer to this portion of the resource descriptor. See the _ASZ definition in <A HREF="Device_Configuration.htm#95646" CLASS="XRef">See Generic Register Descriptor Definition.</A> for more information. For backwards compatibility, the AccesSize parameter is optional when invoking the Register macro. If the AccessSize parameter is not supplied then the AccessSize field will be set to zero. In this case, OSPM will assume the access size.</P>
<P CLASS="Body">
<A NAME="pgfId-1363094"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363095"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1443904"></A>The Register macro evaluates to a buffer that contains a generic register resource descriptor. The format of the generic register resource descriptor can be found in <A HREF="Device_Configuration.htm#95646" CLASS="XRef">See Generic Register Descriptor Definition.</A>. The macro is designed to be used inside of the ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">See ResourceTemplate (Resource To Buffer Conversion Macro).</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363103"></A><A NAME="_Toc489267459"></A><A NAME="ASL_Release"></A><A NAME="_Toc202342058"></A><A NAME="_Toc258262689"></A>Release (Release a Mutex Synchronization Object)<A NAME="marker-1363102"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363106"></A><A NAME="_Toc465246091"></A><A NAME="_Toc469218399"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363107"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Release </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SyncObject</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540576"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363109"></A>SynchObject must be a mutex synchronization object. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363110"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1549487"></A>If the mutex object is owned by the current invocation, ownership for the Mutex is released once. It is fatal to release ownership on a Mutex unless it is currently owned. A Mutex must be totally released before an invocation completes.<A NAME="marker-1549488"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1549494"></A><A NAME="_Toc489267460"></A><A NAME="ASL_Reset"></A><A NAME="_Toc202342059"></A><A NAME="_Toc258262690"></A>Reset (Reset an Event Synchronization Object)<A NAME="marker-1549493"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1549500"></A><A NAME="_Ref369783966"></A><A NAME="_Toc465246092"></A><A NAME="_Toc469218400"></A><A NAME="_Toc465246154"></A><A NAME="_Toc469218462"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363126"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Reset </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SyncObject</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540588"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363128"></A>SynchObject must be an Event synchronization object. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363129"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363130"></A>This operator is used to reset an event synchronization object to a non-signaled state. See also the Wait and Signal function operator definitions.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363138"></A><A NAME="_Toc489267534"></A><A NAME="ASL_ResourceTemplate"></A><A NAME="_Toc202342060"></A><A NAME="_Toc258262691"></A>ResourceTemplate (Resource To Buffer Conversion Macro)<A NAME="marker-1363136"></A><A NAME="marker-1363137"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363139"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363140"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ResourceTemplate () </EM>
{<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceMacroList</EM>
} =&gt; Buffer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363141"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363148"></A>For a full definition of the ResourceTemplateTerm macro, see <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>, &#8220;ASL Resource Templates&#8221;.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363155"></A><A NAME="_Toc489267461"></A><A NAME="ASL_Return"></A><A NAME="_Toc202342061"></A><A NAME="_Toc258262692"></A>Return (Return from Method Execution)<A NAME="marker-1363154"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363158"></A><A NAME="_Toc465246151"></A><A NAME="_Toc469218459"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363159"></A>Return</P>
<P CLASS="Body">
<A NAME="pgfId-1363160"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Return</EM>
 ()</P>
<P CLASS="Body">
<A NAME="pgfId-1363161"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Return</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Arg</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540600"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363163"></A>Arg is optional and can be any valid object or reference.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363164"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363165"></A>Returns control to the invoking control method, optionally returning a copy of the object named in Arg. If no Arg object is specified, a Return(Zero) is generated by the ASL compiler.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1363166"></A>In the absence of an explicit Return () statement, the return value to the caller is undefined.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363173"></A><A NAME="_Toc489267531"></A><A NAME="ASL_Revision"></A><A NAME="_Toc202342062"></A><A NAME="_Toc258262693"></A>Revision (Constant Revision Integer)<A NAME="marker-1363172"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363174"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1526427"></A>Revision =&gt; Integer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363175"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363177"></A>The Revision operator returns an Integer containing the current revision of the AML interpreter. Writes to this object are not allowed.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363184"></A><A NAME="_Toc489267447"></A><A NAME="ASL_Scope"></A><A NAME="_Toc202342063"></A><A NAME="_Toc258262694"></A>Scope (Open Named Scope)<A NAME="marker-1363183"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363185"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363186"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Scope </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Location</EM>
) {ObjectList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540612"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363188"></A>Opens and assigns a base namespace scope to a collection of objects. All object names defined within the scope are created relative to Location. Note that Location does not have to be below the surrounding scope, but can refer to any location within the namespace. The Scope term itself does not create objects, but only locates objects within the namespace; the actual objects are created by other ASL terms.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363189"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363190"></A>The object referred to by Location must already exist in the namespace and be one of the following object types that has a namespace scope associated with it:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363192"></A>A predefined scope such as: &#92; (root), &#92;_SB, &#92;GPE, &#92;_PR, &#92;_TZ, etc.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363193"></A>Device</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363194"></A>Processor</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363195"></A>Thermal Zone</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363196"></A>Power Resource</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363197"></A>The Scope term alters the current namespace location to the existing Location. This causes the defined objects within TermList to be created relative to this new location in the namespace.</P>
<P CLASS="Body">
<A NAME="pgfId-1561125"></A>The object list is encoded as TermList, so that rather than describing a static object list, it is possible to describe a dynamic object list according to the system settings. See &quot;<A HREF="ACPI_Software_Programming_Model.htm#36467" CLASS="XRef">See Definition Block Loading.</A>, Definition Block Loading.&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-1363198"></A>Note: When creating secondary SSDTs, it is often required to use the Scope operator to change the namespace location in order create objects within some part of the namespace that has been defined by the main DSDT. Use the External operator to declare the scope location so that the ASL compiler will not issue an error for an undefined Location. </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363199"></A>Examples</H3>
<P CLASS="Body">
<A NAME="pgfId-1363200"></A>The following example ASL code uses the Scope operator and creates several objects:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363202"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524817"></A>Scope (&#92;PCI0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363203"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363204"></A>    Name (X, 3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363205"></A>    Scope (&#92;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363206"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363207"></A>        Method (RQ) {Return (0)}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363208"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363209"></A>    Name (^Y, 4)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363210"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524824"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1363211"></A>The created objects are placed in the ACPI namespace as shown:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363213"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524831"></A>&#92;PCI0.X</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363214"></A>&#92;RQ</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363215"></A>&#92;Y</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524838"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1381872"></A>This example shows the use of External in conjunction with Scope within an SSDT:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1381874"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524845"></A>DefinitionBlock (&quot;ssdt.aml&quot;, &quot;SSDT&quot;, 2, &quot;X&quot;, &quot;Y&quot;, 0x00000001)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363219"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363220"></A>    External (&#92;_SB.PCI0, DeviceObj)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363221"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363222"></A>    Scope (&#92;_SB.PCI0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363223"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363224"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363225"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524852"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363238"></A><A NAME="_Toc465246093"></A><A NAME="_Toc469218401"></A><A NAME="_Toc202342064"></A><A NAME="_Toc465246132"></A><A NAME="_Toc469218440"></A><A NAME="_Toc489267511"></A><A NAME="ASL_ShiftLeft"></A><A NAME="_Toc202342065"></A><A NAME="_Toc258262695"></A>ShiftLeft (Integer Shift Left)<A NAME="marker-1363237"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363241"></A><A NAME="_Toc465246133"></A><A NAME="_Toc469218441"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363242"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ShiftLeft </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source, ShiftCount</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556578"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Source</EM>
 &lt;&lt; <EM CLASS="Italic">
ShiftCount</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556579"></A><EM CLASS="Italic">
Result</EM>
 &lt;&lt;= <EM CLASS="Italic">
ShiftCount</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540624"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363244"></A>Source and ShiftCount are evaluated as Integers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363245"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363246"></A>Source is shifted left with the least significant bit zeroed ShiftCount times. The result is optionally stored into Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363253"></A><A NAME="_Toc489267512"></A><A NAME="ASL_ShiftRight"></A><A NAME="_Toc202342066"></A><A NAME="_Toc258262696"></A>ShiftRight (Integer Shift Right)<A NAME="marker-1363252"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363254"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363255"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ShiftRight </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ShiftCount</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
) =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1557202"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Source</EM>
 &gt;&gt; <EM CLASS="Italic">
ShiftCount</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1557203"></A><EM CLASS="Italic">
Result</EM>
 &gt;&gt;= <EM CLASS="Italic">
ShiftCount</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540636"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363257"></A>Source and ShiftCount are evaluated as Integers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363258"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363259"></A>Source is shifted right with the most significant bit zeroed ShiftCount times. The result is optionally stored into Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363267"></A><A NAME="_Toc489267462"></A><A NAME="ASL_Signal"></A><A NAME="_Toc202342067"></A><A NAME="_Toc258262697"></A>Signal (Signal a Synchronization Event)<A NAME="marker-1363265"></A><A NAME="marker-1363266"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363272"></A><A NAME="_Toc465246094"></A><A NAME="_Toc469218402"></A><A NAME="_Toc465246134"></A><A NAME="_Toc469218442"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363273"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Signal </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SyncObject</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540648"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363275"></A>SynchObject must be an Event synchronization object. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363276"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363277"></A>The Event object is signaled once, allowing one invocation to acquire the event.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363278"></A><A NAME="_Toc489267513"></A><A NAME="ASL_SizeOf"></A><A NAME="_Toc202342068"></A><A NAME="_Toc258262698"></A>SizeOf (Get Data Object Size)<A NAME="marker-1363283"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363285"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363286"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
SizeOf </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ObjectName</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540660"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363288"></A>ObjectName must be a buffer, string or package object.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363289"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363290"></A>Returns the size of a buffer, string, or package data object. </P>
<P CLASS="Body">
<A NAME="pgfId-1363291"></A>For a buffer, it returns the size in bytes of the data. For a string, it returns the size in bytes of the string, not counting the trailing NULL. For a package, it returns the number of elements. For an object reference, the size of the referenced object is returned. Other data types cause a fatal run-time error.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363298"></A><A NAME="_Toc489267463"></A><A NAME="ASL_Sleep"></A><A NAME="_Toc202342069"></A><A NAME="_Toc258262699"></A>Sleep (Milliseconds Sleep)<A NAME="marker-1363297"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363301"></A><A NAME="_Toc465246095"></A><A NAME="_Toc469218403"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363302"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Sleep </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
MilliSeconds</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540672"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363304"></A>The Sleep term is used to implement long-term timing requirements. Execution is delayed for at least the required number of milliseconds. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363305"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1540408"></A>The implementation of Sleep is to round the request up to the closest sleep time supported by the OS and relinquish the processor. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1540428"></A><A NAME="98115"></A>SPISerialBusV2 (SPI Serial Bus Connection Resource Descriptor (Version 2) Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1540429"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1540430"></A>SPISerialBusV2 (DeviceSelection, DeviceSelectionPolarity, WireMode, DataBitLength, SlaveMode, ConnectionSpeed, ClockPolarity, ClockPhase, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, Shared, VendorData)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540978"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1540432"></A>DeviceSelection is the device selection value. This value may refer to a chip-select line, GPIO line or other line selection mechanism. _ADR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540433"></A>DeviceSelectionPolarity is an optional argument and can be either PolarityHigh or PolarityLow to indicate that the device is active. PolarityLow is the default. The bit field _DPL is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540434"></A>WireMode is an optional argument and can be either ThreeWireMode or FourWireMode. FourWireMode is the default. The bit field name _MOD is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540435"></A>DataBitLength is the size, in bits, of the smallest transfer unit for this connection. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540436"></A>SlaveMode is an optional argument and can be either ControllerInitiated or DeviceInitiated. ControllerInitiated is the default. The bit field name _SLV is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540437"></A>ConnectionSpeed is the maximum connection speed supported by this connection, in hertz. The bit field name _SPE is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540438"></A>ClockPolarity can be either ClockPolarityLow or ClockPolarityHigh. _POL is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540439"></A>ClockPhase can be either ClockPhaseFirst or ClockPhaseSecond. _PHA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1540440"></A>ResourceSource is a string which uniquely identifies the SPI bus controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.</P>
<P CLASS="Body">
<A NAME="pgfId-1540442"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1540443"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1540444"></A><EM CLASS="Italic">
Shared</EM>
 is an optional argument and can be either <EM CLASS="Bold">
Shared</EM>
 or <EM CLASS="Bold">
Exclusive</EM>
. If not specified, <EM CLASS="Bold">
Exclusive</EM>
 is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1558127"></A>VendorData is an optional argument that specifies an object to be decoded by the OS driver. It is a RawDataBuffer. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1540446"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1540447"></A>The <EM CLASS="Bold">
SPISerialBusV2</EM>
 macro evaluates to a buffer that contains a SPI Serial Bus resource descriptor (Version 2). The macro is designed to be used inside of a ResourceTemplate (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1540415"></A><A NAME="_Toc489267464"></A><A NAME="ASL_Stall"></A><A NAME="_Toc202342070"></A><A NAME="_Toc258262700"></A>Stall (Stall for a Short Time)<A NAME="marker-1540414"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363314"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363315"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Stall </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
MicroSeconds</EM>
)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540684"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363317"></A>The Stall term is used to implement short-term timing requirements. Execution is delayed for at least the required number of microseconds. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363318"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363319"></A>The implementation of Stall is OS-specific, but must not relinquish control of the processor. Because of this, delays longer than 100 microseconds must use Sleep instead of Stall.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363329"></A><A NAME="ASL_StartDependentFn"></A><A NAME="_Toc202342071"></A><A NAME="_Toc258262701"></A>StartDependentFn (Start Dependent Function Resource Descriptor<A NAME="marker-1363327"></A><A NAME="marker-1363328"></A> Macro)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363330"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1540710"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
StartDependentFn </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
CompatibilityPriority</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
PerformancePriority</EM>
) {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceList</EM>
}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540718"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1540712"></A>CompatibilityPriority indicates the relative compatibility of the configuration specified by ResourceList relative to the PC/AT. 0 = Good, 1 = Acceptable, 2 = Sub-optimal.</P>
<P CLASS="Body">
<A NAME="pgfId-1363334"></A>PerformancePriority indicates the relative performance of the configuration specified by ResourceList relative to the other configurations. 0 = Good, 1 = Acceptable, 2 = Sub-optimal.</P>
<P CLASS="Body">
<A NAME="pgfId-1363335"></A>ResourceList is a list of resources descriptors which must be selected together for this configuration.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363336"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363337"></A>The StartDependentFn macro evaluates to a buffer which contains a start dependent function resource descriptor, which describes a group of resources which must be selected together. Each subsequent StartDependentFn or StartDependentFnNoPri resource descriptor introduces a new choice of resources for configuring the device, with the last choice terminated with an EndDependentFn resource descriptor. The format of the start dependent function resource descriptor can be found in &#8220;Start Dependent Functions Descriptor&#8221; (<A HREF="Device_Configuration.htm#AML_StartDependentFn" CLASS="XRef">Start Dependent Functions Descriptor</A>). This macro generates the two-byte form of the resource descriptor. The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>). </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363342"></A><A NAME="ASL_StartDependentFnNoPri"></A><A NAME="_Toc202342072"></A><A NAME="_Toc258262702"></A>StartDependentFnNoPri (Start Dependent Function Resource Descriptor Macro) <A NAME="marker-1363343"></A><A NAME="marker-1363344"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363345"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363346"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
StartDependentFnNoPri </EM>
() {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceList</EM>
}</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363347"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363348"></A>The StartDependentFnNoPri macro evaluates to a buffer which contains a start dependent function resource descriptor, which describes a group of resources which must be selected together. Each subsequent StartDependentFn or StartDependentFnNoPri resource descriptor introduces a new choice of resources for configuring the device, with the last choice terminated with an EndDependentFn resource descriptor. The format of the start dependent function resource descriptor can be found in &#8220;Start Dependent Functions Descriptor&#8221; (<A HREF="Device_Configuration.htm#64636" CLASS="XRef">Start Dependent Functions Descriptor Definition</A>). This macro generates the one-byte form of the resource descriptor. The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1545003"></A>This is similar to StartDependentFn (<A HREF="ACPI_Source_Language_Reference.htm#ASL_StartDependentFn" CLASS="XRef">StartDependentFn (Start Dependent Function Resource Descriptor Macro)</A>) with both CompatibilityPriority and PerformancePriority set to 1, but is one byte shorter. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1545009"></A><A NAME="_Toc489267514"></A><A NAME="ASL_Store"></A><A NAME="_Toc202342073"></A><A NAME="_Toc258262703"></A>Store (Store an Object)<A NAME="marker-1545008"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1545010"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363358"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Store </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Destination</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; DataRefObject</P>
<P CLASS="Body">
<A NAME="pgfId-1556627"></A><EM CLASS="Italic">
Destination</EM>
 = <EM CLASS="Italic">
Source</EM>
 =&gt; DataRefObject</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540730"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1382030"></A>This operation evaluates Source, converts it to the data type of Destination, and writes the result into Destination. For information on automatic data-type conversion, see <A HREF="ACPI_Source_Language_Reference.htm#_Toc4819446" CLASS="XRef">See ASL Data Types.</A>, &#8220;ASL Data Types.&#8221; </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363361"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363362"></A>Stores to OperationRegion Field data types may relinquish the processor depending on the address space.</P>
<P CLASS="Body">
<A NAME="pgfId-1363363"></A>All stores (of any type) to the constant Zero, constant One, or constant Ones object are not allowed. Stores to read-only objects are fatal. The execution result of the operation depends on the type of Destination. For any type other than an operation region field, the execution result is the same as the data written to Destination. For operation region fields with an AccessType of ByteAcc, WordAcc, DWordAcc, QWordAcc or AnyAcc, the execution result is the same as the data written to Destination as in the normal case, but when the AccessType is BufferAcc, the operation region handler may modify the data when it is written to the Destination so that the execution result contains modified data.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363364"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1363365"></A>The following example creates the name CNT that references an integer data object with the value 5 and then stores CNT to Local0. After the Store operation, Local0 is an integer object with the value 5.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363367"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524859"></A>Name (CNT, 5)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363368"></A>Store (CNT, Local0)<A NAME="_Toc465246136"></A><A NAME="_Toc469218444"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363378"></A><A NAME="_Toc489267516"></A><A NAME="ASL_Subtract"></A><A NAME="_Toc202342074"></A><A NAME="_Toc258262704"></A>Subtract (Integer Subtract)<A NAME="marker-1363377"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363379"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363380"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Subtract </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Minuend,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Subtrahend,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556646"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Minuend</EM>
 - <EM CLASS="Italic">
Subtrahend</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556647"></A><EM CLASS="Italic">
Result</EM>
 -= <EM CLASS="Italic">
Subtrahend</EM>
 =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540742"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363382"></A>Minuend and Subtrahend are evaluated as Integers. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363383"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363384"></A>Subtrahend is subtracted from Minuend, and the result is optionally stored into Result. Underflow conditions are ignored and the result simply loses the most significant bits.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363385"></A><A NAME="_Toc489267465"></A><A NAME="ASL_Switch"></A><A NAME="_Toc202342075"></A><A NAME="_Toc258262705"></A>Switch (Select Code To Execute Based On Expression)<A NAME="marker-1363390"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363392"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363393"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Switch </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Expression</EM>
) {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
CaseTermList</EM>
}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540754"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363395"></A>Expression is an ASL expression that evaluates to an Integer, String or Buffer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363396"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363397"></A>The Switch, Case and Default statements help simplify the creation of conditional and branching code. The Switch statement transfers control to a statement within the enclosed body of executable ASL code </P>
<P CLASS="Body">
<A NAME="pgfId-1363398"></A>If the Case Value is an Integer, Buffer or String, then control passes to the statement that matches the value of Switch (Expression). If the Case value is a Package, then control passes if any member of the package matches the Switch (Value) The Switch CaseTermList can include any number of Case instances, but no two Case Values (or members of a Value, if Value is a Package) within the same Switch statement can have the same value.</P>
<P CLASS="Body">
<A NAME="pgfId-1363399"></A>Execution of the statement body begins at the selected TermList and proceeds until the TermList end of body or until a Break or Continue statement transfers control out of the body. </P>
<P CLASS="Body">
<A NAME="pgfId-1363400"></A>The Default statement is executed if no Case Value matches the value of Switch (expression). If the Default statement is omitted, and no Case match is found, none of the statements in the Switch body are executed. There can be at most one Default statement. The Default statement can appear anywhere in the body of the Switch statement. </P>
<P CLASS="Body">
<A NAME="pgfId-1363401"></A>A Case or Default term can only appear inside a Switch statement. Switch statements can be nested. (Compatibility Note) The Switch, Case, and Default terms were first introduced in ACPI 2.0. However, their implementation is backward compatible with ACPI 1.0 AML interpreters. <A NAME="marker-1363403"></A><A NAME="marker-1363404"></A></P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363405"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1363406"></A>Use of the Switch statement usually looks something like this: </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363408"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524873"></A>Switch (expression) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363409"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363410"></A>    Case (value) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363411"></A>        Statements executed if Lequal (expression, value) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363412"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363413"></A>    Case (Package () {value, value, value}) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363414"></A>        Statements executed if Lequal (expression, any value in package)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363415"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363416"></A>    Default { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363417"></A>        Statements executed if expression does not equal </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363418"></A>        any case constant-expression </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363419"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363420"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1524880"></A>&nbsp;</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1363421"></A>(Compiler Note) The following example demonstrates how the Switch statement should be translated into ACPI 1.0-compatible AML:</LI>
</UL>
<P CLASS="CodeExample">
<A NAME="pgfId-1363423"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524887"></A>Switch (Add (ABCD( ),1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363424"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363425"></A>    Case (1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363426"></A>        ...statements1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363427"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363428"></A>    Case (Package () {4,5,6}) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363429"></A>        ...statements2...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363430"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363431"></A>    Default {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363432"></A>        ...statements3...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363433"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363434"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524894"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1363435"></A>is translated as:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363437"></A>Name (_T_I, 0)                    // Create Integer temporary variable for result</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363438"></A>While (One)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363439"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363440"></A>    Store (Add (ABCD (), 1), _T_I)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363441"></A>    If (LEqual (_T_I, 1)) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363442"></A>        ...statements1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363443"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363444"></A>    Else {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363446"></A>    If<A NAME="if"></A> (LNotEqual (Match (Package () {4, 5, 6}, MEQ, _T_I, MTR, 0, 0), Ones)) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363447"></A>        ...statements2...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363448"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363449"></A>    Else {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363450"></A>        ...statements3...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363451"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363452"></A>    Break</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363453"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363454"></A>The While (One) is emitted to enable the use of Break and Continue within the Switch statement. Temporary names emitted by the ASL compiler should appear at the top level of the method, since the Switch statement could appear within a loop and thus attempt to create the name more than once.</P>
<P CLASS="Body">
<A NAME="pgfId-1363455"></A>Note: If the ASL compiler is unable to determine the type of the expression, then it will generate a warning and assume a type of Integer. The warning will indicate that the code should use one of the type conversion operators (Such as ToInteger, ToBuffer, ToDecimalString or ToHexString). Caution: Some of these operators are defined starting with ACPI 2.0 and as such may not be supported by ACPI 1.0b compatible interpreters.</P>
<P CLASS="Body">
<A NAME="pgfId-1363456"></A>For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363458"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524908"></A>Switch (ABCD ())    // Cannot determine the type because methods can return anything.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363459"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363460"></A>    ...case statements...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363461"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363462"></A>will generate a warning and the following code:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363464"></A>Name (_T_I, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363465"></A>Store (ABCD (), _T_I)</P>
<P CLASS="Body">
<A NAME="pgfId-1363466"></A>To remove the warning, the code should be:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363468"></A>Switch (ToInteger (ABCD ()))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363469"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363470"></A>    ...case statements...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363471"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1524915"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363472"></A><A NAME="_Toc489267443"></A><A NAME="ASL_ThermalZone"></A><A NAME="_Toc202342076"></A><A NAME="_Toc258262706"></A>ThermalZone (Declare Thermal Zone)<A NAME="marker-1363477"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363479"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363480"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ThermalZone </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ThermalZoneName</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540766"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363482"></A>Declares a Thermal Zone object named ThermalZoneName. ThermalZone opens a name scope.</P>
<P CLASS="Body">
<A NAME="pgfId-1363483"></A>Each use of a ThermalZone term declares one thermal zone in the system. Each thermal zone in a system is required to have a unique ThermalZoneName.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363484"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363485"></A>A thermal zone may be declared in the namespace anywhere within the &#92;_SB scope. For compatibility with operating systems implementing ACPI 1.0, a thermal zone may also be declared under the &#92;_TZ scope. An ACPI-compatible namespace may define Thermal Zone objects in either the &#92;_SB or &#92;_TZ scope but not both.</P>
<P CLASS="Body">
<A NAME="pgfId-1363486"></A>For example ASL code that uses a ThermalZone statement, see <A HREF="Thermal_management.htm#54593" CLASS="XRef">See Thermal Management.</A>, &#8220;Thermal Management.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1561149"></A>The thermal object list is encoded as TermList, so that rather than describing a static thermal object list, it is possible to describe a dynamic thermal object list according to the system settings. See &quot;<A HREF="ACPI_Software_Programming_Model.htm#36467" CLASS="XRef">See Definition Block Loading.</A>, Definition Block Loading.&quot;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363502"></A><A NAME="ASL_Timer"></A><A NAME="_Toc202342077"></A><A NAME="_Toc258262707"></A>Timer (Get 64-Bit Timer Value) <A NAME="marker-1561176"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363503"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363504"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Timer </EM>
=&gt; Integer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363505"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363506"></A>The timer opcode returns a monotonically increasing value that can be used by ACPI methods to measure time passing, this enables speed optimization by allowing AML code to mark the passage of time independent of OS ACPI interpreter implementation. </P>
<P CLASS="Body">
<A NAME="pgfId-1363507"></A>The Sleep opcode can only indicate waiting for longer than the time specified. </P>
<P CLASS="Body">
<A NAME="pgfId-1363508"></A>The value resulting from this opcode is 64 bits. It is monotonically increasing, but it is not guaranteed that every result will be unique, i.e. two subsequent instructions may return the same value. The only guarantee is that each subsequent evaluation will be greater-than or equal to the previous ones. </P>
<P CLASS="Body">
<A NAME="pgfId-1363509"></A>The period of this timer is 100 nanoseconds. While the underlying hardware may not support this granularity, the interpreter will do the conversion from the actual timer hardware frequency into 100 nanosecond units. </P>
<P CLASS="Body">
<A NAME="pgfId-1363510"></A>Users of this opcode should realize that a value returned only represents the time at which the opcode itself executed. There is no guarantee that the next opcode in the instruction stream will execute in any particular time bound. </P>
<P CLASS="Body">
<A NAME="pgfId-1363511"></A>The OSPM can implement this using the ACPI Timer and keep track of overrun. Other implementations are possible. This provides abstraction away from chipset differences</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1363512"></A>(Compatibility Note) New for ACPI 3.0</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363519"></A><A NAME="_Toc489267517"></A><A NAME="ASL_ToBCD"></A><A NAME="_Toc202342078"></A><A NAME="_Toc258262708"></A>ToBCD (Convert Integer to BCD)<A NAME="marker-1363518"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363520"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363521"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToBCD </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Value, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540778"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363523"></A>Value is evaluated as an integer</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363524"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363525"></A>The ToBCD operator is used to convert Value from a numeric (Integer) format to a BCD format and optionally store the numeric value into Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363526"></A><A NAME="_Toc489267472"></A><A NAME="ASL_ToBuffer"></A><A NAME="_Toc202342079"></A><A NAME="_Toc258262709"></A>ToBuffer (Convert Data to Buffer)<A NAME="marker-1363531"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363535"></A><A NAME="_Toc465246106"></A><A NAME="_Toc469218414"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363536"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToBuffer </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Data, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540790"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363538"></A>Data must be an Integer, String, or Buffer data type. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363539"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363540"></A>Data is converted to buffer type and the result is optionally stored into Result. If Data is an integer, it is converted into n bytes of buffer (where n is 4 if the definition block has defined integers as 32 bits or 8 if the definition block has defined integers as 64 bits as indicated by the Definition Block table header&#8217;s Revision field), taking the least significant byte of integer as the first byte of buffer. If Data is a buffer, no conversion is performed. If Data is a string, each ASCII string character is copied to one buffer byte, including the string null terminator. A null (zero-length) string will be converted to a zero-length buffer.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363541"></A><A NAME="_Toc489267478"></A><A NAME="ASL_ToDecimalString"></A><A NAME="_Toc202342080"></A><A NAME="_Toc258262710"></A>ToDecimalString (Convert Data to Decimal String)<A NAME="marker-1363546"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363548"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363549"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToDecimalString </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Data, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540802"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363551"></A>Data must be an Integer, String, or Buffer data type. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363552"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363553"></A>Data is converted to a decimal string, and the result is optionally stored into Result. If Data is already a string, no action is performed. If Data is a buffer, it is converted to a string of decimal values separated by commas. (Each byte of the buffer is converted to a single decimal value.) A zero-length buffer will be converted to a null (zero-length) string.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363563"></A><A NAME="_Toc489267484"></A><A NAME="ASL_ToHexString"></A><A NAME="_Toc202342081"></A><A NAME="_Toc258262711"></A>ToHexString (Convert Data to Hexadecimal String)<A NAME="marker-1363562"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363566"></A><A NAME="_Toc465246115"></A><A NAME="_Toc469218423"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363567"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToHexString </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Data, Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540814"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363569"></A>Data must be an Integer, String, or Buffer data type. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363570"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363571"></A>Data is converted to a hexadecimal string, and the result is optionally stored into Result. If Data is already a string, no action is performed. If Data is a buffer, it is converted to a string of hexadecimal values separated by commas. A zero-length buffer will be converted to a null (zero-length) string.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363578"></A><A NAME="_Toc489267490"></A><A NAME="ASL_ToInteger"></A><A NAME="_Toc202342082"></A><A NAME="_Toc258262712"></A>ToInteger (Convert Data to Integer)<A NAME="marker-1363577"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363579"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363580"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToInteger </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Data,</EM>
 <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540826"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363582"></A>Data must be an Integer, String, or Buffer data type. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363583"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363584"></A>Data is converted to integer type and the result is optionally stored into Result. If Data is a string, it must be either a decimal or hexadecimal numeric string (in other words, prefixed by &#8220;0x&#8221;) and the value must not exceed the maximum of an integer value. If the value is exceeding the maximum, the result of the conversion is unpredictable. A null (zero-length) string is illegal. If Data is a Buffer, the first 8 bytes of the buffer are converted to an integer, taking the first byte as the least significant byte of the integer. A zero-length buffer is illegal. If Data is an integer, no action is performed.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1551768"></A><A NAME="51336"></A>ToPLD (Creates a _PLD Buffer Object)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1551769"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1551770"></A><EM CLASS="Bold">
ToPLD</EM>
 (<EM CLASS="Italic">
PLDKeywordList</EM>
) =&gt; _PLD Buffer Object</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1551771"></A>Arguments</H3>
<P CLASS="Body">
<A NAME="pgfId-1551772"></A><EM CLASS="Italic">
PLDKeywordList</EM>
 is a list of <EM CLASS="Italic">
PLDKeyword</EM>
 types that describe elements of a Physical Layer Description (_PLD) buffer that can be assigned values. The table below shows the available <EM CLASS="Italic">
PLDKeyword</EM>
 types and their assignable types. Refer to the _PLD section for a description of the _PLD method object.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1551887"></A>PLD Keywords and Assignment Types</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1569784"></A>PLDKeyword</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1569786"></A>Assignment Type</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551780"></A>PLD_Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551782"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551784"></A>PLD_IgnoreColor </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551786"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551788"></A>PLD_Red</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551790"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551792"></A>PLD_Green</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551794"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551796"></A>PLD_Blue</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551798"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551800"></A>PLD_Width</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551802"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551804"></A>PLD_Height</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551806"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551808"></A>PLD_UserVisible</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551810"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551812"></A>PLD_Dock</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551814"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551816"></A>PLD_Lid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551818"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551820"></A>PLD_Panel</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551822"></A>Integer or String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551824"></A>PLD_VerticalPosition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551826"></A>Integer or String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551828"></A>PLD_HorizontalPosition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551830"></A>Integer or String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551832"></A>PLD_Shape</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551834"></A>Integer or String</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551836"></A>PLD_GroupOrientation</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551838"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551840"></A>PLD_GroupToken</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551842"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551844"></A>PLD_GroupPosition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551846"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551848"></A>PLD_Bay</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551850"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551852"></A>PLD_Ejectable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551854"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551856"></A>PLD_EjectRequired</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551858"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551860"></A>PLD_CabinetNumber</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551862"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551864"></A>PLD_CardCageNumber</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551866"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551868"></A>PLD_Reference</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551870"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551872"></A>PLD_Rotation</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551874"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551876"></A>PLD_Order</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551878"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551880"></A>PLD_VeriticalOffset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551882"></A>Integer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551884"></A>PLD_HorizontalOffset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551886"></A>Integer</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1551890"></A>A subset of PLDKeyword types can be assigned string values for improved readability. Those types and their assignable values are shown in the table below.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1551918"></A>PLD Keywords and assignable String Values</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1551894"></A>PLDKeyword</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1551896"></A>Assignable String Values</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551898"></A>PLD_Panel</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551900"></A>&#8220;TOP&#8221;, &#8220;BOTTOM&#8221;,&#8221;LEFT&#8221;, &#8220;RIGHT&#8221;,&#8221;FRONT&#8221;,&#8221;BACK&#8221;,&#8221;UNKNOWN&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551902"></A>PLD_VerticalPosition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551904"></A>&#8220;UPPER&#8221;,&#8221;CENTER&#8221;,&#8221;LOWER&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551906"></A>PLD_HorizontalPosition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551908"></A>&#8220;LEFT&#8221;,&#8221;CENTER&#8221;,&#8221;RIGHT&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551910"></A>PLD_Shape</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1551912"></A>&#8220;ROUND&#8221;,&#8221;OVAL&#8221;,&#8221;SQUARE&#8221;,</P>
<P CLASS="TableBody">
<A NAME="pgfId-1551913"></A>&#8220;VERTICALRECTANGLE&#8221;,</P>
<P CLASS="TableBody">
<A NAME="pgfId-1551914"></A>&#8220;HORIZONTALRECTANGLE&#8221;,</P>
<P CLASS="TableBody">
<A NAME="pgfId-1551915"></A>&#8220;VERTICALTRAPEZOID&#8221;,</P>
<P CLASS="TableBody">
<A NAME="pgfId-1551916"></A>&#8220;HORIZONTALTRAPEZOID&#8221;,</P>
<P CLASS="TableBody">
<A NAME="pgfId-1551917"></A>&#8220;UNKNOWN&#8221;</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1551921"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1551922"></A>The ToPLD macro converts a list of PLDKeyword types into a _PLD buffer object. </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1551924"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1551925"></A>The following ASL shows an example using ToPLDto construct a _PLD buffer/package object.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551927"></A>Name (_PLD, Package (0x01)  // _PLD: Physical Location of Device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551928"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551929"></A>        ToPLD (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551930"></A>            PLD_Revision           = 0x2,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551931"></A>            PLD_IgnoreColor        = 0x1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551932"></A>            PLD_Red                = 0x37,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551933"></A>            PLD_Green              = 0x44,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551934"></A>            PLD_Blue               = 0xFF,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551935"></A>            PLD_Width              = 0x4,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551936"></A>            PLD_Height             = 0x19,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551937"></A>            PLD_UserVisible        = 0x1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551938"></A>            PLD_Dock               = 0x0,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551939"></A>            PLD_Lid                = 0x1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551940"></A>            PLD_Panel              = &quot;TOP&quot;,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551941"></A>            PLD_VerticalPosition   = &quot;CENTER&quot;,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551942"></A>            PLD_HorizontalPosition = &quot;RIGHT&quot;,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551943"></A>            PLD_Shape              = &quot;VERTICALRECTANGLE&quot;,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551944"></A>            PLD_GroupOrientation   = 0x1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551945"></A>            PLD_GroupToken         = 0xA,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551946"></A>            PLD_GroupPosition      = 0x21,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551947"></A>            PLD_Bay                = 0x1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551948"></A>            PLD_Ejectable          = 0x0,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551949"></A>            PLD_EjectRequired      = 0x1,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551950"></A>            PLD_CabinetNumber      = 0x1E,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551951"></A>            PLD_CardCageNumber     = 0x17,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551952"></A>            PLD_Reference          = 0x0,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551953"></A>            PLD_Rotation           = 0x7,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551954"></A>            PLD_Order              = 0x3,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551955"></A>            PLD_VerticalOffset     = 0x141,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551956"></A>            PLD_HorizontalOffset   = 0x2C)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1551764"></A>    })</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363591"></A><A NAME="_Toc489267515"></A><A NAME="ASL_ToString"></A><A NAME="_Toc202342083"></A><A NAME="_Toc258262713"></A>ToString (Convert Buffer To String)<A NAME="marker-1363590"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363592"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363593"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToString </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source</EM>
,<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
 Length</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Result</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Italic-Char-Char">
 </EM>
=&gt; String</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540838"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363595"></A>Source is evaluated as a buffer. Length is evaluated as an integer data type.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363596"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363597"></A>Starting with the first byte, the contents of the buffer are copied into the string until the number of characters specified by Length is reached or a null (0) character is found. If Length is not specified or is Ones, then the contents of the buffer are copied until a null (0) character is found. If the source buffer has a length of zero, a zero length (null terminator only) string will be created. The result is copied into the Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363604"></A><A NAME="ASL_UUID"></A><A NAME="_Toc202342084"></A><A NAME="_Toc258262714"></A>ToUUID (Convert String to UUID Macro)<A NAME="marker-1363602"></A> <A NAME="marker-1363603"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363605"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363606"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
ToUUID</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AsciiString</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540850"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363608"></A>AsciiString is evaluated as a String data type.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363609"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363610"></A>This macro will convert an ASCII string to a 128-bit buffer. The string must have the following format:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1363611"></A>aabbccdd-eeff-gghh-iijj-kkllmmnnoopp</P>
<P CLASS="Body">
<A NAME="pgfId-1363612"></A>where aa - pp are one byte hexadecimal numbers, made up of hexadecimal digits. The resulting buffer has the following format:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1363613"></A>UUID Buffer Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1495003"></A>String</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1495005"></A>Offset In Buffer</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363620"></A>aa</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363622"></A>3</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363624"></A>bb</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363626"></A>2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363628"></A>cc</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363630"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363632"></A>dd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363634"></A>0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363636"></A>ee</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363638"></A>5</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363640"></A>ff</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363642"></A>4</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363644"></A>gg</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363646"></A>7</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363648"></A>hh</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363650"></A>6</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363652"></A>ii</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363654"></A>8</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363656"></A>jj</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363658"></A>9</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363660"></A>kk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363662"></A>10</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363664"></A>ll</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363666"></A>11</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363668"></A>mm</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363670"></A>12</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363672"></A>nn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363674"></A>13</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363676"></A>oo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363678"></A>14</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363680"></A>pp</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363682"></A>15</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1363685"></A>(Compatibility Note) New for ACPI 3.0</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1541090"></A><A NAME="41859"></A>UARTSerialBusV2 (UART Serial Bus Connection Resource Descriptor (Version 2) Macro)<A NAME="marker-1541089"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1541091"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1541092"></A><EM CLASS="Bold">
UARTSerialBusV2 </EM>
(InitialBaudRate, BitsPerByte, StopBits, LinesInUse, IsBigEndian, Parity, FlowControl, ReceiveBufferSize, TransmitBufferSize, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, Shared, VendorData)</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1541223"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1541094"></A>InitialBaudRate evaluates to a 32-bit integer that specifies the default or initial connection speed in bytes per second that the device supports. The bit field _SPE is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541095"></A>BitsPerByte is an optional argument that specifies whether five bits (DataBitsFive), six bits (DataBitsSix), seven bits (DataBitsSeven), eight bits (DataBitsEight) or nine bits (DataBitsNine) contain data during transfer of a single packet or character. DataBitsEight is the default. The bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541096"></A>StopBits is an optional argument that specifies whether there are two bits (StopBitsTwo), one and a half bits (StopBitsOnePlusHalf), one bit (StopBitsOne) or no bits (StopBitsZero) used to signal the end of a packet or character. StopBitsOne is the default. The bit field _STB is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541097"></A>LinesInUse evaluates to an integer representing 8 1-bit flags representing the presence (&#8216;1&#8217;) or absence (&#8216;0&#8217;) of a particular line. The bit field _LIN is automatically created to refer to this portion of the resource descriptor.</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1541100"></A>Bit Mask</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1541102"></A>UART Line</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541104"></A>Bit 7 (0x80)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541106"></A>Request To Send (RTS)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541108"></A>Bit 6 (0x40)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541110"></A>Clear To Send (CTS)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541112"></A>Bit 5 (0x20)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541114"></A>Data Terminal Ready (DTR)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541116"></A>Bit 4 (0x10)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541118"></A>Data Set Ready (DSR)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541120"></A>Bit 3 (0x08)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541122"></A>Ring Indicator (RI)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541124"></A>Bit 2 (0x04)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541126"></A>Data Carrier Detect (DTD)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541128"></A>Bit 1 (0x02)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541130"></A>Reserved. Must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541132"></A>Bit 0 (0x01)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1541134"></A>Reserved. Must be 0.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1541137"></A>IsBigEndian is an optional argument that specifies whether the device is expecting big endian (BigEndian) or little endian (LittleEndian) data formats. LittleEndian is the default. The bit field _END is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1543208"></A>Parity is an optional argument that specifies whether the type of parity bits included after the data in a packet are to be interpreted as space parity (ParityTypeSpace), mark parity (ParityTypeMark), odd parity (ParityTypeOdd), even parity (ParityTypeEven) or no parity (ParityTypeNone). ParityTypeNone is the default. The bit field PAR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541140"></A>FlowControl is an optional argument that specifies whether there is hardware-based flow control (FlowControlHardware), software-based flow control (FlowControlXON) or no flow control (FlowControlNone) used when communicating with the device. FlowControlNone is the default. The bit field_FLC is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541144"></A>ReceiveBufferSize evaluates to a 16-bit integer that specifies the upper limit in bytes of the receive buffer that can be optimally utilized while communicating with this device. The bit field_RXL is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541146"></A>TransmitBufferSize evaluates to a 16-bit integer that specifies the upper limit in bytes of the transmit buffer that can be optimally utilized while communicating with this device. The bit field _TXL is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1541147"></A>ResourceSource is a string which uniquely identifies the UART bus controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules. </P>
<P CLASS="Body">
<A NAME="pgfId-1541148"></A>ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1541149"></A>ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.</P>
<P CLASS="Body">
<A NAME="pgfId-1541150"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1541151"></A><EM CLASS="Italic">
Shared</EM>
 is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1559548"></A>VendorData is an optional argument that specifies an object to be decoded by the OS driver. It is a RawDataBuffer. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1541187"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1541074"></A>The UARTSerialBusV2 macro evaluates to a buffer that contains a UART Serial Bus resource descriptor (Version 2). The macro is designed to be used inside of a ResourceTemplate (see<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341949" CLASS="XRef">See ASL Resource Templates.</A> ).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363693"></A><A NAME="_Toc489267535"></A><A NAME="ASL_Unicode"></A><A NAME="_Toc202342085"></A><A NAME="_Toc258262715"></A>Unicode (String To Unicode Conversion Macro)<A NAME="marker-1363691"></A><A NAME="marker-1363692"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363694"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363695"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Unicode </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
String</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Buffer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540862"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363697"></A>This macro will convert a string to a Unicode (UTF-16) string contained in a buffer. The format of the Unicode string is 16 bits per character, with a 16-bit null terminator.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363724"></A><A NAME="_Toc489267466"></A><A NAME="ASL_Unload"></A><A NAME="_Toc202342086"></A><A NAME="_Toc258262716"></A><A NAME="ASL_VendorLong"></A><A NAME="_Toc202342087"></A><A NAME="_Toc258262717"></A>VendorLong (Long Vendor Resource Descriptor)<A NAME="marker-1363722"></A><A NAME="marker-1363723"></A></H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363725"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363726"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
VendorLong </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
) {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
VendorByteList</EM>
}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540886"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363728"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer.</P>
<P CLASS="Body">
<A NAME="pgfId-1363729"></A>VendorByteList evaluates to a comma-separated list of 8-bit integer constants, where each byte is added verbatim to the body of the VendorLong resource descriptor. A maximum of n bytes can be specified. UUID and UUID specific descriptor subtype are part of the VendorByteList.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363730"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363731"></A>The VendorLong macro evaluates to a buffer which contains a vendor-defined resource descriptor. The format of the long form of the vendor-defined resource descriptor can be found in Vendor-Defined Descriptor  (<A HREF="Device_Configuration.htm#AML_VendorShort" CLASS="XRef">Vendor-Defined Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1363732"></A>This is similar to VendorShort (<A HREF="ACPI_Source_Language_Reference.htm#ASL_VendorShort" CLASS="XRef">VendorShort (Short Vendor Resource Descriptor)</A>), except that the number of allowed bytes in VendorByteList is 65,533 (instead of 7).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1572980"></A><A NAME="83985"></A>{deprec ated} Unload (Unload Definition Block) </H6>
<P CLASS="Body">
<A NAME="pgfId-1572981"></A>Syntax</P>
<P CLASS="Body">
<A NAME="pgfId-1572982"></A>Unload (Handle)</P>
<P CLASS="Body">
<A NAME="pgfId-1572983"></A>Arguments</P>
<P CLASS="Body">
<A NAME="pgfId-1572984"></A>Handle is evaluated as a DDBHandle data type.</P>
<P CLASS="Body">
<A NAME="pgfId-1572985"></A>Description</P>
<P CLASS="Body">
<A NAME="pgfId-1572976"></A>Performs a run-time unload of a Definition Block that was loaded using a Load term or LoadTable term. Loading or unloading a Definition Block is a synchronous operation, and no control method execution occurs during the function. On completion of the Unload operation, the Definition Block has been unloaded (all the namespace objects created as a result of the corresponding Load operation will be removed from the namespace).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363740"></A><A NAME="ASL_VendorShort"></A><A NAME="_Toc202342088"></A><A NAME="_Toc258262718"></A>VendorShort (Short Vendor Resource Descriptor<A NAME="marker-1363737"></A><A NAME="marker-1363738"></A><A NAME="marker-1363739"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363741"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363742"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
VendorShort </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
DescriptorName</EM>
) {<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
VendorByteList</EM>
}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1363743"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363744"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363745"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363746"></A>The VendorShort macro evaluates to a buffer which contains a vendor-defined resource descriptor. The format of the short form of the vendor-defined resource descriptor can be found in &#8220;Vendor-Defined Descriptor&#8221; (<A HREF="Device_Configuration.htm#AML_VendorShort" CLASS="XRef">Vendor-Defined Descriptor</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1363747"></A>This is similar to VendorLong (<A HREF="ACPI_Source_Language_Reference.htm#ASL_VendorLong" CLASS="XRef">VendorLong (Long Vendor Resource Descriptor)</A>), except that the number of allowed bytes in VendorByteList is 7 (instead of 65,533).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363754"></A><A NAME="_Toc489267518"></A><A NAME="ASL_Wait"></A><A NAME="_Toc202342089"></A><A NAME="_Toc258262719"></A>Wait (Wait for a Synchronization Event)<A NAME="marker-1363753"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363755"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363756"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Wait </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
SyncObject, TimeoutValue</EM>
)<EM CLASS="Style-Syntax-Element-Bold-Char-Char">
 </EM>
=&gt; Boolean</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540898"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363758"></A>SynchObject must be an event synchronization object. TimeoutValue is evaluated as an Integer. The calling method blocks while waiting for the event to be signaled.<A NAME="marker-1363759"></A></P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363760"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363761"></A>The pending signal count is decremented. If there is no pending signal count, the processor is relinquished until a signal count is posted to the Event or until at least TimeoutValue milliseconds have elapsed. </P>
<P CLASS="Body">
<A NAME="pgfId-1363762"></A>This operation returns a non-zero value if a timeout occurred and a signal was not acquired. A TimeoutValue of 0xFFFF (or greater) indicates that there is no time out and the operation will wait indefinitely.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363769"></A><A NAME="_Toc489267467"></A><A NAME="ASL_While"></A><A NAME="_Toc202342090"></A><A NAME="_Toc258262720"></A>While (Conditional Loop)<A NAME="marker-1363768"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363770"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363771"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
While </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Predicate</EM>
) {TermList}</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540910"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363773"></A>Predicate is evaluated as an integer. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363774"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363775"></A>If the Predicate is non-zero, the list of terms in TermList is executed. The operation repeats until the Predicate evaluates to zero.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1363776"></A>Creation of a named object more than once in a given scope is not allowed. As such, unconditionally creating named objects within a While loop must be avoided. A fatal error will be generated on the second iteration of the loop, during the attempt to create the same named object a second time.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363783"></A><A NAME="ASL_WordBusNumber"></A><A NAME="_Toc202342091"></A><A NAME="_Toc258262721"></A>WordBusNumber (Word Bus Number Resource Descriptor Macro)<A NAME="marker-1363781"></A><A NAME="marker-1363782"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363784"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363785"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
WordBusNumber </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMinFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMaxFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Decode</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressGranularity, AddressMinimum, AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressTranslation</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceSourceIndex, ResourceSource, DescriptorName)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540922"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363787"></A>ResourceUsage specifies whether the bus range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363788"></A>IsMinFixed specifies whether the minimum address of this bus number range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363789"></A>IsMaxFixed specifies whether the maximum address of this bus number range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363790"></A>Decode specifies whether or not the device decodes the bus number range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1363791"></A>AddressGranularity evaluates to a 16-bit integer that specifies the power-of-two boundary (- 1) on which the bus number range must be aligned. The 16-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363792"></A>AddressMinimum evaluates to a 16-bit integer that specifies the lowest possible bus number for the bus number range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363793"></A>AddressMaximum evaluates to a 16-bit integer that specifies the highest possible bus number for the bus number range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363794"></A>AddressTranslation evaluates to a 16-bit integer that specifies the offset to be added to a secondary bus bus number which results in the corresponding primary bus bus number. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 16-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363795"></A>RangeLength evaluates to a 16-bit integer that specifies the total number of bus numbers decoded in the bus number range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363796"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1363797"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1363798"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363799"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1444224"></A>The WordBusNumber macro evaluates to a buffer which contains a 16-bit bus-number resource descriptor. The format of the 16-bit bus number resource descriptor can be found in &#8220;Word Address Space Descriptor &#8221; (<A HREF="Device_Configuration.htm#61483" CLASS="XRef">WORD Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1370916"></A><A NAME="ASL_WordIO"></A><A NAME="_Toc202342092"></A><A NAME="_Toc258262722"></A>WordIO (Word IO Resource Descriptor Macro)<A NAME="marker-1370914"></A><A NAME="marker-1370915"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1370917"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363813"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
WordIO </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMinFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMaxFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Decode</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ISARanges</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressGranularity, AddressMinimum, AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressTranslation</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceSourceIndex, ResourceSource, DescriptorName, TranslationType, TranslationDensity)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540934"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363815"></A>ResourceUsage specifies whether the I/O range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363816"></A>IsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363817"></A>IsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363818"></A>Decode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1363819"></A>ISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2-bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is NonISAOnly, &#8216;2&#8217; is ISAOnly and &#8216;0&#8217; is EntireRange.</P>
<P CLASS="Body">
<A NAME="pgfId-1363820"></A>AddressGranularity evaluates to a 16-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 16-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363821"></A>AddressMinimum evaluates to a 16-bit integer that specifies the lowest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363822"></A>AddressMaximum evaluates to a 16-bit integer that specifies the highest possible base address of the I/O range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363823"></A>AddressTranslation evaluates to a 16-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 16-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363824"></A>RangeLength evaluates to a 16-bit integer that specifies the total number of bytes decoded in the I/O range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363825"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1363826"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1363827"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
<P CLASS="Body">
<A NAME="pgfId-1444214"></A>TranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is TypeTranslation and &#8216;0&#8217; is TypeStatic. See _TTP (<A HREF="Device_Configuration.htm#51978" CLASS="XRef">I/O Resource Flag (Resource Type = 1) Definitions</A>) for more information</P>
<P CLASS="Body">
<A NAME="pgfId-1444215"></A>TranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName. _TRS is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SparseTranslation and &#8216;0&#8217; is DenseTranslation. See _TRS (<A HREF="Device_Configuration.htm#51978" CLASS="XRef">I/O Resource Flag (Resource Type = 1) Definitions</A>) for more information. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363830"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1549503"></A>The WordIO macro evaluates to a buffer which contains a 16-bit I/O range resource descriptor. The format of the 16-bit I/O range resource descriptor can be found in &#8220;Word Address Space Descriptor &#8221; (<A HREF="Device_Configuration.htm#61483" CLASS="XRef">WORD Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1549524"></A><A NAME="_Toc64957499"></A><A NAME="_Toc64958794"></A><A NAME="_Toc64960439"></A><A NAME="_Toc64966062"></A><A NAME="_Toc64968222"></A><A NAME="_Toc64971113"></A><A NAME="_Toc65032239"></A><A NAME="_Toc65047540"></A><A NAME="_Toc65050871"></A><A NAME="ASL_WordSpace"></A><A NAME="_Toc202342093"></A><A NAME="_Toc258262723"></A>WordSpace (Word Space Resource Descriptor Macro) )<A NAME="marker-1549522"></A><A NAME="marker-1549523"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1549525"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363868"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
WordSpace </EM>
(ResourceType, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceUsage</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Decode</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMinFixed</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
IsMaxFixed,</EM>
 TypeSpecificFlags, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressGranularity, AddressMinimum, AddressMaximum</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
AddressTranslation</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
RangeLength</EM>
, <EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ResourceSourceIndex, ResourceSource, DescriptorName)</EM>
</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540946"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363870"></A>ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.</P>
<P CLASS="Body">
<A NAME="pgfId-1363871"></A>ResourceUsage specifies whether the bus range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363872"></A>Decode specifies whether or not the device decodes the bus number range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is SubDecode and &#8216;0&#8217; is PosDecode.</P>
<P CLASS="Body">
<A NAME="pgfId-1363873"></A>IsMinFixed specifies whether the minimum address of this bus number range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MinFixed and &#8216;0&#8217; is MinNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363874"></A>IsMaxFixed specifies whether the maximum address of this bus number range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where &#8216;1&#8217; is MaxFixed and &#8216;0&#8217; is MaxNotFixed.</P>
<P CLASS="Body">
<A NAME="pgfId-1363875"></A>TypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.</P>
<P CLASS="Body">
<A NAME="pgfId-1363876"></A>AddressGranularity evaluates to a 16-bit integer that specifies the power-of-two boundary (- 1) on which the bus number range must be aligned. The 16-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363877"></A>AddressMinimum evaluates to a 16-bit integer that specifies the lowest possible bus number for the bus number range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363878"></A>AddressMaximum evaluates to a 16-bit integer that specifies the highest possible bus number for the bus number range. The value must have &#8216;0&#8217; in all bits where the corresponding bit in AddressGranularity is &#8216;1&#8217;. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363879"></A>AddressTranslation evaluates to a 16-bit integer that specifies the offset to be added to a secondary bus bus number which results in the corresponding primary bus bus number. For all non-bridge devices or bridges which do not perform translation, this must be &#8216;0&#8217;. The 16-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363880"></A>RangeLength evaluates to a 16-bit integer that specifies the total number of bus numbers decoded in the bus number range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1363881"></A>ResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.</P>
<P CLASS="Body">
<A NAME="pgfId-1363882"></A>ResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed. </P>
<P CLASS="Body">
<A NAME="pgfId-1363883"></A>DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363884"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363885"></A>The WordSpace macro evaluates to a buffer which contains a 16-bit Address Space resource descriptor. The format of the 16-bit Address Space resource descriptor can be found in &#8220;Word Address Space Descriptor &#8221; (<A HREF="Device_Configuration.htm#61483" CLASS="XRef">WORD Address Space Descriptor Definition</A>). The macro is designed to be used inside of a ResourceTemplate (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267534" CLASS="XRef">ResourceTemplate (Resource To Buffer Conversion Macro)</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363893"></A><A NAME="ASL_XOr"></A><A NAME="_Toc202342094"></A><A NAME="_Toc258262724"></A>XOr (Integer Bitwise Xor<A NAME="marker-1363891"></A>)</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363894"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363895"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
XOr </EM>
(<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
Source1, Source2, Result</EM>
) =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556665"></A><EM CLASS="Italic">
Result</EM>
 = <EM CLASS="Italic">
Source1</EM>
 ^ <EM CLASS="Italic">
Source2</EM>
 =&gt; Integer</P>
<P CLASS="Body">
<A NAME="pgfId-1556666"></A><EM CLASS="Italic">
Result</EM>
 ^= Source =&gt; Integer</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1540958"></A>Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId-1363897"></A>Source1 and Source2 are evaluated as Integers.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363898"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363899"></A>A bitwise XOR is performed and the result is optionally stored into Result.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363909"></A><A NAME="_Toc489267528"></A><A NAME="ASL_Zero"></A><A NAME="_Toc202342095"></A><A NAME="_Toc258262725"></A>Zero (Constant Zero Integer)<A NAME="marker-1363908"></A></H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363910"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-1363911"></A>Zero =&gt; Integer</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1363912"></A>Description</H3>
<P CLASS="Body">
<A NAME="pgfId-1363913"></A>The Zero operator returns an Integer with the value 0. Writes to this object are not allowed. The use of this operator can reduce AML code size, since it is represented by a one-byte AML opcode.</P>
</DIV>
</DIV>
</DIV>
</BODY>
</HTML>
