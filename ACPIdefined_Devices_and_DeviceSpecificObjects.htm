<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2016/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 9 ACPI-Defined Devices and Device-Specific Objects</TITLE></HEAD>
<BODY>
<DIV>
<H1 CLASS="Heading-1">
<A NAME="pgfId-1375753"></A><A NAME="91076"></A>ACPI-Defined Devices and Device-Specific Objects<DIV>
<IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-1.gif" ALT="">
</DIV>
</H1>
<P CLASS="Body">
<A NAME="pgfId-1377656"></A>This section describes ACPI defined devices and device-specific objects. The system status indicator objects, declared under the &#92;_SI scope in the ACPI Namespace, are also specified in this section.</P>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1379572"></A>Device Object Name Collision</H2>
<P CLASS="Body">
<A NAME="pgfId-1379573"></A>Devices containing both _HID and _CID may have device specific control methods pertaining to both the device ID in the _HID and the device ID in the _CID. These device specific control methods are defined by the device owner (a standard body or a vendor or a group of vendor partners). Since these object names are not controlled by a central authority, there is a likelihood that the names of objects will conflict between two defining parties. The _DSM object described in the next section solves this conflict.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379580"></A><A NAME="RSVD_DSM"></A><A NAME="_Toc202341717"></A><A NAME="_Toc258262394"></A>_DSM (Device Specific Method)<A NAME="marker-1505134"></A><A NAME="marker-1505135"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1379581"></A>This optional object is a control method that enables devices to provide device specific control functions that are consumed by the device driver.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379582"></A>Arguments: (4)</H4>
<P CLASS="Body">
<A NAME="pgfId-1379583"></A>Arg0 - A Buffer containing a UUID</P>
<P CLASS="Body">
<A NAME="pgfId-1379584"></A>Arg1 - An Integer containing the Revision ID</P>
<P CLASS="Body">
<A NAME="pgfId-1379585"></A>Arg2 - An Integer containing the Function Index</P>
<P CLASS="Body">
<A NAME="pgfId-1379586"></A>Arg3 - A Package that contains function-specific arguments</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379587"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379588"></A>If Function Index = 0, a Buffer containing a function index bitfield. Otherwise, the return value and type depends on the UUID and revision ID (see below).</P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379589"></A>Argument Information:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379590"></A>Arg0: 	UUID - A Buffer containing the UUID (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc202340533" CLASS="XRef">See Universally Unique Identifiers (UUIDs).</A>) (16 Bytes)</P>
<P CLASS="Body">
<A NAME="pgfId-1379591"></A>Arg1:	Revision ID - the function&#8217;s revision. This revision is specific to the UUID.</P>
<P CLASS="Body">
<A NAME="pgfId-1379592"></A>Arg2: 	Function Index - Represents a specific function whose meaning is specific to the UUID and Revision ID. Function indices should start with 1. Function number zero is a query function (see the special return code defined below). </P>
<P CLASS="Body">
<A NAME="pgfId-1379593"></A>Arg3: 	<EM CLASS="Italic">
Function Argum</EM>
ents - a package containing the parameters for the function specified by the UUID, Revision ID and Function Index. </P>
<P CLASS="Body">
<A NAME="pgfId-1505299"></A>Successive revisions of Function Arguments must be backward compatible with earlier revisions. New UUIDs may also be created by OEMs and IHVs for custom devices and other interface or device governing bodies (e.g. the PCI SIG), as long as the UUID is different from other published UUIDs. Only the issuer of a UUID can authorize a new Function Index, Revision ID or Function Argument for that UUID.</P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379594"></A>Return Value Information:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379595"></A>If Function Index is zero, the return is a buffer containing one bit for each function index, starting with zero. Bit 0 indicates whether there is support for any functions other than function 0 for the specified UUID and Revision ID. If set to zero, no functions are supported (other than function zero) for the specified UUID and Revision ID. If set to one, at least one additional function is supported. For all other bits in the buffer, a bit is set to zero to indicate if that function index is not supported for the specific UUID and Revision ID. (For example, bit 1 set to 0 indicates that function index 1 is not supported for the specific UUID and Revision ID.)</P>
<P CLASS="Body">
<A NAME="pgfId-1495571"></A>If the bit representing a particular function index would lie outside of the buffer, it should be assumed to be 0 (that is, not supported).</P>
<P CLASS="Body">
<A NAME="pgfId-1505322"></A>If Function Index is non-zero, the return is any data object. The type and meaning of the returned data object depends on the UUID, Revision ID, Function Index, and Function Arguments.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1499177"></A>For backward compatibility _DSM requires that each Revision ID support all of the functions defined by all previous Revision IDs for the same UUID.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379597"></A>Implementation Note</H4>
<P CLASS="Body">
<A NAME="pgfId-1379598"></A>Since the purpose of the _DSM method is to avoid the namespace collision, the implementation of this method shall not use any other method or data object which is not defined in this specification unless its driver and usage is completely under the control of the platform vendor. </P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379599"></A>Example: </H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1379601"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493901"></A>// _DSM - Device Specific Method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379602"></A>//</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379603"></A>// Arg0: UUID  Unique function identifier</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379604"></A>// Arg1:  Integer  Revision Level</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379605"></A>// Arg2:  Integer  Function Index (0 = Return Supported Functions)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379606"></A>// Arg3:  Package  Parameters</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379607"></A>Function(_DSM,{IntObj,BuffObj},{BuffObj, IntObj, IntObj, PkgObj})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379608"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379609"></A> //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379610"></A> // Switch based on which unique function identifier was passed in</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379611"></A> //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379612"></A> switch(Arg0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379613"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379614"></A>  //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379615"></A>  // First function identifier</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379616"></A>  //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379617"></A>  case(ToUUID(&#8220;893f00a6-660c-494e-bcfd-3043f4fb67c0&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379618"></A>  {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379619"></A>   switch(Arg2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379620"></A>   {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379621"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379622"></A>    // Function 0: Return supported functions, based on revision</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379623"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379624"></A>    case(0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379625"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379626"></A>     switch(Arg1)   </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379627"></A>     {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379628"></A>      // revision 0: functions 1-4 are supported</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379629"></A>      case(0) {return (Buffer() {0x1F})} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379630"></A>      // revision 1: functions 1-5 are supported</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379631"></A>      case(1) {return (Buffer() {0x3F})} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379632"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379633"></A>     // revision 2+: functions 1-7 are supported</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379634"></A>     return (Buffer() {0xFF})  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379635"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379636"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379637"></A>    // Function 1:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379638"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379639"></A>    case(1) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379640"></A>    { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379641"></A>     ... function 1 code ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379642"></A>     Return(Zero)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379643"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379644"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379645"></A>    // Function 2:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379646"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379647"></A>    case(2) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379648"></A>    { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379649"></A>     ... function 2 code ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379650"></A>     Return(Buffer(){0x00})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379651"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379652"></A>    case(3) { ... function 3 code ...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379653"></A>    case(4) { ... function 4 code ...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379654"></A>    case(5) { if (LLess(Arg1,1) BreakPoint; ... function 5 code ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379655"></A>    case(6) { if (LLess(Arg1,2) BreakPoint; ... function 6 code ... )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379656"></A>    case(7) { if (LLess(Arg1,3) BreakPoint; ... function 7 code ... )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379657"></A>    default {BreakPoint }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379658"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379659"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379660"></A>  //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379661"></A>  // Second function identifier</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379662"></A>  //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379663"></A>  case(ToUUID(&#8220;107ededd-d381-4fd7-8da9-08e9a6c79644&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379664"></A>  {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379665"></A>   //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379666"></A>   // Function 0: Return supported functions (there is only one revision)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379667"></A>   //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379668"></A>   if (LEqual(Arg2,Zero))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379669"></A>    return (Buffer() {0x3}) // only one function supported</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379670"></A>   //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379671"></A>   // Function 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379672"></A>   //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379673"></A>   if (LEqual(Arg2,One))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379674"></A>   { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379675"></A>    ... function 1 code ... </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379676"></A>    Return(Unicode(&#8220;text&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379677"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379678"></A>   //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379679"></A>   // Function 2+: Runtime Error</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379680"></A>   //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379681"></A>   else    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379682"></A>    BreakPoint;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379683"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379684"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379685"></A> //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379686"></A> // If not one of the UUIDs we recognize, then return a buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379687"></A> // with bit 0 set to 0 indicating no functions supported.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379688"></A> //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379689"></A> return(Buffer(){0})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379690"></A>}</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1377675"></A><A NAME="_Toc489256134"></A><A NAME="_Toc489268058"></A><A NAME="_Toc489272611"></A><A NAME="_Toc202341614"></A><A NAME="_Toc258262355"></A>&#92;_SI System Indicators<A NAME="marker-1377672"></A><A NAME="marker-1377673"></A><A NAME="marker-1377674"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1377676"></A>ACPI provides an interface for a variety of simple and icon-style indicators on a system. All indicator controls are in the &#92;_SI portion of the namespace. The following table lists all defined system indicators. (Notice that there are also per-device indicators specified for battery devices).</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1377677"></A>System Indicator Control Methods</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377680"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377682"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377684"></A>_SST</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377686"></A>System status indicator</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377688"></A>_MSG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377690"></A>Messages waiting indicator</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377692"></A>_BLT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377694"></A>Battery Level Threshold</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377721"></A><A NAME="marker-1377720"></A><A NAME="53500"></A>_SST (System Status)</H6>
<P CLASS="Body">
<A NAME="pgfId-1377722"></A>This optional object is a control method that OSPM invokes to set the system status indicator as desired.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377723"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1377724"></A>Arg0 - An Integer containing the system status indicator identifier</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377725"></A>0 - No system state indication. Indicator off</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377726"></A>1 - Working</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377727"></A>2 - Waking</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377728"></A>3 - Sleeping. Used to indicate system state S1, S2, or S3</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377729"></A>4 - Sleeping with context saved to non-volatile storage</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377730"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377731"></A>None</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377749"></A><A NAME="_Toc489256136"></A><A NAME="_Toc489268060"></A><A NAME="_Toc489272613"></A><A NAME="RSVD_MSG"></A><A NAME="_Toc202341622"></A><A NAME="_Toc258262357"></A>_MSG (Message)<A NAME="marker-1377747"></A><A NAME="marker-1377748"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377750"></A>This control method sets the system&#8217;s message-waiting status indicator. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377751"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1377752"></A>Arg0 - An Integer containing the number of waiting messages</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377753"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377754"></A>None</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377755"></A><A NAME="RSVD_BLT"></A><A NAME="_Toc202341625"></A><A NAME="_Toc258262358"></A>_BLT (Battery Level Threshold)<A NAME="marker-1377759"></A><A NAME="marker-1377760"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1499538"></A>This optional control method is used by OSPM to indicate to the platform the user&#8217;s preference for various battery level thresholds. This method allows platform battery indicators to be synchronized with OSPM provided battery notification levels. Note that if _BLT is implemented on a multi-battery system, it is required that the power unit for all batteries must be the same. See <A HREF="Power_Source_and_Power_Meter_Devices.htm#_Toc489267283" CLASS="XRef">See Control Method Batteries.</A> for more details on battery levels.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377763"></A>Arguments: (3)</H4>
<P CLASS="Body">
<A NAME="pgfId-1377764"></A>Arg0 - An Integer containing the preferred threshold for the battery warning level</P>
<P CLASS="Body">
<A NAME="pgfId-1377765"></A>Arg1 - An Integer containing the preferred threshold for the battery low level</P>
<P CLASS="Body">
<A NAME="pgfId-1377766"></A>Arg2 - An Integer containing the preferred threshold for the battery wake level</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377767"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377768"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1377769"></A>Additional Information</H4>
<P CLASS="Body">
<A NAME="pgfId-1377770"></A>The battery warning level in the range 0x00000001 - 0x7FFFFFFF (in units of mWh or mAh, depending on the Power Units value) is the user&#8217;s preference for battery warning. If the level specified is less than the design capacity of warning, it may be ignored by the platform so that the platform can ensure a successful wake on low battery.</P>
<P CLASS="Body">
<A NAME="pgfId-1377771"></A>The battery low level in the range 0x00000001 - 0x7FFFFFFF (in units of mWh or mAh, depending on the Power Units value) is the user&#8217;s preference for battery low. If this level is less than the design capacity of low, it may be ignored by the platform.</P>
<P CLASS="Body">
<A NAME="pgfId-1377772"></A>The battery wake level in the range 0x00000001 - 0x7FFFFFFF (in units of mWh or mAh, depending on the Power Units value) is the user&#8217;s preference for battery wake. If this level is less than the platform&#8217;s current wake on low battery level, it may be ignored by the platform. If the platform does not support a configurable wake on low battery level, this may be ignored by the platform.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1377804"></A><A NAME="_Toc489256137"></A><A NAME="_Toc489268061"></A><A NAME="_Toc489272614"></A><A NAME="_Toc4819323"></A><A NAME="_Toc202341641"></A><A NAME="_Toc258262359"></A>Ambient Light Sensor Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1377805"></A>The following section illustrates the operation and definition of the control method-based Ambient Light Sensor (ALS) device.<A NAME="marker-1377806"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1377807"></A>The ambient light sensor device can optionally support power management objects (e.g. _PS0, _PS3) to allow the OS to manage the device&#8217;s power consumption. </P>
<P CLASS="Body">
<A NAME="pgfId-1377808"></A>The Plug and Play ID of an ACPI control method ambient light sensor device is ACPI0008.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1377809"></A>Control Method Ambient Light Sensor Device</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377812"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377814"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377816"></A>_ALI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377818"></A>The current ambient light illuminance reading in lux (lumen per square meter). [Required]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377820"></A>_ALC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377822"></A>The current ambient light color chromaticity reading, specified using x and y coordinates per the CIE Yxy color model. [Optional]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377824"></A>_ALT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377826"></A>The current ambient light color temperature reading in degrees Kelvin. [Optional]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377828"></A>_ALR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377830"></A>Returns a set of ambient light illuminance to display brightness mappings that can be used by an OS to calibrate its ambient light policy. [Required]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377832"></A>_ALP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377834"></A>Ambient light sensor polling frequency in tenths of seconds. [Optional]</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377842"></A><A NAME="_Toc202341642"></A><A NAME="_Toc258262360"></A>Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1377843"></A>This definition provides a standard interface by which the OS may query properties of the ambient light environment the system is currently operating in, as well as the ability to detect meaningful changes in these values when the environment changes. Two ambient light properties are currently supported by this interface: illuminance and color. </P>
<P CLASS="Body">
<A NAME="pgfId-1377844"></A>Ambient light illuminance readings are obtained via the _ALI method. Illuminance readings indicate the amount of light incident upon (falling on) a specified surface area. Values are specified in lux (lumen per square meter) and give an indication of how &#8220;bright&#8221; the environment is. For example, an overcast day is roughly 1000 lux, a typical office environment 300-400 lux, and a dimly-lit conference room around 10 lux.</P>
<P CLASS="Body">
<A NAME="pgfId-1377845"></A>A possible use of ambient light illuminance data by the OS is to automatically adjust the brightness (or luminance) of the display device - e.g. increase display luminance in brightly-lit environments and decrease display luminance in dimly-lit environments. Note that Luminance is a measure of light radiated (reflected, transmitted, or emitted) by a surface, and is typically measured in nits. The _ALR method provides a set of ambient light illuminance to display luminance mappings that can be used by an OS to calibrate its policy for a given platform configuration.</P>
<P CLASS="Body">
<A NAME="pgfId-1377846"></A>Ambient light color readings are obtained via the _ALT and/or _ALC methods. Two methods are defined to allow varying types/complexities of ambient light sensor hardware to be used. _ALT returns color temperature readings in degrees Kelvin. Color temperature values correlate a light source to a standard black body radiator and give an indication of the type of light source present in a given environment (e.g. daylight, fluorescent, incandescent). ALC returns color chromaticity readings per the CIE Yxy color model. Chromaticity x and y coordinates provide a more straightforward indication of ambient light color characteristics. Note that the CIE Yxy color model is defined by the International Commission on Illumination (abbreviated as CIE from its French title Commission Internationale de l'Eclairage) and is based on human perception instead of absolute color.</P>
<P CLASS="Body">
<A NAME="pgfId-1377847"></A>A possible use of ambient light color data by the OS is to automatically adjust the color of displayed images depending on the environment the images are being viewed in. This may be especially important for reflective/transflective displays where the type of ambient light may have a large impact on the colors perceived by the user.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377853"></A><A NAME="RSVD_ALI"></A><A NAME="_Toc202341643"></A><A NAME="_Toc258262361"></A>_ALI (Ambient Light Illuminance)<A NAME="marker-1377852"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377854"></A>This control method returns the current ambient light illuminance reading in lux (lumen per square meter). Expected values range from &#126;1 lux for a dark room, &#126;300 lux for a typical office environment, and 10,000+ lux for daytime outdoor environments - although readings may vary depending on the location of the sensor to the light source. Special values are reserved to indicate out of range conditions (see below).</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377855"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377856"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377857"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377858"></A>An Integer containing the ambient light brightness in lux (lumens per square meter)</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377859"></A>0 -	                      The current reading is below the supported range or sensitivity <BR>
                      of 	the sensor.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377860"></A>Ones (-1) -	         The current reading is above the supported range or sensitivity <BR>
                      of the sensor.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377861"></A>Other values -	   The current ambient light brightness in lux (lumens per square meter)</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377867"></A><A NAME="RSVD_ALT"></A><A NAME="_Toc202341650"></A><A NAME="_Toc258262362"></A>_ALT (Ambient Light Temperature)<A NAME="marker-1377866"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377868"></A>This optional control method returns the current ambient light color temperature reading in degrees Kelvin (&#176;K). Lower color temperatures imply warmer light (emphasis on yellow and red); higher color temperatures imply a colder light (emphasis on blue). This value can be used to gauge various properties of the lighting environment - for example, the type of light source. Expected values range from &#126;1500&#176;K for candlelight, &#126;3000<A NAME="OLE_LINK2"></A>&#176;K for a 200-Watt incandescent bulb, and &#126;5500&#176;K for full sunlight on a summer day - although readings may vary depending on the location of the sensor to the light source. Special values are reserved to indicate out of range conditions (see below).</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377870"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377871"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377872"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377873"></A>An Integer containing the ambient light temperature in degrees Kelvin</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377874"></A>0 -		The current reading is below the supported range or sensitivity of</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1498092"></A> 		the sensor</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1381965"></A>Ones (-1) -		The current reading is above the supported range or sensitivity of</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1498103"></A>		 the sensor</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377876"></A>Other values -	The current ambient light temperature in degrees Kelvin</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377882"></A><A NAME="RSVD_ALC"></A><A NAME="_Toc202341657"></A><A NAME="_Toc258262363"></A>_ALC (Ambient Light Color Chromaticity)<A NAME="marker-1377881"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377883"></A>This optional control method returns the current ambient light color chromaticity readings per the CIE Yxy color model. The x and y (chromaticity) coordinates are specified using a fixed 10-4 notation due to the lack of floating point values in ACPI. Valid values are within the range 0 (0x0000) through 1 (0x2710). A single 32-bit integer value is used, where the x coordinate is stored in the high word and the y coordinate in the low word. For example, the value 0x0C370CDA would be used to specify the white point for the CIE Standard Illuminant D65 (a standard representation of average daylight) with x = 0.3127 and y = 0.3290. Special values are reserved to indicate out of range conditions (see below).</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377884"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377885"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377886"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377887"></A>An Integer containing the ambient light temperature in degrees Kelvin</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377888"></A>0 -		The current reading is below the supported range or sensitivity of</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1498113"></A>		 the sensor</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377889"></A>Ones (-1) -		The current reading is above the supported range or sensitivity of</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1498120"></A>		 the sensor</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377890"></A>Other values -		The current ambient light color chromaticity x and y coordinate</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1498127"></A>		 values, per the CIE Yxy color model</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377899"></A><A NAME="RSVD_ALR"></A><A NAME="_Toc202341664"></A><A NAME="_Toc258262364"></A>_ALR (Ambient Light Response)<A NAME="marker-1377898"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377901"></A>This object <A NAME="OLE_LINK1"></A>evaluates to a package of ambient light illuminance to display luminance mappings that can be used by an OS to calibrate its ambient light policy for a given sensor configuration. The OS can use this information to extrapolate an ALS response curve - noting that these values may be treated differently depending on the OS implementation but should be used in some form to calibrate ALS policy.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377902"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377903"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377904"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377905"></A>A variable-length Package containing a list of luminance mapping Packages. Each mapping package consists of two Integers.</P>
<P CLASS="Body">
<A NAME="pgfId-1498146"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377906"></A>The return data is specified as a package of packages, where each tuple (inner package) consists of the pair of Integer values of the form:</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1377907"></A>{&lt;display luminance adjustment&gt;, &lt;ambient light illuminance&gt;}</P>
<P CLASS="Body">
<A NAME="pgfId-1377908"></A>Package elements should be listed in monotonically increasing order based upon the ambient light illuminance value (the Y-coordinate on the graph) to simplify parsing by the OS. </P>
<P CLASS="Body">
<A NAME="pgfId-1377909"></A>Ambient light illuminance values are specified in lux (lumens per square meter). Display luminance (or brightness) adjustment values are specified using relative percentages in order simplify the means by which these adjustments are applied in lieu of changes to the user&#8217;s display brightness preference. A value of 100 is used to indicate no (0%) display brightness adjustment given the lack of signed data types in ACPI. Values less than 100 indicate a negative adjustment (dimming); values greater than 100 indicate a positive adjustment (brightening). For example, a display brightness adjustment value of 75 would be interpreted as a -25% adjustment, and a value of 110 as a +10% adjustment.</P>
<P CLASS="Normal-Indent">
<A NAME="pgfId-1377910"></A>&nbsp;</P>
<P CLASS="Normal-Indent">
<A NAME="pgfId-1377914"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-2.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
<P CLASS="Normal-Indent">
<A NAME="pgfId-1377915"></A>&nbsp;</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1377916"></A><A NAME="72862"></A>A five-point ALS Response Curve</H6>
<P CLASS="Body">
<A NAME="pgfId-1377917"></A><A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#72862" CLASS="XRef">See A five-point ALS Response Curve.</A> illustrates the use of five points to approximate an example response curve, where the dotted line represents an approximation of the desired response (solid curve). Extrapolation of the values between these points is OS-specific - although for the purposes of this example we&#8217;ll assume a piecewise linear approximation. The ALS response curve (_ALR) would be specified as follows:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377918"></A> &nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493588"></A> Name(_ALR, Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377920"></A>  Package{70, 0},   // Min   ( -30% adjust at 0 lux) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377921"></A>  Package{73, 10},   //    ( -27% adjust at 10 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377922"></A>  Package{85, 80},   //    ( -15% adjust at 80 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377923"></A>  Package{100,300},  // Baseline  ( 0% adjust at 300 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377924"></A>  Package{150,1000}  // Max   ( +50% adjust at 1000 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377925"></A> })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493599"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377927"></A>Within this data set exist three points of particular interest: baseline, min, and max. The baseline value represents an ambient light illuminance value (in lux) for the environment where this system is most likely to be used. When the system is operating in this ambient environment the ALS policy will apply no (0%) adjustment to the default display brightness setting. For example, given a system with a 300 lux baseline, operating in a typical office ambient environment (&#126;300 lux), configured with a default display brightness setting of 50% (e.g. 60 nits), the ALS policy would apply no backlight adjustment, resulting in an absolute display brightness setting of 60 nits.</P>
<P CLASS="Body">
<A NAME="pgfId-1377928"></A>Min and max are used to indicate cutoff points in order to prevent an over-zealous response by the ALS policy and to influence the policy&#8217;s mode of operation. For example, the min and max points from the figure above would be specified as (70,0) and (150,1000) respectively - where min indicates a maximum negative adjustment of 30% and max represents a maximum positive adjustment of 50%. Using a large display brightness adjustment for max allows an ALS response that approaches a fully-bright display (100% absolute) in very bright ambient environments regardless of the user&#8217;s display brightness preference. Using a small value for max (e.g. 0% @ 300 lux) would influence the ALS policy to limit the use of this technology solely as a power-saving feature (never brighten the display). Conversely, setting min to a 0% adjustment instructs ALS policy to brighten but never dim.</P>
<P CLASS="Body">
<A NAME="pgfId-1377929"></A>A minimum of two data points are required in the return package, interpreted as min and max. Note that the baseline value does not have to be explicitly stated; it can be derived from the response curve. Addition elements can be provided to fine-tune the response between these points. <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#12015" CLASS="XRef">See A two-point ALS Response Curve.</A> illustrates the use of two data points to achieve a response similar to (but simpler than) that described in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#72862" CLASS="XRef">See A five-point ALS Response Curve.</A> . </P>
<P CLASS="Normal-Indent">
<A NAME="pgfId-1377934"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-3.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1377936"></A><A NAME="12015"></A>A two-point ALS Response Curve</H6>
<P CLASS="Body">
<A NAME="pgfId-1377938"></A>This example lacks an explicit baseline and includes a min with an ambient light value above 0 lux. The baseline can easily be extrapolated by ALS Policy (e.g. 0% adjustment at &#126;400 lux). All ambient light brightness settings below min (20 lux) would be treated in a similar fashion by ALS policy (e.g. -30% adjustment). This two-point response curve would be modeled as:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1382092"></A> Name(_ALR, Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1382094"></A>  Package{70, 30},   // Min   ( -30% adjust at 30 lux) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377942"></A>  Package{150,1000}  // Max   ( +50% adjust at 1000 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377943"></A> })</P>
<P CLASS="Body">
<A NAME="pgfId-1377945"></A>This model can be used to convey a wide range of ambient light to display brightness responses. For example, a transflective display - a technology where illumination of the display can be achieved by reflecting available ambient light, but also augmented in dimly-lit environments with a backlight - could be modeled as illustrated in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#24362" CLASS="XRef">See Example Response Curve for a Transflective Display.</A>. </P>
<P CLASS="Normal-Indent">
<A NAME="pgfId-1377950"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-4.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
<P CLASS="Normal-Indent">
<A NAME="pgfId-1377951"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1377952"></A><A NAME="24362"></A>Example Response Curve for a Transflective Display </H6>
<P CLASS="Body">
<A NAME="pgfId-1377954"></A>This three-point approximation would result in an ALS response that allows the backlight to increase as the ambient lighting decreases. In this example, no backlight adjustment is needed in bright environments (1000+ lux), maximum backlight may be needed in dim environments (&#126;30 lux), but a lower backlight setting may be used in a very-dark room (&#126;0 lux) - resulting in an elbow around 30 lux. This response would be modeled in _ALR as follows:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377956"></A> &nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493606"></A> Name(_ALR, Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484458"></A>  Package{180, 0}      ( +80% adjust at  0 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484459"></A>  Package{200, 30},  // Max  (+100% adjust at 30 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484460"></A>  Package{0, 1000},  // Min  ( 0% adjust at 1,000 lux)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377960"></A> })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493613"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377962"></A>Note the ordering of package elements: monotonically increasing from the lowest ambient light value (0 lux) to the highest ambient light value (1000 lux). </P>
<P CLASS="Body">
<A NAME="pgfId-1377963"></A>The transflective display example also highlights the need for non-zero values for the user&#8217;s display brightness preference - which we&#8217;ll refer to as the reference display brightness value. This requirement is derived from the model&#8217;s use of relative adjustments. For example, applying any adjustment to a 0% reference display brightness value always results in a 0% absolute display brightness setting. Likewise, using a very small reference display brightness (e.g. 5%) results in a muted response (e.g. +30% of 5% = 6.5% absolute). The solution is to apply a reasonably large value (e.g. 50%) as the reference display brightness setting - even in the case where no backlight is applied. This allows relative adjustments to be applied in a meaningful fashion while conveying to the user that the display is still usable (via reflected light) under typical ambient conditions.</P>
<P CLASS="Body">
<A NAME="pgfId-1377964"></A>The OS derives the user&#8217;s display brightness preference (this reference value) either from the Brightness Control Levels (_BCL) object or another OS-specific mechanism. See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#_Toc202341672" CLASS="XRef">See Relationship to Backlight Control Methods.</A>, &#8220;Relationship to Backlight Control Methods&#8221;, for more information.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377973"></A><A NAME="_Toc4819378"></A><A NAME="_Ref25468227"></A><A NAME="RSVD_ALP"></A><A NAME="_Toc202341665"></A><A NAME="_Toc258262365"></A>_ALP (Ambient Light Polling)<A NAME="marker-1377971"></A><A NAME="marker-1377972"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377974"></A>This optional object evaluates to a recommended polling frequency (in tenths of seconds) for this ambient light sensor. A value of zero - or the absence of this object when other ALS objects are defined - indicates that OSPM does not need to poll the sensor in order to detect meaningful changes in ambient light (the hardware is capable of generating asynchronous notifications). </P>
<P CLASS="Body">
<A NAME="pgfId-1377975"></A>The use of polling is allowed but strongly discouraged by this specification. OEMs should design systems that asynchronously notify OSPM whenever a meaningful change in the ambient light occurs--relieving the OS of the overhead associated with polling.</P>
<P CLASS="Body">
<A NAME="pgfId-1377976"></A>This value is specified as tenths of seconds. For example, a value of 10 would be used to indicate a 1 second polling frequency. As this is a recommended value, OSPM will consider other factors when determining the actual polling frequency to use.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377977"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377978"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377979"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377980"></A>An Integer containing the recommended polling frequency in tenths of seconds</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377981"></A>0 -		Polling by the host OS is not required</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377982"></A>Other -		The recommended polling frequency in tenths of seconds</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378017"></A><A NAME="_Toc202341671"></A><A NAME="_Toc258262366"></A>Ambient Light Sensor Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1378018"></A>To communicate meaningful changes in ALS illuminance to OSPM, AML code should issue a Notify(als_device, 0x80) whenever the lux reading changes more than 10% (from the last reading that resulted in a notification). OSPM receives this notification and evaluates the _ALI control method to determine the current ambient light status. The OS then adjusts the display brightness based upon its ALS policy (derived from _ALR).</P>
<P CLASS="Body">
<A NAME="pgfId-1378019"></A>The definition of what constitutes a meaningful change is left to the system integrator, but should be at a level of granularity that provides an appropriate response without overly taxing the system with unnecessary interrupts. For example, an ALS configuration may be tuned to generate events for all changes in ambient light illuminance that result in a minimum &#177;5% display brightness response (as defined by _ALR).</P>
<P CLASS="Body">
<A NAME="pgfId-1378020"></A>To communicate meaningful changes in ALS color temperature to OSPM, AML code should issue a Notify(als_device, 0x81) whenever the lux reading changes more than 10% (from the last reading that resulted in a notification). OSPM receives this notification and evaluates the _ALT and _ALC control method to determine the current ambient light color temperature. </P>
<P CLASS="Body">
<A NAME="pgfId-1378021"></A>To communicate meaningful changes in ALS response to OSPM, AML code should issue a Notify(als_device, 0x82) whenever the set of points used to convey ambient light response has changed. OSPM receives this notification and evaluates the _ALR object to determine the current response points.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378028"></A><A NAME="_Toc202341672"></A><A NAME="_Toc258262367"></A>Relationship to Backlight Control Methods<A NAME="marker-1378027"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1378029"></A>The Brightness Control Levels (_BCL) method - described in section 0 - can be used to indicate user-selectable display brightness levels. The information provided by this method indicates the available display brightness settings, the recommended default brightness settings for AC and DC operation, and the absolute maximum and minimum brightness settings. These values indirectly influence the operation of the OSPM&#8217;s ALS policy.</P>
<P CLASS="Body">
<A NAME="pgfId-1378030"></A>Display brightness adjustments produced by ALS policy are relative to the current user backlight setting, and the resulting absolute value must be mapped (rounded) to one of the levels specified in _BCL. This introduces the requirement for fine-grain display brightness control in order to achieve a responsive ALS system - which typically materializes as a need for additional entries in the _BCL list in order to provide reasonable resolution to the OS (e.g. 3-10% granularity). Note that user brightness controls (e.g. hotkeys) are not required to make use of all levels specified in _BCL.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378034"></A><A NAME="_Toc202341673"></A><A NAME="_Toc258262368"></A>Battery Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1378035"></A>A battery device is required to either have an ACPI Smart Battery Table or a Control Method Battery interface. In the case of an ACPI Smart Battery Table, the Definition Block needs to include a Bus/Device Package for the SMBus host controller. This will install an OS specific driver for the SMBus, which in turn will locate the Smart Battery System Manager or Smart Battery Selector and Smart Battery Charger SMBus devices.</P>
<P CLASS="Body">
<A NAME="pgfId-1378036"></A>The Control Method Battery interface is defined in <A HREF="Power_Source_and_Power_Meter_Devices.htm#_Toc489267283" CLASS="XRef">See Control Method Batteries.</A>, &#8220;Control Method Batteries.&#8221;</P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378053"></A><A NAME="_Toc489256138"></A><A NAME="_Toc489268062"></A><A NAME="_Toc489272615"></A><A NAME="_Toc202341674"></A><A NAME="_Toc258262369"></A>Control Method Lid Device<A NAME="marker-1378052"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1378054"></A>Platforms containing lids convey lid status (open / closed) to OSPM using a Control Method Lid Device.</P>
<P CLASS="Body">
<A NAME="pgfId-1378055"></A>To implement a control method lid device, AML code should issue a Notify(lid_device, 0x80) for the device whenever the lid status has changed. The _LID control method for the lid device must be implemented to report the current state of the lid as either opened or closed.</P>
<P CLASS="Body">
<A NAME="pgfId-1378056"></A>The lid device can support _PRW and _PSW methods to select the wake functions for the lid when the lid transitions from closed to opened.</P>
<P CLASS="Body">
<A NAME="pgfId-1378057"></A>The Plug and Play ID of an ACPI control method lid device is PNP0C0D.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1378058"></A>Control Method Lid Device</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378061"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378063"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378065"></A>_LID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378067"></A>Returns the current status of the lid.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378081"></A><A NAME="_Toc489256139"></A><A NAME="_Toc489268063"></A><A NAME="_Toc489272616"></A><A NAME="RSVD_LID"></A><A NAME="_Toc202341675"></A><A NAME="_Toc258262370"></A>_LID<A NAME="marker-1378080"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1378082"></A>Evaluates to the current status of the lid. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378083"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378084"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378085"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378086"></A>An Integer containing the current lid status</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1378087"></A>0 -		The lid is closed</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1378088"></A>Non-zero -		The lid is open</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378107"></A><A NAME="_Toc489256140"></A><A NAME="_Toc489268064"></A><A NAME="_Toc489272617"></A><A NAME="_Toc202341679"></A><A NAME="_Toc258262371"></A>Control Method Power and Sleep Button Devices<A NAME="marker-1378103"></A><A NAME="marker-1378104"></A><A NAME="marker-1378105"></A><A NAME="marker-1378106"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1378108"></A>The system&#8217;s power or sleep button can either be implemented using the fixed register space as defined in <A HREF="ACPI Hardware Specification.htm#77822" CLASS="XRef">See Console Buttons.</A>, &#8220;Buttons,&#8221; or implemented in AML code as a control method power button device. In either case, the power button override function or similar unconditional system power or reset functionality is still implemented in external hardware.</P>
<P CLASS="Body">
<A NAME="pgfId-1378109"></A>To implement a control method power-button or sleep-button device, implement AML code that delivers two types of notifications concerning the device. The first is Notify(Object, 0x80) to signal that the button was pressed while the system was in the S0 state to indicate that the user wants the machine to transition from S0 to some sleeping state. The other notification is Notify(Object, 0x2) to signal that the button was pressed while the system was in an S1 to S4 state and to cause the system to wake. When the button is used to wake the system, the wake notification (Notify(Object, 0x2)) must occur after OSPM actually wakes, and a button-pressed notification (Notify(Object, 0x80)) must not occur.</P>
<P CLASS="Body">
<A NAME="pgfId-1378110"></A>The Wake Notification indicates that the system is awake because the user pressed the button and therefore a complete system resume should occur (for example, turn on the display immediately, and so on).</P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378126"></A><A NAME="_Toc489256141"></A><A NAME="_Toc489268065"></A><A NAME="_Toc489272618"></A><A NAME="_Toc202341680"></A><A NAME="_Toc258262372"></A>Embedded Controller Device<A NAME="marker-1378125"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1378127"></A>Operation of the embedded controller host controller register interface requires that the embedded controller driver has ACPI-specific knowledge. Specifically, the driver needs to provide an &#8220;operational region&#8221; of its embedded controller address space, and needs to use an ACPI event to service the host controller interface. For more information about an ACPI-compatible embedded controller device, see <A HREF="ACPI_Embedded_Controller_Interface_Specification.htm#71995" CLASS="XRef">See ACPI Embedded Controller Interface Specification.</A>, &#8220;ACPI Embedded Controller Interface Specification.&#8221; </P>
<P CLASS="Body">
<A NAME="pgfId-1378128"></A>The embedded controller device object provides the _HID of an ACPI-integrated embedded controller device of PNP0C09 and the host controller register locations using the device standard methods. In addition, the embedded controller must be declared as a named device object that includes a set of control methods. For more information, see <A HREF="ACPI_Embedded_Controller_Interface_Specification.htm#_Toc489267373" CLASS="XRef">See Defining an Embedded Controller Device in ACPI Namespace.</A>, &#8220;Defining an Embedded Controller Device in ACPI Namespace&#8221;). </P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378146"></A><A NAME="_Toc489256143"></A><A NAME="_Toc489268067"></A><A NAME="_Toc489272620"></A><A NAME="_Toc202341682"></A><A NAME="_Toc258262373"></A>Generic Container Device<A NAME="marker-1378143"></A><A NAME="marker-1378144"></A><A NAME="marker-1378145"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1378147"></A>A generic container device is a bridge that does not require a special OS driver because the bridge does not provide or require any features not described within the normal ACPI device functions. The resources the bridge requires are specified via normal ACPI resource mechanisms. Device enumeration for child devices is supported via ACPI namespace device enumeration and OS drivers require no other features of the bus. Such a bridge device is identified with the Plug and Play ID of PNP0A05 or PNP0A06.</P>
<P CLASS="Body">
<A NAME="pgfId-1378148"></A>A generic bus bridge device is typically used for integrated bridges that have no other means of controlling them and that have a set of well-known devices behind them. For example, a portable computer can have a &#8220;generic bus bridge&#8221; known as an EIO bus that bridges to some number of Super-I/O devices. The bridged resources are likely to be positively decoded as either a function of the bridge or the integrated devices. In this example, a generic bus bridge device would be used to declare the bridge then child devices would be declared below the bridge; representing the integrated Super-I/O devices.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378152"></A><A NAME="_Toc202341683"></A><A NAME="_Toc258262374"></A>ATA Controller Devices</H2>
<P CLASS="Body">
<A NAME="pgfId-1378153"></A>There are two types of ATA Controllers: IDE controllers (also known as ATA controllers) and Serial ATA (SATA) controllers. IDE controllers are those using the traditional IDE programming interface, and may support Parallel ATA (P-ATA) or SATA connections. SATA controllers may be designed to operate in emulation mode only, native mode only, or they may be designed to support both native and non-native SATA modes. Regardless of the mode supported, SATA controllers are designed to work solely with drives supporting the Serial ATA physical interface. As described below, SATA controllers are treated similarly but not identically to traditional IDE controllers. </P>
<P CLASS="Body">
<A NAME="pgfId-1378154"></A>Platforms that contain controllers that support native and non-native SATA modes must take steps to ensure the proper objects are placed in the namespace for the mode in which they are operating.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1378155"></A>ATA Specific Objects</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378158"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378160"></A>Description</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378162"></A>Controller Type</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378164"></A>_GTF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378166"></A>Optional object that returns the ATA task file needed to re-initialize the drive to boot up defaults.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378168"></A>Both</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378170"></A>_GTM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378172"></A>Optional object that returns the IDE controller timing information.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378174"></A>IDE-only</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378176"></A>_STM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378178"></A>Optional control method that sets the IDE controller&#8217;s transfer timing settings.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378180"></A>IDE-only</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378182"></A>_SDD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378184"></A>Optional control method that informs the platform of the type of device attached to a port.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378186"></A>SATA-only</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378196"></A><A NAME="_Toc202341684"></A><A NAME="_Toc258262375"></A>Objects for Both ATA and SATA Controllers</H6>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1415049"></A><A NAME="83118"></A>_GTF (Get Task File)</H6>
<P CLASS="Pb">
<A NAME="pgfId-1378211"></A><A NAME="marker-1378210"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1378214"></A>This optional object returns a buffer containing the ATA commands used to restore the drive to boot up defaults (that is, the state of the drive after POST). The returned buffer is an array with each element in the array consisting of seven 8-bit register values (56 bits) corresponding to ATA task registers 1F1 thru 1F7. Each entry in the array defines a command to the drive. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378215"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378216"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378217"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378218"></A>A Buffer containing a byte stream of ATA commands for the drive</P>
<P CLASS="Body">
<A NAME="pgfId-1497757"></A>This object may appear under SATA port device objects or under IDE channel objects.</P>
<P CLASS="Body">
<A NAME="pgfId-1378220"></A>ATA task file array definition:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1378221"></A>Seven register values for command 1 </LI>
</UL>
<DIV>
<H6 CLASS="BulletSubDash">
<A NAME="pgfId-1378222"></A>Reg values: (1F1, 1F2, 1F3, 1F4, 1F5, 1F6, 1F7)</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1378223"></A>Seven register values for command 2</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="BulletSubDash">
<A NAME="pgfId-1378224"></A>Reg values: (1F1, 1F2, 1F3, 1F4, 1F5, 1F6, 1F7)</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1378225"></A>Seven register values for command 3</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="BulletSubDash">
<A NAME="pgfId-1378226"></A>Reg values: (1F1, 1F2, 1F3, 1F4, 1F5, 1F6, 1F7)</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1378227"></A>Etc.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1378228"></A>After powering up the drive, OSPM will send these commands to the drive, in the order specified. On SATA HBAs, OSPM evaluates _SDD before evaluating _GTF. The IDE driver may modify some of the feature commands or append its own to better tune the drive for OSPM features before sending the commands to the drive.</P>
<P CLASS="Body">
<A NAME="pgfId-1378229"></A>This Control Method is listed under each drive device object. OSPM must evaluate the _STM object or the _SDD object before evaluating the _GTF object.</P>
<P CLASS="Body">
<A NAME="pgfId-1378230"></A>Example of the return from _GTF:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493620"></A>Method(_GTF, 0x0, NotSerialized)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378233"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378234"></A> Return(GTF0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378235"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378236"></A>Name(GTF0, Buffer(0x1c)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378237"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378238"></A> 0x03, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xef, 0x03, 0x00, 0x00, 0x00, 0x00,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378239"></A> 0xa0, 0xef, 0x00, 0x10, 0x00, 0x00, 0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378240"></A> 0x00, 0x00, 0xa0, 0x91</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378241"></A>}</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378260"></A><A NAME="marker-1378257"></A>IDE Controller Device</H6>
<P CLASS="Body">
<A NAME="pgfId-1378261"></A>Most device drivers can save and restore the registers of their device. For IDE controllers and drives, this is not true because there are several drive settings for which ATA does not provide mechanisms to read. Further, there is no industry standard for setting timing information for IDE controllers. Because of this, ACPI interface mechanisms are necessary to provide the operating system information about the current settings for the drive and channel, and for setting the timing for the channel. </P>
<P CLASS="Body">
<A NAME="pgfId-1378262"></A>OSPM and the IDE driver will follow these steps when powering off the IDE subsystem:</P>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1378263"></A>The IDE driver will call the _GTM control method to get the current transfer timing settings for the IDE channel. This includes information about DMA and PIO modes.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378264"></A>The IDE driver will call the standard OS services to power down the drives and channel.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378265"></A>As a result, OSPM will execute the appropriate _PS3 methods and turn off unneeded power resources. </LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1378266"></A>To power on the IDE subsystem, OSPM and the IDE driver will follow these steps:</P>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1378267"></A>The IDE driver will call the standard OS services to turn on the drives and channel.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378268"></A>As a result, OSPM will execute the appropriate _PS0 methods and turn on required power resources.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378269"></A>The IDE driver will call the _STM control method passing in transfer timing settings for the channel, as well as the ATA drive ID block for each drive on the channel. The _STM control method will configure the IDE channel based on this information.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378270"></A>For each drive on the IDE channel, the IDE driver will run the _GTF to determine the ATA commands required to reinitialize each drive to boot up defaults. </LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378271"></A>The IDE driver will finish initializing the drives by sending these ATA commands to the drives, possibly modifying or adding commands to suit the features supported by the operating system. </LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1378272"></A>The following shows the namespace for these objects:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378274"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493634"></A>&#92;_SB        // System bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378275"></A> PCI0       // PCI bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378276"></A>  IDE1      // First IDE channel</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378277"></A>   _ADR     // Indicates address of the channel on the PCI bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378278"></A>   _GTM     // Control method to get current IDE channel settings</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378279"></A>   _STM     // Control method to set current IDE channel settings</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378280"></A>   _PR0     // Power resources needed for D0 power state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484437"></A>   DRV1     // Drive 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484438"></A>    _ADR    // Indicates address of master IDE device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484439"></A>    _GTF    // Control method to get task file</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484434"></A>   DRV2     // Drive 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484428"></A>    _ADR    // Indicates address of slave IDE device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484429"></A>    _GTF    // Control method to get task file</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484424"></A>  IDE2      // Second IDE channel</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484419"></A>   _ADR     // Indicates address of the channel on the PCI bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378289"></A>   _GTM     // Control method to get current IDE channel settings</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378290"></A>   _STM     // Control method to set current IDE channel settings</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378291"></A>   _PR0     // Power resources needed for D0 power state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484407"></A>   DRV1     // Drive 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484408"></A>    _ADR    // Indicates address of master IDE device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484409"></A>    _GTF    // Control method to get task file</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484404"></A>   DRV2     // Drive 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484398"></A>    _ADR    // Indicates address of slave IDE device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484399"></A>    _GTF    // Control method to get task file</P>
<P CLASS="Body">
<A NAME="pgfId-1378299"></A>The sequential order of operations is as follows:</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1378300"></A>Powering down:</H4>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1378301"></A>Call _GTM.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1378302"></A>Power down drive (calls _PS3 method and turns off power planes).</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1378303"></A>Powering up:</H4>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1378304"></A>Power up drive (calls _PS0 method if present and turns on power planes).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1378305"></A>Call _STM passing info from _GTM (possibly modified), with ID data from</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1378306"></A>each drive.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1378307"></A>Initialize the channel.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1378308"></A>May modify the results of _GTF.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1378309"></A>For each drive:</LI>
</UL>
<DIV>
<H6 CLASS="BulletSubDash">
<A NAME="pgfId-1378310"></A>		Call _GTF.</H6>
</DIV>
<DIV>
<H6 CLASS="BulletSubDash">
<A NAME="pgfId-1378311"></A>		Execute task file (possibly modified).</H6>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1378312"></A>IDE Controller-specific Objects</H6>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1378333"></A><A NAME="marker-1378330"></A><A NAME="31942"></A>_GTM (Get Timing Mode)</H6>
<P CLASS="Body">
<A NAME="pgfId-1378334"></A>This Control Method exists under each channel device object and returns the current settings for the IDE channel. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378335"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378336"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1498551"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1498552"></A>A Buffer containing the current IDE channel timing information block as described in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#89327" CLASS="XRef">See GTM Method Result Codes.</A> below.</P>
<P CLASS="Body">
<A NAME="pgfId-1378339"></A>_GTM returns a buffer with the following format</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493648"></A>Buffer (){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378342"></A> PIO Speed 0      //DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378343"></A> DMA Speed 0      //DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378344"></A> PIO Speed 1      //DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378345"></A> DMA Speed 1      //DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378346"></A> Flags        //DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378347"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1378349"></A><A NAME="89327"></A>GTM Method Result Codes</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1484477"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1484479"></A>Format</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1484481"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378358"></A>PIO Speed 0 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378360"></A>DWORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378362"></A>The PIO bus-cycle timing for drive 0 in nanoseconds. 0xFFFFFFFF indicates that this mode is not supported by the channel. If the chipset cannot set timing parameters independently for each drive, this field represents the timing for both drives.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378364"></A>DMA Speed 0 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378366"></A>DWORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378368"></A>The DMA bus-cycle for drive 0 timing in nanoseconds. If bit 0 of the Flags register is set, this DMA timing is for UltraDMA mode, otherwise the timing is for multi-word DMA mode. 0xFFFFFFFF indicates that this mode is not supported by the channel. If the chipset cannot set timing parameters independently for each drive, this field represents the timing for both drives.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378370"></A>PIO Speed 1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378372"></A>DWORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378374"></A>The PIO bus-cycle timing for drive 1 in nanoseconds. 0xFFFFFFFF indicates that this mode is not supported by the channel. If the chipset cannot set timing parameters independently for each drive, this field must be 0xFFFFFFFF.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378376"></A>DMA Speed 1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378378"></A>DWORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378380"></A>The DMA bus-cycle timing for drive 1 in nanoseconds. If bit 0 of the Flags register is set, this DMA timing is for UltraDMA mode, otherwise the timing is for multi-word DMA mode. 0xFFFFFFFF indicates that this mode is not supported by the channel. If the chipset cannot set timing parameters independently for each drive, this field must be 0xFFFFFFFF.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378382"></A>Flags </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378384"></A>DWORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378386"></A>Mode flags<BR>
Bit [0]: 1 indicates using UltraDMA on drive 0<BR>
Bit [1]: 1 indicates IOChannelReady is used on drive 0</P>
<P CLASS="TableBody">
<A NAME="pgfId-1378387"></A>Bit [2]: 1 indicates using UltraDMA on drive 1<BR>
Bit [3]: 1 indicates IOChannelReady is used on drive 1</P>
<P CLASS="TableBody">
<A NAME="pgfId-1378388"></A>Bit [4]: 1 indicates chipset can set timing independently for each drive</P>
<P CLASS="TableBody">
<A NAME="pgfId-1378389"></A>Bits [31:5]: reserved (must be 0)</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1378404"></A><A NAME="_Toc489256147"></A><A NAME="_Toc489268071"></A><A NAME="_Toc489272624"></A><A NAME="RSVD_STM"></A>_STM (Set Timing Mode)<A NAME="marker-1378402"></A><A NAME="marker-1378403"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1378405"></A>This Control Method sets the IDE channel&#8217;s transfer timings to the setting requested. The AML code is required to convert and set the nanoseconds timing to the appropriate transfer mode settings for the IDE controller. _STM may also make adjustments so that _GTF control methods return the correct commands for the current channel settings.</P>
<P CLASS="Body">
<A NAME="pgfId-1378406"></A>This control method takes three arguments: Channel timing information (as described in Table 9-6), and the ATA drive ID block for each drive on the channel. The channel timing information is not guaranteed to be the same values as returned by _GTM; the OS may tune these values as needed. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378407"></A>Arguments: (3)</H4>
<P CLASS="Body">
<A NAME="pgfId-1378408"></A>Arg0 - A Buffer containing a channel timing information block (described in Table 9-6)</P>
<P CLASS="Body">
<A NAME="pgfId-1378409"></A>Arg1 - A Buffer containing the ATA drive ID block for channel 0</P>
<P CLASS="Body">
<A NAME="pgfId-1378410"></A>Arg2 - A Buffer containing the ATA drive ID block for channel 1</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378411"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378412"></A>None</P>
<P CLASS="Body">
<A NAME="pgfId-1378413"></A>The ATA drive ID block is the raw data returned by the Identify Drive ATA command, which has the command code &#8220;0ECh.&#8221; The _STM control method is responsible for correcting for drives that misreport their timing information.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378420"></A><A NAME="_Toc202341692"></A><A NAME="_Toc258262377"></A>Serial ATA (SATA) Controller Device</H6>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1382459"></A>Definitions</H6>
<P CLASS="ArgDefinition">
<A NAME="pgfId-1382460"></A>HBA 	Host Bus Adapter </P>
<P CLASS="ArgDefinition">
<A NAME="pgfId-1382461"></A>Native SATA aware 	Refers to system software (platform firmware, option ROM, operating system, etc) that comprehends a particular SATA HBA implementation and understands its programming interface and power management behavior.</P>
<P CLASS="ArgDefinition">
<A NAME="pgfId-1378424"></A>Non-native SATA aware 	Refers to system software (platform firmware, option ROM, operating system, etc) that does not comprehend a particular SATA HBA implementation and does not understand its programming interface or power management behavior. Typically, non-native SATA aware software will use a SATA HBA&#8217;s emulation interface (e.g. task file registers) to control the HBA and access its devices.</P>
<P CLASS="ArgDefinition">
<A NAME="pgfId-1378425"></A>Emulation mode 	Optional mode supported by a SATA HBA. Allows non-native SATA aware software to access SATA devices via traditional task file registers.</P>
<P CLASS="ArgDefinition">
<A NAME="pgfId-1378426"></A>Native mode 	Optional mode supported by a SATA HBA. Allows native SATA aware software to access SATA devices via registers that are specific to the HBA. </P>
<P CLASS="ArgDefinition">
<A NAME="pgfId-1378427"></A>Hybrid Device 	Refers to a SATA HBA that implements both an emulation and a native programming interface. <A NAME="marker-1378428"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1378429"></A><A NAME="95049"></A> Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1378430"></A>A SATA HBA differs from an IDE controller in a number of ways. First, it can save its complete device context. Second, it replaces IDE channels, which may support up to 2 attached devices, with ports, which support only a single attached device, unless a port multiplier is present. See the SATA spec at &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;SATA Specification&quot;for more information. Finally, SATA does not require timing information from the platform, allowing a simplification in how SATA controllers are represented in ACPI. (_GTM and _STM are replaced by the simpler _SDD method.)</P>
<P CLASS="Body">
<A NAME="pgfId-1378431"></A>All ports, even those attached off a port multiplier, are represented as children directly under the SATA controller device. This is practical because the SATA specification does not allow a port multiplier to be attached to a port multiplier. Each port&#8217;s _ADR indicates to which root port they are connected, as well as the port multiplier location, if applicable. (See <A HREF="Device_Configuration.htm#78816" CLASS="XRef">See ADR Object Address Encodings.</A> for _ADR format.)</P>
<P CLASS="Body">
<A NAME="pgfId-1378432"></A>Since this specification only covers the configuration of motherboard devices, it is also the case that the control methods defined in this section cannot be used to send taskfiles to devices attached via either an add-in SATA HBA, or attached via a motherboard SATA HBA, if used with a port multiplier that is not also on the motherboard.</P>
<P CLASS="Body">
<A NAME="pgfId-1378433"></A>The following shows an example SATA namespace:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378435"></A>&#92;_SB    - System bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378436"></A> PCI0   - PCI bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378437"></A>  SATA  - SATA Controller device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378438"></A>   ADR   - Indicates address of the controller on the PCI bus</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378439"></A>   PR0   - Power resources needed for D0 power state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378440"></A>   PRT0  - Port 0 device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378441"></A>    _ADR  - Indicates physical port and port multiplier topology</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378442"></A>    _SDD  - Identify information for drive attached to this port</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378443"></A>    _GTF  - Control method to get task file</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378444"></A>   PRTn  - Port n device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378445"></A>    _ADR  - Indicates physical port and port multiplier topology</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378446"></A>    _SDD  - Identify information for drive attached to this port</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378447"></A>    _GTF  - Control method to get task file</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1378449"></A><A NAME="48593"></A>SATA controller-specific control methods</H6>
<P CLASS="Body">
<A NAME="pgfId-1378450"></A>In order to ensure proper interaction between OSPM, the firmware, and devices attached to the SATA controller, it is a requirement that OSPM execute the _SDD and _GTF control methods when certain events occur. OSPM&#8217;s response to events must be as follows:</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1378451"></A>COMRESET, Initial OS load, device insertion, HBA D3 to D0 transition, asynchronous loss of signal:</H4>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1378452"></A>OSPM sends IDENTIFY DEVICE or IDENTIFY PACKET DEVICE command to the attached device.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378453"></A>OS executes _SDD. _SDD control method requires 1 argument that consists of the data block received from an attached device as a result of a host issued IDENTIFY DEVICE or IDENTIFY PACKET DEVICE command.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1378454"></A>After the _SDD method completes, the OS executes the _GTF method. Using the task file information provided by _GTF, the OS then sends the _GTF taskfiles to the attached device.</LI>
</OL>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1378455"></A>Device removal and HBA D0 to D3 transition:</H4>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1378456"></A>No OSPM action required.</LI>
</OL>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1382516"></A>_<A NAME="RSVD_SDD"></A>SDD (Set Device Data)</H6>
<P CLASS="Body">
<A NAME="pgfId-1378460"></A>This optional object is a control method that conveys to the platform the type of device connected to the port. The _SDD object may exist under a SATA port device object. The platform typically uses the information conveyed by the _SDD object to construct the values returned by the _GTF object.</P>
<P CLASS="Body">
<A NAME="pgfId-1378461"></A>OSPM conveys to the platform the ATA drive ID block, which is the raw data returned by the Identify (Packet) Device, ATA command (command code &#8220;0ech.&#8221;). Please see the ATA/ATAPI-6 specification for more details.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378462"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1378463"></A>Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA specification</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378464"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378465"></A>None</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378481"></A><A NAME="_Toc489256148"></A><A NAME="_Toc489268072"></A><A NAME="_Toc489272625"></A><A NAME="_Toc202341698"></A><A NAME="_Toc258262378"></A>Floppy Controller Device Objects<A NAME="marker-1378479"></A><A NAME="marker-1378480"></A></H2>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378494"></A><A NAME="_Toc489256149"></A><A NAME="_Toc489268073"></A><A NAME="_Toc489272626"></A><A NAME="RSVD_FDE"></A><A NAME="_Toc202341699"></A><A NAME="_Toc258262379"></A>_FDE (Floppy Disk Enumerate)<A NAME="marker-1378492"></A><A NAME="marker-1378493"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1388280"></A>Enumerating devices attached to a floppy disk controller is a time-consuming function. In order to speed up the process of floppy enumeration, ACPI defines an optional enumeration object that is defined directly under the device object for the floppy disk controller. It returns a buffer of five 32-bit values. The first four values are Boolean values indicating the presence or absence of the four floppy drives that are potentially attached to the controller. A non-zero value indicates that the floppy device is present. The fifth value returned indicates the presence or absence of a tape controller. Definitions of the tape presence value can be found in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#84854" CLASS="XRef">See Tape Presence.</A>.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1388281"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378497"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378498"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378499"></A>A Buffer containing a floppy drive information block, as decribed below</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378501"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493669"></A>Buffer (){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378502"></A> Floppy 0      // Boolean DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378503"></A> Floppy 1      // Boolean DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378504"></A> Floppy 2      // Boolean DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378505"></A> Floppy 3      // Boolean DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378506"></A> Tape       // DWORD - See table below</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378507"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1378508"></A><A NAME="84854"></A>Tape Presence</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378511"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1378513"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378515"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378517"></A>Device presence is unknown or unavailable</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378519"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378521"></A>Device is present</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378523"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378525"></A>Device is never present</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378527"></A>&gt;2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1378529"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378552"></A><A NAME="97508"></A>_FDI (Floppy Disk Information)</H6>
<P CLASS="Body">
<A NAME="pgfId-1382641"></A><A NAME="marker-1378550"></A>This object returns information about a floppy disk drive. This information is the same as that returned by the INT 13 Function 08H on IA-PCs.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378553"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378554"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378555"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378556"></A>A Package containing the floppy disk information as a list of Integers</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378558"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493683"></A>Package {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378559"></A> Drive Number      // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378560"></A> Device Type      // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378561"></A> Maximum Cylinder Number   // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378562"></A> Maximum Sector Number   // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378563"></A> Maximum Head Number    // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378564"></A> disk_specify_1     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378565"></A> disk_specify_2     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378566"></A> disk_motor_wait     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378567"></A> disk_sector_siz     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378568"></A> disk_eot       // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378569"></A> disk_rw_gap      // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378570"></A> disk_dtl       // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378571"></A> disk_formt_gap     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378572"></A> disk_fill      // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378573"></A> disk_head_sttl     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493695"></A> disk_motor_strt     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493696"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1493800"></A>ACPI Floppy Drive Information</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1493699"></A>Package Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1493701"></A>Element Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1493703"></A>Actual Valid Data Width</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493705"></A>00 - Drive Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493707"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493709"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493711"></A>01 - Device Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493713"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493715"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493717"></A>02 - Maximum Cylinder Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493719"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493721"></A>WORD</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493723"></A>03 - Maximum Sector Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493725"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493727"></A>WORD</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493729"></A>04 - Maximum Head Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493731"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493733"></A>WORD</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493735"></A>05 - Disk_specify_1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493737"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493739"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493741"></A>06 - Disk_specify_2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493743"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493745"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493747"></A>07 - Disk_motor_wait</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493749"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493751"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493753"></A>08 - Disk_sector_siz</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493755"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493757"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493759"></A>09 - Disk_eot</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493761"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493763"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493765"></A>10 - Disk_rw_gap</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493767"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493769"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493771"></A>11 - Disk_dtl</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493773"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493775"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493777"></A>12 - Disk_formt_gap</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493779"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493781"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493783"></A>13 - Disk_fill</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493785"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493787"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493789"></A>14 - Disk_head_sttl</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493791"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493793"></A>BYTE</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493795"></A>15 - Disk_motor_strt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493797"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1493799"></A>BYTE</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378701"></A><A NAME="marker-1378700"></A><A NAME="73966"></A>_FDM (Floppy Disk Drive Mode)</H6>
<P CLASS="Body">
<A NAME="pgfId-1378702"></A>This control method switches the mode (300 RPM or 360 RPM) of all floppy disk drives attached to this controller. If this control method is implemented, the platform must reset the mode of all drives to 300RPM mode after a Dx to D0 transition of the controller.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378703"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1378704"></A>Arg0 - An Integer containing the new drive mode</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1378705"></A>0 - Set the mode of all drives to 300 RPM mode</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1378706"></A>1 - Set the mode of all drives to 360 RPM mode</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1378707"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1378708"></A>None</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378719"></A><A NAME="_Toc489256152"></A><A NAME="_Toc489268076"></A><A NAME="_Toc489272629"></A><A NAME="_Toc202341707"></A><A NAME="_Toc258262382"></A>GPE Block Device<A NAME="marker-1378717"></A><A NAME="marker-1378718"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1378720"></A>The GPE Block device is an optional device that allows a system designer to describe GPE blocks beyond the two that are described in the FADT. Control methods associated with the GPE pins of GPE block devices exist as children of the GPE Block device, not within the &#92;_GPE namespace. Because GPE block devices are meant as an extension to the GPE blocks defined in the FADT, and that portion of the FADT is to be ignored in hardware-reduced ACPI, GPE block devices are not supported in hardware-reduced ACPI.</P>
<P CLASS="Body">
<A NAME="pgfId-1378721"></A>A GPE Block device consumes I/O or memory address space, as specified by its _PRS or _CRS child objects. The interrupt vector used by the GPE block does not need to be the same as the SCI_INT field. The interrupt used by the GPE block device is specified in the _CRS and _PRS methods associated with the GPE block. The _CRS of a GPE Block device may only specify a single register address range, either I/O or memory. This range contains two registers: the GPE status and enable registers. Each register&#8217;s length is defined as half of the length of the _CRS-defined register address range.</P>
<P CLASS="Body">
<A NAME="pgfId-1378722"></A>A GPE Block device must have a _HID or a _CID of &#8220;ACPI0006.&#8221;</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1378723"></A>A system designer must describe the GPE block necessary to bootstrap the system in the FADT as a GPE0/GPE1 block. GPE Block devices cannot be used to implement these GPE inputs.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1378724"></A>A GPE Block Device must contain the _Lxx, _Exx, _Wxx, _CRS, _PRS, and _SRS methods required to use and program that block.</P>
<P CLASS="Body">
<A NAME="pgfId-1378725"></A>To represent the GPE block associated with the FADT, the system designer shouldinclude in the namespace a Device object with the ACPI0006 _HID that contains no _CRS, _PRS, _SRS, _Lxx, _Exx, or _Wxx methods. OSPM assumes that the first such ACPI0006 device is the GPE Block Device that is associated with the FADT GPEs. (See the example below).</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378728"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1494187"></A>// ASL example of a standard GPE block device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378729"></A>Device(&#92;_SB.PCI0.GPE1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378730"></A> Name(_HID, &#8221;ACPI0006&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378731"></A> Name(_UID, 2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378732"></A> Name(_CRS, Buffer () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378733"></A>  IO(Decode16, FC00, FC03, 4, 4,) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378734"></A>  IRQ( Level, ActiveHigh, Shared,) { 5 }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378735"></A> })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378736"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378737"></A> Method(_L02) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378738"></A> Method(_E07) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378739"></A> Method(_W04) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378740"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378741"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378742"></A>// ASL example of a GPE block device that refers to the FADT GPEs.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378743"></A>// Cannot contain any _Lxx, _Exx, _Wxx, _CRS, _PRS, or. _SRS methods.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378744"></A>Device(&#92;_SB.PCI0.GPE0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378745"></A> Name(_HID,&#8221;ACPI0006&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378746"></A> Name(_UID,1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378747"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1378749"></A>Notice that it is legal to replace the I/O descriptors with Memory descriptors if the register is memory mapped.</P>
<P CLASS="Body">
<A NAME="pgfId-1378750"></A>If the system must run any GPEs to bootstrap the system (for example, when Embedded Controller events are required), the associated block of GPEs must be described in the FADT. This register block is not relocatable and will always be available for the life of the operating system boot.</P>
<P CLASS="Body">
<A NAME="pgfId-1378751"></A>A GPE block associated with the ACPI0006 _HID can be stopped, ejected, reprogrammed, and so on. The system can also have multiple such GPE blocks. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1378765"></A><A NAME="_Toc489256153"></A><A NAME="_Toc489268077"></A><A NAME="_Toc489272630"></A><A NAME="_Toc202341708"></A><A NAME="_Toc258262383"></A>Matching Control Methods for Events in a GPE Block Device</H6>
<P CLASS="Body">
<A NAME="pgfId-1378766"></A>When a GPE Device raises an interrupt, OSPM executes a corresponding control method (as described in <A HREF="ACPI_Software_Programming_Model.htm#45352" CLASS="XRef">See Queuing the Matching Control Method for Execution.</A>, &#8220;Queuing the Matching Control Method for Execution&#8221;). These control methods (of the form _Lxx, _Exx, and _Wxx) for GPE Devices are not within the &#92;_GPE namespace. They are children of the GPE Block device.</P>
<P CLASS="Body">
<A NAME="pgfId-1378767"></A>For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493819"></A>Device(GPE5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378770"></A>  Name(_HID, &#8220;ACPI0006&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378771"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378772"></A>  Method(_L02) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378773"></A>  Method(_E07) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378774"></A>  Method(_W04) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378775"></A>}</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1378786"></A><A NAME="_Toc489256154"></A><A NAME="_Toc489268078"></A><A NAME="_Toc489272631"></A><A NAME="_Toc202341709"></A><A NAME="_Toc258262384"></A>Module Device<A NAME="marker-1378784"></A><A NAME="marker-1378785"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1378787"></A>This optional device is a container object that acts as a bus node in a namespace. It may contain child objects that are devices or buses. The module device is declared using the ACPI0004 hardware identifier (HID).</P>
<P CLASS="Body">
<A NAME="pgfId-1378788"></A>If the module device contains a _CRS object, the &#8220;bus&#8221; described by this object is assumed to have these resources available for consumption by its child devices. If a _CRS object is present, any resources not produced in the module device&#8217;s _CRS object may not be allocated to child devices.</P>
<P CLASS="Body">
<A NAME="pgfId-1499391"></A>Providing a _CRS object is undesirable in some module devices. For example, consider a module device used to describe an add-in board containing multiple host bridges without any shared resource decoding logic. In this case the resource ranges available to the host bridges are not controlled by any entity residing on the add-in board, implying that a _CRS object in the associated module device would not describe any real feature of the underlying hardware. A module device must contain a _CRS object if the device contains any PCI host bridge devices.</P>
<P CLASS="Body">
<A NAME="pgfId-1378789"></A>To account for cases like this, the system designer may optionally omit the module device&#8217;s _CRS object. If no _CRS object is present, OSPM will assume that the module device is a simple container object that does not produce the resources consumed by its child devices. In this case, OSPM will assign resources to the child devices as if they were direct children of the module device's parent object.</P>
<P CLASS="Body">
<A NAME="pgfId-1378791"></A>For an example with a module device _CRS object present, consider a Module Device containing three child memory devices. If the _CRS object for the Module Device contains memory from 2 GB through 6 GB, then the child memory devices may only be assigned addresses within this range.</P>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1378792"></A>Example:</H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1493826"></A>Device (&#92;_SB.NOD0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378795"></A> Name (_HID, &quot;ACPI0004&quot;)     // Module device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378796"></A> Name (_UID, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378797"></A> Name (_PRS, ResourceTemplate() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378798"></A>  WordIO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378799"></A>   ResourceProducer,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378800"></A>   MinFixed,     // _MIF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378801"></A>   MaxFixed,,,    // _MAF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378802"></A>   0x0000,     // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378803"></A>   0x0000,     // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378804"></A>   0x7FFF,     // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484442"></A>   0x0,      // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484443"></A>   0x8000)     // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484444"></A>  DWordMemory (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484394"></A>   ResourceProducer,,  // For Main Memory + PCI</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378809"></A>   MinNotFixed,    // _MIF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378810"></A>   MaxNotFixed,    // _MAF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378811"></A>   Cacheable,    // _MEM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378812"></A>   ReadWrite,    // _RW</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378813"></A>   0x0FFFFFFF,    // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378814"></A>   0x40000000,    // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378815"></A>   0x7FFFFFFF,    // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378816"></A>   0x0,      // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378817"></A>   0x00000000)    // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378818"></A> })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378819"></A> Method (_SRS, 1) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378820"></A> Method (_CRS, 0) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378821"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378822"></A> Device (MEM0) {     // Main Memory (256MB module)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378823"></A>  Name (_HID, EISAID(&quot;PNP0C80&quot;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378824"></A>  Name (_UID, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378825"></A>  Method (_STA, 0) {   // If memory not present --&gt; Return(0x00)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378826"></A>          // Else if memory is disabled --&gt; Return(0x0D)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378827"></A>          // Else --&gt; Return(0x0F)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378828"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378829"></A>  Name (_PRS, ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378830"></A>   DWordMemory (,,,,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378831"></A>    Cacheable,   // _MEM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378832"></A>    ReadWrite,   // _RW</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378833"></A>    0x0FFFFFFF,   // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378834"></A>    0x40000000,   // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378835"></A>    0x7FFFFFFF,   // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378836"></A>    0x0,     // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378837"></A>    0x10000000)   // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378838"></A>  })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378839"></A>  Method (_CRS, 0) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378840"></A>  Method (_SRS, 1) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378841"></A>  Method (_DIS, 0) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378842"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378843"></A> Device (MEM1) {     // Main Memory (512MB module)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378844"></A>  Name (_HID, EISAID(&quot;PNP0C80&quot;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378845"></A>  Name (_UID, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378846"></A>  Method (_STA, 0) {    // If memory not present --&gt; Return(0x00)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378847"></A>          // Else if memory is disabled --&gt; Return(0x0D)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378848"></A>          // Else --&gt; Return(0x0F)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378849"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378850"></A>  Name (_PRS, ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378851"></A>   DWordMemory (,,,,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378852"></A>    Cacheable,   // _MEM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378853"></A>    ReadWrite,   // _RW</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378854"></A>    0x1FFFFFFF,   // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378855"></A>    0x40000000,   // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378856"></A>    0x7FFFFFFF,   // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378857"></A>    0x0,     // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378858"></A>    0x20000000)   // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378859"></A>  })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378860"></A>  Method (_CRS, 0) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378861"></A>  Method (_SRS, 1) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378862"></A>  Method (_DIS, 0) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378863"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378866"></A><A NAME="OLE_LINK55"></A><A NAME="OLE_LINK56"></A> Device (PCI0) {     // PCI Root Bridge</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378867"></A>  Name (_HID, EISAID(&quot;PNP0A03&quot;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378868"></A>  Name (_UID, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378869"></A>  Name (_BBN, 0x00)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378870"></A>  Name (_PRS, ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378871"></A>   WordBusNumber (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378872"></A>    ResourceProducer,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378873"></A>    MinFixed,    // _MIF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378874"></A>    MaxFixed,,   // _MAF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484110"></A>    0x00,     // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484111"></A>    0x00,     // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484112"></A>    0x7F,     // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484113"></A>    0x0,     // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484105"></A>    0x80)     // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378880"></A>   WordIO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378881"></A>    ResourceProducer,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378882"></A>    MinFixed,    // _MIF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378883"></A>    MaxFixed,,,   // _MAF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378884"></A>    0x0000,    // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378885"></A>    0x0000,    // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378886"></A>    0x0CF7,    // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378887"></A>    0x0,     // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378888"></A>    0x0CF8)    // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378889"></A>   WordIO (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378890"></A>    ResourceProducer,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378891"></A>    MinFixed,    // _MIF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378892"></A>    MaxFixed,,,   // _MAF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378893"></A>    0x0000,    // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378894"></A>    0x0D00,    // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378895"></A>    0x7FFF,    // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378896"></A>    0x0,     // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378897"></A>    0x7300)    // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378903"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378904"></A>   DWordMemory (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378905"></A>    ResourceProducer,,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378906"></A>    MinNotFixed,   // _MIF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378907"></A>    MaxNotFixed,   // _MAF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378908"></A>    NonCacheable,   // _MEM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378909"></A>    ReadWrite,   // _RW</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378910"></A>    0x0FFFFFFF,   // _GRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378911"></A>    0x40000000,   // _MIN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378912"></A>    0x7FFFFFFF,   // _MAX</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378913"></A>    0x0,     // _TRA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378914"></A>    0x00000000)   // _LEN</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378915"></A>  })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378916"></A>  Method (_CRS, 0) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378917"></A>  Method (_SRS, 1) { ... }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378918"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1378919"></A>}</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1507424"></A><A NAME="30870"></A>Memory Devices<A NAME="marker-1508169"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1507425"></A>Memory devices allow a platform to convey dynamic properties of memory to OSPM and are required when a platform supports the addition or removal of memory while the system is active or when the platform supports memory bandwidth monitoring and reporting (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#99513" CLASS="XRef">See Memory Bandwidth Monitoring and Reporting.</A>, Memory Bandwidth Monitoring and Reporting). Memory devices may describe exactly the same physical memory that the System Address Map interfaces describe (see chapter 15, <A HREF="Sys_Address_Map_Interfaces.htm#68313" CLASS="XRef">See System Address Map Interfaces.</A>). They do not describe how that memory is, or has been, used. If a region of physical memory is marked in the System Address Map interface as AddressRangeReserved or AddressRangeNVS and it is also described in a memory device, then it is the responsibility of the OS to guarantee that the memory device is never disabled.</P>
<P CLASS="Body">
<A NAME="pgfId-1507433"></A>It is not necessary to describe all memory in the system with memory devices if there is some</P>
<P CLASS="Body">
<A NAME="pgfId-1507539"></A> memory in the system that is static in nature. If, for instance, the memory that is used for the first 16 MB of system RAM cannot be ejected, inserted, or disabled, that memory may only be represented by the System Address Map interfaces. But if memory can be ejected, inserted, or disabled, or if the platform supports memory bandwidth monitoring and reporting, the memory must be represented by a memory device.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1507440"></A>Address Decoding<A NAME="marker-1508181"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1507441"></A>Memory devices must provide a _CRS object that describes the physical address space that the memory decodes. If the memory can decode alternative ranges in physical address space, the devices may also provide _PRS, _SRS and _DIS objects. Other device objects may also apply if the device can be ejected.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1507443"></A><A NAME="99513"></A>Memory Bandwidth Monitoring and Reporting</H6>
<P CLASS="Body">
<A NAME="pgfId-1507444"></A>During platform operation, an adverse condition external to the platform may arise whose remedy requires a reduction in the platform&#8217;s available memory bandwidth. For example, a server management controller&#8217;s detection of an adverse thermal condition or the need to reduce the total power consumption of platforms in the data center to stay within acceptable limits. Providing OSPM with knowledge of a platform induced reduction of memory bandwidth enables OSPM to provide more robust handling of the condition. The following sections describe objects OSPM uses to configure platform-based memory bandwidth monitoring and to ascertain available memory bandwidth when the platform performs memory bandwidth throttling. </P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1507446"></A><A NAME="81152"></A>_MBM (Memory Bandwidth Monitoring Data)</H6>
<P CLASS="Body">
<A NAME="pgfId-1507447"></A>The optional _MBM object provides memory bandwidth monitoring information for the memory device.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1507448"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1507449"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1507450"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1507454"></A>A Package containing memory device status information as described in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#91259" CLASS="XRef">See MBM Package Details.</A> below</P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379081"></A>Return Value Information:</H4>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379082"></A>_MBM evaluation returns a package of the following format:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379084"></A>Package (){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379085"></A>  Revision,     // Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379086"></A>  WindowSize,     // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379087"></A>  SamplingInterval,   // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379088"></A>  MaximumBandwidth,   // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379089"></A>  AverageBandwidth,   // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379090"></A>  LowBandwidth,    // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379091"></A>  LowNotficationThreshold,  // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379092"></A>  HighNotificationThreshold // Integer DWORD</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379093"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1379095"></A><A NAME="91259"></A>MBM Package Details</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379098"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379100"></A>Format</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379102"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379104"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379106"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379108"></A>Current revision is: 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379110"></A>Window Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379112"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379114"></A>This field indicates the size of the averaging window (in seconds) that the platform uses to report average bandwidth.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379116"></A>Sampling Interval</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379118"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379120"></A>This field indicates the sampling interval (in seconds) that the platform uses to record bandwidth during the averaging window.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379122"></A>Maximum Bandwidth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379124"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379126"></A>This field indicates the maximum memory bandwidth (in megabytes per second) for the memory described by this memory device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379128"></A>Average Bandwidth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379130"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379132"></A>This field indicates the moving average memory bandwidth (in percent) for the averaging window.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379134"></A>Low Bandwidth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379136"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379138"></A>This field indicates the lowest memory bandwidth (in percent) recorded for the averaging window.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379140"></A>Low Notification Threshold</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379142"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379144"></A>The platform to issues a Notify (0x80) on the memory device when the moving average memory bandwidth value (in percent) falls below the value indicated by this field. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379146"></A>High Notification Threshold</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379148"></A>Integer (DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379150"></A>The platform to issues a Notify (0x81) on the memory device when the moving average memory bandwidth value (in percent) increases to or exceeds the value indicated by this field. </P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1379155"></A><A NAME="88657"></A> _MSM (Memory Set Monitoring)</H6>
<P CLASS="Body">
<A NAME="pgfId-1379156"></A>This optional object sets the memory bandwidth monitoring parameters described in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#91259" CLASS="XRef">See MBM Package Details.</A>.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379157"></A>Arguments: (4)</H4>
<P CLASS="Body">
<A NAME="pgfId-1379158"></A>Arg0 - WindowSize (Integer(DWORD)): indicates the window size in seconds.</P>
<P CLASS="Body">
<A NAME="pgfId-1379159"></A>Arg1 - SamplingInterval (Integer(DWORD)): indicates the sampling interval in seconds.</P>
<P CLASS="Body">
<A NAME="pgfId-1379160"></A>Arg2 - LowNotificationThreshold (Integer(DWORD)): indicates the low notification threshold in percent. Must be &lt;= HighNotificationThreshold.</P>
<P CLASS="Body">
<A NAME="pgfId-1379161"></A>Arg3 - HighNotificationThreshold (Integer(DWORD)): indicates the high notification threshold in percent. Must be &gt;= LowNotificationThreshold.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379162"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1379163"></A>An Integer (DWORD) containing a bit encoded result code as follows: </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379164"></A>0x00000000 - 	Succeeded to set all memory bandwidth monitoring parameters.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379165"></A>Non-Zero - 	At least one memory bandwith monitoring parameter value could not be set as follows:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1379166"></A>MSM Result Encoding</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379169"></A>Bits</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379171"></A>Definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379173"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379175"></A>If clear indicates WindowSize was set successfully. If set, indicates invalid WindowSize argument.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379177"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379179"></A>If clear indicates SamplingInterval was set successfully. If set, indicates invalid SamplingInterval argument.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379181"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379183"></A>If clear indicates LowNotificationThreshold was set successfully. If set, indicates invalid LowNotificationThreshold argument.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379185"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379187"></A>If clear indicates HighNotificationThreshold was set successfully. If set, indicates invalid HighNotificationThreshold argument.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379189"></A>31:4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379191"></A>Reserved (must be 0)</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379200"></A>_<A NAME="_Toc258262389"></A>OSC Definition for Memory Device</H6>
<P CLASS="Body">
<A NAME="pgfId-1379201"></A>OSPM evaluates _OSC under the Memory Device to convey OSPM capabilities to the platform. Argument definitions are as follows:</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379202"></A>Arguments: (4)</H4>
<P CLASS="Body">
<A NAME="pgfId-1379203"></A>Arg0 - UUID (Buffer): 03B19910-F473-11DD-87AF-0800200C9A66</P>
<P CLASS="Body">
<A NAME="pgfId-1379204"></A>Arg1 - Revision ID (Integer): 1</P>
<P CLASS="Body">
<A NAME="pgfId-1379205"></A>Arg2 - Count of Entries in Arg3 (Integer): 2</P>
<P CLASS="Body">
<A NAME="pgfId-1498523"></A>Arg3 - DWORD capabilities (Buffer): </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1512963"></A>First DWORD: as described in <A HREF="Device_Configuration.htm#_Toc489256054" CLASS="XRef">See _MAT (Multiple APIC Table Entry).</A></LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1512969"></A>Second DWORD: See <A HREF="Device_Configuration.htm#14334" CLASS="XRef">See DWORD Address Space Descriptor Definition.</A>.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1498524"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1379208"></A>A Buffer containing platform capabilities</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1379210"></A>Memory Device _OSC Capabilities DWORD number 2</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379213"></A>Bits</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379215"></A>Field Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1379217"></A>Definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379219"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379221"></A>Memory Bandwidth Change Notifications</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379223"></A>This bit is set if OSPM supports the processing of memory bandwidth change notifications. If the platform supports the ability to issue a notification when Memory Bandwidth changes, it may only do so after _OSC has been evaluated with this bit set. _OSC evaluation with this bit clear will cause the platform to cease issuing notifications if previously enabled.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379225"></A>31:1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379227"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379229"></A>Reserved (must be 0)</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379233"></A>Return Value Information</H4>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379234"></A>Capabilities Buffer (Buffer) - The platform acknowledges the Capabilities Buffer by returning a buffer of DWORDs of the same length. Set bits indicate acknowledgement and cleared bits indicate that the platform does not support the capability. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379243"></A><A NAME="_Toc489256157"></A><A NAME="_Toc489268081"></A><A NAME="_Toc489272634"></A><A NAME="_Toc202341713"></A><A NAME="_Toc258262390"></A>Example: Memory Device</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1379245"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493856"></A>Scope (&#92;_SB){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379246"></A> Device (MEM0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379247"></A>  Name (_HID, EISAID (&#8220;PNP0C80&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379248"></A>  Name (_CRS, ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379249"></A>   QWordMemory </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379250"></A>    ResourceConsumer,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379251"></A>    ,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379252"></A>    MinFixed,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379253"></A>    MaxFixed,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379254"></A>    Cacheable,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379255"></A>    ReadWrite,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379256"></A>    0xFFFFFFF,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379257"></A>    0x10000000,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379258"></A>    0x30000000,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379259"></A>    0,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379260"></A>    ,,)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379261"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379262"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379263"></A>}</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1379268"></A><A NAME="RSVD_UPC"></A><A NAME="_Toc202341714"></A><A NAME="_Toc258262391"></A>_UPC (USB Port Capabilities) </H2>
<P CLASS="Body">
<A NAME="pgfId-1379269"></A>This optional object is a method that allows the platform to communicate to the operating system, certain USB port capabilities that are not provided for through current USB host bus adaptor specifications (e.g. UHCI, OHCI and EHCI). If implemented by the platform, this object will be present for each USB port (child) on a given USB host bus adaptor; operating system software can examine these characteristics at boot time in order to gain knowledge about the system&#8217;s USB topology, available USB ports, etc. This method is applicable to USB root hub ports as well as ports that are implemented through integrated USB hubs.</P>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379270"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379271"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379272"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379273"></A>A Package as described below</P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379274"></A>Return Value Information:</H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1493863"></A>Package {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379277"></A> Connectable     // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379278"></A> Type      // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379279"></A> Reserved0     // Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379280"></A> Reserved1     // Integer)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379281"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1379288"></A><A NAME="62523"></A>UPC Return Package Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1484505"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1484507"></A>Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1484509"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379297"></A>Connectable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379299"></A>Integer (BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379301"></A>If this value is non-zero, then the port is connectable. If this value is zero, then the port is not connectable.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379303"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379305"></A>Integer (BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379307"></A>Specifies the host connector type. It is ignored by OSPM if the port is not user visible:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379308"></A>0x00: 		Type &#8216;A&#8217; connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379309"></A>0x01: 		Mini-AB connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379310"></A>0x02: 		ExpressCard</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379311"></A>0x03: 		USB 3 Standard-A connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379312"></A>0x04: 		USB 3 Standard-B connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379313"></A>0x05: 		USB 3 Micro-B connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379314"></A>0x06: 		USB 3 Micro-AB connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379315"></A>0x07: 		USB 3 Power-B connector</P>
<P CLASS="TableBody">
<A NAME="pgfId-1500470"></A>0x08: 		Type C connector - USB2-only</P>
<P CLASS="TableBody">
<A NAME="pgfId-1500471"></A>0x09: 		Type C connector - USB2 and SS with Switch</P>
<P CLASS="TableBody">
<A NAME="pgfId-1500472"></A>0x0A: 		Type C connector - USB2 and SS without Switch</P>
<P CLASS="TableBody">
<A NAME="pgfId-1500473"></A>0x0B- 0xFE:  Reserved</P>
<P CLASS="TableBody">
<A NAME="pgfId-1379317"></A>0xFF:		Proprietary connector</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379319"></A>Reserved0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379321"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379323"></A>This value is reserved for future use and must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379325"></A>Reserved1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379327"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1379329"></A>This value is reserved for future use and must be zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379332"></A>Additional Notes:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379333"></A>The definition of a 'connectable' port is dependent upon the implementation of the USB port within a particular platform. For example, </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1379334"></A>If a USB port is user visible<EM CLASS="footnote-reference">
 </EM>
(as indicated by the _PLD object) and connectable, then an end user can freely connect and disconnect USB devices to the USB port.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1379335"></A>If a USB port is not user visible and is connectable, then an end user cannot freely connect and disconnect USB devices to the USB port. A USB device that is directly &quot;hard-wired&quot; to a USB port is an example of a USB port that is not user visible and is connectable.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1379336"></A>If a USB port is not user visible and is not connectable, then the USB port is physically implemented by the USB host controller, but is not being used by the platform and therefore cannot be accessed by an end user.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1379337"></A>A USB port cannot be specified as both visible and not connectable.</P>
<P CLASS="Body">
<A NAME="pgfId-1500495"></A>The pins of a Type-C connector support one USB2 signal pair (D+/D-) and two SuperSpeed signal pairs (SSTXp1/SSTXn1 and SSRXp2/SSRXn2). The use of two SS signal pairs allows the CC wire and USB SuperSpeed data bus wires to be used for signaling within the cable track without regard to the orientation and twist of the cable.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1500496"></A>Type C connector - USB2 USB2-only receptacles</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1500513"></A> These only implement the USB2 signal pair, and do not implement the SS signal pairs.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1500497"></A>Type C connector - USB2 and SS with Switch receptacles</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1500516"></A> These implement the USB2 signal pair, and a Functional Switch with a physical Multiplexer that is used to dynamically connect one of the two receptacle SuperSpeed signal pairs to a single USB Host Controller port as function of the Type-C plug orientation.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1500498"></A>Type C connector - USB2 and SS <EM CLASS="Italic">
without</EM>
 Switch receptacles </H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1500527"></A>These implement the USB2 signal pair and a Functional Switch by connecting each receptacle SuperSpeed signal pair to a separate USB Host Controller port.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1500499"></A>Refer to section 4.5.1.1 in the USB Type-C Specification for more information.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379338"></A>Example</H4>
<P CLASS="Body">
<A NAME="pgfId-1379339"></A>The following is an example of a port characteristics object implemented for a USB host controller&#8217;s root hub where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1379340"></A>Three Ports are implemented; Port 1 is not user visible/not connectable and Ports 2 and 3 are user visible and connectable.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1379341"></A>Port 2 is located on the back panel </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1379342"></A>Port 3 has an integrated 2 port hub. Note that because this port hosts an integrated hub, it is therefore not sharable with another host controller (e.g. If the integrated hub is a USB2.0 hub, the port can never be shared with a USB1.1 companion controller).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1379343"></A>The ports available through the embedded hub are located on the front panel and are adjacent to one another.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-1379347"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-5.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1382997"></A>USB ports</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1379349"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493870"></A>//</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379350"></A>// Root hub device for this host controller. This controller implements 3 root hub ports. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379351"></A>//</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379352"></A>Device( RHUB) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379353"></A>  Name( _ADR, 0x00000000)   // Value of 0 is reserved for root HUB</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379354"></A>  // Root hub, port 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379355"></A>  Device( PRT1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379356"></A>   // Address object for port 1. This value must be 1 </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379357"></A>   Name( _ADR, 0x00000001)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379358"></A>   // USB port capabilities object. This object returns the system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379359"></A>   // specific USB port configuration information for port number 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379360"></A>   // Because this port is not connectable it is assumed to be not visible. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379361"></A>   // Therefore a _PLD descriptor is not required.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1383068"></A>   Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1383069"></A>    0x00,      // Port is not connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1383070"></A>    0xFF,      // Connector type (N/A for non-visible ports)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379365"></A>    0x00000000,    // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379366"></A>    0x00000000})    // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379367"></A> }          // Device( PRT1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379368"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379369"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379370"></A>           // Root Hub, Port 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379371"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379372"></A> Device( PRT2) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379373"></A>           // Address object for port 2. This value must be 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379374"></A>   Name(_ADR, 0x00000002)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379375"></A>   Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379376"></A>    0xFF,      // Port is connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379377"></A>    0x00,      // Connector type - Type &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379378"></A>    0x00000000,    // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379379"></A>    0x00000000})    // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379380"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379381"></A>           // provide physical port location info</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379382"></A>   Name( _PLD, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379383"></A>    Buffer(0x14) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379384"></A>     0x82,0x00,0x00,0x00, // Revision 2, Ignore color</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379385"></A>           // Color (ignored), width and height not</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379386"></A>     0x00,0x00,0x00,0x00, // required as this is a standard USB &#8216;A&#8217; type</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379387"></A>           // connector</P>
<P CLASS="Body">
<A NAME="pgfId-1379388"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379389"></A>     0x69,0x0c,0x00,0x00, // User visible, Back panel, Vertical</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379390"></A>           // Center, shape = vert. rectangle</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379391"></A>     0x03,0x00,0x00,0x00, // ejectable, requires OPSM eject assistance</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379392"></A>     0xFF,0xFF,0xFF,0xFF})} // Vert. and Horiz. Offsets not supplied</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379393"></A>}           // Device( PRT2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379394"></A> &nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379395"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379396"></A>           // Root Hub, Port 3</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379397"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379398"></A> Device( PRT3) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379399"></A>           // This device is the integrated USB hub.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379400"></A>           // Address object for port 3. This value must be 3</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484341"></A>  Name(_ADR, 0x00000003)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484342"></A>  // Because this port is not connectable it is assumed to be not visible. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1484343"></A>  // Therefore a _PLD descriptor is not required.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379404"></A>  Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379405"></A>   0xFF,       // Port is connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379406"></A>   0xFF,       // Connector type (N/A for non-visible ports)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379407"></A>   0x00000000,     // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379408"></A>   0x00000000})     // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379409"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379410"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379411"></A>           // Integrated hub, port 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379412"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379413"></A>   Device( PRT1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379414"></A>   // Address object for the port. Because the port is implemented on </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379415"></A>   // integrated hub port #1, this value must be 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379416"></A>   Name( _ADR, 0x00000001)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379417"></A>   // USB port characteristics object. This object returns the system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379418"></A>   // specific USB port configuration information for integrated hub port</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379419"></A>   // number 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379420"></A>   Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379421"></A>    0xFF,      // Port is connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379422"></A>    0x00,      // Connector type - Type &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379423"></A>    0x00000000,    // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379424"></A>0x00000000})        // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379425"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379426"></A>           // provide physical port location info</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379427"></A>   Name( _PLD, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379428"></A>    Buffer(0x14) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379429"></A>    0x82,0x00,0x00,0x00,,  // Revision 2, Ignore color</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1383134"></A>           // Color (ignored), width and height not</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1383135"></A>    0x00,0x00,0x00,0x00,  // required as this is a standard USB &#8216;A&#8217; type</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379432"></A>           // connector</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379433"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379434"></A> 0xa1,0x10,0x00,0x00,     // User visible, front panel, Vertical</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379435"></A>           // lower, horz. Left, shape = horz. rectangle</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379436"></A>    0x03,0x00,0x00,0x00,  // ejectable, requires OPSM eject assistance</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379437"></A>    0xFF,0xFF,0xFF,0xFF})}  // Vert. and Horiz. Offsets not supplied</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379438"></A>   }        // Device( PRT1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379439"></A>   </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379440"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379441"></A>           // Integrated hub, port 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379442"></A>           //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379443"></A>   Device( PRT2) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379444"></A>    // Address object for the port. Because the port is implemented on </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379445"></A>    // integrated hub port #2, this value must be 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379446"></A>    Name( _ADR, 0x00000002)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379447"></A>    // USB port characteristics object. This object returns the system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379448"></A>    // specific USB port configuration information for integrated hub port</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379449"></A>    // number 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379450"></A>    Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379451"></A>     0xFF,     // Port is connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379452"></A>     0x00,     // Connector type - Type &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379453"></A>     0x00000000,    // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379454"></A>     0x00000000})   // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379455"></A>    Name( _PLD, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379456"></A>     Buffer(0x14) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379457"></A>     0x82,0x00,0x00,0x00, // Revision 2, Ignore color</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379458"></A>           // Color (ignored), width and height not</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379459"></A>     0x00,0x00,0x00,0x00, // required as this is a standard USB &#8216;A&#8217; type</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379460"></A>           // connector</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379461"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379462"></A>     0xa1,0x12,0x00,0x00, // User visible, front panel, Vertical</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379463"></A>           // lower, horz. right, shape = horz. rectangle</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379464"></A>     0x03,0x00,0x00,0x00, // ejectable, requires OPSM eject assistance</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379465"></A>     0xFF,0xFF,0xFF,0xFF}) // Vert. and Horiz. Offsets not supplied</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379466"></A>   }        // Device( PRT2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379467"></A>  }         // Device( PRT3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379468"></A>}           // Device( RHUB)</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379472"></A><A NAME="_Toc202341715"></A><A NAME="_Toc258262392"></A>USB 2.0 Host Controllers and _UPC and _PLD</H6>
<P CLASS="Body">
<A NAME="pgfId-1379473"></A>Platforms implementing USB2.0 host controllers that consist of one or more USB1.1 compliant companion controllers (e.g. UHCI or OHCI) must implement a _UPC and a _PLD object for each port USB port that can be routed between the EHCI host controller and its associated companion controller. This is required because a USB Port Capabilities object implemented for a port that is a child of an EHCI host controller may not be available if the OSPM disables the parent host controller. For example, if root port 1 on an EHCI host controller is routable to root port 1 on its companion controller, then the namespace must provide a _UPC and a _PLD object under each host controller&#8217;s associated port 1 child object. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379474"></A>Example</H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1379476"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493884"></A>Scope( &#92;_SB) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379477"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379478"></A>Device(PCI0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379479"></A>... </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379480"></A>       // Host controller (EHCI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379481"></A>Device( USB0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379482"></A>        // PCI device#/Function# for this HC. Encoded as specified in the ACPI</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379483"></A>       // specification</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379484"></A>Name(_ADR, 0xyyyyzzzz)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379485"></A>       // Root hub device for this HC #1. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379486"></A>Device(RHUB) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379487"></A>Name(_ADR, 0x00000000)  // must be zero for USB root hub</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379488"></A>       // Root hub, port 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379489"></A>Device(PRT1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379490"></A>Name(_ADR, 0x00000001)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379491"></A>     </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379492"></A>     // USB port configuration object. This object returns the system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379493"></A>// specific USB port configuration information for port number 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379494"></A>// Must match the _UPC declaration for USB1.RHUB.PRT1 as it is this </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379495"></A>// host controller&#8217;s companion</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379496"></A>Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379497"></A>0xFF,      // Port is connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379498"></A>0x00,      // Connector type - Type &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379499"></A>0x00000000,     // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379500"></A>0x00000000})     // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379501"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379502"></A>// provide physical port location info for port 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379503"></A>// Must match the _UPC declaration for USB1.RHUB.PRT1 as it is this </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379504"></A>// host controller&#8217;s companion</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379505"></A>Name( _PLD, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379506"></A> Buffer(0x14) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379507"></A> 0x82,0x00,0x00,0x00, // Revision 2, Ignore color</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379508"></A>       // Color (ignored), width and height not</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379509"></A> 0x00,0x00,0x00,0x00, // required as this is a standard USB &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379510"></A>       // type connector</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379511"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379512"></A> 0xa1,0x10,0x00,0x00, // User visible, front panel, Vertical</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379513"></A>       // lower, horz. Left, shape = horz. Rect.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379514"></A> 0x03,0x00,0x00,0x00, // ejectable, needs OPSM eject assistance</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379515"></A>     0xFF,0xFF,0xFF,0xFF})}  // Vert. and Horiz. Offsets not supplied</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379516"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379517"></A>}       // Device( PRT1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379518"></A>       //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379519"></A>       // Define other ports, control methods, etc</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379520"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379521"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379522"></A>}       // Device( RHUB)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379523"></A>}       // Device( USB0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379524"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379525"></A>       // Companion Host controller (OHCI or UHCI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379526"></A>Device( USB1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379527"></A>       // PCI device#/Function# for this HC. Encoded as specified in the ACPI</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379528"></A>       // specification</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379529"></A>Name(_ADR, 0xyyyyzzzz)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379530"></A>       // Root hub device for this HC #1. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379531"></A>Device(RHUB) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379532"></A>Name(_ADR, 0x00000000)  // must be zero for USB root hub</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379533"></A>       // Root hub, port 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379534"></A>Device(PRT1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379535"></A>Name(_ADR, 0x00000001)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379536"></A>// USB port configuration object. This object returns the system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379537"></A>// specific USB port configuration information for port number 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379538"></A>// Must match the _UPC declaration for USB0.RHUB.PRT1 as this host </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379539"></A>// controller is a companion to the EHCI host controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379540"></A>// provide physical port location info for port 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379541"></A>Name( _UPC, Package(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379542"></A>0xFF,      // Port is connectable</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379543"></A>0x00,      // Connector type - Type &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379544"></A>0x00000000,     // Reserved 0 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379545"></A>0x00000000})    // Reserved 1 - must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379546"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379547"></A>// Must match the _PLD declaration for USB0.RHUB.PRT1 as this host</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379548"></A>// controller is a companion to the EHCI host controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379549"></A>Name( _PLD, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379550"></A> Buffer( 0x14) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379551"></A> 0x82,0x00,0x00,0x00, // Revision 2, Ignore color</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379552"></A>       // Color (ignored), width and height not</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379553"></A> 0x00,0x00,0x00,0x00, // required as this is a standard USB &#8216;A&#8217;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379554"></A>       // type connector</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379555"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379556"></A> 0xa1,0x10,0x00,0x00, // User visible, front panel, Vertical</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379557"></A>       // lower, horz. Left, shape = horz. Rect.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379558"></A> 0x03,0x00,0x00,0x00, // ejectable, requires OPSM eject assistance</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379559"></A>     0xFF,0xFF,0xFF,0xFF})}  // Vert. and Horiz. Offsets not supplied</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379560"></A>}       // Device( PRT1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379561"></A>       //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379562"></A>       // Define other ports, control methods, etc</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379563"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379564"></A>...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379565"></A>}       // Device( RHUB)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379566"></A>}       // Device( USB1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379567"></A>}       // Device( PCI0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379568"></A>}       // Scope( _&#92;SB)</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1379694"></A><A NAME="_Toc202341716"></A><A NAME="_Toc258262393"></A><A NAME="_Toc202341718"></A><A NAME="_Toc258262395"></A>PC/AT RTC/CMOS Devices</H2>
<P CLASS="Body">
<A NAME="pgfId-1379695"></A>Most computers contain an RTC device which also contains battery-backed RAM represented as a linear array of bytes. There is a standard mechanism for accessing the first 64 bytes of non-volatile RAM in devices that are compatible with the Motorola RTC/CMOS device that was in the IBM PC/AT. Newer devices usually contain at least 128 bytes of battery-backed RAM. New PNP IDs were assigned for these devices.</P>
<P CLASS="Body">
<A NAME="pgfId-1499148"></A>Certain bytes within the battery-backed RAM have pre-defined values. In particular, the time, date, month, year, century, alarm time and RTC periodic interrupt are read-only.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1499152"></A><A NAME="_Toc489267431"></A><A NAME="_Toc202341719"></A><A NAME="_Toc258262396"></A>PC/AT-compatible RTC/CMOS Devices (PNP0B00)</H6>
<P CLASS="Body">
<A NAME="pgfId-1499153"></A>The standard PC/AT-compatible RTC/CMOS device is denoted by the PnP ID PNP0B00. If an ACPI platform uses a device that is compatible with this device, it may describe this in its ACPI namespace. ASL may then read and write this as a linear 64-byte array. If PNP0B00 is used, ASL and ACPI operating systems may not assume that any extensions to the CMOS exist.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1499138"></A>This means that the CENTURY field in the Fixed ACPI Description Table may only contain values between 0 and 63.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379704"></A>Example: </H4>
<P CLASS="Body">
<A NAME="pgfId-1379705"></A>This is an example of how this device could be described:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379707"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493922"></A>Device (RTC0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379708"></A>    Name(_HID, EISAID(&quot;PNP0B00&quot;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379709"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379710"></A>Name (_FIX, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379711"></A>EISAID(&quot;PNP0B00&quot;) }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379712"></A>)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379713"></A>Name(_CRS, ResourceTemplate() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379714"></A>   IO(Decode16, 0x70, 0x70, 0x1, 0x2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379715"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379716"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379717"></A>    OperationRegion(CMS1, SystemCMOS, 0, 0x40)  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379718"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379719"></A>    Field(CMS1, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379720"></A>        AccessAs(ByteAcc, 0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379721"></A>        CM00,  8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379722"></A>        ,256,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379723"></A>        CM01,  8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379724"></A>        CM02, 16,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379725"></A>        , 216,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379726"></A>        CM03,  8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379728"></A>    }<A NAME="_Toc489267432"></A></P>
</DIV>
<DIV>
<H3 CLASS="ACPIHeading-3">
<A NAME="pgfId-1499133"></A><A NAME="_Toc202341720"></A><A NAME="_Toc258262397"></A>Intel PIIX4-compatible RTC/CMOS Devices (PNP0B01)</H3>
<P CLASS="Body">
<A NAME="pgfId-1499134"></A>The Intel PIIX4 contains an RTC/CMOS device that is compatible with the one in the PC/AT. But it contains 256 bytes of non-volatile RAM. The first 64 bytes are accessed via the same mechanism as the 64 bytes in the PC/AT. The upper 192 bytes are accessed through an interface that is only used on Intel chips. (See 82371AB PCI-TO-ISA / IDEXCELERATOR (PIIX4) for details.)</P>
<P CLASS="Body">
<A NAME="pgfId-1499121"></A>Any platform containing this device or one that is compatible with it may use the PNP ID PNP0B01. This will allow an ACPI-compatible OS to recognize the RTC/CMOS device as using the programming interface of the PIIX4. Thus, the array of bytes that ASL can read and write with this device is 256 bytes long.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1379735"></A>This also means that the CENTURY field in the Fixed ACPI Description Table may contain values between 0 and 255.</LI>
</UL>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1379736"></A>Example:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379737"></A>This is an example of how this device could be described:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1493915"></A>Device (RTC0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379740"></A>    Name(_HID, EISAID(&quot;PNP0B01&quot;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379741"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379742"></A>Name (_FIX, Package(1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379743"></A>EISAID(&quot;PNP0B01&quot;) }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379744"></A>) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379745"></A>    Name(_CRS, ResourceTemplate() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379746"></A>        IO(Decode16, 0x70, 0x70, 0x1, 0x2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379747"></A>        IO(Decode16, 0x72, 0x72, 0x1, 0x2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379748"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379749"></A> </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379750"></A>    OperationRegion(CMS1, SystemCMOS, 0, 0x100) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379751"></A> </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379752"></A>    Field(CMS1, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379753"></A>        AccessAs(ByteAcc, 0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379754"></A>        CM00,  8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379755"></A>        ,256,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379756"></A>        CM01,  8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379757"></A>        CM02, 16,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379758"></A>        , 224,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379759"></A>        CM03,  8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379760"></A>        , 184,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379761"></A>        CENT,  8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1379762"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499115"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1499118"></A><A NAME="_Toc202341721"></A><A NAME="_Toc258262398"></A>Dallas Semiconductor-compatible RTC/CMOS Devices (PNP0B02)</H6>
<P CLASS="Body">
<A NAME="pgfId-1379769"></A>Dallas Semiconductor RTC/CMOS devices are compatible with the one in the PC/AT, but they contain 256 bytes of non-volatile RAM or more. The first 64 bytes are accessed via the same mechanism as the 64 bytes in the PC/AT. The upper bytes are accessed through an interface that is only used on Dallas Semiconductor chips.</P>
<P CLASS="Body">
<A NAME="pgfId-1379770"></A>Any platform containing this device or one that is compatible with it may use the PNP ID PNP0B02. This will allow an ACPI-compatible OS to recognize the RTC/CMOS device as using the Dallas Semiconductor programming interface. Thus, the array of bytes that ASL can read and write with this device is 256 bytes long.</P>
<P CLASS="Body">
<A NAME="pgfId-1379771"></A>Description of these devices is similar to the PIIX4 example above, and the CENTURY field of the FADT may also contain values between 0 and 255.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1495522"></A><A NAME="_Toc202341722"></A><A NAME="_Toc258262399"></A>User Presence Detection Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1495523"></A>The following section illustrates the operation and definition of the control method-based User Presence Detection (UPD) device.<A NAME="marker-1495524"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1495525"></A>The user presence detection device can optionally support power management objects (e.g. _PS0, _PS3) to allow the OS to manage the device&#8217;s power consumption. </P>
<P CLASS="Body">
<A NAME="pgfId-1495526"></A>The Plug and Play ID of an ACPI control method user presence detection device is ACPI000F.</P>
<P CLASS="Body">
<A NAME="pgfId-1495527"></A>&nbsp;</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1495541"></A>User Presence Detection Device</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1495530"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1495532"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495534"></A>_UPD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495536"></A>The current user presence detection reading. [Required]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495538"></A>_UPP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495540"></A>User presence detection polling frequency in tenths of seconds. [Optional]</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379803"></A><A NAME="_Toc202341723"></A><A NAME="_Toc258262400"></A>_UPD (User Presence Detect<A NAME="marker-1379801"></A>)</H6>
<P CLASS="Body">
<A NAME="pgfId-1379804"></A>This control method returns the user presence detection reading, indicating whether or not the user is currently present from the perspective of this sensor. Three states are currently defined for UPD sensor readings: absent, present, and unknown, represented by the values 0x00, 0x01, and 0xFF respectively. The unknown state is used to convey that the sensor is currently unable to determine user presence due to some environmental or other transient factor. All other values are reserved.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379805"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379806"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379807"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379808"></A>An Integer containing the user presence code:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379809"></A>0x00 -	Absent: A user is not currently detected by this sensor.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379810"></A>0x01 -	Present: A user is currently detected by this sensor.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379811"></A>0xFF -	Unknown: The sensor is currently unable to determine if a user is present or absent.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379818"></A><A NAME="RSVD_UPP"></A><A NAME="_Toc202341724"></A><A NAME="_Toc258262401"></A>_UPP (User Presence Polling)<A NAME="marker-1379816"></A><A NAME="marker-1379817"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1379819"></A>This optional object evaluates to a recommended polling frequency (in tenths of seconds) for this user presence sensor. A value of zero - or the absence of this object when other UPD objects are defined - indicates that the OS does not need to poll the sensor in order to detect meaningful changes in user presence (the hardware is capable of generating asynchronous notifications). </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379820"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379821"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379822"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379823"></A>An Integer containing the recommended polling frequency in tenths of seconds. A value of zero indicates that polling is not required.</P>
<P CLASS="Body">
<A NAME="pgfId-1498302"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1498309"></A>The use of polling is allowed but strongly discouraged by this specification. OEMs should design systems that asynchronously notify OSPM whenever a meaningful change in user presence occurs--relieving the OS of the overhead associated with polling.</P>
<P CLASS="Body">
<A NAME="pgfId-1379825"></A>This value is specified as tenths of seconds. For example, a value of 10 would be used to indicate a 1 second polling frequency. As this is a recommended value, OSPM will consider other factors when determining the actual polling frequency to use.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379834"></A><A NAME="_Toc202341730"></A><A NAME="_Toc258262402"></A>User Presence Sensor Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1379835"></A>To communicate changes in user presence to OSPM, AML code should issue a Notify(upd_device, 0x80) whenever a change in user presence has occurred. The OS receives this notification and calls the _UPD control method to determine the current user presence status.</P>
<P CLASS="Body">
<A NAME="pgfId-1379836"></A>UPD notifications should be generated whenever a transition occurs between one of the user presence states (absent, present, or unknown) - but at a level of granularity that provides an appropriate response without overly taxing the system with unnecessary interrupts.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1379840"></A><A NAME="_Toc202341731"></A><A NAME="_Toc258262403"></A>I/O APIC Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1379841"></A>This optional device describes a discrete I/O APIC device that is not bus enumerated (e.g., as a PCI device). Describing such a device in the ACPI namespace is only necessary if hot plug of this device is supported. If hot plug of this device is not supported, an MADT I/O APIC (<A HREF="ACPI_Software_Programming_Model.htm#82632" CLASS="XRef">See I/O APIC Structure.</A>,&#8221;I/O APIC Structure&#8221;) entry or I/O SAPIC (<A HREF="ACPI_Software_Programming_Model.htm#51165" CLASS="XRef">See I/O SAPIC Structure.</A>, &#8220;I/O SAPIC Structure&#8221;) entry is sufficient to describe this device. </P>
<P CLASS="Body">
<A NAME="pgfId-1379842"></A>An I/O APIC device is an I/O unit that complies with either of the APIC interrupt models supported by ACPI. These interrupt models are described <A HREF="ACPI_Software_Programming_Model.htm#82632" CLASS="XRef">See I/O APIC Structure.</A>,&#8221;I/O APIC Structure&#8221; and <A HREF="ACPI_Software_Programming_Model.htm#51165" CLASS="XRef">See I/O SAPIC Structure.</A>,&#8221;I/O SAPIC Structure&#8221;. If the device is an I/O unit that complies with the APIC interrupt model, it is declared using the ACPI000A identifier. If this device is an I/O unit that complies with the SAPIC interrupt model, it is declared using the ACPI000B identifier. If this device complies with both the APIC and SAPIC interrupt models (I/OxAPIC), it is declared using the ACPI0009 identifier. </P>
<P CLASS="Body">
<A NAME="pgfId-1379845"></A>An I/O APIC device declared using any of the above identifiers must contain a <A NAME="OLE_LINK51"></A><A NAME="OLE_LINK52"></A>_GSB object as defined in<A HREF="Device_Configuration.htm#RSVD_GSB" CLASS="XRef">See _GSB (Global System Interrupt Base).</A>, &#8220;_GSB (Global System Interrupt Base)&#8221; to report its Global System Interrupt Base. It must also contain a _CRS object that reports the base address of the I/O APIC device. The _CRS object is required to contain only one resource, a memory resource pointing to the I/O APIC register base. </P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1379846"></A>Because the _CRS and _GSB methods provide sufficient information, it is not necessary to provide _MAT under an I/O APIC device.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1379847"></A>For an I/O APIC device that is described both in the MADT and in the namespace, the base address described in the MADT entry must be the same as the base address in the IO APIC device _CRS at boot time. OSPM must use the information from the MADT until such a time as the _CRS and _GSB methods in the namespace device can be processed. At this point OSPM must ignore the MADT entry.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1379855"></A><A NAME="_Toc205787821"></A><A NAME="_Toc212803943"></A><A NAME="_Toc215215398"></A><A NAME="_Toc215217712"></A><A NAME="_Toc215220026"></A><A NAME="_Toc258262404"></A>Time and Alarm Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1495278"></A>The following sections define the operation and definition of the optional control method-based Time and Alarm device, which provides a hardware independent abstraction and a more robust alternative to the Real Time Clock (RTC), See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#_Toc202341718" CLASS="XRef">See PC/AT RTC/CMOS Devices.</A>, &quot;PC/AT RTC/CMOS Devices&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId-1495282"></A>The time capabilities of the time and alarm device maintain the time of day information across platform power transitions, and keep track of time even when the platform is turned off. It is expected that the time on the platform will be consistent when different firmware interfaces are used to query the platform time. For example, a UEFI call to get the time should return the same time as if the OSPM used the time and alarm device at the same point in time. </P>
<P CLASS="Body">
<A NAME="pgfId-1495283"></A>The Time and Alarm device can optionally support power management objects (e.g. _PS0, _PS3) to allow the OS to manage the device's power consumption. </P>
<P CLASS="Body">
<A NAME="pgfId-1497584"></A>The Time andAlarm device must support control method _PRW for being enabled to wake up the system. It might support _DSW or _PSW to provide the functionality to enable or disable the device's ability to wake a sleep system. On Hardware-reduced ACPI platforms, _PRW is only required if the device depends on ACPI-defined power resources. _PRW&#8217;s <EM CLASS="ArgCharacter">
GPEInfo</EM>
 structure is ignored by OSPM. For enabling Wakeup, _DSW and _SxW are used, and the wakeup event is signaled by the GPIO-signaled ACPI event mechanism (<A HREF="ACPI_Software_Programming_Model.htm#19454" CLASS="XRef">See GPIO-signaled ACPI Events.</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1495284"></A>The Plug and Play ID of the Time and Wake Alarm device is ACPI000E.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1495327"></A>Time and Alarm Device</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1495288"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1495290"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495292"></A>_GCP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495294"></A>Get the capabilities of the time and alarm device</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495296"></A>_GRT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495298"></A>Get the Real time</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495300"></A>_SRT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495302"></A>Set the Real time</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495304"></A>_GWS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495306"></A>Get Wake status</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495308"></A>_CWS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495310"></A>Clear Wake Status</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495312"></A>_STP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495314"></A>Sets expired timer wake policy for the specified timer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495316"></A>_STV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495318"></A>Sets the value in the specified timer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495320"></A>_TIP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495322"></A>Returns the current expired timer policy setting of the specified timer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495324"></A>_TIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1495326"></A>Returns the remaining time of the specified timer.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H3 CLASS="ACPIHeading-3">
<A NAME="pgfId-1379897"></A>O<A NAME="_Toc258262405"></A>verview</H3>
<P CLASS="Body">
<A NAME="pgfId-1495345"></A>The Time and Alarm device provides an alternative to the real time clock (RTC), which is defined as a fixed feature hardware device. The wake timers allow the system to transition from the S3 (or optionally S4/S5) state to S0 state after a time period elapses. In comparison with the Real Time Clock (RTC) Alarm, the Time and Alarm device provides a larger scale of flexibility in the operation of the wake timers, and allows the implementation of the time source to be abstracted from the OSPM. </P>
<P CLASS="Body">
<A NAME="pgfId-1495346"></A>Time and Alarm device provides the OSPM with a firmware abstraction of time and alarm services that can be applicable to a variety of hardware designs. The methods for setting and getting real time provide an alternative to the (RTC). </P>
<P CLASS="Body">
<A NAME="pgfId-1495347"></A>Time and Alarm devices that implement AC/DC wake service contain two programmable timers that can be configured to wake the system depending on the platform's current power source (AC or DC) when the timers expire. The two timers, which are referred to as the AC timer and the DC timer, are independent in that they are individually programmable and applicable without interfering each other. Each of the timers can be programmed with the number of seconds to elapse from the time the timer is programmed until a wake is requested. When a timer expires, the Time and Alarm device decides whether to wake the system based on the current power source. If the current power source is consistent with the timer type that expired, a wake signal will be asserted. Otherwise, the wake signal will not be asserted.</P>
<P CLASS="Body">
<A NAME="pgfId-1495348"></A>Time and Alarm devices that implement the AC only (power independent) wake contain one programmable timer that can be configured to wake up the system regardless of the platform's power source when the timer expires. To simplify the programming interface the AC wake will use the AC timer portion of the AC/DC wake; writes to the DC timer when AC only wake is supported will be ignored.</P>
<P CLASS="Body">
<A NAME="pgfId-1495349"></A>To simplify the programming interface for the time and alarm device, timer expiration events will persist. This means that if the OSPM programs a wake timer that expires before the OSPM completes the transition into S3 (or S4/S5 if supported) the time and alarm device will wake the system immediately after the OSPM completes the transition. <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#50834" CLASS="XRef">See System transitions with WakeAlarm -- Timer.</A> illustrates this behavior.</P>
<P CLASS="Normal">
<A NAME="pgfId-1495356"></A> &nbsp;</P>
<DIV>
<IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-6.gif" ALT="">
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1495357"></A>Persistence of expired timer events</H6>
<P CLASS="Body">
<A NAME="pgfId-1495358"></A>The time and alarm device will provide the OSPM with an interface to query the status of the wake timers and discover what timers have expired. This interface enables the OSPM to discover the wake source. The status of wake timers can be reset by setting the wake alarm; the OSPM may clear the alarm status using the clear wake status method. All expired wake timer must be cleared if the OSPM requires the platform to stay in S3 (S4/S5), otherwise the expired timers will immediately wake up the system.</P>
<P CLASS="Body">
<A NAME="pgfId-1495359"></A>For the AC/DC wake services, and in case the current power source is inconsistent with the timer type that expires, an expired timer wake policy value, in units of seconds, is defined that enables the time and alarm device to wake the system when the power source corresponding to the expired timer becomes active (wake either immediately, after some time period, or never). The expired timer wake policy is applicable only on devices that support AC/DC wake and only when the timer expires and the power source is not consistent with the timer type. The expired timer policy is applied in conjunction with expired timer persistence described earlier.</P>
<P CLASS="Body">
<A NAME="pgfId-1495360"></A>For example, if a mobile platform programs the AC timer to be 2 hours long and DC timer to be 4 hours long and then transitions from the S0 state to S3 state at 1:00 AM, the AC timer is set to expire at 3:00 AM and the DC timer is set to expire at 5:00 AM. For the AC Timer, a expired timer wake policy value is programmed as 60 seconds.</P>
<P CLASS="Body">
<A NAME="pgfId-1495361"></A>If the platform is unplugged from AC power at 1:40 AM and remains unplugged, the Time and Alarm Device will not wake up the system at 3:00 AM. If the platform remains on DC power until 5:00 AM when the DC timer expires, a wake signal will then be asserted. The following graph illustrates the above example.</P>
<P CLASS="Normal">
<A NAME="pgfId-1379906"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-7.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1379907"></A><A NAME="50834"></A>System transitions with WakeAlarm -- Timer</H6>
<P CLASS="Body">
<A NAME="pgfId-1383419"></A>If the AC power is plugged in again at 4:00 AM, then the system will be woken up at 4:01 AM due to the AC expired timer wake policy value setting. The following graph illustrates this.</P>
</DIV>
<DIV>
<H5 CLASS="ACPINormal">
<A NAME="pgfId-1379911"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-8.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1383433"></A>System transitions with WakeAlarm -- Policy</H6>
<P CLASS="Body">
<A NAME="pgfId-1495375"></A>The Time and Alarm device can support a range of services, the OSPM evaluates the _GCP object to get the supported capabilities of the device. If the capabilities indicate that the device supports time services, the OSPM evaluates the _GRT and _SRT objects to get and set time respectively. </P>
<P CLASS="Body">
<A NAME="pgfId-1495376"></A>If alarm services are supported by the device, the OSPM evaluates the _STV object to program both the AC and DC timer values. The values, which are in units of seconds, indicate the elapsed time before the timer expires. OSPM evaluates the _TIV object to read the current AC and DC timer values (seconds remaining until expiration).</P>
<P CLASS="Body">
<A NAME="pgfId-1495377"></A>OSPM evaluates the _STP object to set timer policies for both the AC and DC timers OSPM reads the current timer policy by evaluating the _TIP object, which return policy settings for both the AC and DC timer. </P>
<P CLASS="Body">
<A NAME="pgfId-1495378"></A>The OSPM evaluates the _GWS object to identify expired timers that may have waked the platform. The OSPM must evaluate the _CWS object to clear any expired timer events that can prevent the system from performing a sleep transition according the expired timer wake policy, and the expired timer persistence described above.</P>
<P CLASS="Body">
<A NAME="pgfId-1507299"></A>The Time and Alarm device, if implemented with wake support, must support waking up the system from S3. Waking from S4/S5 support is optional.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495393"></A><A NAME="51896"></A>_GCP (Get Capability)</H6>
<P CLASS="Body">
<A NAME="pgfId-1495394"></A>This object is required and provides the OSPM with a bit mask of the device capabilities. The device can implement the time function in addition to the wake function. The capabilities bitmask will indicate to the OSPM what support is implemented. If the platform implements both AC and DC timers then it is capable of waking up based on the power source.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495395"></A>Arguments: (0)</H4>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495396"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1495397"></A>A 32-bit integer containing a result bitmask as follows: </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495398"></A>Bit [0] - 1 = AC wake implemented, 0 = not supported</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495399"></A>Bit [1] - 1 = DC wake implemented, 0 = not supported</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495400"></A>Bit [2] - 1 = Get/Set real time features implemented, 0 = not supported</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495401"></A>Bit [3] - 1 = Real time accuracy in milliseconds, 0 = Real time accuracy in seconds</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1502046"></A>Bit [4] - 1 = _GWS returns correct values for wakes from S4/S5 caused by timer. 0 = not supported</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1508911"></A> Bit [5] - 1 = Wake supported from S4 on AC, 0 = Wake not supported from S4 on AC</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1508912"></A> Bit [6] - 1 = Wake supported from S5 on AC, 0 = Wake not supported from S5 on AC</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1508913"></A> Bit [7] - 1 = Wake supported from S4 on DC, 0 = Wake not supported from S4 on DC</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1508914"></A> Bit [8] - 1 = Wake supported from S5 on DC, 0 = Wake not supported from S5 on DC</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1502047"></A> Bit [9] to Bit [31] are reserved and must be 0.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495403"></A><A NAME="68661"></A>_GRT (Get Real Time)</H6>
<P CLASS="Body">
<A NAME="pgfId-1495404"></A>This object is required if the capabilities bit 2 is set to 1. The OSPM can use this object to get time. The return value is a buffer containing the time information as described below. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495405"></A>Arguments: (0)</H4>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495406"></A>Return Value: </H4>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1499266"></A>A buffer containing the time information, in the following format</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499287"></A>Buffer(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499288"></A>WORD Year;						// 1900 - 9999</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499289"></A>BYTE Month;						// 1 - 12</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499290"></A>BYTE Day;						// 1 - 31</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499291"></A>BYTE Hour;						// 0 - 23</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499292"></A>BYTE Minute;						// 0 - 59</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499293"></A>BYTE Second:						// 0 - 59</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499294"></A>BYTE Valid;						// 0 - Time is not valid (request failed); 1 - Time is valid</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499295"></A>WORD milliseconds, 						// 1-1000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499296"></A>WORD TimeZone;						// -1440 to 1440 or 2047 (unspecified)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499297"></A>BYTE Daylight;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499298"></A>BYTE Pad2[3];						// Reserved, must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499299"></A>}</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1499281"></A><A NAME="25205"></A>_SRT (Set Real Time)</H6>
<P CLASS="Body">
<A NAME="pgfId-1495422"></A>This object is required if the capabilities bit 2 is set to 1. The OSPM can use this object to set the time. The argument is a buffer containing the time information, as defined above.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495423"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1495424"></A>A buffer containing the time information, in the following format:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499318"></A>Buffer(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499319"></A>WORD Year;						// 1900 - 9999</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499320"></A>BYTE Month;						// 1 - 12</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499321"></A>BYTE Day;						// 1 - 31</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499322"></A>BYTE Hour;						// 0 - 23</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499323"></A>BYTE Minute;						// 0 - 59</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499324"></A>BYTE Second;						// 0 - 59</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499325"></A>BYTE Pad1;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499326"></A>WORD milliseconds,						// 1-1000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499327"></A>WORD TimeZone;						// -1440 to 1440 or 2047 (unspecified)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499328"></A>BYTE Daylight;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499329"></A>BYTE Pad2[3];						// Reserved, must be zero</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499330"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1495437"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495438"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1495439"></A>An Integer:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495440"></A>0 - success</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495441"></A>0xFFFFFFFF- Failed</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1495443"></A>Time is maintained using a battery backed time device (e.g. a real time clock)</LI>
<LI CLASS="Note">
<A NAME="pgfId-1495444"></A>The time will always be local time; the time zone value can be used to determine the offset from UTC.</LI>
<LI CLASS="Note">
<A NAME="pgfId-1495445"></A>Time zone field is the number of minutes that the local time lags behind the UTC time. (i.e. time zone = UTC - local time). The time zone is in 2's complement format.</LI>
<LI CLASS="Note">
<A NAME="pgfId-1495446"></A>Time zone value of 2047, means that time zone value is not specified, and no relation to UTC can be inferred. </LI>
<LI CLASS="Note">
<A NAME="pgfId-1495447"></A>Daylight is a bitmask containing the daylight savings time information for the time, as follows:</LI>
</UL>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495448"></A>Bit [0]: 1 = the time is affected by daylight savings time, 0= time is not affected by daylight savings. This value does not indicate that the time has been adjusted for daylight savings time. It indicates only that it should be adjusted when the time enters daylight savings time.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495449"></A>Bit [1]: 1= the time has been adjusted for daylight savings time, 0= the time hasn't been adjusted for daylight savings. </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495450"></A>All other bits must be zero.</P>
<P CLASS="Body">
<A NAME="pgfId-1495451"></A>When entering daylight saving time, if the time is affected, but hasn't been adjusted (DST = 1), use the new calculation:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1495452"></A>The date/time should be increased by the appropriate amount.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1495453"></A>The TimeZone should be decreased by the appropriate amount (EX: +480 changes to +420 when moving from PST to PDT).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1495454"></A>The Daylight value changes to 3.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1495455"></A>When exiting daylight saving time, if the time is affected and has been adjusted (DST = 3), use the new calculation:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1495456"></A>The date/time should be decreased by the appropriate amount.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1495457"></A>The TimeZone should be increased by the appropriate amount.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1495458"></A>The Daylight value changes to 1.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495459"></A><A NAME="70322"></A>_GWS (Get Wake alarm status)</H6>
<P CLASS="Body">
<A NAME="pgfId-1495460"></A>This object is required and enables the OSPM to read the status of wake alarms. Expired wake timers will wake the platform even if the transition to a sleep state was completed after the wake timer has expired. This method enables the OSPM to retrieve the status of wake timers and clear any of them if needed.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495461"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1495462"></A>Arg0 - Timer Identifier (Integer (DWORD)): indicates the timer to be cleared:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495463"></A>0x00000000 - AC Timer </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495464"></A>0x00000001 - DC Timer</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495465"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1495466"></A>An Integer (DWORD) containing current expired timers in bit field</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495467"></A>Bit [0]- 1 = timer expired, 0 = timer did not expired</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495468"></A>Bit [ 1]- 1= timer caused a platform wake, 0 = timer did not cause a platform wake</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495469"></A>Bit [31:2] reserved and should be 0.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495470"></A><A NAME="72922"></A>_CWS (Clear Wake alarm status)</H6>
<P CLASS="Body">
<A NAME="pgfId-1495471"></A>This object is required and enables the OSPM to clear the status of wake alarms. Expired wake timers will wake the platform even if the transition to a sleep state was completed after the wake timer has expired. This method enables the OSPM to clear the status of expired wake timers.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495472"></A> Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1495473"></A>Arg0 - Timer Identifier (Integer (DWORD)): indicates the timer to be cleared:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495474"></A>0x00000000 - AC Timer </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495475"></A>0x00000001 - DC Timer</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1495476"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1495477"></A>An Integer (DWORD) containing current expired timer wake policy:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495478"></A>0x00000000 - Success</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1495479"></A>0x00000001 - Failure</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379925"></A><A NAME="_Toc205787826"></A><A NAME="_Toc212803948"></A><A NAME="_Toc215215410"></A><A NAME="_Toc215217724"></A><A NAME="_Toc215220038"></A><A NAME="_Toc258262406"></A>_STP (Set Expired Timer Wake Policy)<A NAME="marker-1379924"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1379926"></A>This object is required and sets the expired timer wake policy. The policy is applied when a corresponding timer expired but the wake signal was not asserted as a result of the power source. The platform accumulates elapsed time on the power source and asserts the wake signal when the elapsed timer on the power source exceeds the expired timer wake policy value. Power source transitions do not reset the expired timer wake policy values. When the Wake Alarm device asserts the wake, the expired timer wake policy values of both the AC timer and DC timer are reset to 0xFFFFFFFF automatically by hardware. <A NAME="_Toc215215411"></A><A NAME="_Toc215217725"></A><A NAME="_Toc215220039"></A></P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379930"></A>Arguments: (2)</H4>
<P CLASS="Body">
<A NAME="pgfId-1379931"></A>Arg0 - TimerIdentifier (Integer(DWORD)): indicates the timer to be set:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379932"></A>0x00000000 - AC Timer </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379933"></A>0x00000001 - DC Timer</P>
<P CLASS="Body">
<A NAME="pgfId-1379934"></A>Arg1 - ExpiredTimerWakePolicy (Integer(DWORD)): indicates the expired timer wake policy:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379935"></A>0x00000000 - The timer will wake up the system instantly after the power source changes.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379936"></A>0x00000001 - 0xFFFFFFFE: time between the power source changes and the timer wakes up the system (in units of second).</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379937"></A>0xFFFFFFFF - The timer will never wake up the system after the power source changes.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379941"></A><A NAME="_Toc215215412"></A><A NAME="_Toc215217726"></A><A NAME="_Toc215220040"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1379942"></A>An Integer containing a result code as follows:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379943"></A>0x00000000 - Succeeded to set the expired timer wake policy.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379944"></A>0x00000001 - Failed to set the timer policy. Actual timer policy unknown.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379959"></A><A NAME="marker-1379945"></A><A NAME="marker-1379946"></A>_<A NAME="_Toc258262407"></A>STV (Set Timer Value)<A NAME="marker-1379958"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1379960"></A>This object is required and sets the timer to the specified value. As defined in _TIV, the value indicates the number of seconds between the time when the timer is programmed and the time when it expires. When the Wake Alarm device asserts the wake signal, the timer value is automatically reset to 0xFFFFFFFF (disabled). </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379964"></A><A NAME="_Toc215215408"></A><A NAME="_Toc215217722"></A><A NAME="_Toc215220036"></A>Arguments: (2)</H4>
<P CLASS="Body">
<A NAME="pgfId-1379965"></A>Arg0 - TimerIdentifier (Integer (DWORD)): indicates the timer to be set:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379966"></A>0x00000000 - AC Timer </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379967"></A>0x00000001 - DC Timer</P>
<P CLASS="Body">
<A NAME="pgfId-1379968"></A>Arg1 - TimerValue (Integer): indicates the value to be set.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379972"></A><A NAME="_Toc215215409"></A><A NAME="_Toc215217723"></A><A NAME="_Toc215220037"></A>Return Value: </H4>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379973"></A>An Integer containing a result code as follows:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379974"></A>0x00000000 - Succeeded to set timer value.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379975"></A>0x00000001 - Failed to set timer value. Actual timer value unknown.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1379986"></A><A NAME="_Toc205787824"></A><A NAME="_Toc212803946"></A><A NAME="_Toc215215404"></A><A NAME="_Toc215217718"></A><A NAME="_Toc215220032"></A><A NAME="_Toc258262408"></A>_TIP (Expired Timer Wake Policy)<A NAME="marker-1379985"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1379987"></A>This object is required and returns the current expired timer wake policy setting of the specified timer. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379991"></A><A NAME="_Toc215215405"></A><A NAME="_Toc215217719"></A><A NAME="_Toc215220033"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1379992"></A>Arg0 - TimerIdentifier (Integer (DWORD)): indicates the timer to be read:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379993"></A>0x00000000 - AC Timer </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379994"></A>0x00000001 - DC Timer</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1379998"></A><A NAME="_Toc215215406"></A><A NAME="_Toc215217720"></A><A NAME="_Toc215220034"></A>Return Value: </H4>
<P CLASS="Body">
<A NAME="pgfId-1379999"></A>An Integer (DWORD) containing current expired timer wake policy:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1380000"></A>0x00000000 - The timer will wake up the system instantly after the power source changes</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1380001"></A>0x00000001 - 0xFFFFFFFE: Time between the power source changes and the timer wakes up the system ( in units of seconds)</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1380002"></A>0xFFFFFFFF - The timer will never wake up the system after the power source changes</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1380017"></A>_<A NAME="_Toc258262409"></A>TIV (Timer Values)</H6>
<P CLASS="Body">
<A NAME="pgfId-1380018"></A>This object is required and returns the remaining time of the specified timer before it expires.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1380022"></A><A NAME="_Toc215215402"></A><A NAME="_Toc215217716"></A><A NAME="_Toc215220030"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1380023"></A>Arg0 - TimerIdentifier (Integer(DWORD)): indicates the timer to be read:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1380024"></A>0x00000000 - AC Timer </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1380025"></A>0x00000001 - DC Timer</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1380026"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1380027"></A>An Integer containing the current timer value. A value of 0xFFFFFFFF indicates that the timer is disabled.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1380030"></A>A<A NAME="_Toc258262410"></A>CPI Wakeup Alarm Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1380031"></A>The Wake Alarm, device as a generic hardware, supports control methods _PSW and _PRW to wake up the system and issues a Notify(&lt;device&gt;, 0x2) on the wakeup alarm device. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1380040"></A><A NAME="_Toc205787829"></A><A NAME="_Toc212803950"></A><A NAME="_Toc215215414"></A><A NAME="_Toc215217728"></A><A NAME="_Toc215220042"></A> <A NAME="_Toc258262411"></A>Relationship to Real Time Clock Alarm <A NAME="marker-1380039"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1495494"></A>Though both of the devices support wakeup timers to wake up system from sleeping state, they work independently. The Real Time Clock Alarm is defined as a fixed feature hardware whereas Time and Alarm device is defined as a generic hardware and can replace or coexist with the real time clock. OSPM may choose which device to utilize to provide timed wake capability. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495495"></A>Time and Alarm device as a replacement to the RTC</H6>
<P CLASS="Body">
<A NAME="pgfId-1495496"></A>The Time and Alarm device can be an alternative to the RTC on some platforms where the legacy RTC hardware is not available, on these platforms the OSPM can use the Time and Alarm device to obtain time and set wake alarms. For platforms that don't require AC/DC wake service (e.g. a platform that have one power source only) the AC timer can be used to provide all the functions that were traditionally provided by the RTC. Using the capabilities object the Time and Alarm device can provide a scalable range of services to the OSPM.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495497"></A>Relationship to UEFI time source</H6>
<P CLASS="Body">
<A NAME="pgfId-1495498"></A>The Time and Alarm device must be driven from the same time source as UEFI time services. This ensures that the platform has a consistent value of real time (time of day) and wake alarms. The OSPM can interact with this value using either ACPI or UEFI.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1499036"></A>OSPM must use only one runtime interface to configure/query the platform alarm(s); undefined behavior may occur if the two wakeup interfaces are used on the same hardware.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1499064"></A>If OSPM is trying to set an alarm using EFI runtime services, the alarm should be honored regardless of the power source (i.e. if the platform has an independent timer for each power source, they should both be configured with that alarm).</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1495506"></A><A NAME="_Toc205787830"></A><A NAME="_Toc212803951"></A><A NAME="_Toc215215415"></A><A NAME="_Toc215217729"></A><A NAME="_Toc215220043"></A><A NAME="_Toc258262412"></A>Example ASL code <A NAME="marker-1495505"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1498898"></A>The following ASL code serves as an example of how the Time and Alarm Device could be implemented. It is beyond the capability and the scope of this specification to provide a complete hardware implementation example. </P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1498661"></A>Example 1: Define an ACPI Wake Alarm device</H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1498662"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498663"></A>Device(&#92;_SB.AWAK){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498664"></A>Name(_HID, &quot;ACPI000E&quot;) //device ID </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498665"></A>Name(_PRW, Package(){...})//enable or disable to wake up the system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498666"></A>OperationRegion(CMOP, EmbeddedControl, ...) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498667"></A>Field(CMOP, ByteAcc, ...){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498668"></A>........ //timer status and policies </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498669"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498670"></A>Method(_GCP) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498671"></A>Return (0x03)   //Both AC and DC alarms are implemented; Time capability is NOT supported</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498672"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498673"></A>Method(_STP, 2){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498674"></A>If(LEqual(Arg0, 0) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498675"></A>Store(Arg1, ...)   //Set AC timer policy </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498676"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498677"></A>Else { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498678"></A>Store(Arg1, ...)   //Set DC timer policy </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498679"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498680"></A>Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498681"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498682"></A>Method(_TIP, 1){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498683"></A>If(LEqual(Arg0, 1) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498684"></A>Store(..., Local0)  //Get DC timer policy </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498685"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498686"></A>Else { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498687"></A>Store(..., Local0)  //Get AC timer policy </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498688"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498689"></A>Return (Local0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498690"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498691"></A>Method(_STV, 2){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498692"></A>If(LEqual(Arg0, 0) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498693"></A>Store(Arg1, ...)   //Set AC timer value </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498694"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498695"></A>Else { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498696"></A>Store(Arg1, ...)   //Set DC timer value </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498697"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498698"></A>Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498699"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498938"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498700"></A>Method(_TIV, 1){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498701"></A>If(LEqual(Arg0, 1) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498702"></A>Store(..., Local0)  //Get DC timer value </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498703"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498704"></A>Else { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498705"></A>Store(..., Local0)  //Get AC timer value </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498706"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498707"></A>Return (Local0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498998"></A>} </P>
<P CLASS="Body">
<A NAME="pgfId-1498999"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499000"></A>Method(_GWS, 1){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498710"></A>If(LEqual(Arg0, 1) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499003"></A>Store(..., Local0)  //Get DC timer wake status </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499004"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499005"></A>Else { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498971"></A>Store(..., Local0)  //Get AC timer wake status </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498972"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498973"></A>Return (Local0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498717"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498718"></A>Method(_CWS, 2){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498719"></A>If(LEqual(Arg0, 0) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498720"></A>Store(0, ...)   //Clear AC Wake status </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498721"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498722"></A>Else { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498723"></A>Store(0, ...)   //Clear DC Wake status </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498724"></A>} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498725"></A>Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498726"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498727"></A>}      // end of ACPI Wake Alarm device object </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498728"></A>Scope(&#92;_GPE) {  // Root level event handlers </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498729"></A>Method(_Lxx){ </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498730"></A>Store(One, ...) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498731"></A>Notify(&#92;_SB.AWA, 0x2) //notify the OSPM of device wake </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498732"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498733"></A>}      // end of &#92;_GPE scope</P>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1498738"></A>Example 2: Define an ACPI Real Time device on a HW-Reduced ACPI platform</H4>
<P CLASS="CodeExample">
<A NAME="pgfId-1498740"></A>Device(&#92;_SB.I2C1)  //The controller used to access the RTC hardware</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498741"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498742"></A> Name (_HID, ...)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498743"></A> ...// Other objects required for this I2C controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498744"></A> // Track status of SPB OpRegion availability for this controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498745"></A> Name(AVBL, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498746"></A> Method(_REG,2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498747"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498748"></A>  /* 9 is the OpRegion type for SPB. (8 == GPIO, etc) */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498749"></A>  If (Lequal(Arg0, 9))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498750"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498751"></A>   Store(Arg1, ^AVBL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498752"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498753"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498754"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498755"></A>Device(&#92;_SB.TAAD)   //The Time and Alarm Device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498756"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498757"></A> Name (_HID, &quot;ACPI000E&quot;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498758"></A> Scope(&#92;_SB.I2C1)  //OpRegion declaration must appear under the controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498759"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498760"></A>  OperationRegion(TOP1, GenericSerialBus, 254, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498761"></A>  Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498762"></A>  {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498763"></A>   Connection(I2CSerialBusV2(0x4a,,400000,,&quot;&#92;&#92;_SB.I2C1&quot;,,,,,)), //Connection to the controller for the following field accesses</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498764"></A>   AccessAs(BufferAcc, AttribWord),   //AccessProtocol for the following field(s)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498765"></A>   Y, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498766"></A>   AccessAs(BufferAcc, AttribByte),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498767"></A>   M, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498768"></A>   D, 8, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498769"></A>   H, 8, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498770"></A>   Mi,8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498771"></A>   S, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498772"></A>   P, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498773"></A>   AccessAs(BufferAcc, AttribWord),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498774"></A>   Ms, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498775"></A>   Tz, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498776"></A>   AccessAs(BufferAcc, AttribByte),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498777"></A>   Dl, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498778"></A>   P2, 8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498779"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498780"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498781"></A> Method (_GCP, 0x0, NotSerialized)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498782"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498783"></A>  Return(0x4)       //Implements Real Time interface, but no alarms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498784"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498785"></A> Method(_GRT, 0x0, NotSerialized)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498786"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498787"></A>  If(LNotEqual(&#92;_SB.TC1.AVBL, 1))  // Verify that SPB OpRegion is available for this access</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498788"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498789"></A>   Return(0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498790"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498791"></A>  Name(BUFF, Buffer(4){})    // Create SerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498792"></A>  CreateByteField(BUFF, 0x00, STAT) // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498793"></A>  CreateWordField(BUFF, 0x02, DATA) // DATA = Data (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498794"></A>  Name(BUF2,Buffer(0x10){})  // Create buffer to hold the Real Time structure as BUF2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498795"></A>  CreateWordField(BUF2, 0x0,Y)  //year</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498796"></A>  CreateByteField(BUF2,0x2,M)   //Month</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498797"></A> ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498798"></A>  CreateByteField(BUF2,0xc,Dl)  //Dl</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498799"></A>  CreateByteField(BUF2,0xd,P2)  //Pad2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498800"></A>  Store(&#92;_SB.I2C1.Y, BUFF)  //Get each member from the OpRegion and store in the structure</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498801"></A>  Store(DATA,Y)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498802"></A>  Store(&#92;_SB.I2C1.M, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498803"></A>  Store(DATA,M)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498804"></A> ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498805"></A>  Store(&#92;_SB.I2C1.Dl, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498806"></A>  Store(DATA,Dl)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498807"></A>  Store(&#92;_SB.I2C1.P2, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498808"></A>  Store(DATA,P2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498809"></A>  Return(BUF2)      // Success -&gt; return what was last in buffer </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498810"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498811"></A> Method(_SRT,0x1, NotSerialized) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498812"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498813"></A>  Name(BUFF, Buffer(4){})    // Create SerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498814"></A>  CreateByteField(BUFF, 0x00, STAT) // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498815"></A>  CreateWordField(BUFF, 0x02, DATA) // DATA = Data (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498816"></A> // Verify that SPB OpRegion is available for this access</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498817"></A>  If(LNotEqual(&#92;_SB.I2C1.AVBL, 1))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498818"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498819"></A>   Return(0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498820"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498821"></A>  CreateWordField(Arg0,0x0,Y) //Create Fields to access each member of the input data</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498822"></A> ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498823"></A>  CreateByteField(Arg0,0xd,P2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498824"></A>  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498825"></A> Store(Store(Y, &#92;_SB.I2C1.Y), BUFF)  //Store each input member into the hardware, and </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498880"></A>           //set the transaction status into BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498826"></A>  If(LEqual(STAT, 0x00))    //Transaction was _NOT_successful </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498827"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498828"></A>   Return(0xFFFFFFFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498829"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498830"></A> &nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498831"></A>  ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498832"></A>  Store(Store(P2, &#92;_SB.I2C1.P2), BUFF) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498833"></A>  If(LEqual(STAT, 0x00))    //Transaction was _NOT_successful </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498834"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498835"></A>   Return(0xFFFFFFFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498836"></A>  } </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498837"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498838"></A> Name(_DEP, Package() {&quot;&#92;&#92;_SB.I2C1&quot;}) //Identify the OpRegion dependency for this device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1498839"></A>}</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1499761"></A><A NAME="53119"></A>Generic Buttons Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1499763"></A><A HREF="http://www.usb.org/developers/hidpage/" CLASS="URL"><A HREF="http://uefi.org/acpi" CLASS="URL">The Generic Button device is a standard device for reporting button events via hardware interrupts, and mapping those interrupts to specific usages defined in the Human Interface Device (HID) specification. In order to express the functionality of a button to the OS, two pieces of information are required: Usage of the HID Control, and Usage of the HID Collection that the Control belongs to. A Usage is a combination of a Usage Page and Usage ID. For example, the Volume Up button is identified as the Volume Up Usage (Usage Page 0x0C, Usage Id 0xE9) in the Consumer Control Collection (Usage Page 0x0C, Usage Id 0x01).</A></A></P>
<P CLASS="Body">
<A NAME="pgfId-1499765"></A>The Plug and Play ID of the Generic Button device is ACPI0011.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1499766"></A>If the Power button is described using this device, it must also support the Power Button Override feature defined in <A HREF="ACPI Hardware Specification.htm#77498" CLASS="XRef">See Power Button.</A> Power Button Override.</LI>
</UL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1499768"></A>Generic Buttons Device Child Objects</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1499771"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1499773"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499775"></A>_CRS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499777"></A>Lists the resources consumed by the Generic Button device. Only interrupt resources (GpioInt() and Interrupt() ) are valid for this device. Each interrupt listed must signal one distinct button event.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499779"></A>_DSD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499781"></A>Provides a list of HID Button Descriptors, as defined by UUID FA6BD625-9CE8-470D-A2C7-B3CA36C4282E. (See <EM CLASS="Hyperlink">
http://www.uefi.org/sites/default/files/resources/_DSD-HID-buttondescriptor-UUID.pdf</EM>
). Only HID 2-state button usages are valid for the descriptors returned for this device. </P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1499784"></A>If there are more HID Button Descriptors returned by _DSD than there are interrupts listed in _CRS, behavior is OS-specific.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1499786"></A>Button Interrupts</H6>
<P CLASS="Body">
<A NAME="pgfId-1499787"></A>Interrupts for the Generic Buttons Device are required to be edge-triggered and not level-triggered since there is no interface defined for the driver to quiesce the interrupt line once the interrupt is received. The polarity (ActiveLow/High vs. ActiveBoth) of the interrupt is determined by the Usage Type of the HID Usage associated with the interrupt, as described in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#45114" CLASS="XRef">See Usage Types and Interrupt Polarity.</A>.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1499789"></A><A NAME="45114"></A>Usage Types and Interrupt Polarity</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1499792"></A>Usage Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1499794"></A>Interrupt Polarity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1499796"></A>Explanation</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499798"></A>OSC - One Shot Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499800"></A>ActiveHigh/ActiveLow</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499802"></A>An interrupt should be triggered on a button press. This is for a toggle button. On every such event (interrupt), the Operating System will toggle the internal property of the entity that it controls. Example: Mute button</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499804"></A>MC - Momentary Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499806"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499808"></A>An interrupt should be triggered on both the button press and release. Example: Left mouse button.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499810"></A>RTC - Re-trigger Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499812"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499814"></A>An interrupt should be triggered on both the button press and release. While the button is pressed, the Operating System will repeatedly re-execute the action that it would take when the button is pressed. Example: A Volume Up button when pressed and held, will repeatedly increment the Volume.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499816"></A>OOC - On/Off Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499818"></A>ActiveHigh/ActiveLow<BR>
OR<BR>
ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499820"></A>ActiveHigh/ActiveLow polarity should be specified if implemented as a button that goes back to its initial state automatically. E.g. A Push Button or a spring-loaded Slider switch. Only one interrupt should be fired for press/release pair.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1500157"></A>Example: A spring-loaded Wireless Radio Slider Switch.<BR>
<BR>
ActiveBoth polarity should be specified if implemented as a button that stays in its state until the user moves it again. E.g. A button that stays in pressed state, or a Slider switch that sticks to its position. Example: Wireless Radio Slider Switch.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1499825"></A>Button Usages and Collections</H6>
<P CLASS="Body">
<A NAME="pgfId-1499826"></A>The HID Usage tables have an extensive list of Standardized Usages for various kinds of buttons. Some of the common buttons found on Computing devices and their Usages are listed in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#43754" CLASS="XRef">See Common HID Button Usages.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1499827"></A>For the full list, see &#8220;HID Usage Tables&#8221;, available from &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;HID Usage Tables&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId-1499828"></A>Buttons are grouped under a HID Collection. Several HID Collections are commonly understood by Operating Systems, e.g., Keyboard Collection, Consumer Controls Collection, Wireless Radio Controls Collection, etc. </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1499829"></A><A NAME="43754"></A>Common HID Button Usages</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1514537"></A>Button</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1514539"></A>Usage Page / Usage</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1514541"></A>Usage Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1514543"></A>Interrupt Polarity</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1514545"></A>Spec Reference</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499842"></A>Power</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499844"></A>Generic Desktop Page (0x01)<BR>
System Power Down (0x01)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499846"></A>OSC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499848"></A>ActiveBoth1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499851"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf" CLASS="URL">HID Usage Tables 1.12</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499852"></A> Section 4</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499854"></A>Volume Up</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499856"></A>Consumer Page (0x0C)<BR>
Volume Increment (0xE9)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499858"></A>RTC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499860"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499863"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf" CLASS="URL">HID Usage Tables 1.12</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499864"></A> Section 15</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499866"></A>Volume Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499868"></A>Consumer Page (0x0C)<BR>
Volume Decrement (0xEA)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499870"></A>RTC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499872"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499875"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf" CLASS="URL">HID Usage Tables 1.12</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499876"></A> Section 15</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499878"></A>Camera Shutter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499880"></A>Camera Control Page (0x90)<BR>
Camera Shutter (0x21)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499882"></A>OSC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499884"></A>Active High/ActiveLow</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499886"></A>Camera Shutter Usage 0x21 is planned for a future version of the HID Usage Tables.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499888"></A>Display Brightness Up</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499890"></A>Consumer Page (0x0C)<BR>
Display Brightness Increment (0x6F)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499892"></A>RTC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499894"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499897"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/HUTRR41.pdf" CLASS="URL">Review Request 41</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499898"></A> Display Brightness Controls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499900"></A>Display Brightness Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499902"></A>Consumer Page (0x0C)<BR>
Display Brightness Decrement (0x6F)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499904"></A>RTC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499906"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499909"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/HUTRR41.pdf" CLASS="URL">Review Request 41</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499910"></A> Display Brightness Controls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499912"></A>Wireless Radio Button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499914"></A>Generic Desktop Page (0x01)<BR>
Wireless Radio Button (0xC6)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499916"></A>OOC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499918"></A>ActiveHigh/ActiveLow</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499921"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/HUTRR40RadioHIDUsagesFinal.pdf" CLASS="URL">Review Request 40</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499922"></A> HID Radio On/Off Usages</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499924"></A>Wireless Radio Slider Switch</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499926"></A>Generic Desktop Page (0x01)<BR>
Wireless Radio Slider Switch (0xC8)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499928"></A>OOC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499930"></A>ActiveBoth</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1499933"></A><EM CLASS="Hyperlink">
<A HREF="http://www.usb.org/developers/hidpage/HUTRR40RadioHIDUsagesFinal.pdf" CLASS="URL">Review Request 40</A></EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1499934"></A> HID Radio On/Off Usages</P>
</TD>
</TR>
</TABLE>
<P CLASS="Normal">
<A NAME="pgfId-1499937"></A>1 The System Power Down Usage (Page:01, ID: 81) has Type OSC, although its interrupt must be ActiveBoth in order to allow drivers to perform functions based on &#8220;hold-down&#8221; timing. This is an exception to the Usage Type Rules for Interrupt Polarity (<A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#45114" CLASS="XRef">See Usage Types and Interrupt Polarity.</A>).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1499938"></A>Example</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1499940"></A>Device(BTNS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499941"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499942"></A>Name(_HID, &#8220;ACPI0011&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499943"></A>Name(_CRS, ResourceTemplate() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499944"></A>		 GpioInt(Edge, ActiveBoth...) {pin} //Vol Down</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499945"></A>		 GpioInt(Edge, ActiveBoth...) {pin} //Vol Up</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499946"></A>		 GpioInt(Edge, ActiveBoth,...) {pin} //Power (MUST BE</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499947"></A> //ACTIVEBOTH!)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499948"></A>	})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499949"></A>Name(_DSD, Package(2) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499950"></A>		//UUID for HID Button Descriptors:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499951"></A>ToUUID(&#8220;FA6BD625-9CE8-470D-A2C7-B3CA36C4282E&#8221;),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499952"></A>//Data structure for this UUID:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499953"></A>Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499954"></A>	Package(5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499955"></A>		0,	//Declare a Collection </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499956"></A>		1,	//Unique ID for this collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499957"></A>		0,	//It is a top-level collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499958"></A>		0x0c,//Usage Page (&#8220;Consumer&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499959"></A>		0x01 //Usage (&#8220;Consumer Control&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499960"></A>	},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499961"></A>	Package(5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499962"></A>		0,	//Declare another Collection </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499963"></A>		2,	//Unique ID for this collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499964"></A>		0,	//Also a top-level collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499965"></A>		0x01,// Usage Page (&#8221;Generic Desktop&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499966"></A>		0x80 //Usage (&#8220;System Control&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499967"></A>	},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499968"></A>Package(5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499969"></A>		1,	//Declare a Control </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499970"></A>		0,	//Interrupt index in _CRS for Vol Down</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499971"></A>		1,	//In the &#8220;Consumer Control&#8221; collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499972"></A>		0x0c,//Usage Page (&#8220;Consumer&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499973"></A>		0xEA //Usage (&#8220;Volume Decrement&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499974"></A>	},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499975"></A>	Package(5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499976"></A>		1,	//Declare another Control </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499977"></A>		2,	//Interrupt index for the Power Button</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499978"></A>		2,	//In the &#8220;System Control&#8221; collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499979"></A>		0x01,//Usage Page (&#8221;Generic Desktop&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499980"></A>		0x81 //Usage (&#8220;System Power Down&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499981"></A>	},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499982"></A>	Package(5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499983"></A>		1,	//Declare another Control</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499984"></A>		1,	//Interrupt index for the Vol Up button</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499985"></A>		1,	//In the &#8220;Consumer Control&#8221; collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499986"></A>		0x0c,//Usage Page (&#8220;Consumer&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499987"></A>		0xE9 //Usage (&#8220;Volume Increment&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499988"></A>	},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499989"></A>	Package(5) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499990"></A>		1,	//Another Control</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499991"></A>	 0xFF,	//No Interrupt for this one... e.g. OS-</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499992"></A>// specific signaling for Rotation Lock</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499993"></A>		1,	//In the &#8220;Consumer Control&#8221; collection</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499994"></A>		0x0C,//Usage Page (&#8220;Consumer&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499995"></A>		0x245 //Usage (&#8220;AC Rotate&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499996"></A>	}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499997"></A>		}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1499998"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1380041"></A>}// End Device</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1500641"></A><A NAME="21528"></A>NVDIMM Devices</H2>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1504467"></A>Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1500647"></A>In order to handle NVDIMMs, the OS must first be able to detect and enumerate the NVDIMMs. To facilitate the plug and play discovery of NVDIMM and driver loading, ACPI namespace devices are used. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1504485"></A><A NAME="72060"></A>NVDIMM Root Device</H6>
<P CLASS="Body">
<A NAME="pgfId-1500648"></A>The NVDIMM root device is represented by an ACPI namespace device with a _HID of &quot;ACPI0012&quot; (see <A HREF="Device_Configuration.htm#_Toc489256044" CLASS="XRef">See _HID (Hardware ID).</A> and <A HREF="ACPI_Software_Programming_Model.htm#96811" CLASS="XRef">See ACPI Device IDs.</A>). If the platform supports NVDIMMs, then platform firmware shall report one NVDIMM root device in the &#92;SB scope (see <A HREF="ACPI_Software_Programming_Model.htm#99993" CLASS="XRef">See Predefined Root Namespaces.</A>). This device allows the OS to trigger enumeration of NVDIMMs through NFIT (see <A HREF="ACPI_Software_Programming_Model.htm#24805" CLASS="XRef">See NVDIMM Firmware Interface Table (NFIT).</A>) at boot time and re-enumeration at root level via the _FIT method (see <A HREF="Device_Configuration.htm#31911" CLASS="XRef">See _FIT (Firmware Interface Table).</A>) during runtime. </P>
<P CLASS="Body">
<A NAME="pgfId-1504534"></A><A HREF="ACPI_Software_Programming_Model.htm#33466" CLASS="XRef">See NVDIMM Root Device Notification Values.</A> defines NFIT Update Notification notification values for the NVDIMM root device. </P>
<P CLASS="Body">
<A NAME="pgfId-1500652"></A>For each NVDIMM present or intended to be supported by platform, platform firmware also exposes an NVDIMM device (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#79373" CLASS="XRef">See NVDIMM Device.</A>) under the NVDIMM root device. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1504574"></A><A NAME="79373"></A>NVDIMM Device</H6>
<P CLASS="Body">
<A NAME="pgfId-1504575"></A>Each NVDIMM is represented by an ACPI namespace device under the NVDIMM root device (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#72060" CLASS="XRef">See NVDIMM Root Device.</A>) with an _ADR (see <A HREF="Device_Configuration.htm#_Toc489256041" CLASS="XRef">See _ADR (Address).</A>) containing the NFIT Device Handle. </P>
<P CLASS="Body">
<A NAME="pgfId-1504576"></A>The NFIT Device Handle is constructed as follows:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1504577"></A>Bits [3:0] DIMM number within the memory channel</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1504578"></A>Bits [7:4] memory channel number within the memory controller</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1504579"></A>Bits [11:8] memory controller ID within the socket</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1504580"></A>Bits [15:12] socket ID within the node controller, if any</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1504581"></A>Bits [27:16] node controller ID, if any</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1504582"></A>Bits [31:28] Reserved</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1509134"></A><A HREF="ACPI_Software_Programming_Model.htm#28325" CLASS="XRef">See NVDIMM Device Notification Values.</A> defines NVDIMM Device Notification Values for an NVDIMM device.</P>
<P CLASS="Body">
<A NAME="pgfId-1504583"></A>Information about the Label Storage Area on the NVDIMM is provided by the _LSI (see <A HREF="Device_Configuration.htm#92051" CLASS="XRef">See _LSI (Label Storage Information).</A>) method. The OSPM uses the methods _LSR (see <A HREF="Device_Configuration.htm#61245" CLASS="XRef">See _LSR (Label Storage Read).</A>) and _LSW (see <A HREF="Device_Configuration.htm#24038" CLASS="XRef">See _LSW (Label Storage Write).</A>) to read and write to the Label Storage Area. The format of the Label Storage Area data is defined in UEFI. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1500654"></A>Example</H6>
<P CLASS="Body">
<A NAME="pgfId-1504604"></A>An example name space is shown below for a platform containing one NVDIMM:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500655"></A>   Scope (&#92;_SB){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500657"></A>   Device (NVDR) // NVDIMM root device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500658"></A>   {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500659"></A>    Name (_HID, &#8220;ACPI0012&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500660"></A>    Method (_STA) {...} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500661"></A>    Method (_FIT) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500662"></A>    Method (_DSM, ...) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500663"></A>    ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500664"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500665"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500666"></A>    Device (NVD) // NVDIMM device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500667"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500668"></A>     Name(_ADR, h) //where h is NFIT Device Handle for this NVDIMM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500669"></A>     Method (_DSM, ...) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500670"></A>     ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500671"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500672"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500673"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500674"></A>   }</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1504695"></A>Loading NVDIMM drivers</H6>
<P CLASS="Body">
<A NAME="pgfId-1500708"></A>While using ACPI namespace devices allows for OS handling of NVDIMMs in a standard manner, the format of the address ranges described by this scheme may still vary depending on the vendor (or even different NVDIMM version of the vendor). For example, the command and status values supported by a Block Control Window are vendor specific and possibly even vary for a given vendor. </P>
<P CLASS="Body">
<A NAME="pgfId-1500709"></A>The NVDIMM Control Region Structure (see <A HREF="ACPI_Software_Programming_Model.htm#42965" CLASS="XRef">See NVDIMM Control Region Structure.</A>) includes a Vendor ID, Device ID, and Revision ID. Because an NVDIMM could be a combination device consisting of different region types (e.g., Persistent Memory and Block), a Region Format Interface Code is also included to indicate the region type as well as the specific implementation within that type. This allows for variability across vendors as well as within vendor offerings.</P>
<P CLASS="Body">
<A NAME="pgfId-1504803"></A>These fields enable loading of drivers for managing the NVDIMM as well as for handling the address ranges supported by the NVDIMM. The Region Format Interface Code is used to load generic drivers for the following: management driver, persistent memory driver and block driver. A vendor specific driver for each of the above can be loaded by matching on Vendor ID, Device ID and Revision ID (in addition to the Region Format Interface Code).</P>
<P CLASS="Body">
<A NAME="pgfId-1500711"></A>Region Format Interface Code requirements shall be met by all compliant NVDIMMs. Any Vendor specific extensions are only allowed to extend on top of the Region Format Interface Code requirements. </P>
<P CLASS="Body">
<A NAME="pgfId-1500712"></A>It is assumed that the OSPM is capable of loading the Region Format Interface Code specific driver or vendor specific drivers based on such discovery. This scheme is as shown in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#71008" CLASS="XRef">See Vendor/Device Specific Driver Loading.</A>.</P>
<P CLASS="Normal">
<A NAME="pgfId-1500716"></A></P>
<P CLASS="Normal">
<A NAME="pgfId-1500720"></A><IMG SRC="ACPIdefined_Devices_and_DeviceSpecificObjects-9.gif" ALIGN="BASELINE" ALT="">
</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1500722"></A><A NAME="71008"></A>Vendor/Device Specific Driver Loading</H6>
<P CLASS="Body">
<A NAME="pgfId-1500723"></A>The Subsystem Vendor ID, Subsystem Device ID and Subsystem Revision ID fields allow selection of specific solution provider drivers that may span across devices from multiple vendors.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1500725"></A><A NAME="11120"></A> Hot Plug Support</H6>
<P CLASS="Body">
<A NAME="pgfId-1500726"></A>The NVDIMM memory hot plug representation of the ACPI Name Space is described in this section. The NVDR device is the NVDIMM root device, the NVD1 and NVD2 are NVDIMM devices, the MEM0 is memory module device corresponding to the NVD1 and NVD2 devices. The _FIT method under NVDR device returns all NFIT entries including the hot added devices.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500727"></A> Device (NVDR) // Root device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500728"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500729"></A>   Name (_HID, &#8220;ACPI0012&#8221;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500730"></A>   Method (_STA) {...} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500731"></A>   Method (_FIT) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500732"></A>   Method (_DSM, ...) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500733"></A>   ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500734"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500735"></A>    Device (NVD1) // NVDIMM1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500736"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500737"></A>      Name(_ADR, h1) //where h1 is NFIT Device Handle for this NVDIMM1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500738"></A>      Method (_DSM, ...) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500739"></A>      ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500740"></A>      }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500741"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500742"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500743"></A>   Device (NVD2) // NVDIMM2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500744"></A>   {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500745"></A>      Name(_ADR, h2) //where h2 is NFIT Device Handle for this NVDIMM2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500746"></A>      Method (_DSM, ...) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500747"></A>      ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500748"></A>      }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500749"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500750"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500751"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500752"></A> Device (MEM0) // Memory module</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500753"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500754"></A>   Name (_HID, EISAID (&#8220;PNP0C80&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500755"></A>   Method (_STA) {...} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500756"></A>   Method (_CRS) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500757"></A> }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500758"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500759"></A> Scope (&#92;_GPE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500760"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500761"></A>  Method (_L00) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500762"></A>   Notify (&#92;_SB.NVDR, 0x80) // Notify to NVDIMM root device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500763"></A>   Notify (&#92;_SB.MEM0, 1) // Device Check to Memory Module</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500764"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1500765"></A> }</P>
<P CLASS="Body">
<A NAME="pgfId-1500766"></A>Hot Plugged memory is indicated to OS using ACPI Name Space device with PNPID of PNP0C80. The NFIT entries created by the hot plug NVDIMM are communicated by the ACPI Name Space device with ACPI0012. </P>
<P CLASS="Body">
<A NAME="pgfId-1500768"></A>NVDIMM hot add flow:</P>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1500769"></A>Prior to hot add of the NVDIMM, the corresponding ACPI Name Space devices, NVD1, NVD2 return an address from _ADR object (NFIT Device handle) which does not match any entries present in NFIT (either the static or from _FIT) indicating that the corresponding NVDIMM is not present. Further ACPI Name Space Device MEM0 returns _STA status of 0 indicating that the devices are not present, not enabled and not functioning.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1500770"></A>On hot add</LI>
<LI CLASS="StepSubAlpha-1">
<A NAME="pgfId-1500771"></A>Send Notify 0x80 to NVDR to cause NVDIMM bus driver to enumerate all the devices under the root hierarchy</LI>
<LI CLASS="StepSubAlpha-N">
<A NAME="pgfId-1500772"></A>NVDIMM bus driver evaluates the _FIT method under the NVDR device and identifies the changes to the NVDIMM devices present (by identifying new NFIT Device handles that have been added).</LI>
<LI CLASS="StepSubAlpha-N">
<A NAME="pgfId-1500774"></A>NVDIMM bus driver now finds matching entries for addresses returned by _ADR objects of NVD1 and NVD2 and loads the corresponding drivers.</LI>
<LI CLASS="StepSubAlpha-N">
<A NAME="pgfId-1500776"></A>Send Notify Device Check to MEM0 to cause re-enumeration of device causing the memory manager to add _CRS range to the memory pool.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1500777"></A>MEM0 will now report all the memory ranges now created and made visible.</LI>
</OL>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1502242"></A><A NAME="88893"></A> NVDIMM Root Device _DSMs</H6>
<P CLASS="Body">
<A NAME="pgfId-1502243"></A>A device specific method (_DSM) for NVDIMM root devices (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#72060" CLASS="XRef">See NVDIMM Root Device.</A>) is described in this section. </P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1502246"></A> Input Parameters:</H6>
<P CLASS="Body">
<A NAME="pgfId-1502247"></A>Arg0 - UUID (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc202340533" CLASS="XRef">See Universally Unique Identifiers (UUIDs).</A>) (set to 2f10e7a4-9e91-11e4-89d3-123b93f75cba) </P>
<P CLASS="Body">
<A NAME="pgfId-1502248"></A>Arg1 - Revision ID (set to 1)</P>
<P CLASS="Body">
<A NAME="pgfId-1502249"></A>Arg2 - Function Index </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502250"></A><A NAME="41412"></A>NVDIMM Root Device Function Index</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1502253"></A>Function Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1502255"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502257"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502259"></A>Query command implemented (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#RSVD_DSM" CLASS="XRef">See _DSM (Device Specific Method).</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502261"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502263"></A>Query Address Range Scrub (ARS) Capabilities (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#64636" CLASS="XRef">See Function Index 1 - Query ARS Capabilities.</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502265"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502267"></A>Start Address Range Scrub (ARS) (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#44801" CLASS="XRef">See Function Index 2 - Start ARS.</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502269"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502271"></A>Query Address Range Scrub (ARS) Status (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#85266" CLASS="XRef">See  Function Index 3 - Query ARS Status.</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502273"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502275"></A>Clear Uncorrectable Error (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#70930" CLASS="XRef">See Function Index 4 - Clear Uncorrectable Error.</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509525"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509527"></A>Translate SPA</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511932"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511934"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509556"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509558"></A>ARS Error Inject</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509552"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509554"></A>ARS Error Inject Clear</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509548"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509550"></A>ARS Error Inject Status Query</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1517739"></A>0xA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1517741"></A>Query ARS Error Inject Capabilities</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502277"></A>0xB - 0xFFFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502279"></A>Reserved</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1502283"></A>Arg3 - a package containing parameters for the function specified by the UUID, Revision ID and Function Index. The layout of the package for each command along with the corresponding output is illustrated in the following tables. The input and output package are a list of bytes (Buffer).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1502285"></A><A NAME="88603"></A>Address Range Scrubbing (ARS) Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1509182"></A>ARS allows the platform to communicate memory errors to system software. This capability allows system software to prevent accesses to addresses with uncorrectable errors in memory. </P>
<P CLASS="Body">
<A NAME="pgfId-1509183"></A>The ARS functions are system scope and are not specific to a single NVDIMM, i.e., they manage all NVDIMMs present in the system. </P>
<P CLASS="Body">
<A NAME="pgfId-1509184"></A>The Query ARS Capabilities function indicates if ARS is supported for an address range and to discover system-wide attributes, such as the maximum amount of data that can be returned from a Query ARS Status function and whether the platform provides an asynchronous ACPI notification that a new uncorrectable error has been discovered.</P>
<P CLASS="Body">
<A NAME="pgfId-1509185"></A>Only one scrub can be in progress system wide at any given time. OSPM should first issue a Query ARS Status function and ensure no ARS is in progress before issuing a Start ARS function. If a successful status is returned, the extended status of the Query ARS Status function indicates to OSPM one of the following:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1509186"></A>An ARS has been completed and ARS results are returned. These results should be processed by OSPM before issuing another Start ARS function. When a new address range scrub operation is started, the previous ARS results are lost.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1509187"></A>An ARS is in progress and no ARS results are returned. A Start ARS function fails while an ARS is in progress. OSPM should periodically issue Query ARS Status functions until the ARS is no longer in progress.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1509188"></A>There has been no ARS since the platform was booted so there are no ARS results returned. A new Start ARS function may be issued.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1509189"></A>An ARS stopped prematurely and partial results are returned. If the platform has more data to return than will fit in the Max Query ARS Status Output Buffer Size (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#64636" CLASS="XRef">See Function Index 1 - Query ARS Capabilities.</A>), OSPM may issue Start ARS and Query ARS Status functions in a loop and retrieve all of the ARS Error Records, modifying the ARS Start SPA Address and length with each iteration. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1509193"></A>If a Start ARS function is issued, the OSPM provides the ARS Start SPA Address and ARS Length for the range to be scrubbed. If the previous ARS stopped prematurely, these fields should be set to the values from the Restart ARS Start SPA Address and Restart ARS Length from the previous Query ARS Status output buffer. For any Start ARS function, OSPM may optionally set the Flags Bit[0] to indicate to the platform that the ARS is a priority and may cause delays in other processing, such as when booting. The output from a successful Start ARS function provides an estimated time for the scrub to complete as a hint to the OSPM regarding when to issue a Query ARS Status function.</P>
<P CLASS="Body">
<A NAME="pgfId-1509194"></A>As indicated in the Query ARS Capabilities function output, a platform may issue the asynchronous event notification 0x81 (Unconsumed Uncorrectable Memory Error Detected Notification) when new uncorrectable errors are detected. Upon receiving the notification, the OSPM may decide to issue a Start ARS with Flags Bit [1] set to prepare for the retrieval of existing records and issue the Query ARS Status function to retrieve the records. The OSPM can pass the entire range of persistent memory as &#8216;ARS Start SPA Address&#8217; and &#8216;ARS Length&#8217; for Start ARS, even if the persistent memory range is not contiguous. Alternatively, the OSPM may decide to ignore event notification 0x81. If the memory range is accessed before OSPM can process the ARS data, default platform error handing sequences, such as Machine Check, may occur. </P>
<P CLASS="Body">
<A NAME="pgfId-1519081"></A>Platforms may support the ability for OSPM to clear an error previously reported from an ARS. OSPM should only issue the Clear Uncorrectable Error function for a memory address range if that the address range has been retired from further use or if valid error-free data is written to the range before those locations are read. If the Clear Uncorrectable Error function is not supported by the platform or if a Clear Uncorrectable Error function for an address range fails, the OSPM should continue to prevent accesses to the address ranges.</P>
<P CLASS="Body">
<A NAME="pgfId-1509196"></A>The ARS related functions use the following convention for the Status and Extended Status fields.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1512838"></A>Address Range Scrub (ARS) Error Injection Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1512839"></A>The expected OSPM ARS Error Injection flow is: </P>
<OL>
<LI CLASS="StepNumList-1">
<A NAME="pgfId-1512840"></A>Inject an error with ARS Error Inject.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1512841"></A>Optionally and if ARS Unconsumed Uncorrectable Memory Error Detected Notification is supported by the host, system firmware triggers an ACPI NVDIMM root device notification 0x81 for the OSPM.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1512842"></A>Use Start ARS with Flags Bit[1] set for OSPM acknowledgment of the notification to system firmware and use ARS Query Status to query ARS status.   </LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1512843"></A>Optionally, use ARS Error Inject Status Query to query the error injected ranges.   </LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1512834"></A>Use ARS Error Inject Clear to clear the ARS error injected ranges. Until the error is cleared, system firmware will report the error in the ARS Query Status output buffer. </LI>
</OL>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502291"></A><A NAME="80690"></A>Status and Extended Status Field Generic Interpretations</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1507172"></A>Bytes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1507174"></A>Field Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1507176"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507178"></A>1-0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507180"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507182"></A>0 - Success</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507183"></A>1 - Function Not Supported</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507184"></A>2 - Invalid Input Parameters</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507185"></A>3 - Hardware Error</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507186"></A>4 - Retry Suggested; it is up to the OSPM regarding the number of retries to perform.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507187"></A>5 - Error - Unknown Reason</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507188"></A>6 - Function-Specific Error Code</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507189"></A>7 - FFFFh Reserved for errors</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507191"></A>3-2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507193"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507195"></A> Function Specific</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1505714"></A><A NAME="53256"></A>If Status is nonzero, the Output Buffer for all the functions in this _DSM (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#RSVD_DSM" CLASS="XRef">See _DSM (Device Specific Method).</A>) is limited to only the Status and Extended Status fields. </LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1502326"></A><A NAME="64636"></A>Function Index 1 - Query ARS Capabilities</H6>
<P CLASS="Body">
<A NAME="pgfId-1502327"></A>This function provides ARS capabilities for a given address range. The format of the input and output for this function is given below.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1503639"></A>Function Input</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502329"></A>Query ARS Capabilities - Input Buffer</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1502332"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1502334"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1502336"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1502338"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502340"></A>ARS Start SPA Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502342"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502344"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502346"></A>Starting of System Physical Address of ARS</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502348"></A>ARS Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502350"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502352"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502354"></A>In bytes</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502358"></A>Function Output</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502359"></A>Query ARS Capabilities - Output Buffer</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509218"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509220"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509222"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509224"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509226"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509228"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509230"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509235"></A>Defined in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80690" CLASS="XRef">See Status and Extended Status Field Generic Interpretations.</A>.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509236"></A>All other fields in this structure are Reserved if Status is not set to 0 (i.e., Success).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509238"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509240"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509242"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509244"></A>Bit[0] - If set to 1, indicates scrub of Volatile Memory is supported. Volatile memory is any region that is not marked as Persistent Memory in UEFI or in an ACPI Address Range Type.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509245"></A>Bit[1] - If set to 1, indicates scrub of Persistent Memory is supported. Persistent Memory is any region that has one of the following memory range types:</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1509246"></A>UEFI memory type of EfiPersistentMemory</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1509247"></A>Any UEFI memory type that has the EFI_MEMORY_NV memory attribute set </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1509248"></A>ACPI Address Range Type of AddressRangePersistentMemory</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1509249"></A>Bits[15:2] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509251"></A>Max Query ARS Status Output Buffer Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509253"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509255"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509257"></A>In bytes.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509258"></A>Maximum size of buffer (including the Status and Extended Status fields) returned by the Query ARS Status function. This can be used to calculate the maximum number of ARS Error Records that are supported. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1509259"></A>This value shall be a constant for the platform, independent of the input SPA range. As long as a valid input SPA range is specified, the value returned for this shall always be the same.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509261"></A>Clear Uncorrectable Error Range Length Unit Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509263"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509265"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509267"></A>In bytes.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509268"></A>This field describes the uncorrectable error clearing unit</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509269"></A>size. This value shall be a power of two. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1509270"></A>The Clear Uncorrectable Error Range Length argument to the Clear Uncorrectable Errors LSM function shall be an integer multiple of this unit size. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1509272"></A>The Query ARS Status ARS Error Record Format &#8220;Length&#8221; field shall be an integer multiple of this unit size. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1509273"></A>This value shall be a constant for the platform, independent of the input SPA range. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509275"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509277"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509279"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509281"></A>Bit[0] - Unconsumed Uncorrectable Memory Error Detected Notification flag. If set to 1, indicates platform supports the ACPI NVDIMM Root Device Unconsumed Error Notification (0x81) as described in <A HREF="ACPI_Software_Programming_Model.htm#33466" CLASS="XRef">See NVDIMM Root Device Notification Values.</A>. If set to 0, the platform doesn&#8217;t support this notification mechanism.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1519116"></A>Bit[1] - ARS Stopped Notification flag. If set to 1, indicates the platform supports ARS Stopped Notification (0x82) as described in <A HREF="ACPI_Software_Programming_Model.htm#33466" CLASS="XRef">See NVDIMM Root Device Notification Values.</A> . If set to 0, the platform does not support this notification. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1509282"></A>Bit[15-2] - Reserved.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509284"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509286"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509288"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509290"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1502415"></A><A NAME="44801"></A>Function Index 2 - Start ARS</H6>
<P CLASS="Body">
<A NAME="pgfId-1502416"></A>The Start ARS function triggers an Address Range Scrub for the given range of memory. Address scrubbing can be done for volatile memory, persistent memory, or both. For the given input ARS Start SPA and length, there may be one or more ranges, including gaps between them for the given Type parameter.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502417"></A>Function Input</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502418"></A>Start ARS - Input Buffer</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509330"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509332"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509334"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509336"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509338"></A>ARS Start SPA Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509340"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509342"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509344"></A>In bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509346"></A>ARS Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509348"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509350"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509352"></A>In bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509354"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509356"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509358"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509360"></A>Bit[0] - If set to 1, Scrub Volatile Memory</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509361"></A>Bit[1] - If set to 1, Scrub Persistent Memory</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509362"></A>Bits[15:2] Reserved</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509363"></A>Note: If the range provided includes both volatile and persistent sub-ranges, only the types indicated here will be scrubbed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509365"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509367"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509369"></A>18</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509371"></A>Bit[0] - If set to 1 specifies that the platform may cause delays in processing other operations while performing the ARS (e.g., for use during system boot). If set to 0 specifies that the platform shall not cause delays in processing other operations while performing the ARS (e.g., for use during run time).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1509372"></A>Bit[1]: If set to 1 the firmware shall return data from a previous scrub, if any, without starting a new scrub. If set to 0 firmware shall start a new ARS. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509374"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509376"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509378"></A>19</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509380"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502472"></A> Function Output</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502473"></A>Start ARS - Output Buffer</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504299"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504301"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504303"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504305"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502484"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502486"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502488"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502496"></A>6 - ARS already in progress </P>
<P CLASS="TableBody">
<A NAME="pgfId-1502497"></A>All other values defined in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80690" CLASS="XRef">See Status and Extended Status Field Generic Interpretations.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506954"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506956"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506958"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506960"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502499"></A>Estimated Time for Scrub</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502501"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502503"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502505"></A>In seconds</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502506"></A>Estimated time to scrub the given address range.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1502510"></A><A NAME="85266"></A> Function Index 3 - Query ARS Status</H6>
<P CLASS="Body">
<A NAME="pgfId-1502511"></A>The Query ARS Status command allows software to get the status of ARS.</P>
<P CLASS="Body">
<A NAME="pgfId-1519087"></A>If the platform supports ARS error injection, then it shall also include injected errors as part of its payload.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502512"></A>Function Input</H6>
<P CLASS="Normal">
<A NAME="pgfId-1502513"></A>None</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502514"></A>Function Output</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502515"></A>Query ARS Status - Output Buffer</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504282"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504284"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504286"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504288"></A>Interpretation</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1503513"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1503515"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1503517"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506469"></A>Defined in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80690" CLASS="XRef">See Status and Extended Status Field Generic Interpretations.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507010"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507012"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507014"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1507044"></A>0 - ARS complete</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507045"></A>1 - ARS in progress. Any returned ARS data shall be all zeros.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507046"></A>2 - No ARS performed for current boot. Any returned ARS data shall be all zeros.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1507047"></A>3 - ARS Stopped Prematurely - This may occur when the implementation reaches the maximum number of errors that can be reported. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1507048"></A>4 ..0xFFFF- Reserved. Any returned ARS Data shall be all zeros.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1503528"></A> ARS Data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1503610"></A>Varies</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1503532"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1505098"></A>See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#_Toc430169073" CLASS="XRef">See ARS Data.</A>.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Normal">
<A NAME="pgfId-1502572"></A>The output SPA range return indicates the scope of the ARS scrub for the specified type. </P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502585"></A><A NAME="_Toc430169073"></A><A NAME="_Ref416429539"></A>ARS Data</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504237"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504239"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504241"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504243"></A>Interpretation</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502596"></A>Output (Size)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502598"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502600"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502602"></A>Size of Output Buffer in bytes, including this field. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502604"></A>Start SPA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502606"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502608"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502610"></A>In bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502612"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502614"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502616"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502618"></A>In bytes</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502619"></A>ARS performed range is from Start SPA to Start SPA + Length</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502621"></A>Restart ARS Start SPA Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502623"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502625"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502627"></A>Starting SPA to restart the ARS if Status is Success and Extended Status was reported as ARS Stopped Prematurely. The value specified here is used without modification as the ARS Start SPA Address when calling Start ARS to continue an ARS that stopped prematurely before completing the requested ARS Length.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502628"></A>Note: It is not required to continue an ARS that has stopped prematurely.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502630"></A>Restart ARS Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502632"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502634"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502636"></A>SPA Length to restart the ARS if Status is Success and Extended Status was reported as ARS Stopped Prematurely. The value specified here is used without modification as the ARS Length when calling Start ARS to continue an ARS that stopped prematurely before completing the requested ARS Length.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502638"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502640"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502642"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502644"></A>Bit[0] - Volatile Memory range if set to 1</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502645"></A>Bit[1] - Persistent Memory range if set to 1</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502646"></A>If both bit[0] and bit[1] are set, both Persistent Memory and volatile memory are in this range.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502647"></A>Bits[15:2] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502649"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502651"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502653"></A>38</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502655"></A>Bit[0] - If set to 1, indicates an overflow condition has occurred. This means that more errors were reported in the error log than will fit in the maximum total buffer size of Max Query ARS Status Data Size from the Query ARS Capabilities. The returned Extended Status should be ARS Stopped Prematurely when this bit is set to 1.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502656"></A>Bits[15:1] Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502658"></A>Number of Error Records</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502660"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502662"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502664"></A>Number of ARS Error Record structures reported</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502666"></A>ARS Error Records</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502668"></A>Varies</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502670"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502675"></A>Refer to <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#30060" CLASS="XRef">See ARS Error Record Format.</A> for the format of the error record.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502691"></A><A NAME="30060"></A>ARS Error Record Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504207"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504209"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504211"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504213"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502702"></A>NFIT Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502704"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502706"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502708"></A>NFIT Handle indicates the specific NVDIMM at Start SPA of Error Location (offset 8)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502710"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502712"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502714"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502717"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502719"></A>Start SPA of Error Location </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502721"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502723"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502725"></A>Start of System Physical Address of the error. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502727"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502729"></A>8 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502731"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502733"></A>Length indicates the consecutive bytes from Start SPA of Error Location that are in error. Due to interleaving, the range covered by Start SPA of Error Location and Length may include addresses that are present in other NVDIMMs in an interleave set.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502734"></A>In case of overflow, the address range indicated by Start SPA of Error Location and Length will cover the NVDIMM interleave set that is impacted by the error. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1502735"></A>The range covered by Start SPA of Error Location and Length may exceed the requested scrub range due to platform limitations.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1502738"></A><A NAME="70930"></A>Function Index 4 - Clear Uncorrectable Error</H6>
<P CLASS="Body">
<A NAME="pgfId-1502739"></A>The Clear Uncorrectable Error Function allows system software to clear uncorrectable errors from the NVDIMM based on System Physical Address (SPA). Uncorrectable errors reported by the Query ARS Status function can be cleared utilizing this mechanism.</P>
<P CLASS="Body">
<A NAME="pgfId-1502740"></A>For each uncorrectable error range length covered by the specified SPA range that contains an uncorrectable error, platform software shall clear the error and may modify the data at those addresses. For each uncorrectable error range length covered by the specified SPA range that does not contain an uncorrectable error, platform software shall do nothing.</P>
<P CLASS="Body">
<A NAME="pgfId-1502741"></A>The Clear Uncorrectable Error SPA Range Base shall be aligned to the Clear Uncorrectable Error Range Length Unit Size and the Clear Uncorrectable Error Range Length must be an integer multiple of the Clear Uncorrectable Error Range Length Unit Size. The Clear Uncorrectable Error request shall result in an Invalid Parameter error status if these rules are not followed.</P>
<P CLASS="Body">
<A NAME="pgfId-1502742"></A>Attempting to clear an error with a range length that overruns the end of a region shall result in an Invalid Parameter error status.</P>
<P CLASS="Body">
<A NAME="pgfId-1502743"></A>Attempting to clear an error with a range length that is greater than the range of uncorrectable errors is not considered a failure. </P>
<P CLASS="Body">
<A NAME="pgfId-1502744"></A>Attempting to clear an error from an address that does not currently have an uncorrectable error is not considered a failure. </P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1502746"></A>The data contained in the locations that are cleared with this command are indeterminate. Care must be taken when using this command since once the error has been cleared, subsequent reads of those cleared locations will cause silent data corruption if software is unaware that the original contents were lost. Software should only utilize this command if it can guarantee that the locations have been retired from further use or will be written with valid data before the locations are read.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1517803"></A>OSPM may call <EM CLASS="CodeCharacter">
Clear Uncorrectable Error </EM>
on an ARS error range that was injected via the ARS Error Inject function.  If the platform supports this, it should ultimately treat it as if the <EM CLASS="CodeCharacter">
ARS Error Inject Clear </EM>
function was called.  If the platform does not support this, it should fail with an Invalid Input Parameter error.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502747"></A>Function Input</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502748"></A>Clear Uncorrectable Error - Input Buffer</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504163"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504165"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504167"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504169"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502759"></A>Clear Uncorrectable Error SPA Range Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502761"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502763"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502765"></A>In bytes<BR>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502766"></A>Starting location from which to clear the uncorrectable error. This address should be aligned to the Clear Uncorrectable Error Range Length Unit Size reported in the Query ARS Capabilities function (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#64636" CLASS="XRef">See Function Index 1 - Query ARS Capabilities.</A>).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502768"></A>Clear Uncorrectable Error Range Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502770"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502772"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502774"></A>In bytes</P>
<P CLASS="TableBody">
<A NAME="pgfId-1502775"></A>Length of the region to clear the uncorrectable error from. This length should be an integer multiple of the Clear Uncorrectable Error Range Length Unit Size reported in the Query ARS Capabilities function (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#64636" CLASS="XRef">See Function Index 1 - Query ARS Capabilities.</A>).</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1502779"></A>Function Output </H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1502822"></A>Clear Uncorrectable Error - Output Buffer</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504171"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504173"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504175"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1504177"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502791"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502793"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502795"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502803"></A>Defined in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80690" CLASS="XRef">See Status and Extended Status Field Generic Interpretations.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506675"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506677"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506679"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1506681"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502805"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502807"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502809"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502811"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502813"></A>Cleared Uncorrectable Error Range Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502815"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502817"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1502819"></A>The range of errors actually cleared by the platform, starting from the requested Clear Uncorrectable Error SPA Range Base. This length shall be an integer multiple of the Clear Uncorrectable Error Range Length Unit Size reported in the Query ARS Capabilities function (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#64636" CLASS="XRef">See Function Index 1 - Query ARS Capabilities.</A>).<BR>
<BR>
Note: This range length may be smaller than the length requested by the input range length.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1511718"></A><A NAME="17785"></A>Function Index 5 - Translate SPA</H6>
<P CLASS="Body">
<A NAME="pgfId-1509902"></A>This command instructs the platform to translate the requested System Physical Address (SPA) in to one or more NVDIMM devices consisting of an NFIT Device Handle and DIMM Physical Address (DPA) on that device. </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1509903"></A>The SPA address to translate must lie within one of the SPA ranges described in the NFIT System Physical Address Range table. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1509904"></A>For non-mirrored interleave sets, the SPA address will translate to a single NVDIMM and single DPA. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1509905"></A>For a HW mirrored interleave set, the Flags Bit[0] - Mirrored SPA Location bit is set and all NVDIMM Devices the SPA translates to are included in the returned NVDIMM Device List.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1509906"></A>Function Input</H4>
<P CLASS="Body">
<A NAME="pgfId-1509637"></A>The following table outlines the expected input payload for this command.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1509959"></A>Translate SPA - Input Payload Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509929"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509931"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509933"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1509935"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509937"></A>SPA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509939"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509941"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1509943"></A>System Physical Address to translate. This is a byte aligned address and all bits are considered valid. No masking or shifting occurs.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1510012"></A>Function Output</H4>
<P CLASS="Body">
<A NAME="pgfId-1519242"></A>The following tables outline the expected output payload for this command.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1510008"></A>Translate SPA - Output Payload Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1515746"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1515748"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1515750"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1515752"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510023"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510025"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510027"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510029"></A>Defined in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80690" CLASS="XRef">See Status and Extended Status Field Generic Interpretations.</A>.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510030"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510031"></A>If the SPA does not lie within one of the SPA ranges described in the NFIT System Physical Address Range table, a status of 2, Invalid Input Parameter, is returned.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510032"></A><BR>
All other fields in this structure are Reserved if Status is<BR>
not set to 0 (i.e., Success).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510034"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510036"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510038"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510040"></A>Extended Status Field (Vendor Defined)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510042"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510044"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510046"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510048"></A>Bit[0] - Mirrored SPA Location - If set to 1, indicates the SPA location maps to one or more NVDIMMs that are mirrored together and contributing to a single SPA range.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510049"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510050"></A>All NVDIMMs currently contributing to the HW Mirror shall be reported and the Number of NVDIMMs shall report all of the devices in the Mirrored SPA range.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510052"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510054"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510056"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510058"></A>Must be 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510060"></A>Translated Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510062"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510064"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510066"></A>The number of bytes the returned SPA translation applies to. The SPA range defined by the input SPA + output Translated Length -1 will yield an address translation with a constant Translated NVDIMM Device List containing a constant set of NFIT Device Handles.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510068"></A>Number of NVDIMMs</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510070"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510072"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510074"></A>The number of NVDIMM devices being returned in the list of Translated NVDIMM Devices. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1512933"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510075"></A>This is typically 1 for a given SPA location but for Mirrored SPA Locations, it is possible to have multiple NVDIMMs that provide the same SPA.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510077"></A>Translated NVDIMM Device List</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510079"></A>Varies</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510081"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510083"></A>List of one or more Translated NVDIMM Devices</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SubHeading">
<A NAME="pgfId-1510103"></A>Translated NVDIMM Device<A NAME="_Toc464288711"></A></H4>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1510099"></A>Translate SPA - Translated NVDIMM Device List Output Payload Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510106"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510108"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510110"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510112"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510114"></A>NFIT Device Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510116"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510118"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510120"></A>Handle to physical NVDIMM that the SPA maps to. This handle can be utilized to retrieve other NFIT table data that further describes the physical device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510122"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510124"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510126"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510128"></A>Returned as zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510130"></A>DPA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510132"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510134"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510136"></A>DIMM Physical Address that the SPA translates to.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1509662"></A><A NAME="63158"></A>Function Index 7 - ARS Error Inject</H6>
<P CLASS="Body">
<A NAME="pgfId-1509658"></A>ARS Error Inject allows the injection of an error for the memory range in the defined input payload. Input is a package containing a single buffer, where the buffer is formatted as shown in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#75139" CLASS="XRef">See ARS Error Inject - Input Format.</A>. </P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1510524"></A>Input (Arg3)<A NAME="_Toc459707590"></A><A NAME="_Ref455504872"></A></H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1510526"></A><A NAME="75139"></A>ARS Error Inject - Input Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510550"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510552"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510554"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510556"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510558"></A>ARS Error Inject SPA Range Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510560"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510562"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510564"></A>Starting location from which to inject the error.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510566"></A>ARS Error Inject SPA Range Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510568"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510570"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510572"></A>In bytes</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510573"></A>Length of the region to inject the error from. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1510574"></A>If Length makes the range cross NVDIMM SPA ranges, the system firmware implementation may report more than one ARS error record in the output buffer of the ARS Query Status _DSM function.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510576"></A>ARS Error Inject Options</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510578"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510580"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510582"></A>Bit 0: Unconsumed Uncorrectable Memory Error Detected Notification. Set to 1 Firmware shall notify the OSPM. Set to 0 the notification will not occur.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1517855"></A>Bit 1: Force Overflow. Set to 1 to trigger a Query ARS Status overflow condition with this range.  A value of 0 is ignored.  See below for details.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1517851"></A>Bit 2: Persistent Error. Set to 1 to persist this error across reboots.  These are uncorrectable errors injected to specified memory locations. Set to 0 to ensure this error is cleared on reboot.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510583"></A>Bits 7-3: Reserved.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1517891"></A>OSPM can trigger a Query ARS Status overflow condition by setting the Force Overflow bit (bit 1) in the ARS Error Inject Options in the input structure. </P>
<P CLASS="Body">
<A NAME="pgfId-1517892"></A>If the Force Overflow bit is set to 0 then the platform may still trigger an overflow condition if necessary (e.g. the number of error records to return from Query ARS Status exceeds Query ARS Status Data Size).</P>
<P CLASS="Body">
<A NAME="pgfId-1517893"></A>The typical sequence to force an overflow condition is as follows:</P>
<P CLASS="Body">
<A NAME="pgfId-1517894"></A>1.	OSPM calls ARS Error Inject to inject an error for a particular range and sets the following fields in the input structure:</P>
<P CLASS="Body">
<A NAME="pgfId-1517895"></A>a.		ARS Error Inject Options bit 0 to 0 so that the Unconsumed Uncorrectable Memory Error Detected notification does not occur for this range.</P>
<P CLASS="Body">
<A NAME="pgfId-1517896"></A>b.		ARS Error Inject Options bit 1 set to 1 to indicate system firmware should force an overflow condition when it encounters this range.</P>
<P CLASS="Body">
<A NAME="pgfId-1517897"></A>2.	OSPM injects a second error with ARS Error inject, setting ARS Error Inject Options bit 0 to 1 and clearing bit 1 to 0.</P>
<P CLASS="Body">
<A NAME="pgfId-1517898"></A>3.	System firmware notifies the OSPM of the new errors with the Unconsumed Uncorrectable Memory Error Detected notification.</P>
<P CLASS="Body">
<A NAME="pgfId-1517899"></A>4.	OSPM calls Query ARS Status in response to the notification.</P>
<P CLASS="Body">
<A NAME="pgfId-1517900"></A>5.	When system firmware encounters the first injected range, it sees that ARS Error Inject Options bit 1 was set and sets Flags bit 0 to 1 in the output ARS Data to indicate an overflow condition.  System firmware also sets the Restart ARS Start SPA Address and Restart ARS Length accordingly.</P>
<P CLASS="Body">
<A NAME="pgfId-1517901"></A>6.	OSPM calls Start ARS with the following fields set in the input structure:</P>
<P CLASS="Body">
<A NAME="pgfId-1517902"></A>a.		Flags bit 1 set to 1 to indicate it does not want to initiate a new scrub.</P>
<P CLASS="Body">
<A NAME="pgfId-1517903"></A>b.		ARS Start SPA Address set to the Restart ARS Start SPA Address from the Query ARS Status output.</P>
<P CLASS="Body">
<A NAME="pgfId-1517904"></A>c.		ARS Length set to the Restart ARS Length from the Query ARS Status output.</P>
<P CLASS="Body">
<A NAME="pgfId-1517905"></A>7.	OSPM calls Query ARS Status.</P>
<P CLASS="Body">
<A NAME="pgfId-1517906"></A>8.	System firmware returns the second injected range.</P>
<P CLASS="Body">
<A NAME="pgfId-1517907"></A>When the Persistent Error bit is set, the error range and the ARS Error Inject Options bits should persist across reboots.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1510522"></A>Output</H6>
<P CLASS="Body">
<A NAME="pgfId-1510710"></A>Return Value for this function is a buffer formatted as shown in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#94801" CLASS="XRef">See ARS Error Inject - Output Format.</A>.<A NAME="_Toc459707591"></A><A NAME="_Ref455504897"></A></P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1510744"></A><A NAME="94801"></A>ARS Error Inject - Output Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510753"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510755"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510757"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510759"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510761"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510763"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510765"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510767"></A>Bytes[1-0] </P>
<P CLASS="TableBody">
<A NAME="pgfId-1510768"></A>0 - Success </P>
<P CLASS="TableBody">
<A NAME="pgfId-1510769"></A>1 - Not Supported. The ARS Error Inject method is not supported by the platform.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1510771"></A>2 - Invalid Input Parameters. Platform reports that the SPA range parameters passed to the ARS Error Inject method are invalid or if notification is not supported. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510774"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510776"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510778"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510780"></A>Reserved</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1509678"></A><A NAME="59100"></A>Function Index 8 - ARS Error Inject Clear</H6>
<P CLASS="Body">
<A NAME="pgfId-1509674"></A>ARS Error Clear allows the clearing of the injected error state in the persistent memory range in the defined input payload. </P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1510847"></A>Input (Arg3)</H6>
<P CLASS="Body">
<A NAME="pgfId-1510863"></A>Input is a package containing a single buffer, where the buffer is formatted as shown in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#13230" CLASS="XRef">See ARS Error Inject Clear - Input Format.</A>.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1510845"></A><A NAME="13230"></A>ARS Error Inject Clear - Input Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510906"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510908"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510910"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1510912"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510914"></A>ARS Error Inject Clear SPA Range Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510916"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510918"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510920"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510922"></A>ARS Error Inject Clear SPA Range Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510924"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510926"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1510928"></A>In bytes</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1510969"></A>Output</H6>
<P CLASS="Body">
<A NAME="pgfId-1510971"></A>Return Value for this function is a buffer formatted as shown in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#55980" CLASS="XRef">See ARS Error Inject Clear - Output Format.</A>.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1511027"></A><A NAME="55980"></A>ARS Error Inject Clear - Output Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511068"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511070"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511072"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511074"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511076"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511078"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511080"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511082"></A>Bytes[1-0] </P>
<P CLASS="TableBody">
<A NAME="pgfId-1511083"></A>0 - Success </P>
<P CLASS="TableBody">
<A NAME="pgfId-1511084"></A>1 - Not Supported. The ARS Error Inject Clear method is not supported by the platform.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1511085"></A>2 - Invalid Input Parameters. Platform reports that the SPA range parameters passed to the ARS Error Inject method are invalid or the specified range does not have an injected error.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511087"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511089"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511091"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511093"></A>Reserved</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1509694"></A><A NAME="40521"></A>Function Index 9 - ARS Error Inject Status Query</H6>
<P CLASS="Body">
<A NAME="pgfId-1517969"></A>The maximum buffer size returned by the ARS Error Inject Status Query function is the same as the Max Query ARS Status Output Buffer Size reported by the Query ARS Capabilities function.</P>
<P CLASS="Body">
<A NAME="pgfId-1509690"></A>This ARS Error Inject Status Query allows the OSPM to list the currently active injected errors in the persistent memory ranges presented in the output buffer payload. </P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1511203"></A>Input (Arg3)</H6>
<P CLASS="Body">
<A NAME="pgfId-1511217"></A>None. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1511225"></A>Output</H6>
<P CLASS="Body">
<A NAME="pgfId-1511234"></A>Return Value for this function is a buffer, formatted as shown below.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1516953"></A>ARS Error Inject Status Query - Output Format<A NAME="_Toc459707593"></A><A NAME="_Ref455504952"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511338"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511340"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511342"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511344"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511346"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511348"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511350"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511352"></A>Bytes[1-0] </P>
<P CLASS="TableBody">
<A NAME="pgfId-1511353"></A>0 - Success. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1511354"></A>1 - Not Supported. The ARS Error Inject Status Query method is not supported by the platform.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511357"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511359"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511361"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511363"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511365"></A>Injected Error Record Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511367"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511369"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511371"></A>Number of Error Records in the following array of Error Records.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1511372"></A>If no ARS injected error, the Injected Error Count field is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511374"></A>ARS Error Inject Status Query Error Records</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511376"></A>Varies</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511378"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511380"></A>Refer to <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#23288" CLASS="XRef">See ARS Error Inject Status Query - Error Record Format.</A>, ARS Error Inject Status Query - Error Record Format for the format of the ARS Error Inject Status Query Error Record.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1511261"></A>The ARS Error Status Query Error Record is defined as follows.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1511469"></A><A NAME="23288"></A>ARS Error Inject Status Query - Error Record Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511431"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511433"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511435"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1511437"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511439"></A>ARS Error Inject Status Query Error Record SPA Range Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511441"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511443"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511445"></A>Starting SPA range of an injected error.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511447"></A>ARS Error Inject Status Query Error Record SPA Range Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511449"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511451"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1511453"></A>Length in bytes of the injected error starting at the SPA range.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1518023"></A><A NAME="43041"></A>Function Index 0xA - Query ARS Error Inject Capabilities </H6>
<P CLASS="Body">
<A NAME="pgfId-1518159"></A>Query ARS Error Inject Capabilities is used by software to detect the system platforms capabilities related to injecting ARS errors.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1518178"></A>Function Input (Arg3)</H6>
<P CLASS="Body">
<A NAME="pgfId-1518201"></A>None. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1518213"></A>Function Output</H6>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1520593"></A>ARS Error Inject Options Support</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518246"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518248"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518250"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518252"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518254"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518256"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518258"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518260"></A>Defined in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#41412" CLASS="XRef">See NVDIMM Root Device Function Index.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518262"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518264"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518266"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518268"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518270"></A>Platform Support</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518272"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518274"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518276"></A>Bit 0: Injected ARS Error Persistence.  This bit only applies if Bit 2 of the ARS Error Inject Options Support, Persistent Error Support, is 0.  If set to 1, all injected ARS errors persist across reboots and the OSPM must explicitly clear them. These are uncorrectable errors injected to specified memory locations. If set to 0, all injected ARS errors are cleared on reboot.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1518278"></A>Bits 31-1: Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518280"></A>ARS Error Inject Options Support</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518282"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518284"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1518286"></A>Bit 0: <EM CLASS="SC-15-176145">
Unconsumed Uncorrectable Memory Error Detected Notification Support.  If set to 1, indicates system platform supports Bit 0 in the ARS Error Inject Options field in the ARS Error Inject input structure.</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1518288"></A>Bit 1: Force Overflow Support.  If set to 1, indicates system platform supports Bit 1 in the ARS Error Inject Options field in the ARS Error Inject input structure.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1518290"></A>Bit 2: Persistent Error Support.  If set to 1, indicates system platform supports Bit 2 in the ARS Error Inject Options field in the ARS Error Inject input structure.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1518292"></A>Bits 7-3: Reserved</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1518392"></A><A NAME="27370"></A>NVDIMM Device Methods</H6>
<P CLASS="Body">
<A NAME="pgfId-1518393"></A>The return status codes for NVDIMM device methods is described in the following table.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1518394"></A><A NAME="11718"></A>NVDIMM Device Method Return Status Code</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518982"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518984"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518986"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518988"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518457"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518459"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518461"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518463"></A>0 - Success</P>
<P CLASS="Normal">
<A NAME="pgfId-1518464"></A>1 - Not Implemented</P>
<P CLASS="Normal">
<A NAME="pgfId-1518465"></A>2 - Invalid Input Parameters</P>
<P CLASS="Normal">
<A NAME="pgfId-1518466"></A>3 - Hardware Error</P>
<P CLASS="Normal">
<A NAME="pgfId-1518467"></A>4 - Retry Suggested</P>
<P CLASS="Normal">
<A NAME="pgfId-1518468"></A>5 - Error - Unknown Reason</P>
<P CLASS="Normal">
<A NAME="pgfId-1518469"></A>6 - Method Specific Error Code</P>
<P CLASS="Normal">
<A NAME="pgfId-1518470"></A>7 - FFFFh Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518472"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518474"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518476"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518478"></A>Method Specific</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1518537"></A><A NAME="38144"></A>_NCH (Get NVDIMM Current Health Information)</H6>
<P CLASS="Body">
<A NAME="pgfId-1518538"></A>This method provides current health information of the NVDIMM device. The platform notifies OSPM by NVDIMM Device NFIT Health Event Notification (see <A HREF="ACPI_Software_Programming_Model.htm#28325" CLASS="XRef">See NVDIMM Device Notification Values.</A>) whenever anything happens that can impact health of NVDIMM device (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#98437" CLASS="XRef">See _NCH Return Value.</A>). When OSPM receives the notification, it can get the current health information by calling this method. Regardless of health notification, OSPM can call this method at any time to get the current health of the NVDIMM device.</P>
<P CLASS="Body">
<A NAME="pgfId-1518539"></A>During boot time, the OSPM can call this method to get the current health of NVDIMM device and take appropriate action. During OSPM runtime, if a health problem gets corrected then also the platform shall notify OSPM by the NVDIMM Device NFIT Health Event Notification.</P>
<P CLASS="Body">
<A NAME="pgfId-1518540"></A>Arguments:</P>
<P CLASS="Body">
<A NAME="pgfId-1518541"></A>    None </P>
<P CLASS="Body">
<A NAME="pgfId-1518542"></A>Return Value:</P>
<P CLASS="Body">
<A NAME="pgfId-1518543"></A>    A buffer containing the current health information as described below</P>
<P CLASS="Body">
<A NAME="pgfId-1518544"></A>Return Value Information:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1518545"></A><A NAME="98437"></A>_NCH Return Value</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518924"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518926"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518928"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518930"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518606"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518608"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518610"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518612"></A>See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518614"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518616"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518618"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518620"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518622"></A>Validation Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518624"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518626"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518628"></A>Bit [0] - Set to 1 to indicate that the Overall Health Status Flags field is valid. This bit is set to 1.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518629"></A>Bit [1] - Set to 1 to indicate that the Overall Health Status Attributes field is valid.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518630"></A>Bit [2-15] - Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518632"></A>Overall Health Status Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518634"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518636"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518638"></A>Multiple bits may be set as appropriate. A bit set to 0 means the respective health problem does not exist or the bit is not applicable to the NVDIMM. If all bits are 0, the NVDIMM is healthy.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518639"></A>Bit [0] - MAINTENANCE NEEDED. This bit is set to 1 to indicate that maintenance is required e.g. temperature alarm tripped, energy source lifetime alarm tripped.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518640"></A>Bit [1] - PERFORMANCE DEGRADED. This bit is set to 1 to indicate that performance is degraded.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518641"></A>Bit [2-7] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1518642"></A>Following bits indicate situations where the OSPM should assume write persistency loss but reads still function properly:</P>
<P CLASS="Normal">
<A NAME="pgfId-1518643"></A>Bit [8] -  WRITE PERSISTENCY LOSS IN EVENT OF POWER LOSS. This bit is set to 1 to indicate that the OSPM should assume that all the writes since last time the NVDIMM was brought online may be lost in event of power loss.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518644"></A>Bit [9] - WRITE PERSISTENCY LOSS IN EVENT OF OFFLINE. This bit is set to 1 to indicate that the OSPM should assume that all the writes since last time the NVDIMM was brought online may be lost when any subsequent offline operation is attempted. </P>
<P CLASS="Normal">
<A NAME="pgfId-1518645"></A>Bit [10] -  WRITE PERSISTENCY LOSS IMMINENT. This bit is set to 1 to indicate that the OSPM should assume that subsequent writes may not persist.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518646"></A>Bit [11-15] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1518647"></A>Following bits indicate situations where the OSPM should assume all data loss:</P>
<P CLASS="Normal">
<A NAME="pgfId-1518648"></A>Bit [16] -  ALL DATA LOSS IN THE EVENT OF POWER LOSS. This bit is set to 1 to indicate that the OSPM should assume that all data may be lost in the event of power loss. </P>
<P CLASS="Normal">
<A NAME="pgfId-1518649"></A>Bit [17] - ALL DATA LOSS IN THE EVENT OF OFFLINE. This bit is set to 1 to indicate that the OSPM should assume that all data may be lost when any subsequent offline operation is attempted. </P>
<P CLASS="Normal">
<A NAME="pgfId-1518650"></A>Bit [18] -  ALL DATA LOSS IMMINENT. This bit is set to 1 to indicate that the OSPM should assume that subsequent reads may fail or return invalid data and subsequent writes may not persist. </P>
<P CLASS="Normal">
<A NAME="pgfId-1518651"></A>Bit [19-31] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1518652"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518654"></A>Overall Health Status Attributes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518656"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518658"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518660"></A>Bit [0] - PERMANENT HEALTH CONDITION - This bit is set to 1 to indicate that the health problem(s) reported in Overall Health Status Flags are permanent. If all the bits of Overall Health Status Flags are 0&#8217;s, then NVDIMM is healthy and this bit shall be ignored by OSPM.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518661"></A>Bit [1-31] - Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518663"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518665"></A>50</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518667"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518669"></A>Reserved</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1518576"></A>Note: These fields do not track data loss during the previous shutdown or any failures during boot time. If the condition that caused those failures still exists when _NCH method is called, then platform shall reflect appropriately in the fields of this method. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1518725"></A><A NAME="14711"></A>_NBS (Get NVDIMM Boot Status)</H6>
<P CLASS="Body-Text">
<A NAME="pgfId-1518726"></A>This method provides information about NVDIMM device&#8217;s status at boot time. The information provided by this method is updated by the platform during boot and remains unchanged during runtime. </P>
<P CLASS="Body-Text">
<A NAME="pgfId-1518727"></A>Arguments:</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1518728"></A>None </P>
<P CLASS="Normal">
<A NAME="pgfId-1518729"></A>Return Value:</P>
<P CLASS="Normal">
<A NAME="pgfId-1518730"></A>A buffer containing device boot status information as described below</P>
<P CLASS="Normal">
<A NAME="pgfId-1518731"></A>&nbsp;</P>
<P CLASS="Normal">
<A NAME="pgfId-1518732"></A>Return Value Information: </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1518713"></A><A NAME="25646"></A>_NBS Return Value</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518861"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518863"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518865"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1518867"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518756"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518758"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518760"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518762"></A>See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518764"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518766"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518768"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518770"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518772"></A>Validation Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518774"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518776"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518778"></A>Bit [0] - Set to 1 to indicate that Data Loss Count field is valid. This bit is set to 1.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518779"></A>Bit [1-15] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518781"></A>Data Loss Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518783"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518785"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518787"></A>A monotonically increasing counter which is incremented whenever the NVDIMM device fails to save and/or flush data to the persistent media. This also includes any data corruption or loss which is not signaled to the OSPM by any other architected means.</P>
<P CLASS="Normal">
<A NAME="pgfId-1518789"></A>This counter is intended for the OSPM to compare against one previously saved by the OSPM in determining the possibility of catastrophic data loss. For example, since data loss counter is monotonically increasing, OSPM can detect data loss if another OSPM was booted on the machine between the shutdown and boot of the original OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518791"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518793"></A>54</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518795"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1518797"></A>Reserved</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1519385"></A>_NIC (Get NVDIMM Health Error Injection Capabilities)</H6>
<P CLASS="Body">
<A NAME="pgfId-1519386"></A>This method reports health error injection capabilities that are supported by the platform. The health errors mentioned in table 9-320 are same as those mentioned in _NCH method (see Section 10.20.8.1).</P>
<P CLASS="Body">
<A NAME="pgfId-1519387"></A>Arguments:</P>
<P CLASS="Body">
<A NAME="pgfId-1519388"></A>None</P>
<P CLASS="Body">
<A NAME="pgfId-1519389"></A>Return Value:</P>
<P CLASS="Body">
<A NAME="pgfId-1519873"></A>See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#13475" CLASS="XRef">See _NIC Output Buffer.</A> below. </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1519390"></A><A NAME="13475"></A>_NIC Output Buffer</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519393"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519395"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519397"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519399"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519401"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519403"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519405"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519407"></A>See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519409"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519411"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519413"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519415"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519417"></A>Health Error Injection Capabilities</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519419"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519421"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519423"></A>A bit is set to 1 if the respective health error injection is supported, otherwise the bit is set to 0.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519424"></A>Bit [0] - MAINTENANCE NEEDED</P>
<P CLASS="Normal">
<A NAME="pgfId-1519425"></A>Bit [1] - PERFORMANCE DEGRADED</P>
<P CLASS="Normal">
<A NAME="pgfId-1519426"></A>Bit [2-7] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1519427"></A>Bit [8] -  WRITE PERSISTENCY LOSS IN EVENT OF POWER LOSS</P>
<P CLASS="Normal">
<A NAME="pgfId-1519428"></A>Bit [9] - WRITE PERSISTENCY LOSS IN EVENT OF OFFLINE</P>
<P CLASS="Normal">
<A NAME="pgfId-1519429"></A>Bit [10] -  WRITE PERSISTENCY LOSS IMMINENT</P>
<P CLASS="Normal">
<A NAME="pgfId-1519430"></A>Bit [11-15] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1519431"></A>Bit [16] -  ALL DATA LOSS IN THE EVENT OF POWER LOSS</P>
<P CLASS="Normal">
<A NAME="pgfId-1519432"></A>Bit [17] - ALL DATA LOSS IN THE EVENT OF OFFLINE</P>
<P CLASS="Normal">
<A NAME="pgfId-1519433"></A>Bit [18] -  ALL DATA LOSS IMMINENT </P>
<P CLASS="Normal">
<A NAME="pgfId-1519434"></A>Bit[19-31] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519436"></A>Overall Health Status Attributes Capabilities</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519438"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519440"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519442"></A>Bit [0] - PERMANENT HEALTH CONDITION. This bit is set to 1 if permanent health errors can be injected, otherwise the bit is set to 0.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519443"></A>Bit [1-31] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519445"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519447"></A>52</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519449"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519451"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1519456"></A><A NAME="80518"></A>_NIH (NVDIMM Inject/Clear Health Errors)</H6>
<P CLASS="Body">
<A NAME="pgfId-1519457"></A>This method has two modes: Inject mode and Clear mode. The OSPM should use this method for health error injection only after verifying that the NVDIMM device has no real health errors.</P>
<P CLASS="Body">
<A NAME="pgfId-1519458"></A>In Inject mode, the OSPM can request the platform to: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1519459"></A>inject one or more health errors  </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1519460"></A>set one or more &#8220;Overall Health Status Attributes&#8221;</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1519461"></A>The OSPM can request either or both the items mentioned above in a single call. Unless errors are cleared, the platform shall accumulate the injected errors and attributes through subsequent calls of this method. </P>
<P CLASS="Body">
<A NAME="pgfId-1519462"></A>If platform can inject at least one error or set at least one attribute, then the platform shall send NVDIMM Device Health Event Notification if supported (see <A HREF="ACPI_Software_Programming_Model.htm#28325" CLASS="XRef">See NVDIMM Device Notification Values.</A>) . The OSPM can call _NCH (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#38144" CLASS="XRef">See _NCH (Get NVDIMM Current Health Information).</A>) and the platform shall report the currently injected errors and attributes in the return buffer.</P>
<P CLASS="Body">
<A NAME="pgfId-1519463"></A>If a platform can inject only a subset of OSPM requested errors or set only a subset of OSPM requested attributes, then the platform shall return an output buffer with Status set to 6 (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A>) and Extended Status set to 1 (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#85182" CLASS="XRef">See _NIH Output Buffer.</A>).  At that time, the OSPM can call the _NIG method (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80627" CLASS="XRef">See _NIG (Get NVDIMM Inject Health Error Status).</A>) to get currently injected errors. If the OPSM requests to inject errors which is already injected, then the platform shall return Success. If the OSPM requests to inject an error or set an attribute which is not supported by method _NIC, then that method shall return output buffer with Status set to 2 (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1519464"></A>The impact of the injected errors on fields reported by the method _NCH, NVDIMM State Flags of NVDIMM Region Mapping Structure (see <A HREF="ACPI_Software_Programming_Model.htm#35502" CLASS="XRef">See NVDIMM Region Mapping Structure .</A>) and on fields reported by NVDIMM device method _NBS (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#14711" CLASS="XRef">See _NBS (Get NVDIMM Boot Status).</A>) after a reset is implementation specific. </P>
<P CLASS="Body">
<A NAME="pgfId-1519465"></A>In Clear mode, the OSPM can request the platform to:</P>
<P CLASS="Body">
<A NAME="pgfId-1520113"></A>clear one or more currently injected errors</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1519467"></A>clear one or more &#8220;Overall Health Status Attributes&#8221; of currently injected error(s)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1519468"></A>The OSPM can request either or both the items mentioned above in a single call.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1519469"></A>If platform can clear at least one error or one attribute, then it shall send NVDIMM Device Health Event Notification (see <A HREF="ACPI_Software_Programming_Model.htm#28325" CLASS="XRef">See NVDIMM Device Notification Values.</A>) if supported. The OSPM can call _NCH (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#38144" CLASS="XRef">See _NCH (Get NVDIMM Current Health Information).</A>) and the platform shall report any remaining injected errors and the attributes in the return buffer.</P>
<P CLASS="Body">
<A NAME="pgfId-1519470"></A>If a platform can clear only a subset of OSPM requested errors and attributes, then the platform shall return an output buffer with Status set to 6 (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A>) and Extended Status set to 1 (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#85182" CLASS="XRef">See _NIH Output Buffer.</A>). At that time, the OSPM can call _NIG method (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80627" CLASS="XRef">See _NIG (Get NVDIMM Inject Health Error Status).</A>) to get currently injected errors. If the OPSM requests to clear error(s) which are not currently injected or requests to clear attribute(s) which are not currently set, then the platform shall return Success. If the OSPM requests to clear an error or clear an attribute which is not supported by method _NIC, then this method shall return output buffer with Status set to 2 (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1519471"></A>One implementation of the health error injection is to emulate at firmware level without injecting any errors in real hardware. </P>
<P CLASS="Body">
<A NAME="pgfId-1519472"></A>Arguments:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1519473"></A><A NAME="49277"></A>_NIH Input Buffer</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519476"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519478"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519480"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519482"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519484"></A>Mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519486"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519488"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519490"></A>0 - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1519491"></A>1 - Inject error(s)</P>
<P CLASS="Normal">
<A NAME="pgfId-1519492"></A>2 - Clear error(s)</P>
<P CLASS="Normal">
<A NAME="pgfId-1519493"></A>3 - 255 - Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519495"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519497"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519499"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519501"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519503"></A>Overall Health Status Errors</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519505"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519507"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519509"></A>These bits are used to inject/clear health error(s) reported by _NIC method (see Section 9.20.8.4). If Mode is set to 1, a bit is set to 1 to inject the respective error. OSPM can set one or more error bits to 1. </P>
<P CLASS="Normal">
<A NAME="pgfId-1519510"></A>If Mode is set to 2, a bit is set to 1 to clear the respective error. OSPM can set one or more error bits to 1. </P>
<P CLASS="Normal">
<A NAME="pgfId-1519511"></A>Bit [0] - MAINTENANCE NEEDED</P>
<P CLASS="Normal">
<A NAME="pgfId-1519512"></A>Bit [1] - PERFORMANCE DEGRADED</P>
<P CLASS="Normal">
<A NAME="pgfId-1519513"></A>Bit [2-7] - Reserved </P>
<P CLASS="Normal">
<A NAME="pgfId-1519514"></A>Bit [8] -  WRITE PERSISTENCY LOSS IN EVENT OF POWER LOSS</P>
<P CLASS="Normal">
<A NAME="pgfId-1519515"></A>Bit [9] - WRITE PERSISTENCY LOSS IN EVENT OF OFFLINE</P>
<P CLASS="Normal">
<A NAME="pgfId-1519516"></A>Bit [10] - WRITE PERSISTENCY LOSS IMMINENT</P>
<P CLASS="Normal">
<A NAME="pgfId-1519517"></A>Bit [11-15] - Reserved </P>
<P CLASS="Normal">
<A NAME="pgfId-1519518"></A>Bit [16] -  ALL DATA LOSS IN THE EVENT OF POWER LOSS</P>
<P CLASS="Normal">
<A NAME="pgfId-1519519"></A>Bit [17] - ALL DATA LOSS IN THE EVENT OF OFFLINE</P>
<P CLASS="Normal">
<A NAME="pgfId-1519520"></A>Bit [18] -  ALL DATA LOSS IMMINENT </P>
<P CLASS="Normal">
<A NAME="pgfId-1519521"></A>Bit [19-31] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519523"></A>Overall Health Status Attributes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519525"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519527"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519529"></A>Bit [0] - PERMANENT HEALTH CONDITION. If Mode is set to 1, this bit is set to 1 to inject health errors as permanent errors, otherwise the bit is set to 0. If Mode is set to 2, this bit is set to 1 to clear the &#8220;Permanent Health Condition&#8221; of the injected errors.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519530"></A>Bit [1-31] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519532"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519534"></A>52</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519536"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519538"></A>Reserved</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1519542"></A>Return Value:</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1519543"></A><A NAME="85182"></A>_NIH Output Buffer</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519546"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519548"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519550"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519552"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519554"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519556"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519558"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519560"></A>Set <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519562"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519564"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519566"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519568"></A>0 - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1519569"></A>1 - If Mode is 1, only a subset of requested errors is injected or only a subset of requested attributes is set. If Mode is 2, only a subset of requested errors is cleared or only a subset of requested attributes is cleared.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519570"></A>2 - FFFFh Reserved</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1519574"></A><A NAME="80627"></A>_NIG (Get NVDIMM Inject Health Error Status)</H6>
<P CLASS="Body">
<A NAME="pgfId-1519575"></A>This method reports currently active health errors and their error attributes that are injected by NVDIMM device method _NIH (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#80518" CLASS="XRef">See _NIH (NVDIMM Inject/Clear Health Errors).</A>). </P>
<P CLASS="Body">
<A NAME="pgfId-1519576"></A>Arguments:</P>
<P CLASS="Body">
<A NAME="pgfId-1519577"></A>None</P>
<P CLASS="Body">
<A NAME="pgfId-1519578"></A>Return Value:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1519579"></A>_NIG Output Buffer</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519582"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519584"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519586"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519588"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519590"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519592"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519594"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519596"></A>See <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#11718" CLASS="XRef">See NVDIMM Device Method Return Status Code.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519598"></A>Extended Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519600"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519602"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519604"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519606"></A>Validation Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519608"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519610"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519612"></A>Bit [0] - Set to 1 to indicate that the &#8220;Injected Overall Health Status Flags&#8221; field is valid. This bit is set to 1.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519613"></A>Bit [1] - Set to 1 to indicate that the &#8220;Overall Health Status Attributes of Injected Errors&#8221; field is valid.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519614"></A>Bit [2-15] - Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519616"></A>Injected Overall Health Status Errors</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519618"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519620"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519622"></A>If a bit is set to 1 then the respective error is currently injected.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519623"></A>Bit [0] - MAINTENANCE NEEDED</P>
<P CLASS="Normal">
<A NAME="pgfId-1519624"></A>Bit [1] - PERFORMANCE DEGRADED</P>
<P CLASS="Normal">
<A NAME="pgfId-1519625"></A>Bit [2-7] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1519626"></A>Bit [8] -  WRITE PERSISTENCY LOSS IN EVENT OF POWER LOSS</P>
<P CLASS="Normal">
<A NAME="pgfId-1519627"></A>Bit [9] - WRITE PERSISTENCY LOSS IN EVENT OF OFFLINE</P>
<P CLASS="Normal">
<A NAME="pgfId-1519628"></A>Bit [10] -  WRITE PERSISTENCY LOSS IMMINENT</P>
<P CLASS="Normal">
<A NAME="pgfId-1519629"></A>Bit [11-15] - Reserved</P>
<P CLASS="Normal">
<A NAME="pgfId-1519630"></A>Bit [16] -  ALL DATA LOSS IN THE EVENT OF POWER LOSS</P>
<P CLASS="Normal">
<A NAME="pgfId-1519631"></A>Bit [17] - ALL DATA LOSS IN THE EVENT OF OFFLINE </P>
<P CLASS="Normal">
<A NAME="pgfId-1519632"></A>Bit [18] -  ALL DATA LOSS IMMINENT </P>
<P CLASS="Normal">
<A NAME="pgfId-1519633"></A>Bit [19-31] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519635"></A>Overall Health Status Attributes of Injected Errors</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519637"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519639"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519641"></A>Bit [0] - PERMANENT HEALTH CONDITION. This bit is set to 1 to indicate that the injected error(s) are permanent health error(s), otherwise the bit is set to 0.</P>
<P CLASS="Normal">
<A NAME="pgfId-1519642"></A>Bit [1-31] - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519644"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519646"></A>50</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519648"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1519650"></A>Reserved</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1519652"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
</BODY>
</HTML>
