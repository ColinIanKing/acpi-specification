<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2016/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="Processor_Configuration_and_Control.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 8 Processor Configuration and Control</TITLE></HEAD>
<BODY>
<DIV>
<H1 CLASS="Heading-1">
<A NAME="pgfId-1375753"></A><A NAME="48288"></A>Processor Configuration and Control<DIV>
<IMG SRC="Processor_Configuration_and_Control-1.gif" ALT="">
</DIV>
</H1>
<P CLASS="Body">
<A NAME="pgfId-1375760"></A>This section describes the configuration and control of the processor&#8217;s power and performance states. The major controls over the processors are:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1375761"></A>Processor power states: C0, C1, C2, C3, ... Cn</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1375762"></A>Processor clock throttling</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1375763"></A>Processor performance states: P0, P1, ... Pn</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1375764"></A>These controls are used in combination by OSPM to achieve the desired balance of the following sometimes conflicting goals:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1375765"></A>Performance</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1375766"></A>Power consumption and battery life</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1375767"></A>Thermal requirements</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1375768"></A>Noise-level requirements </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1375774"></A>Because the goa<A NAME="_Toc354805343"></A><A NAME="_Toc357859068"></A><A NAME="_Toc369097121"></A>ls interact with each other, the operating software needs to implement a policy as to when and where tradeoffs between the goals are to be made<A HREF="#pgfId-1449962" CLASS="footnote">1</A>. For example, the operating software would determine when the audible noise of the fan is undesirable and would trade off that requirement for lower thermal requirements, which can lead to lower processing performance. Each processor configuration and control interface is discussed in the following sections along with how controls interacts with the various goals.</P>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1375797"></A><A NAME="_Toc489256107"></A><A NAME="_Toc489268031"></A><A NAME="_Toc489272584"></A><A NAME="_Toc202341599"></A><A NAME="_Toc258262338"></A>Processor Power States<A NAME="marker-1375794"></A><A NAME="marker-1375795"></A><A NAME="marker-1375796"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1382282"></A><A NAME="_Toc354805344"></A><A NAME="_Toc357859069"></A><A NAME="_Toc369097122"></A>ACPI defines the power state of system processors while in the G0 working state<A HREF="#pgfId-1382288" CLASS="footnote">2</A> as being either active (executing) or sleeping (not executing). Processor power states include are designated C0, C1, C2, C3, ...Cn. The C0 power state is an active power state where the CPU executes instructions. The C1 through Cn power states are processor sleeping states where the processor consumes less power and dissipates less heat than leaving the processor in the C0 state. While in a sleeping state, the processor does not execute any instructions. Each processor sleeping state has a latency associated with entering and exiting that corresponds to the power savings. In general, the longer the entry/exit latency, the greater the power savings when in the state. To conserve power, OSPM places the processor into one of its supported sleeping states when idle. While in the C0 state, ACPI allows the performance of the processor to be altered through a defined &#8220;throttling&#8221; process and through transitions into multiple performance states (P-states). A diagram of processor power states is provided below.<IMG SRC="Processor_Configuration_and_Control-2.gif" ALIGN="BASELINE" ALT="">
</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1375815"></A>Processor Power States</H6>
<P CLASS="Body">
<A NAME="pgfId-1375817"></A>ACPI defines logic on a per-CPU basis that OSPM uses to transition between the different processor power states. This logic is optional, and is described through the FADT table and processor objects (contained in the hierarchical namespace). The fields and flags within the FADT table describe the symmetrical features of the hardware, and the processor object contains the location for the particular CPU&#8217;s clock logic (described by the P_BLK register block and _CST objects).</P>
<P CLASS="Body">
<A NAME="pgfId-1375818"></A>The P_LVL2 and P_LVL3 registers provide optional support for placing the system processors into the C2 or C3 states. The P_LVL2 register is used to sequence the selected processor into the C2 state, and the P_LVL3 register is used to sequence the selected processor into the C3 state. Additional support for the C3 state is provided through the bus master status and arbiter disable bits (BM_STS in the PM1_STS register and ARB_DIS in the PM2_CNT register). System software reads the P_LVL2 or P_LVL3 registers to enter the C2 or C3 power state. The Hardware must put the processor into the proper clock state precisely on the read operation to the appropriate P_LVLx register. The platform may alternatively define interfaces allowing OSPM to enter C-states using the _CST object, which is defined in <A HREF="Processor_Configuration_and_Control.htm#_Toc489256116" CLASS="XRef">See _CST (C States).</A>, &#8220;_CST (C States)&#8221;.<A NAME="marker-1375819"></A><A NAME="marker-1375820"></A><A NAME="marker-1375821"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1375822"></A>Processor power state support is symmetric when presented via the FADT and P_BLK interfaces; OSPM assumes all processors in a system support the same power states. If processors have non-symmetric power state support, then the platform runtime firmware will choose and use the lowest common power states supported by all the processors in the system through the FADT table. For example, if the CPU0 processor supports all power states up to and including the C3 state, but the CPU1 processor only supports the C1 power state, then OSPM will only place idle processors into the C1 power state (CPU0 will never be put into the C2 or C3 power states). Notice that the C1 power state must be supported. The C2 and C3 power states are optional (see the PROC_C1 flag in the FADT table description in <A HREF="ACPI_Software_Programming_Model.htm#92684" CLASS="XRef">See System Description Table Header.</A>, &#8220;System Description Table Header&#8221;).<A NAME="marker-1375823"></A><A NAME="marker-1375824"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1375825"></A>The following sections describe processor power states in detail.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1375850"></A><A NAME="marker-1375847"></A><A NAME="76331"></A>Processor Power State C0</H6>
<P CLASS="Body">
<A NAME="pgfId-1375854"></A><A NAME="_Toc354805345"></A><A NAME="_Toc357859070"></A><A NAME="_Toc369097123"></A>While the processor is in the C0 power state, it executes instructions. While in the C0 power state, OSPM can generate a policy to run the processor at less than maximum performance. The clock throttling mechanism provides OSPM with the functionality to perform this task in addition to thermal control. The mechanism allows OSPM to program a value into a register that reduces the processor&#8217;s performance to a percentage of maximum performance. <A NAME="marker-1375855"></A><A NAME="marker-1375856"></A><A NAME="marker-1375857"></A><A NAME="marker-1375858"></A><A NAME="marker-1375859"></A></P>
</DIV>
<DIV>
<H5 CLASS="ACPINormal">
<A NAME="pgfId-1375863"></A><IMG SRC="Processor_Configuration_and_Control-3.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1375864"></A>Throttling Example</H6>
<P CLASS="Body">
<A NAME="pgfId-1375865"></A>The FADT contains the duty offset and duty width values. The duty offset value determines the offset within the P_CNT register of the duty value. The duty width value determines the number of bits used by the duty value (which determines the granularity of the throttling logic). The performance of the processor by the clock logic can be expressed with the following equation:</P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="ACPINormal">
<A NAME="pgfId-1375871"></A><A NAME="_Ref361728007"></A><IMG SRC="Processor_Configuration_and_Control-4.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1375872"></A>Equation 1   Duty Cycle Equation</H6>
<P CLASS="Body">
<A NAME="pgfId-1375874"></A>Nominal performance is defined as &#8220;close as possible, but not below the indicated performance level.&#8221; OSPM will use the duty offset and duty width to determine how to access the duty setting field. OSPM will then program the duty setting based on the thermal condition and desired power of the processor object. OSPM calculates the nominal performance of the processor using the equation expressed in Equation 1. Notice that a dutysetting of zero is reserved.For example, the clock logic could use the stop grant cycle to emulate a divided processor clock frequency on an IA processor (through the use of the STPCLK# signal). This signal internally stops the processor&#8217;s clock when asserted LOW. To implement logic that provides eight levels of clock control, the STPCLK# pin could be asserted as follows (to emulate the different frequency settings):</P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="ACPINormal">
<A NAME="pgfId-1375885"></A><IMG SRC="Processor_Configuration_and_Control-5.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1375886"></A>Example Control for the STPCLK<EM CLASS="Caption1-Char">
#</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1375887"></A>To start the throttling logic OSPM sets the desired duty setting and then sets the THT_EN bit HIGH. To change the duty setting, OSPM will first reset the THT_EN bit LOW, then write another value to the duty setting field while preserving the other unused fields of this register, and then set the THT_EN bit HIGH again.</P>
<P CLASS="Body">
<A NAME="pgfId-1375888"></A>The example logic model is shown below:</P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="ACPINormal">
<A NAME="pgfId-1375892"></A><IMG SRC="Processor_Configuration_and_Control-6.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1375893"></A>ACPI Clock Logic (One per Processor)</H6>
<P CLASS="Body">
<A NAME="pgfId-1375894"></A>Implementation of the ACPI processor power state controls minimally requires the support a single CPU sleeping state (C1). All of the CPU power states occur in the G0/S0 system state; they have no meaning when the system transitions into the sleeping state(S1-S4). ACPI defines the attributes (semantics) of the different CPU states (defines four of them). It is up to the platform implementation to map an appropriate low-power CPU state to the defined ACPI CPU state. </P>
<P CLASS="Body">
<A NAME="pgfId-1375895"></A>ACPI clock control is supported through the optional processor register block (P_BLK). ACPI requires that there be a unique processor register block for each CPU in the system. Additionally, ACPI requires that the clock logic for multiprocessor systems be symmetrical when using the P_BLK and FADT interfaces; if the P0 processor supports the C1, C2, and C3 states, but P1 only supports the C1 state, then OSPM will limit all processors to enter the C1 state when idle.</P>
<P CLASS="Body">
<A NAME="pgfId-1375902"></A>The following sections define the different ACPI CPU sleeping states.<A NAME="_Toc369597383"></A><A NAME="_Toc369936220"></A><A NAME="_Toc374092144"></A><A NAME="_Toc375244396"></A><A NAME="_Toc375924792"></A><A NAME="_Toc423760015"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1375921"></A><A NAME="marker-1375918"></A><A NAME="90134"></A>Processor Power State C1</H6>
<P CLASS="Body">
<A NAME="pgfId-1375922"></A>All processors must support this power state. This state is supported through a native instruction of the processor (HLT for IA 32-bit processors), and assumes no hardware support is needed from the chipset. The hardware latency of this state must be low enough that OSPM does not consider the latency aspect of the state when deciding whether to use it. Aside from putting the processor in a power state, this state has no other software-visible effects. In the C1 power state, the processor is able to maintain the context of the system caches. </P>
<P CLASS="Body">
<A NAME="pgfId-1375932"></A><A NAME="_Toc354805346"></A><A NAME="_Toc357859071"></A><A NAME="_Toc369097124"></A>The hardware can exit this state for any reason, but must always exit this state when an interrupt is to<A NAME="_Toc369597384"></A><A NAME="_Toc369936221"></A><A NAME="_Toc374092145"></A><A NAME="_Toc375244397"></A><A NAME="_Toc375924793"></A><A NAME="_Toc423760016"></A> be presented to the processor.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1375944"></A><A NAME="_Toc489256110"></A><A NAME="_Toc489268034"></A><A NAME="_Toc489272587"></A><A NAME="_Toc202341602"></A><A NAME="_Toc258262341"></A>Processor Power State C2<A NAME="marker-1375943"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1375945"></A>This processor power state is optionally supported by the system. If present, the state offers improved power savings over the C1 state and is entered by using the P_LVL2 command register for the local processor or an alternative mechanism as indicated by the _CST object. The worst-case hardware latency for this state is declared in the FADT and OSPM can use this information to determine when the C1 state should be used instead of the C2 state. Aside from putting the processor in a power state, this state has no other software-visible effects. OSPM assumes the C2 power state has lower power and higher exit latency than the C1 power state.<A NAME="_Toc354805347"></A><A NAME="_Toc357859072"></A><A NAME="_Toc369097125"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1375949"></A>The C2 power state is an optional ACPI clock state that needs chipset hardware support. This clock logic consists of an interface that can be manipulated to cause the processor complex to precisely transition into a C2 power state. In a C2 power state, the processor is assumed capable of keeping its caches coherent; for example, bus master and multiprocessor activity can take place without corrupting cache context.</P>
<P CLASS="Body">
<A NAME="pgfId-1375950"></A>The C2 state puts the processor into a low-power state optimized around multiprocessor and bus master systems. OSPM will cause an idle processor complex to enter a C2 state if there are bus masters or Multiple processor activity (which will prevent OSPM from placing the processor complex into the C3 state). The processor complex is able to snoop bus master or multiprocessor CPU accesses to memory while in the C2 state. </P>
<P CLASS="Body">
<A NAME="pgfId-1375951"></A>The hardware can exit this state for any reason, but must always exit this state whenever an interrupt is to be presented t<A NAME="_Toc369597385"></A><A NAME="_Toc369936222"></A><A NAME="_Toc374092146"></A><A NAME="_Toc375244398"></A><A NAME="_Toc375924794"></A><A NAME="_Toc423760017"></A>o the processor.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1375969"></A><A NAME="_Toc489256111"></A><A NAME="_Toc489268035"></A><A NAME="_Toc489272588"></A><A NAME="_Toc202341603"></A><A NAME="_Toc258262342"></A>Processor Power State C3<A NAME="marker-1375968"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1375970"></A>This processor power state is optionally supported by the system. If present, the state offers improved power savings over the C1 and C2 state and is entered by using the P_LVL3 command register for the local processor or an alternative mechanism as indicated by the _CST object. The worst-case hardware latency for this state is declared in the FADT, and OSPM can use this information to determine when the C1 or C2 state should be used instead of the C3 state. While in the C3 state, the processor&#8217;s caches maintain state but the processor is not required to snoop bus master or multiprocessor CPU accesses to memory. <A NAME="_Toc354805348"></A><A NAME="_Toc357859073"></A><A NAME="_Toc369097126"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1375974"></A>The hardware can exit this state for any reason, but must always exit this state when an interrupt is to be presented to the processor or when BM_RLD is set and a bus master is attempting to gain access to memory.</P>
<P CLASS="Body">
<A NAME="pgfId-1375975"></A>OSPM is responsible for ensuring that the caches maintain coherency. In a uniprocessor environment, this can be done by using the PM2_CNT.ARB_DIS bus master arbitration disable register to ensure bus master cycles do not occur while in the C3 state. In a multiprocessor environment, the processors&#8217; caches can be flushed and invalidated such that no dynamic information remains in the caches before entering the C3 state.</P>
<P CLASS="Body">
<A NAME="pgfId-1375982"></A>There are two mechanisms for supporting the C3 power state:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1375983"></A>Having OSPM flush and invalidate the caches prior to entering the C3 state.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1375984"></A>Providing hardware mechanisms to prevent masters from writing to memory (uniprocessor-only support).</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1375985"></A>In the first case, OSPM will flush the system caches prior to entering the C3 state. As there is normally much latency associated with flushing processor caches, OSPM is likely to only support this in multiprocessor platforms for idle processors. Flushing of the cache is accomplished through one of the defined ACPI mechanisms (described below in <A HREF="Processor_Configuration_and_Control.htm#_Toc489256113" CLASS="XRef">See Flushing Caches.</A>, &#8220;Flushing Caches&#8221;).</P>
<P CLASS="Body">
<A NAME="pgfId-1375986"></A>In uniprocessor-only platforms that provide the needed hardware functionality (defined in this section), OSPM will attempt to place the platform into a mode that will prevent system bus masters from writing into memory while the processor is in the C3 state. This is accomplished by disabling bus masters prior to entering a C3 power state. Upon a bus master requesting an access, the CPU will awaken from the C3 state and re-enable bus master accesses. </P>
<P CLASS="Body">
<A NAME="pgfId-1375987"></A>OSPM uses the BM_STS bit to determine the power state to enter when considering a transition to or from the C2/C3 power state. The BM_STS is an optional bit that indicates when bus masters are active. OSPM uses this bit to determine the policy between the C2 and C3 power states: a lot of bus master activity demotes the CPU power state to the C2 (or C1 if C2 is not supported), no bus master activity promotes the CPU power state to the C3 power state. OSPM keeps a running history of the BM_STS bit to determine CPU power state policy.</P>
<P CLASS="Body">
<A NAME="pgfId-1375988"></A>The last hardware feature used in the C3 power state is the BM_RLD bit. This bit determines if the Cx power state is exited as a result of bus master requests. If set, then the Cx power state is exited upon a request from a bus master. If reset, the power state is not exited upon bus master requests. In the C3 state, bus master requests need to transition the CPU back to the C0 state (as the system is capable of maintaining cache coherency), but such a transition is not needed for the C2 state. OSPM can optionally set this bit when using a C3 power state, and clear it when using a C1 or C2 power state. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1375999"></A><A NAME="_Toc489256112"></A><A NAME="_Toc489268036"></A><A NAME="_Toc489272589"></A><A NAME="_Toc202341604"></A><A NAME="_Toc258262343"></A>Additional Processor Power States<A NAME="marker-1375998"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1454923"></A>ACPI introduced optional processor power states beyond C3 starting in ACPI 2.0. These power states, C4... Cn, are conveyed to OSPM through the _CST object defined in <A HREF="Processor_Configuration_and_Control.htm#_Toc489256116" CLASS="XRef">See _CST (C States).</A>, &#8220;_CST (C-States).&#8221; These additional power states are characterized by equivalent operational semantics to the C1 through C3 power states, as defined in the previous sections, but with different entry/exit latencies and power savings. See <A HREF="Processor_Configuration_and_Control.htm#_Toc489256116" CLASS="XRef">See _CST (C States).</A>, &#8220;_CST (C-States),&#8221; for more information.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1454937"></A><A NAME="_Toc489256113"></A><A NAME="_Toc489268037"></A><A NAME="_Toc489272590"></A><A NAME="_Toc202341605"></A><A NAME="_Toc258262344"></A>Flushing Caches<A NAME="marker-1454935"></A><A NAME="marker-1454936"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1454938"></A>To support the C3 power state without using the ARB_DIS feature, the hardware must provide functionality to flush and invalidate the processors&#8217; caches (for an IA processor, this would be the WBINVD instruction). To support the S1, S2 or S3 sleeping states, the hardware must provide functionality to flush the platform caches. Flushing of caches is supported by one of the following mechanisms:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1376015"></A>Processor instruction to write back and invalidate system caches (WBINVD instruction for IA processors).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1376018"></A>Processor instruction to write back but not invalidate system caches (WBINVD instruction for IA processors and some chipsets with partial support; that is, they don&#8217;t invalidate the caches).</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1376019"></A>The ACPI specification expects all platforms to support the local CPU instruction for flushing system caches (with support in both the CPU and chipset), and provides some limited &#8220;best effort&#8221; support for systems that don&#8217;t currently meet this capability. The method used by the platform is indicated through the appropriate FADT fields and flags indicated in this section.</P>
<P CLASS="Body">
<A NAME="pgfId-1376020"></A>ACPI specifies parameters in the FADT that describe the system&#8217;s cache capabilities. If the platform properly supports the processor&#8217;s write back and invalidate instruction (WBINVD for IA processors), then this support is indicated to OSPM by setting the WBINVD flag in the FADT.<A NAME="marker-1474698"></A><A NAME="marker-1474699"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1376029"></A>If the platform supports neither of the first two flushing options, then OSPM can attempt to manually flush the cache if it meets the following criteria:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1376030"></A>A cache-enabled sequential read of contiguous physical memory of not more than 2 MB will flush the platform caches. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1376031"></A>There are two additional FADT fields needed to support manual flushing of the caches:</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1376032"></A>FLUSH_SIZE, typically twice the size of the largest cache in the system. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1376033"></A>FLUSH_STRIDE, typically the smallest cache line size in the system. </LI>
</UL>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1376049"></A><A NAME="_Toc489256114"></A><A NAME="_Toc489268038"></A><A NAME="_Toc489272591"></A><A NAME="_Toc202341606"></A><A NAME="_Toc258262345"></A>Power, Performance, and Throttling State Dependencies</H2>
<P CLASS="Body">
<A NAME="pgfId-1376050"></A>Cost and complexity trade-off considerations have driven into the platform control dependencies between logical processors when entering power, performance, and throttling states. These dependencies exist in various forms in multi-processor, multi-threaded processor, and multi-core processor-based platforms. These dependencies may also be hierarchical. For example, a multi-processor system consisting of processors containing multiple cores containing multiple threads may have various dependencies as a result of the hardware implementation.</P>
<P CLASS="Body">
<A NAME="pgfId-1376051"></A>Unless OSPM is aware of the dependency between the logical processors, it might lead to scenarios where one logical processor is implicitly transitioned to a power, performance, or throttling state when it is unwarranted, leading to incorrect / non-optimal system behavior. Given knowledge of the dependencies, OSPM can coordinate the transitions between logical processors, choosing to initiate the transition when doing so does not lead to incorrect or non-optimal system behavior. This OSPM coordination is referred to as Software (SW) Coordination. Alternately, it might be possible for the underlying hardware to coordinate the state transition requests on multiple logical processors, causing the processors to transition to the target state when the transition is guaranteed to not lead to incorrect or non-optimal system behavior. This scenario is referred to as Hardware (HW) coordination. When hardware coordinates transitions, OSPM continues to initiate state transitions as it would if there were no dependencies. However, in this case it is required that hardware provide OSPM with a means to determine actual state residency so that correct / optimal control policy can be realized. </P>
<P CLASS="Body">
<A NAME="pgfId-1376052"></A>Platforms containing logical processors with cross-processor dependencies in the power, performance, or throttling state control areas use ACPI defined interfaces to group logical processors into what is referred to as a dependency domain. The Coordination Type characteristic for a domain specifies whether OSPM or underlying hardware is responsible for the coordination. When OSPM coordinates, the platform may require that OSPM transition ALL (0xFC) or ANY ONE (0xFD) of the processors belonging to the domain into a particular target state. OSPM may choose at its discretion to perform coordination even though the underlying hardware supports hardware coordination. In this case, OSPM must transition all logical processors in the dependency domain to the particular target state.</P>
<P CLASS="Body">
<A NAME="pgfId-1376053"></A>There are no dependencies implied between a processor&#8217;s C-states, P-states or T-states. Hence, for example it is possible to use the same dependency domain number for specifying dependencies between P-states among one set of processors and C-states among another set of processors without any dependencies being implied between the P-State transitions on a processor in the first set and C-state transitions on a processor in the second set. </P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1376054"></A>   <A NAME="_Toc202341607"></A><A NAME="_Toc258262346"></A>Declaring Processors<A NAME="marker-1459727"></A><A NAME="marker-1459728"></A><A NAME="marker-1459729"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1459752"></A>Each processor in the system must be declared in the ACPI namespace in the &#92;_SB scope. Declaration of processors in the &#92;_PR scope was only required for platforms desiring compatibility with ACPI 1.0-based OSPM implementations. It is deprecated for all other uses. Processors are declared via the ASL <EM CLASS="Bold">
Device</EM>
 statement. Declarations via the ASL <EM CLASS="Bold">
Processor statement</EM>
 are deprecated. A <EM CLASS="Bold">
Device</EM>
 definition for a processor is declared using the ACPI0007 hardware identifier (HID). Processor configuration information is provided exclusively by objects in the processor device's object list.</P>
<P CLASS="Body">
<A NAME="pgfId-1459753"></A>When the platform uses the APIC interrupt model, UID object values under a processor device are used to associate processor devices with entries in the MADT. </P>
<P CLASS="Body">
<A NAME="pgfId-1459754"></A>Processor-specific objects may be declared within the processor device's scope. These objects serve multiple purposes including processor performance state control. Other ACPI-defined device-related objects are also allowed under the processor device's scope (for example, the unique identifier object _UID mentioned above). </P>
<P CLASS="Body">
<A NAME="pgfId-1459755"></A>With device-like characteristics attributed to processors, it is implied that a processor device driver will be loaded by OSPM to, at a minimum, process device notifications. OSPM will enumerate processors in the system using the ACPI Namespace, processor-specific native identification instructions, and the _HID method.</P>
<P CLASS="Body">
<A NAME="pgfId-1459756"></A>For more information on the declaration of the processor device object, see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267427" CLASS="XRef">See Device (Declare Device Package).</A>, &quot;Device (Declare Device Package).&quot; Processor-specific child objects are described in the following sections.</P>
<P CLASS="Body">
<A NAME="pgfId-1459794"></A>ACPI 6.0 introduces the notion of processor containers. Processor containers are declared using the <EM CLASS="Bold">
Processor Container Device</EM>
. A processor container can be used to describe a collection of associated processors that share common resources, such as shared caches, and which have power states that affect the processors in the collection. For more information see <A HREF="Processor_Configuration_and_Control.htm#73999" CLASS="XRef">See Processor Container Device .</A> &quot;Processor Container Device&#8221;.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1376091"></A><A NAME="97302"></A><A NAME="_Toc4819270"></A><A NAME="RSVD_PDC"></A><A NAME="_Toc202341608"></A><A NAME="_Toc258262347"></A>_PDC (Processor Driver Capabilities) </H6>
<P CLASS="Body">
<A NAME="pgfId-1376092"></A>This optional object is a method that is used by OSPM to communicate to the platform the level of processor power management support provided by OSPM. This object is a child object of the processor. OSPM evaluates _PDC prior to evaluating any other processor power management objects returning configuration information.</P>
<P CLASS="Body">
<A NAME="pgfId-1376093"></A>The _PDC object provides OSPM a mechanism to convey to the platform the capabilities supported by OSPM for processor power management. This allows the platform to modify the ACPI namespace objects returning configuration information for processor power management based on the level of support provided by OSPM. Using this method provides a mechanism for OEMs to provide support for new technologies on legacy OSes, while also allowing OSPM to leverage new technologies on platforms capable of supporting them. This method is evaluated once during processor device initialization, and will not be re-evaluated during resume from a sleep state transition. The platform must preserve state information across S1-S3 sleep state transitions.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376094"></A>Arguments: (1)</H4>
<P CLASS="Body">
<A NAME="pgfId-1376095"></A>Arg0 - A variable-length Buffer containing a list of capabilities as described below</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376096"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376097"></A>None</P>
<P CLASS="Body">
<A NAME="pgfId-1376098"></A>The buffer argument contains a list of DWORDs in the following format:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376099"></A>RevisionId -		Revision of the buffer format</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376100"></A>Count -		The number of capability values in the capabilities array</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376101"></A>Capabilities[Count] -		Capabilities array</P>
<P CLASS="Body">
<A NAME="pgfId-1376102"></A>Each DWORD entry in the capabilities array is a bitfield that defines capabilities and features supported by OSPM for processor configuration and power management as specified by the CPU manufacturer.</P>
<P CLASS="Body">
<A NAME="pgfId-1376103"></A>The use of _PDC is deprecated in ACPI 3.0 in favor of _OSC. For backwards compatibility, _PDC may be implemented using _OSC as follows:</P>
<DIV>
<H5 CLASS="ACPINormal">
<A NAME="pgfId-1376104"></A>&nbsp;</H5>
<P CLASS="CodeExample">
<A NAME="pgfId-1376105"></A>Method(_PDC,1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376106"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376107"></A>    CreateDWordField (Arg0, 0, REVS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376108"></A>    CreateDWordField (Arg0, 4, SIZE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376109"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376110"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376111"></A>    // Local0 = Number of bytes for Arg0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376112"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376113"></A>    Store (SizeOf (Arg0), Local0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376114"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376115"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376116"></A>    // Local1 = Number of Capabilities bytes in Arg0 </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376117"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376118"></A>    Store (Subtract (Local0, 8), Local1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376119"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376120"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376121"></A>    // TEMP = Temporary field holding Capability DWORDs</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376122"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376123"></A>    CreateField (Arg0, 64, Multiply (Local1, 8), TEMP)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376124"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376125"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376126"></A>    // Create the Status (STS0) buffer with the first DWORD = 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376127"></A>    // This is required to return errors defined by _OSC.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376128"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376129"></A>    Name (STS0, Buffer () {0x00, 0x00, 0x00, 0x00})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376130"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376131"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376132"></A>    // Concatenate the _PDC capabilities bytes to the STS0 Buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376133"></A>    // and store them in a local variable for calling OSC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376134"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376135"></A>    Concatenate (STS0, TEMP, Local2)</P>
<P CLASS="Body">
<A NAME="pgfId-1376136"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376137"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376138"></A>    // Note: The UUID passed into _OSC is CPU vendor specific. Consult CPU</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376139"></A>    // vendor documentation for UUID and Capabilities Buffer bit definitions</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376140"></A>    //</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376141"></A>    _OSC (ToUUID(&quot;4077A616-290C-47BE-9EBD-D87058713953&quot;), REVS, SIZE, Local2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376142"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1449979"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1376143"></A><A HREF="Device_Configuration.htm#RSVD_OSC" CLASS="XRef">See _OSC (Operating System Capabilities).</A>, &#8220;_OSC (Operating System Capabilities)&#8221;, describes the _OSC object, which can be used to convey processor related OSPM capabilities to the platform. Consult CPU vendor specific documentation for the UUID and Capabilities Buffer bit definitions used by _OSC for a specific processor.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1376153"></A><A NAME="_Toc202341610"></A><A NAME="_Toc258262348"></A>Processor Power State Control</H6>
<P CLASS="Body">
<A NAME="pgfId-1376154"></A>ACPI defines multiple processor power state (C state) control interfaces. These are:</P>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1376155"></A>The Processor Register Block&#8217;s (P_BLK&#8217;s) P_LVL2 and P_LVL3 registers coupled with FADT P_LVLx_LAT values and</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1376156"></A>The _CST object in the processor&#8217;s object list.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1460505"></A>The _LPI objects for processors and processor containers.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1376157"></A>P_BLK based C state controls are described in <A HREF="ACPI Hardware Specification.htm#44941" CLASS="XRef">See ACPI Hardware Specification.</A>, &#8220;ACPI Hardware Specification&#8221; and <A HREF="Processor_Configuration_and_Control.htm#_Toc489256107" CLASS="XRef">See Processor Power States.</A>, &#8220;Processor Power States&#8221;. _CST based C state controls expand the functionality of the P_BLK based controls allowing the number and type of C states to be dynamic and accommodate CPU architecture specific C state entry and exit mechanisms as indicated by registers defined using the Functional Fixed Hardware address space.</P>
<P CLASS="Body">
<A NAME="pgfId-1461618"></A>_CST is an optional object that provides: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1461635"></A>The Processor Register Block's (P_BLK's) P_LVL2 and P_LVL3 registers coupled with FADT P_LVLx_LAT values. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1461641"></A>The _CST object in the processor's object list.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1460521"></A>ACPI 6.0 introduces _LPI, the low power idle state object. _LPI provides more detailed power state information and can describe idle states at multiple levels of hierarchy in conjunction with Processor Containers. See <A HREF="Processor_Configuration_and_Control.htm#66957" CLASS="XRef">See _LPI (Low Power Idle States).</A> for details.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376165"></A><A NAME="_Toc489256116"></A><A NAME="_Toc489268040"></A><A NAME="_Toc489272593"></A><A NAME="RSVD_CST"></A>_CST (C States)<A NAME="marker-1376163"></A><A NAME="marker-1376164"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376166"></A>_CST is an optional object that provides an alternative method to declare the supported processor power states (C States). Values provided by the _CST object override P_LVLx values in P_BLK and P_LVLx_LAT values in the FADT. The _CST object allows the number of processor power states to be expanded beyond C1, C2, and C3 to an arbitrary number of power states. The entry semantics for these expanded states, (in other words), the considerations for entering these states, are conveyed to OSPM by the C-state Type field and correspond to the entry semantics for C1, C2, and C3 as described in <A HREF="Processor_Configuration_and_Control.htm#90134" CLASS="XRef">See Processor Power State C1.</A> through <A HREF="Processor_Configuration_and_Control.htm#_Toc489256111" CLASS="XRef">See Processor Power State C3.</A>. _CST defines ascending C-states characterized by lower power and higher entry/exit latency. </P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376167"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376168"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376169"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376170"></A>A variable-length Package containing a list of C-state information Packages as described below</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376171"></A>Return Value Information</H3>
<P CLASS="Body">
<A NAME="pgfId-1376172"></A>_CST returns a variable-length Package that contains the following elements:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376173"></A>Count         An Integer that contains the number of CState sub-packages that follow</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376174"></A>CStates[]    A list of Count CState sub-packages</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376176"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1449990"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376177"></A>    Count                   // Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376178"></A>    CStates[0]              // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376179"></A>    ....</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376180"></A>    CStates[Count-1]        // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376181"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450011"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1376182"></A>Each fixed-length Cstate sub-Package contains the elements described below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376184"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450004"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376185"></A>    Register                // Buffer (Resource Descriptor)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376186"></A>    Type                    // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376187"></A>    Latency                 // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376188"></A>    Power                   // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376189"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376190"></A>Cstate Package Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1452029"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1452031"></A>Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1452033"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376199"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376201"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376203"></A>Contains a Resource Descriptor with a single Register() descriptor that describes the register that OSPM must read to place the processor in the corresponding C state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376205"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376207"></A>Integer<BR>
(BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376209"></A>The C State type (1=C1, 2=C2, 3=C3). This field conveys the semantics to be used by OSPM when entering/exiting the C state. Zero is not a valid value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376211"></A>Latency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376213"></A>Integer<BR>
(WORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376215"></A>The worst-case latency to enter and exit the C State (in microseconds). There are no latency restrictions.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376217"></A>Power </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376219"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376221"></A>The average power consumption of the processor when in the corresponding C State (in milliwatts).</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1376225"></A>The platform must expose a _CST object for either all or none of its processors. If the _CST object exists, OSPM uses the C state information specified in the _CST object in lieu of P_LVL2 and P_LVL3 registers defined in P_BLK and the P_LVLx_LAT values defined in the FADT. Also notice that if the _CST object exists and the _PTC object does not exist, OSPM will use the Processor Control Register defined in P_BLK and the C_State_Register registers in the _CST object. </P>
<P CLASS="Body">
<A NAME="pgfId-1376226"></A>The platform may change the number or type of C States available for OSPM use dynamically by issuing a Notify event on the processor object with a notification value of 0x81. This will cause OSPM to re-evaluate any _CST object residing under the processor object notified. For example, the platform might notify OSPM that the number of supported C States has changed as a result of an asynchronous AC insertion / removal event.</P>
<P CLASS="Body">
<A NAME="pgfId-1376227"></A>The platform must specify unique C_State_Register addresses for all entries within a given _CST object.</P>
<P CLASS="Body">
<A NAME="pgfId-1376228"></A>_CST eliminates the ACPI 1.0 restriction that all processors must have C State parity. With _CST, each processor can have its own characteristics independent of other processors. For example, processor 0 can support C1, C2 and C3, while processor 1 supports only C1.</P>
<P CLASS="Body">
<A NAME="pgfId-1376229"></A>The fields in the processor structure remain for backward compatibility.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376230"></A>Example</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1450018"></A>Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376233"></A>&#92;_SB.CPU0,        // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376234"></A>1,                // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376235"></A>0x120,            // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376236"></A>6 )               // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376237"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376238"></A>Name(_CST, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376239"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376240"></A>4,                // There are four C-states defined here with three semantics</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376241"></A>                  // The third and fourth C-states defined have the same C3 entry semantics </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376242"></A>Package(){ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},     1,  20, 1000}, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376243"></A>Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x161)}, 2,  40,  750},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376244"></A>Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x162)}, 3,  60,  500},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376245"></A>Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x163)}, 3, 100,  250} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376246"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376247"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450025"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1376248"></A>Notice in the example above that OSPM should anticipate the possibility of a _CST object providing more than one entry with the same C_State_Type value. In this case OSPM must decide which C_State_Register it will use to enter that C state. </P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376249"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1376250"></A>This is an example usage of the _CST object using the typical values as defined in ACPI 1.0. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450032"></A>Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376253"></A>&#92;_SB.CPU0,        // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376254"></A>1,                // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376255"></A>0x120,            // PBLK system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376256"></A>6 )               // PBLK Len</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376257"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376258"></A>Name(_CST, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376259"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376260"></A>2,               //  There are two C-states defined here - C2 and C3</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376261"></A>Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x124)}, 2, 2,  750},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376262"></A>Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x125)}, 3, 65, 500} </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376263"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376264"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1376266"></A>The platform will issue a Notify(&#92;_SB.CPU0, 0x81) to inform OSPM to re-evaluate this object when the number of available processor power states changes.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376272"></A>_<A NAME="RSVD_CSD"></A>CSD (C-State Dependency)<A NAME="marker-1376270"></A><A NAME="marker-1376271"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376275"></A> <A NAME="OLE_LINK29"></A><A NAME="OLE_LINK30"></A>This optional object provides C-state control cross logical processor dependency information to OSPM. The _CSD object evaluates to a packaged list of information that correlates with the C-state information returned by the _CST object. Each packaged list entry identifies the C-state for which the dependency is being specified (as an index into the _CST object list), a dependency domain number for that C-state, the coordination type for that C-state and the number of logical processors belonging to the domain for the particular C-state. It is possible that a particular C-state may belong to multiple domains. That is, it is possible to have multiple entries in the _CSD list with the same CStateIndex value.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376276"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376277"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376278"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376279"></A>A variable-length Package containing a list of C-state dependency Packages as described below.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376280"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1376282"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450039"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376283"></A>    CStateDependency[0]    // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376284"></A>    ....</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376285"></A>    CStateDependency[n]    // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376286"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450046"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1376287"></A>Each CstateDependency sub-Package contains the elements described below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376288"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376289"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376290"></A>    NumEntries                // Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376291"></A>    Revision                // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376292"></A>    Domain                    // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376293"></A>    CoordType                // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376294"></A>    NumProcessors            // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376295"></A>    Index                    // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376296"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376297"></A>CStateDependency Package Values</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376300"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376302"></A>Object Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376304"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376306"></A>NumEntries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376308"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376310"></A>The number of entries in the CStateDependency package including this field. Current value is 6.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376312"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376314"></A>Integer<BR>
(BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376316"></A>The revision number of the CStateDependency package format. Current value is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376318"></A>Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376320"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376322"></A>The dependency domain number to which this C state entry belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376324"></A>CoordType</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376326"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376328"></A>The type of coordination that exists (hardware) or is required (software) as a result of the underlying hardware dependency. Could be either 0xFC (SW_ALL), 0xFD (SW_ANY) or 0xFE (HW_ALL) indicating whether OSPM is responsible for coordinating the C-state transitions among processors with dependencies (and needs to initiate the transition on all or any processor in the domain) or whether the hardware will perform this coordination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376330"></A>Num Processors</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376332"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376334"></A>The number of processors belonging to the domain for the particular C-state. OSPM will not start performing power state transitions to a particular C-state until this number of processors belonging to the same domain for the particular C-state have been detected and started.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376336"></A>Index </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376338"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376340"></A>Indicates the index of the C-State entry in the _CST object for which the dependency applies.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1376343"></A>Given that the number or type of available C States may change dynamically, ACPI supports Notify events on the processor object, with Notify events of type 0x81 causing OSPM to re-evaluate any _CST objects residing under the particular processor object notified. On receipt of Notify events of type 0x81, OSPM should re-evaluate any present _CSD objects also. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376344"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1376345"></A>This is an example usage of the _CSD structure in a Processor structure in the namespace. The example represents a two processor configuration. The C1-type state can be independently entered on each processor. For the C2-type state, there exists dependence between the two processors, such that one processor transitioning to the C2-type state, causes the other processor to transition to the C2-type state. A similar dependence exists for the C3-type state. OSPM will be required to coordinate the C2 and C3 transitions between the two processors. Also OSPM can initiate a transition on either processor to cause both to transition to the common target C-state. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376347"></A>Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376348"></A>&#92;_SB.CPU0,                           // Processor Name </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376349"></A>1,                                   // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376350"></A>0x120,                               // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376351"></A>6 )                                  // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376352"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376353"></A>Name (_CST, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376354"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376355"></A>    3,            // There are three C-states defined here with three semantics</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376356"></A>    Package(){ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},     1,  20, 1000}, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376357"></A>    Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x161)}, 2,  40,  750},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376358"></A>    Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x162)}, 3,  60,  500}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376359"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376360"></A>Name(_CSD, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376361"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376362"></A>    Package(){6, 0, 0, 0xFD, 2, 1} , // 6 entries,Revision 0,Domain 0,OSPM Coordinate</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376365"></A>                                     // Initiate on Any Proc,2 Procs<A NAME="OLE_LINK35"></A><A NAME="OLE_LINK36"></A>, Index 1 (C2-type)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376366"></A>    Package(){6, 0, 0, 0xFD, 2, 2}   // 6 entries,Revision 0 Domain 0,OSPM Coordinate</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376367"></A>                                     // Initiate on Any Proc,2 Procs, Index 2 (C3-type)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376368"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376369"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376370"></A>Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376371"></A>&#92;_SB.CPU1,                           // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376372"></A>2,                                   // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376373"></A>,                                    // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376374"></A>)                                    // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376375"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376376"></A>Name(_CST, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376377"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376378"></A>    3,            // There are three C-states defined here with three semantics</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376379"></A>    Package(){ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},     1,  20, 1000}, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376380"></A>    Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x161)}, 2,  40,  750},</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376381"></A>    Package(){ResourceTemplate(){Register(SystemIO, 8, 0, 0x162)}, 3,  60,  500}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376382"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376383"></A>Name(_CSD, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376384"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376385"></A>    Package(){6, 0, 0, 0xFD, 2, 1},    // 6 entries,Revision 0,Domain 0,OSPM Coordinate</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376386"></A>                                       // Initiate on any Proc,2 Procs, Index 1 (C2-type)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376387"></A>    Package(){6, 0, 0, 0xFD, 2, 2}     // 6 entries,Revision 0,Domain 0,OSPM Coordinate</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376388"></A>                                       // Initiate on any Proc,2 Procs,Index 2 (C3-type)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376389"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376390"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450053"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1376391"></A>When the platform issues a Notify(&#92;_SB.CPU0, 0x81) to inform OSPM to re-evaluate _CST when the number of available processor power states changes, OSPM should also evaluate _CSD. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1459821"></A>Processor Hierarchy</H6>
<P CLASS="Body">
<A NAME="pgfId-1459822"></A><EM CLASS="SC-13-266245">
It is very typical for computing platforms to have a multitude of processors that share common resources, such as caches, and which have common power states that affect groups of processors. These are arranged in a hierarchical manner. For example, a system may contain a set of NUMA nodes, each with a number of sockets, which may contain multiple groups of processors, each of which may contain individual processor cores, each of which may contain multiple hardware threads. Different architectures use different terminology to denominate logically associated processors, but terms such as package, cluster, module, and socket are typical examples. ACPI uses the term processor container to describe a group of associated processors. Processors are said to belong to a container if they are associated in some way, such as a shared cache or a low power mode which affects them all.</EM>
</P>
<P CLASS="Normal">
<A NAME="pgfId-1459826"></A><IMG SRC="Processor_Configuration_and_Control-7.gif" ALIGN="BASELINE" ALT="">
</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1459828"></A><A NAME="55672"></A>Processor Hierarchy<EM CLASS="SC-13-266245">
</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1459833"></A><EM CLASS="SC-13-266245">
<A HREF="Processor_Configuration_and_Control.htm#55672" CLASS="XRef">See Processor Hierarchy<EM CLASS="SC-13-266245">
</EM>
.</A> depicts an example system, which comprises a system level processor container, which in turn contains two cluster processor containers, each of which contains two processors. The overall collection is called the processor hierarchy and standard tree terminology is used to refer to different parts of it. For example, an individual processor or container is called a node, the nodes which reside within a processor container are called children of that parent, etc. This example is symmetric but that is not a requirement. For example, a system may contain a different number of processors in different containers or an asymmetric hierarchy where one side of the topology tree is deeper than another. Also note that while this example includes a single top level processor container encompassing all processors, this is not a requirement. It is legal for a system to be described using a collection of trees.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1467543"></A><EM CLASS="SC-13-266245">
The processor hierarchy can be used to describe a number of different characteristics of system topology. The main example is shared power states, see the Low Power Idle states in <A HREF="Processor_Configuration_and_Control.htm#44700" CLASS="XRef">See Lower Power Idle States.</A> for details. </EM>
</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1461854"></A><A NAME="73999"></A>Processor Container Device </H6>
<P CLASS="Body">
<A NAME="pgfId-1461855"></A>This optional device is a container object that acts much like a bus node in a namespace. It may contain child objects that are either processor devices or other processor containers. This allows representing hierarchical processor topologies. Each processor container or processor in the hierarchy is herein referred to as a node. The processor container device is declared using the hardware identifier (_HID) ACPI0010.</P>
<P CLASS="Body">
<A NAME="pgfId-1461856"></A>To aid support of operating systems which do not parse processor containers, a container can carry a Compatible ID (_CID) of PNP0A05, which represents a generic container device (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc202340663" CLASS="XRef">See Device Class-Specific Objects.</A>)</P>
<P CLASS="Body">
<A NAME="pgfId-1461857"></A>A processor container declaration must supply a _UID method returning an ID that is unique in the processor container hierarchy. A processor container must contain either other processor containers or other processor devices declared within its scope. In addition, a processor container may also contain the following methods in its scope:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1468967"></A>Processor Container Device Objects</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1461862"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1461864"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461866"></A>_LPI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461868"></A>Declares local power states for the hierarchy node represented by the processor container</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461870"></A>_RDI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461872"></A>Declares power resource dependencies that affect system level power states</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461874"></A>_STA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461876"></A>Determines the status of a processor container. See <A HREF="ACPI_Software_Programming_Model.htm#_Toc202340663" CLASS="XRef">See Device Class-Specific Objects.</A></P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1461880"></A><EM CLASS="SC-13-266245">
_LPI may be present under a processor device, and is described in <A HREF="Processor_Configuration_and_Control.htm#66957" CLASS="XRef">See _LPI (Low Power Idle States).</A> _RDI can only be present under a singular top level processor container object, and is described below.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1461881"></A><EM CLASS="SC-13-266245">
ACPI allows the definition of more than one root level processor container. In other words, it is possible to define multiple top level containers.  For example, in a NUMA system if there are no idle states or other objects that need to be encapsulated at the system level, multiple NUMA-node level processor containers may be defined at the top level of the hierarchy.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1461882"></A><EM CLASS="SC-13-266245">
Processor Container Device objects are only valid for implementations conforming to ACPI 6.0 or higher. A platform can ascertain whether an operating system supports parsing of processor container objects via the _OSC method (see </EM>
<A HREF="Device_Configuration.htm#73116" CLASS="XRef">See Platform-Wide OSPM Capabilities.</A><EM CLASS="SC-13-266245">
).</EM>
</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1460819"></A><A NAME="44700"></A>Lower Power Idle States</H6>
<P CLASS="Body">
<A NAME="pgfId-1460820"></A>ACPI 6.0 introduces Lower Power Idle states (LPI). This extends the specification to allow expression of idle states that, like C-states, are selected by the OSPM when a processor goes idle, but which may affect more than one processor, and may affect other system components. LPI extensions in the specification leverage the processor container device, and in this way can express which parts of the system are affected by a given LPI state. </P>
<P CLASS="Body">
<A NAME="pgfId-1460821"></A>LPI states are defined via the following objects:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1460822"></A>_LPI objects define the states themselves, and may be declared inside a processor or a processor container device</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1460823"></A>_RDI allows expressing constraints on LPI usage borne out of device usage</LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1459837"></A>Hierarchical Idle States</H6>
<P CLASS="Body">
<A NAME="pgfId-1459838"></A><EM CLASS="SC-13-266245">
Processor containers (<A HREF="Processor_Configuration_and_Control.htm#73999" CLASS="XRef">See Processor Container Device .</A>) can be used in conjunction with _LPI (<A HREF="Processor_Configuration_and_Control.htm#66957" CLASS="XRef">See _LPI (Low Power Idle States).</A>) to describe idle states in a hierarchical manner. Within the processor hierarchy, each node has low power states that are specific to that node. ACPI refers to states that are specific to a node in the hierarchy as Local Power States. For example in the system depicted in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A>, the local power states of CPU0 are clock gate, retention and power down.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1459843"></A><EM CLASS="SC-13-266245">
When the OS running on a given processor detects there is no more work to schedule on that processor, it needs to select an idle state. The state may affect more than just that processor. A processor going idle could be the last one in the system, or in a processor container, and therefore may select a power state what affects multiple processors. In order to select such a state, the OS needs to choose a local power state for each affected level in the processor hierarchy.</EM>
</P>
<P CLASS="Normal">
<A NAME="pgfId-1459847"></A><IMG SRC="Processor_Configuration_and_Control-8.gif" ALIGN="BASELINE" ALT="">
</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1459850"></A><A NAME="30957"></A>Power states for processor hierarchy</H6>
<P CLASS="Body">
<A NAME="pgfId-1459854"></A><EM CLASS="SC-13-266245">
Consider a situation where Core 0 is the last active core depicted in the example system, <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A>. It may put the system into the lowest possible idle state. To do so, the OS chooses local state 3 (Power Down) for Core0, local state 3 (Power Down) for Cluster0, and local state 1 (Power Down) for the system. However, most HW architectures only support a single power state request from the OS to the platform. That is, it is not possible to make a separate local power state request per hierarchy node to the platform. Therefore, the OS must combine the per level local power states into a single Composite power state. The platform then acts on the Composite power state request. </EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1459855"></A><EM CLASS="SC-13-266245">
A platform can only support a limited set of Composite power states, and not every combination of Local Power states across levels is valid. The valid power states in our example system are depicted in the following table:</EM>
</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1459860"></A><A NAME="88997"></A>Valid Local State Combinations in Figure 2 example system</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1462909"></A>System Level Processor Container</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1462911"></A>Cluster level Processor Container </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1462913"></A>Processor </P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459869"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459871"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459873"></A>Clock Gated</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459875"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459877"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459879"></A>Retention</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459881"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459883"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459885"></A>Power Down</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459887"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459889"></A>Clock Gated</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459891"></A>Clock Gated</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459893"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459895"></A>Clock Gated</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459897"></A>Retention</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459899"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459901"></A>Clock Gated</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459903"></A>Power Down</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459905"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459907"></A>Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459909"></A>Retention</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459911"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459913"></A>Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459915"></A>Power Down</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459917"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459919"></A>Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459921"></A>Power Down</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459923"></A>Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459925"></A>Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459927"></A>Power Down</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1459931"></A><A NAME="99319"></A>Idle State Coordination</H6>
<P CLASS="Body">
<A NAME="pgfId-1459932"></A><EM CLASS="SC-13-266245">
With hierarchical idle states, multiple processors affect the idle state for any non-leaf hierarchy node. Taking our example system in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A>, for cluster 0 to enter a low power state, both Core 0 and Core 1 must be idle. In addition, the power state selection done for Core 0 and Core 1 as they go idle has bearing on the state that can be used for Cluster 0. This requires coordination of idle state requests between the two processors. ACPI supports two different coordination schemes (detailed in subsections following): </EM>
</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1465611"></A><EM CLASS="SC-13-266245">
Platform coordinated </EM>
</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1465622"></A><EM CLASS="SC-13-266245">
OS initiated.</EM>
</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1459817"></A>The OS and the platform can handshake on support for OS Initiated Idle or Platform Coordinated Idle using the _OSC method as described in <A HREF="Device_Configuration.htm#73116" CLASS="XRef">See Platform-Wide OSPM Capabilities.</A>. Note that an Architecture specific command may be required to enter OS Initiated mode, in which case please refer to architecture specific documentation. (For PSCI documentation see <EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
 under the heading &#8220;PCSI Specification&#8221;; for ARM FFH documentation, see <EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
 under the heading &#8220;ARM FFH Specification&#8221;.)</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1459936"></A>Platform Coordinated</H6>
<P CLASS="Body">
<A NAME="pgfId-1459937"></A>With the Platform Coordinated scheme, the platform is responsible for coordination of idle states across processors. OSPM makes a request for all levels of hierarchy from each processor meaning that each processor makes a vote by requesting a local power state for itself, its parent, its parent&#8217;s parent, etc. (In some cases, the vote for a particular hierarchy level may be implicit - see the autopromotion discussion below for more details). When choosing idle states at higher levels, the OSPM on a processor may opt to keep a higher level node in a running state - this is still a vote for that node which the platform must respect. The vote expressed by the OSPM sets out the constraints on the local power state that the platform may choose for processor, and any parent nodes affected by the vote. In particular the vote expresses that the platform must not enter:</P>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1459938"></A>A deeper (lower power) local state than the requested one.</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1459939"></A>A local power state with a higher wake up latency than the requested one.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1459940"></A>A local power state with power resource dependencies that the requested state does not have. </LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1459941"></A>The platform looks across the votes for each hierarchy node from all underlying cores and chooses the deepest local state which satisfies all of the constraints associated with all of the votes. Normally, this just means taking the shallowest state that one of the cores voted for, since shallower states have lower wakeup latencies, lower minimum residencies, and fewer power resource dependencies. However, this may not always be the true, as state depth and latencies do not always increase together. For the sake of efficiency, the platform should generally not enter a power state with a higher minimum residency than the requested one. However, this is not a strict functional requirement. The platform may resolve to a state with higher minimum residency if it believes that is the most efficient choice based on the specific states and circumstances.</P>
<P CLASS="Body">
<A NAME="pgfId-1459945"></A>Using the above example in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A><EM CLASS="SC-13-266245">
, </EM>
a simple flow would look like this:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1459946"></A>Core0 goes idle - OS requests Core0 Power Down, Cluster0 Retention</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1459947"></A>Platform receives Core0 requests - place Core0 in the  Power Down state</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1459948"></A>Core1 goes idle - OS requests Core1 Power Down, Cluster0 Power Down</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1459949"></A>Platform receives Core1 request - puts Core1 in the Power Down state, and takes shallowest vote for Cluster0, thus placing it into the Retention state</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1459951"></A>If the OSPM wanted to request power states beyond the cluster level, then Core0 and Core1 would both vote for an idle state at System level too, and the platform would resolve the final state selection across their votes and votes from any other processors under the System hierarchy via the method described above.</P>
<P CLASS="Body">
<A NAME="pgfId-1459952"></A>As mentioned above, certain platforms support a mechanism called autopromotion where the votes for higher level states may be implicit rather than explicit. In this scheme, the platform provides OSPM with commands to request idle states at a lower level of the processor hierarchy which automatically imply a specific idle state request at the respective higher level of the hierarchy.  There is no command to explicitly request entry into the higher level state, only the implicit request based on the lower level state.</P>
<P CLASS="Body">
<A NAME="pgfId-1459953"></A>For example, if the platform illustrated in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A> uses autopromotion for the Cluster0 Clock Gated state, neither Core0 nor Core1 can explicitly request it. However, a core level Clock Gate request from either Core0 or Core1 would imply a Cluster0 Clock Gate request. Therefore, if both cores request core clock gating (or deeper), Cluster0 will be clock gated automatically by the platform. Additional details on how autopromotion is supported by ACPI can be found in <A HREF="Processor_Configuration_and_Control.htm#90925" CLASS="XRef">See <EM CLASS="SC-13-266245">
Entry Method and Composition</EM>
.</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1459955"></A>OS Initiated</H6>
<P CLASS="Body">
<A NAME="pgfId-1459956"></A>In the OS Initiated coordination scheme, OSPM only requests an idle state for a particular hierarchy node when the last underlying processor goes to sleep. Obviously a processor always selects an idle state for itself, but idle states for higher level hierarchy nodes like clusters are only selected when the last processor in the cluster goes idle. The platform only considers the most recent request for a particular node when deciding on its idle state. </P>
<P CLASS="Body">
<A NAME="pgfId-1459957"></A>The main motivations for OS Initiated coordination are:</P>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1459958"></A>Avoid overhead of OSPM evaluating selection for higher level idle states which will not be used since other processors are still awake</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1459959"></A>Allow OSPM to make higher level idle state selections based on the latest information by taking only the most recent request for a particular node and ignoring requests from processors which went to sleep in the past (and may have been based on information which is now stale)</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1459963"></A>Using the above example in<EM CLASS="SC-13-266245">
 </EM>
a simple flow would look like this:</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1465243"></A>Step</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465247"></A>OS View of power states</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465249"></A>Platform view of power states</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459974"></A>0: </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459976"></A>Cores 0 and 1 are both awake and running code</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459978"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459979"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459980"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459982"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459983"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459984"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459986"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459988"></A>OS on Core0 requests Core0 PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459990"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459991"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459992"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459994"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459995"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1459996"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1459998"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460000"></A>Platform observes request and places Core0 into power down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460002"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460003"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460004"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460006"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460007"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460008"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460010"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460012"></A>OS on Core1 requests Core1 PowerDown and Cluster0 PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460014"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460015"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460016"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460018"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460019"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460020"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460022"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460024"></A>Platform observes requests for Core1 and Cluster0 and processes them</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460026"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460027"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460028"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460030"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460031"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460032"></A>Cluster0: PowerDown</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1460036"></A>Note that Core1 is making a cluster decision which affects both Core0 and Core1 so OSPM should consider expected sleep duration, wake up latency requirements, device dependencies, etc. for both cores and not just Core1 when requesting the cluster state.</P>
<P CLASS="Body">
<A NAME="pgfId-1460037"></A>The platform is still responsible for ensuring functional correctness. For example, if Core0 wakes back up, the cluster state requested by Core1 in the above example should be exited or the entry into the state should be aborted. OSPM has no responsibility to guarantee that the last core down is also the first core up, or that a core does not wake up just as another is requesting a higher level sleep state.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1460039"></A><A NAME="59068"></A>OS Initiated Request Semantics</H6>
<P CLASS="Body">
<A NAME="pgfId-1460040"></A>With OS Initiated coordination, the ordering of requests from different cores is critically important since the platform acts upon the latest one. If the platform does not process requests in the order the OS intended then it may put the platform into the wrong state. Consider this scenario in our example system in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A>:</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1465223"></A>Step</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465227"></A>OS View of power states</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465229"></A>Platform view of power states</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460054"></A>0: </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460056"></A>Core0 in PowerDown, and Core1 is running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460058"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460059"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460060"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460062"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460063"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460064"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460066"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460068"></A>Core1 goes idle - the OSPM requests Core1 PowerDown  and Cluster0 Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460070"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460071"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460072"></A>Cluster0: Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460074"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460075"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460076"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460078"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460080"></A>Core0 receives an interrupt and wakes up into platform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460082"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460083"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460084"></A>Cluster0: Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460086"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460087"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460088"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460090"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460092"></A>Core0 moves into OSPM and starts processing interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460094"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460095"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460096"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460098"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460099"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460100"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460102"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460104"></A>Core0 goes idle and OSPM request Core0 Power Down, Cluster0 Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460106"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460107"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460108"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460110"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460111"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460112"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460114"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460116"></A>Core0&#8217;s idle request &#8220;passes&#8221; Core1&#8217;s request. Platform puts Core0 to Power Down but ignores cluster request since Core1 is still running </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460118"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460119"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460120"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460122"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460123"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460124"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460126"></A>6 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460128"></A>Core1&#8217;s request is observed by the platform.  Platform puts Core1 to Power Down and Cluster0 to retention.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460130"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460131"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460132"></A><EM CLASS="Bold">
Cluster0: PowerDown!! </EM>
(See Note)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460134"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460135"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460136"></A><EM CLASS="Bold">
Cluster0: Retention!! </EM>
(See Note)</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1466248"></A>Bold text here indicates mismatched states.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1460139"></A>The key issue here is the race condition between the requests from the two cores; there is no guarantee that they reach the platform in the same order the OS made them. It is not expected to be common, but Core0&#8217;s request could &#8220;pass&#8221; Core1&#8217;s for a variety of potential reasons - lower frequency, different cache behavior, handling of some non-OS visible event, etc. This sequence of events results in the platform incorrectly acting on the stale Cluster0 request from Core1 rather than the latest request from Core0. The net result is that Cluster0 is left in the wrong state until the next wakeup.</P>
<P CLASS="Body">
<A NAME="pgfId-1460140"></A>To address such race conditions and ensure that the platform and OS have a consistent view of the request ordering, OS Initiated idle state request semantics are enhanced to include a hierarchical dependency check. When the platform receives a request, it is responsible for checking whether the requesting core is really the last core down in the requested domain and rejecting the request if not. Note that even if OSPM and the platform are behaving correctly, they may not always agree on the state of the system due to various races. For example, the platform may see a core waking up before OSPM, and therefore see that core as running, whilst the OSPM still sees it as sleeping. The platform can start treating a particular core as being in a low power state, for the sake of the dependency check, once it has seen the core&#8217;s request (so that it can be correctly ordered versus other OS requests). The platform must start treating a core as running before returning control to the OS after it wakes up from an idle state. </P>
<P CLASS="Normal">
<A NAME="pgfId-1460141"></A>With this dependency check, the above example would change as follows: </P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1465167"></A>Step</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465171"></A>OS View of power states</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465173"></A>Platform view of power states</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460152"></A>0-4: </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460154"></A>Same as above</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460156"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460157"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460158"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460160"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460161"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460162"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460164"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460166"></A>Core0&#8217;s idle request &#8220;passes&#8221; Core1&#8217;s request. Platform rejects Core0&#8217;s request since it includes Cluster0 but Core1 is still awake. </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460168"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460169"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460170"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460172"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460173"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460174"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460176"></A>6 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460178"></A>Core1&#8217;s request is observed by the platform.  Platform rejects Core1&#8217;s request since it includes Cluster0 but Core0 is still awake.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460180"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460181"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460182"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460184"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460185"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460186"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460188"></A>7 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460190"></A>OS resumes on Core0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460192"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460193"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460194"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460196"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460197"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460198"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460200"></A>8 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460202"></A>OS resumes on Core1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460204"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460205"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460206"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460208"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460209"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460210"></A>Cluster0: Running</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1460215"></A>Once control is returned to the OS, it can handle as it sees fit - likely just re-evaluating the idle state on both cores. When requests are received out of order, some overhead is introduced by rejecting the command and forcing the OS to re-evaluate, but this is expected to be rare. Requests sent by the OS should be seen by the platform in the same order the vast majority of the time, and in this case, the idle command will proceed as normal.</P>
<P CLASS="Body">
<A NAME="pgfId-1460216"></A>It is possible that the OS may choose to keep a particular hierarchy node running even if all CPUs underneath it are asleep. This gives rise to another potential corner case - see below. </P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1465151"></A>Step</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465155"></A>OS View of power states</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465157"></A>Platform view of power states</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460228"></A>0: </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460230"></A>Core0 in PowerDown, and Core1 is running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460232"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460233"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460234"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460236"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460237"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460238"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460240"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460242"></A>Core1 goes idle - the OSPM OS requests Core1 PowerDown  and Cluster0 Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460244"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460245"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460246"></A>Cluster0: Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460248"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460249"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460250"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460252"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460254"></A>Core0 receives an interrupt and wakes up into platform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460256"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460257"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460258"></A>Cluster0: Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460260"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460261"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460262"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460264"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460266"></A>Core0 moves into OSPM and starts processing interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460268"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460269"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460270"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460272"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460273"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460274"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460276"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460278"></A>Core0 goes idle and OSPM request Core0 Power Down and requests Cluster0 to stay running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460280"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460281"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460282"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460284"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460285"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460286"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460288"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460290"></A>Core0&#8217;s idle request &#8220;passes&#8221; Core1&#8217;s request. Platform puts Core0 to PowerDown.  </P>
<P CLASS="TableBody">
<A NAME="pgfId-1460291"></A>Even though the OS made a request for the cluster to run, Platform does not know to reject Core0&#8217;s request since it doesn&#8217;t include a Cluster idle state </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460293"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460294"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460295"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460297"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460298"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460299"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460301"></A>6 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460303"></A>Core1&#8217;s request is observed by the platform.  Platform puts Core1 to Power Down and Cluster0 to retention.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460305"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460306"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460307"></A><EM CLASS="Bold">
Cluster0: Running!! </EM>
(See Note, below)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460309"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460310"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460311"></A><EM CLASS="Bold">
Cluster0: Retention!!</EM>
(See Note, below)</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1466356"></A>Bold text here indicates mismatched states.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1460314"></A>The fundamental issue is that the platform cannot infer what hierarchy level a request is for, based on what levels are being placed into a low power mode. To mitigate this, each idle state command must include a hierarchy parameter specifying the highest level hierarchy node for which the OS is making a request in addition to the normal idle state identifier. Even if the OS does not want some higher level hierarchy node to enter an idle state, it should indicate if the core is the last core down for that node. This allows the platform to understand the OS&#8217;s view of the state of the hierarchy and ensure ordering of requests even if the OS requests a particular node to stay running.</P>
<P CLASS="Body">
<A NAME="pgfId-1460315"></A>This enhancement is illustrated in this example: </P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1465183"></A>Step</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465187"></A>OS View of power states</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465189"></A>Platform view of power states</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460327"></A>0: </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460329"></A>Core0 in PowerDown, and Core1 is running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460331"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460332"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460333"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460335"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460336"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460337"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460339"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460341"></A>Core1 goes idle - the OSPM OS requests Core1 PowerDown  and Cluster0 Retention and identifies itself as last down in Cluster0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460343"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460344"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460345"></A>Cluster0: Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460347"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460348"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460349"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460351"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460353"></A>Core0 receives an interrupt and wakes up into platform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460355"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460356"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460357"></A>Cluster0: Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460359"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460360"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460361"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460363"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460365"></A>Core0 moves into OSPM and starts processing interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460367"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460368"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460369"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460371"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460372"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460373"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460375"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460377"></A>Core0 goes idle and OSPM request Core0 Power Down and requests Cluster0 to stay running and identifies itself as last down in Cluster0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460379"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460380"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460381"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460383"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460384"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460385"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460387"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460389"></A>Core0&#8217;s idle request &#8220;passes&#8221; Core1&#8217;s request. Platform rejects Core0&#8217;s request since it is a request for Cluster0 but Core1 is still awake. </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460391"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460392"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460393"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460395"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460396"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460397"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460399"></A>6 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460401"></A>Core1&#8217;s request is observed by the platform.  Platform rejects Core1&#8217;s request since it is a request for Cluster0 but Core0 is still awake.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460403"></A>Core0: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460404"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460405"></A>Cluster0: PowerDown</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460407"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460408"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460409"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460411"></A>7 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460413"></A>OS resumes on Core0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460415"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460416"></A>Core1: PowerDown</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460417"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460419"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460420"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460421"></A>Cluster0: Running</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460423"></A>8 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460425"></A>OS resumes on Core1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460427"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460428"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460429"></A>Cluster0: Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460431"></A>Core0: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460432"></A>Core1: Running</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460433"></A>Cluster0: Running</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1466889"></A>As before, once control is returned to the OS, it can handle as it sees fit - likely just re-requesting the idle state on both cores. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1460824"></A><A NAME="66957"></A>_LPI (Low Power Idle States)</H6>
<P CLASS="Body">
<A NAME="pgfId-1460825"></A>_LPI is an optional object that provides a method to describe Low Power Idle states that defines the local power states for each node in a hierarchical processor topology. The OSPM uses the _LPI object to select a local power state for each level of processor hierarchy in the system. These local state selections are then used to produce a composite power state request that is presented to the platform by the OSPM.</P>
<P CLASS="Body">
<A NAME="pgfId-1460826"></A>This object may be used inside a Processor Container or a processor declaration. _LPI takes the following format:</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1460827"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1460828"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1460829"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1460830"></A><EM CLASS="SC-13-266245">
A variable-length Package containing the local power states for the parent Processor or Processor Container device as described in the table following below. _LPI evaluation returns the below format: </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460831"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460832"></A>        Revision,  // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460833"></A>        LevelID,   // Integer (QWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460834"></A>        Count,     // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460835"></A>        LPI[1],    // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460836"></A>        ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460837"></A>        LPI[N]     // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460838"></A>        }</P>
<P CLASS="Normal">
<A NAME="pgfId-1460877"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1460842"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1460844"></A>Object Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1460846"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460848"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460850"></A>Integer (WORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460852"></A>The revision number of the _LPI object. Current revision is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460854"></A>LevelID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460856"></A>Integer (QWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460858"></A>A platform defined number that identifies the level of hierarchy of the processor node to which the LPI states apply. This is used in composition of IDs for OS Initiated states described in <A HREF="Processor_Configuration_and_Control.htm#90925" CLASS="XRef">See <EM CLASS="SC-13-266245">
Entry Method and Composition</EM>
.</A>. In a platform that only supports platform coordinated mode, this field must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460860"></A>Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460862"></A>Integer (WORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460864"></A>The count of following LPI packages.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460866"></A>LPI[1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460868"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460870"></A>A Package containing the definition of LPI state 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460872"></A>LPI[N]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460874"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460876"></A>A Package containing the definition of LPI state N.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1460880"></A><EM CLASS="SC-13-266245">
Each LPI sub-Package contains the elements described below: </EM>
	</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460881"></A>Package() { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460882"></A>        Min Residency,               // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460883"></A>        Worst case wakeup latency,   // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460884"></A>        Flags,                       // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460885"></A>        Arch. Context Lost Flags,    // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460886"></A>        Residency Counter Frequency, // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460887"></A>        Enabled Parent State,        // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460888"></A>        Entry Method, 	               // Buffer (ResourceDescriptor) or</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460889"></A>                                     // Integer (QWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460890"></A>        Residency Counter Register   // Buffer (ResourceDescriptor)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460891"></A>        Usage Counter Register       // Buffer (ResourceDescriptor) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460892"></A>        State Name                   // String (ASCIIZ)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1460893"></A>        }  </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1460894"></A>Extended LPI fields</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465197"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465199"></A>Object Type </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1465201"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460903"></A><EM CLASS="SC-13-266245">
 Min Residency</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460905"></A><EM CLASS="SC-13-266245">
Integer (DWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460907"></A><EM CLASS="SC-13-266245">
Minimum Residency - time in microseconds after which a state becomes more energy efficient than any shallower state. See <A HREF="Processor_Configuration_and_Control.htm#10834" CLASS="XRef">See <EM CLASS="SC-13-266245">
Power, Minimum Residency, and Worst Case Wakeup Latency</EM>
.</A>.</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460909"></A><EM CLASS="SC-13-266245">
Worst case wakeup latency</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460911"></A><EM CLASS="SC-13-266245">
Integer (DWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460913"></A><EM CLASS="SC-13-266245">
Worst case time in microseconds from a wake interrupt being asserted to the return to a running state of the owning hierarchy node (processor or processor container). See <A HREF="Processor_Configuration_and_Control.htm#10834" CLASS="XRef">See <EM CLASS="SC-13-266245">
Power, Minimum Residency, and Worst Case Wakeup Latency</EM>
.</A>.</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460915"></A><EM CLASS="SC-13-266245">
Flags</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460917"></A><EM CLASS="SC-13-266245">
Integer</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460918"></A><EM CLASS="SC-13-266245">
(DWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460920"></A><EM CLASS="SC-13-266245">
Valid flags are described in <A HREF="Processor_Configuration_and_Control.htm#43617" CLASS="XRef">See Flags for LPI states.</A></EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460922"></A><EM CLASS="SC-13-266245">
Arch. Context Lost Flags</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460924"></A><EM CLASS="SC-13-266245">
Integer</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460925"></A><EM CLASS="SC-13-266245">
(DWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460927"></A><EM CLASS="SC-13-266245">
Architecture specific context loss flags. These flags may be used by a processor architecture to indicate processor context that may be lost by the power state and must be handled by OSPM. See <A HREF="Processor_Configuration_and_Control.htm#38071" CLASS="XRef">See Architecture Specific Context Loss Flags .</A> &#8220;Architecture Specific Context Loss Flags&#8221; for more detail.</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460929"></A><EM CLASS="SC-13-266245">
Residency Counter Frequency </EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460931"></A><EM CLASS="SC-13-266245">
Integer</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460932"></A><EM CLASS="SC-13-266245">
(DWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460934"></A><EM CLASS="SC-13-266245">
Residency counter frequency in cycles-per-second (Hz). Value 0 indicates that counter runs at an architectural-specific frequency.</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460935"></A><EM CLASS="SC-13-266245">
Valid only if a Residency Counter Register is defined.</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460937"></A><EM CLASS="SC-13-266245">
Enabled Parent State</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460939"></A><EM CLASS="SC-13-266245">
Integer</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460940"></A><EM CLASS="SC-13-266245">
(DWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460942"></A><EM CLASS="SC-13-266245">
Every shallower power state in the parent is also enabled. 0 implies that no local idle states may be entered at the parent node.</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460945"></A><EM CLASS="SC-13-266245">
Entry Method</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460947"></A><EM CLASS="SC-13-266245">
Buffer or Integer (QWORD)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460949"></A><EM CLASS="SC-13-266245">
This may contain a resource descriptor or an integer</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460950"></A><EM CLASS="SC-13-266245">
A Resource Descriptor with a single Register() descriptor may be used to describe the register that must be read in order to enter the power state. </EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460951"></A><EM CLASS="SC-13-266245">
Alternatively, an integer may be provided in which case the integer would be used in composing the final Register Value that must be used to enter this state. This composition process is described below in <A HREF="Processor_Configuration_and_Control.htm#90925" CLASS="XRef">See <EM CLASS="SC-13-266245">
Entry Method and Composition</EM>
.</A> &#8220;Entry Method and Composition&#8221;</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460953"></A><EM CLASS="SC-13-266245">
Residency Counter Register</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460955"></A><EM CLASS="SC-13-266245">
Buffer</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460957"></A><EM CLASS="SC-13-266245">
Optional residency counter register which provides the amount of time the owning hierarchy node has been in this local power state. The time is provided in a frequency denoted by the Residency counter frequency field (see above). The register is optional. If the platform does not support it, then the following NULL register descriptor should be used:</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460958"></A><EM CLASS="SC-13-266245">
ResourceTemplate() {Register {(SystemMemory, 0, 0, 0, 0)}} </EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460960"></A><EM CLASS="SC-13-266245">
Usage Counter Register</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460962"></A><EM CLASS="SC-13-266245">
Buffer</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460964"></A><EM CLASS="SC-13-266245">
Optional register that provides the number of times the owning hierarchy node has been in this local power state. If the platform does not support this register, then the following NULL register descriptor should be used:</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460965"></A><EM CLASS="SC-13-266245">
ResourceTemplate() {Register {(SystemMemory, 0, 0, 0, 0)}} </EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460967"></A><EM CLASS="SC-13-266245">
State Name</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460969"></A><EM CLASS="SC-13-266245">
String (ASCIIZ)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460971"></A><EM CLASS="SC-13-266245">
String containing a human-readable identifier of this LPI state. This element is optional and an empty string (a null character) should be used if this is not supported.</EM>
</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1460976"></A><A NAME="43617"></A>Flags for LPI states</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1460979"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1460981"></A>Bits </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1460983"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460985"></A><EM CLASS="SC-13-266245">
Enabled </EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460987"></A><EM CLASS="SC-13-266245">
0</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1460989"></A><EM CLASS="SC-13-266245">
1 if the power state is enabled for use</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1460990"></A><EM CLASS="SC-13-266245">
0 if the power state is disabled</EM>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1460994"></A>It is not required that all processors or processor containers include _LPI objects. However, if a processor container includes an _LPI object, then all children processors or processor containers must have _LPI objects. </P>
<P CLASS="Body">
<A NAME="pgfId-1460995"></A>The following sections describe the more complex properties of LPI in more detail, as well as rules governing wakeup for LPI states.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1460996"></A><EM CLASS="SC-13-266245">
Disabling a State</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1460997"></A>When a local state is disabled by clearing the Enabled bit in the Flags field, any deeper states for that node are <EM CLASS="Italic">
not</EM>
 renumbered. This allows other properties which rely on indexing into the state list for that node (Enabled Parent State for example) to not change.</P>
<P CLASS="Body">
<A NAME="pgfId-1469831"></A>Disabled states should not be requested by the OS and values returned by Residency/Usage Counter Registers are undefined.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1460998"></A><EM CLASS="SC-13-266245">
Enabled Parent State</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1460999"></A>As mentioned above, LPI represent local states, which must be combined into a composite state. However not every combination is possible. Consider the example system described in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A>. In this system it would not be possible to simultaneously select clock gating as local state for Core0 and power down as local state for Cluster0. As Core0 is physically in Cluster0, power gating the cluster would imply power gating the core. The correct combinations of local states for this example system are described in <A HREF="Processor_Configuration_and_Control.htm#88997" CLASS="XRef">See Valid Local State Combinations in Figure 2 example system.</A>. LPI states support enumeration of the correct combinations through the Enabled Parent State (EPS) property. </P>
<P CLASS="Body">
<A NAME="pgfId-1465911"></A>LPI States are 1-indexed. Much like C and S states, LPI0 is considered to be a running state. For a given LPI, the EPS is a 1 based index into the processor containers&#8217; _LPI states. The index points at the deepest local power state of the parent processor that the given LPI state enables. Every shallower power state in the parent is also enabled. Taking the system described in <A HREF="Processor_Configuration_and_Control.htm#30957" CLASS="XRef">See Power states for processor hierarchy.</A>, the states and EPS value for the states is described in <A HREF="Processor_Configuration_and_Control.htm#98280" CLASS="XRef">See Enabled Parent State values for example system.</A>.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1461009"></A><A NAME="98280"></A>Enabled Parent State values for example system</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1461012"></A>System Level Processor Container LPI States</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1461016"></A>Enabled Parent State</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461018"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461020"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461022"></A>N/A</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461024"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461026"></A>Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461028"></A>0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="3">
<P CLASS="TableHeading">
<A NAME="pgfId-1461030"></A>Cluster Level Processor Container LPI States</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461036"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461038"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461040"></A>N/A</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461042"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461044"></A>Clock Gating</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461046"></A>0 - System must be running if cluster is clock gated</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461048"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461050"></A>Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461052"></A>0 - System must be running if cluster is in retention</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461054"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461056"></A>Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461058"></A>1 - System may be in power down if cluster is in power down</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="3">
<P CLASS="TableHeading">
<A NAME="pgfId-1461060"></A>Core Level Processor Container LPI States</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461066"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461068"></A>Running</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461070"></A>N/A</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461072"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461074"></A>Clock Gating</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461076"></A>1 - Cluster may be clock gated or running of core is clock gated</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461078"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461080"></A>Retention</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461082"></A>2 - Cluster may running, or clock gated, or in retention if core is in retention</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461084"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461086"></A>Power Down</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461088"></A>3 - All states at cluster level are supported if the core is powered down</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461092"></A><A NAME="10834"></A><EM CLASS="SC-13-266245">
Power, Minimum Residency, and Worst Case Wakeup Latency</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461093"></A>Power is not included in _LPI since relative power of different states (along with minimum residency to comprehend transition energy), and not absolute power, drive OSPM idle state decisions. To correctly convey relative power, local states in _LPI must be declared in power consumption order. That is, the local states for a particular hierarchy node must be listed from highest power (shallowest) to lowest power (deepest).</P>
<P CLASS="Body">
<A NAME="pgfId-1461094"></A>The worst case wakeup latency (WCWL) for a particular local state is the longest time from when a wake interrupt is asserted, to when the hierarchy node can return to execution. Generally, the WCWL will be the idle state&#8217;s exit latency plus some portion of its entry latency. How much of the entry flow is included depends on where (and if) the platform supports checking for pending wake events and aborting the idle state entry. For any given power state there will be a &#8220;point of no return&#8221; after which the entry into the power state cannot be reversed. This is illustrated in <A HREF="Processor_Configuration_and_Control.htm#62361" CLASS="XRef">See <EM CLASS="SC-13-266245">
Worst case wake latency</EM>
.</A> below. The WCWL must include the time period from the point of no return to the time at which a wake up interrupt can be handled.</P>
<P CLASS="Normal">
<A NAME="pgfId-1461101"></A><IMG SRC="Processor_Configuration_and_Control-9.gif" ALIGN="BASELINE" ALT="">
</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1461106"></A><EM CLASS="SC-13-266245">
Worst case wake latency</EM>
<A NAME="62361"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1461109"></A>Note that other worst case paths could end up determining the WCWL, but what is described above is expected to be the most common. For example, there could be another period between the OS making the idle request and the point of no return where the platform does not check for wake up events, and which is longer than the time taken to enter and exit the power state. In that case that period would become the worst case wakeup latency.</P>
<P CLASS="Normal">
<A NAME="pgfId-1461113"></A><IMG SRC="Processor_Configuration_and_Control-10.gif" ALIGN="BASELINE" ALT="">
</P>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1461118"></A><A NAME="53745"></A>Energy of states A,B and C versus sleep duration<EM CLASS="SC-13-266245">
</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461119"></A>Minimum residency (MR) is the time after which a state becomes more energy efficient than any shallower state. This parameter answers the fundamental question: how long does the hierarchy node need to stay in the idle state to overcome the energy cost of transitioning in/out, and make choosing that state a net win relative to shallower alternatives? Note that this also includes comparing against not entering an idle state and keeping the node running. This is illustrated in <A HREF="Processor_Configuration_and_Control.htm#53745" CLASS="XRef">See Energy of states A,B and C versus sleep duration<EM CLASS="SC-13-266245">
</EM>
.</A> which shows the energy associated with three different state choices as a function of the sleep duration. Note that State A&#8217;s MR relative to keeping the node running is not pictured.</P>
<P CLASS="Body">
<A NAME="pgfId-1461123"></A>Generally minimum residency and worst case wakeup latency will be larger for deeper states, however this may not always be the case. Taking a different example to the above, consider two system level states, StateY and StateZ, with similar entry overhead but where StateZ saves more power than StateY. An abstract state list might look like:<BR>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461124"></A>	StateX: MR = 100 us</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461125"></A>	StateY: MR = 1000 us</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461126"></A>	StateZ: MR = 800 us, power resource A must be OFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461127"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1461128"></A><EM CLASS="SC-13-266245">
F</EM>
rom an energy perspective, StateZ is always preferred, but in this example, StateZ is only available when certain device dependencies are met. This makes StateY attractive when the dependencies cannot be met. Despite being the deeper (lower power) state, StateZ has a lower MR than StateY since the entry overheads are similar and StateZ&#8217;s lower power more quickly amortizes the transition cost. Although the crossover, which sets MR, should generally be versus the next shallowest state, MR is defined relative to any shallower (higher power) state to deal with cases like this. In this case, StateZ&#8217;s MR is set by the crossover with StateX since StateZ (if allowed based on device dependencies) is always preferred to StateY. To achieve the lowest energy, OSPM must select the deepest (lowest power) state for which all entry constraints are satisfied and should not assume that deeper states are not viable just because a shallower state&#8217;s WCWL/MR threshold was not met.</P>
<P CLASS="Body">
<A NAME="pgfId-1461129"></A>Since WCWL may be used by OSPM to restrict idle state selection and guarantee response times to critical interrupts, it should be set conservatively (erring on the high side) so that OSPM is not surprised with worse than specified interrupt response time. On the other hand, MR helps OSPM make efficient decisions. If MR is inaccurate in a certain scenario and OSPM chooses a state which is deeper or shallower than optimal for a particular idle period, there may be some wasted energy but the system will not be functionally broken. This is not to say that MR doesn&#8217;t matter -energy efficiency is important - just that the platform may choose to optimize MR based on the typical case rather than the worst case.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1461131"></A><EM CLASS="SC-13-266245">
Minimum Residency and Worst Case Wakeup Latency Combination Across Hierarchy Levels</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461133"></A><EM CLASS="SC-13-266245">
</EM>
The WCWL in _LPI is for a particular local state. When evaluating composite state choices versus system latency tolerance as part of idle state selection, OSPM will add wakeup latencies across hierarchy levels. For example, if a system has core powerdown with WCWL = 50 us and cluster powerdown with WCWL = 20 us then the core powerdown + cluster powerdown composite state latency is calculated as 70 us.</P>
<P CLASS="Body">
<A NAME="pgfId-1461135"></A>MRs defined in _LPI apply to a particular hierarchy node. The implicit assumption is that each hierarchy node represents an independent power manageable domain and can be considered separately. For example, assume that a cluster retention state is legal if the underlying cores are in core powerdown or core retention. The MR for cluster retention is based on the energy cost of taking shared logic outside of the cores in and out of retention versus the steady state power savings achieved in that shared logic while in that state. The key is that the specific state chosen at the core level does not fundamentally affect the cluster level decision since it is tied to properties of shared logic outside the core. The energy cost of entering/exiting the cluster state and the power savings it provides are independent of whether the core is in retention or powerdown. Based on this, MRs are considered independent per level in ACPI. That is, when comparing MR for different states to expected sleep duration for a particular node, OSPM uses the MRs defined in that node&#8217;s _LPI as is with no adjustment based on states at lower levels of hierarchy (though of course the state must be legal based on the lower level state&#8217;s Enabled Parent State property).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1461136"></A><EM CLASS="SC-13-266245">
Known Limitations with Minimum Residency and Worst Case Wakeup Latency</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461137"></A>Note that the WCWL and MR parameters are not perfect. For example, they do not scale with frequency, voltage, temperature, and various other factors which may affect them. Nor are the rules for how they combine across levels perfect. For example, cluster level MRs may move slightly based on core state choice since the entry latency of the core state will delay entry into the cluster state, derating the expected sleep duration. The cluster level MR can be adjusted to comprehend this, but if multiple core level states with different entry latencies enable the same cluster state, then its MR cannot perfectly comprehend them all. With that said, this set of parameters and combination scheme is believed to strike a good balance between simplicity/usability and accuracy.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461138"></A><EM CLASS="SC-13-266245">
Entry Method and Composition</EM>
<A NAME="90925"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1461139"></A>The OSPM combines Local LPI states to create an overall composite power state. Each LPI state provides an entry method field. These fields, for the selected local power states, are combined to create the entry method register that must be read in order to enter a given composite power state.</P>
<P CLASS="Body">
<A NAME="pgfId-1461140"></A>To derive the appropriate register address from the local states&#8217; entry methods, the following approach is used:</P>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1461141"></A><EM CLASS="SC-13-266245">
Local states for Processors always declare a register based entry method. This provides a base register.</EM>
</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1461142"></A><EM CLASS="SC-13-266245">
Higher levels may use an integer or a register. If an Integer is used, then its value must be added to the base register obtained in step 1. If a register is used, then this becomes the new base register, overriding any previous value. Note that in this case, the selected LPI must imply specific local LPI selections for all lower level nodes.</EM>
</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1461144"></A><EM CLASS="SC-13-266245">
In OS Initiated mode it is also necessary for the OSPM to tell the platform on which hierarchy level the calling processor is the last to go idle. This is done by adding the Level ID property of the hierarchy node&#8217;s LPI to the base register. </EM>
</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1461145"></A><EM CLASS="SC-13-266245">
The basic composition algorithm for entry state is shown in the pseudo-code below for a platform coordinated system:</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461146"></A>Reg = SelectedLocalState(CurrentProcessor).EntryMethod</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461147"></A>WCWL = SelectedLocalState(CurrentProcessor).WCWL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461148"></A>MR = SelectedLocalState(CurrentProcessor).MR</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461149"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461150"></A>for level = Parent(CurrentProcessor) to system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461151"></A>	LocalState = SelectedLocalState(level)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461152"></A>	If LocalState == Run</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461153"></A>		break</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461154"></A>	EM = LocalState.EntryMethod</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461155"></A>	WCWL = WCWL+ LocalState.WCWL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461156"></A>	MR = LocalState.MR</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461157"></A>	If IsInteger(EM) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461158"></A>		Reg.Addr = Reg.Addr+ZeroExtend(EM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461159"></A>	Else</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461160"></A>		// Entry method here overrides any previous method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461161"></A>		Reg = EM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461162"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461163"></A>CompositeState.EntryMethod = Reg</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461164"></A>CompositeState.WCWL=WCWL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461165"></A>CompositeState.MR=MR</P>
<P CLASS="Normal">
<A NAME="pgfId-1461167"></A><EM CLASS="SC-13-266245">
In OS Initiated mode it is also necessary for the OSPM to tell the platform on which hierarchy level the calling processor is the last to go idle and request a power state. To do this, the algorithm above is modified as follows:</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461168"></A><EM CLASS="SC-13-266245">
R</EM>
eg = SelectedLocalState(CurrentProcessor).EntryMethod</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461169"></A>WCWL = SelectedLocalState(CurrentProcessor).WCWL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461170"></A>MR = SelectedLocalState(CurrentProcessor).MR</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461171"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461172"></A>RegDecided = False</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461173"></A>// Retrieve Level Index from Processor&#8217;s _LPI object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461174"></A>LastLevel = GetLevelIDOfLevel(CurrentProcessor) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461175"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461176"></A>for level = Parent(CurrentProcessor) to system </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461177"></A>	LocalState = SelectedLocalState(level)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461178"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461179"></A>	If LocalState == Run</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461180"></A>		break</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461181"></A>	EM = LocalState.EntryMethod</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461182"></A>	WCWL = WCWL+ LocalState.WCWL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461183"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461184"></A>     EM = LocalState.EntryMethod </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1465967"></A>     If IsInteger(EM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461185"></A>		Reg.Addr = Reg.Addr+ZeroExtend(EM)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461186"></A>     Else</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461187"></A>		// Entry method is register</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461188"></A>		Reg = EM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461189"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461190"></A>If IsProcessorLastInLevel(CurrentProcessor,level)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461191"></A>		// If calling processor is last one to go idle in </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461192"></A>             // current level, retrieve Level Index from </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461193"></A>             // the container&#8217;s _LPI object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461194"></A>		LastLevel = GetLevelIDOfLevel(level)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461195"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461196"></A>Reg.Addr = Reg.Addr+LastLevel</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461197"></A>CompositeState.EntryMethod = Reg</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461198"></A>CompositeState.WCWL=WCWL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461199"></A>CompositeState.MR=MR</P>
<P CLASS="Body">
<A NAME="pgfId-1469860"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1461201"></A>In a platform coordinated system, it is possible for an LPI belonging to a hierarchy node above the processor level to use an integer value of zero as its entry method. Since entry method composition is done by addition, this results in the entry command for that state being the same as for a composite state which only includes its children.  An entry value of 0 essentially identifies a state as &#8220;autopromotable.&#8221; This means that the OS does not explicitly request entry into this state, but that the platform can automatically enter it when all children have entered states which allow the parent state based on their EPS properties. OSPM should follow normal composition procedure for other parameters (worst case wakeup latency, minimum residency, etc.) when including composite states involving autopromotable local states.</P>
<P CLASS="Body">
<A NAME="pgfId-1461203"></A>This is described in the following example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461204"></A>Device (SYSM) { // System level states</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1467720"></A>       Name (_HID, &quot;ACPI0010&quot;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1467721"></A>       Name (_UID, 0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1467722"></A>       Name (_LPI, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461205"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461209"></A>                      0, // Version</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461210"></A>                      0, // Level ID</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461211"></A>                      1, // Count</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461212"></A>                      </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461213"></A>                      Package () {    // Power gating state for system</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461214"></A>                              900, // Min residency (uS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461215"></A>                              400, // Wake latency (uS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461216"></A>                              0, // Enabled Parent State</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461217"></A>                              ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461218"></A>                             ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461219"></A>                                  // Register Entry method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461220"></A>                                  Register(FFH,0x20,0x00,0x00000000DECEA5ED,0x3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461221"></A>                              },</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461222"></A>                              ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461223"></A>                      }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461224"></A>            )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461225"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461226"></A>            Device (CLU0) { // Package0 state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1466020"></A>                   Name (_HID, &quot;ACPI0010&quot;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1466021"></A>                   Name (_UID, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1466022"></A>                   Name (_LPI, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461230"></A>                         Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461231"></A>                                   0, // Version</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461232"></A>                                   0, // Level ID</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461233"></A>                                   2, // Count</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461234"></A>                                   Package () { // Retention state for Cluster</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461235"></A>                                             40, // Min residency (uS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461236"></A>                                             20, // Wake latency (uS) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461237"></A>                                             ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461238"></A>                                             0, // System must be running</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461239"></A>                                             0,  //  Integer Entry method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461240"></A>                                             ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461241"></A>                                             },</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461242"></A>                                   Package () { // Power Gating state for Cluster</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461243"></A>                                             100, // Min residency (uS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461244"></A>                                             80, // Wake latency (uS) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461245"></A>                                             ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461246"></A>                                             1, // System may power down</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461247"></A>                                             0x1020000,  //  Integer Entry method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461248"></A>                                             ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461249"></A>                                             }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461250"></A>                                    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461251"></A>                         )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461252"></A>        </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461253"></A>                 Name(PLPI, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461254"></A>                     Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461255"></A>                                  0, // Version</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461256"></A>                                  0, // Level ID</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461257"></A>                                  2, // Count </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461258"></A>                                  Package () { // Retention state for CPU</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461259"></A>                                            40, // Min residency (uS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461260"></A>                                            20, // Wake latency (uS) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461261"></A>                                            ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461262"></A>                                            1, // Parent node can be </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461263"></A>                                               // in retention or running </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461264"></A>                                            ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461265"></A>                                                  // Register Entry method		 </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1463360"></A>                                                  Register(FFH,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461266"></A>                                                             0x20,0x00,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461267"></A>                                                             0x000000000000DEAF,0x3),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461268"></A>                                                  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461269"></A>                                            ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461270"></A>                                            },</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461271"></A>                                 Package () { // Power Gating state for CPU</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461272"></A>                                            100, // Min residency (uS)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461273"></A>                                            80, // Wake latency (uS) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461274"></A>                                            ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461275"></A>                                            2, // Parent node can be in any state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461276"></A>                                            ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461277"></A>                                                  // Register Entry method		</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1463624"></A>                                                  Register(FFH,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461278"></A>                                                             0x20,0x00,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461279"></A>                                                             0x0000000000000DEAD,0x3),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461280"></A>                                                  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461281"></A>                                            ...  // (skipped fields). . .</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461282"></A>                                            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461283"></A>                           }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461284"></A>                    )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461285"></A> </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461286"></A>                   Device (CPU0) { // Core0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461287"></A>                           Name (_HID, &quot;ACPI0007&quot;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461288"></A>                           Method (_LPI, 0, NotSerialized) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461289"></A>                       {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461290"></A>                                 return(PLPI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461291"></A>                       }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461292"></A>                   }                       </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461293"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461294"></A>                   Device (CPU1) { // Core1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461295"></A>                           Name (_HID, &quot;ACPI0007&quot;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461296"></A>                           Method (_LPI, 0, NotSerialized) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461297"></A>                       {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461298"></A>                                 return(PLPI)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461299"></A>                       }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461300"></A>                   }                       </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461301"></A>                      		   </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461302"></A>            }  // end of NOD0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461303"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461304"></A>            Device (CLU1) { // Package1 state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1466105"></A>                   Name (_HID, &quot;ACPI0010&quot;)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1466106"></A>                   Name (_UID, 2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461305"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461307"></A>                ....</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461308"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461309"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461310"></A>} // End of SYM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461311"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1461312"></A>In the example above, the OSPM on CPU0 and CPU1 would be able to select the following composite states:</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1461313"></A>Entry method example</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1464002"></A>Core LPI</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1464004"></A>Cluster LPI</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1464006"></A>System LPI</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1464008"></A>Composite State Entry Method</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461324"></A><EM CLASS="SC-13-266245">
Retention</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461325"></A><EM CLASS="SC-13-266245">
Register: 0xDEAF</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461327"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461329"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461331"></A><EM CLASS="SC-13-266245">
Core Retention</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461332"></A><EM CLASS="SC-13-266245">
Register: 0xDEAF</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461334"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461335"></A><EM CLASS="SC-13-266245">
Register 0xDEAD</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461337"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461339"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461341"></A><EM CLASS="SC-13-266245">
Core Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461342"></A><EM CLASS="SC-13-266245">
Register: 0xDEAD</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461344"></A><EM CLASS="SC-13-266245">
Retention</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461345"></A><EM CLASS="SC-13-266245">
Register: 0xDEAF</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461347"></A><EM CLASS="SC-13-266245">
Retention</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461348"></A><EM CLASS="SC-13-266245">
Integer: 0x0</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461350"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461352"></A><EM CLASS="SC-13-266245">
Core Retain|Cluster Retention</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461353"></A><EM CLASS="SC-13-266245">
Register 0xDEAF+0x0 = 0xDEAF</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461355"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461356"></A><EM CLASS="SC-13-266245">
Register: 0xDEAD</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461358"></A><EM CLASS="SC-13-266245">
Retention</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461359"></A><EM CLASS="SC-13-266245">
Integer: 0x0</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461361"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461365"></A><EM CLASS="SC-13-266245">
Core Power Down|Cluster Retention</EM>
<A NAME="OLE_LINK4"></A><A NAME="OLE_LINK3"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1461366"></A><EM CLASS="SC-13-266245">
Register 0xDEAD+0x1020000 = 0xDEAD</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461368"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461369"></A><EM CLASS="SC-13-266245">
Register: 0xDEAD</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461371"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461372"></A><EM CLASS="SC-13-266245">
Integer: 0x1020000</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461374"></A><EM CLASS="SC-13-266245">
Run</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461376"></A><EM CLASS="SC-13-266245">
Core Power Down|Cluster Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461377"></A><EM CLASS="SC-13-266245">
Register 0xDEAD+0x1020000 = 0x102DEAD</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461379"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461380"></A><EM CLASS="SC-13-266245">
Register: 0xDEAD</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461382"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461383"></A><EM CLASS="SC-13-266245">
Integer: 0x1020000</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461385"></A><EM CLASS="SC-13-266245">
Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461386"></A><EM CLASS="SC-13-266245">
Register : 0xDECEA5ED</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461388"></A><EM CLASS="SC-13-266245">
System Power Down</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1461389"></A><EM CLASS="SC-13-266245">
Register 0xDECEA5ED</EM>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1461393"></A>As can be seen in the example, the cluster level retention state defines the integer value of 0 as its entry method. By virtue of composition, this means that the entry methods for the composite states Core Power Down and Core Power Down|Cluster Retention are the same (FFH register 0xDEAD). Similarly the composite states for Core Retention and Core Retention|Cluster Retention are the same (FFH register 0xDEAF). Consequently, if both CPU0 and CPU1 are in either Power Down or Power Retention, then the platform may enter cluster CLU0 into Retention.</P>
<P CLASS="Body">
<A NAME="pgfId-1461394"></A>The example also shows how a register based entry method at a high level overrides entry method definitions of lower levels. As pointed above this is only possible if the selected LPI implies specific LPIs at all lower levels. In this example the System Power Down LPI, entered through FFH register 0xDECEA5ED, implies Power Down LPIs at core and cluster level since based on EPS, no other core/cluster local states could enable System Power Down.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461395"></A><A NAME="38071"></A>Architecture Specific Context Loss Flags </H6>
<P CLASS="Body">
<A NAME="pgfId-1461396"></A>For Intel based systems the value of this flags register is 0.</P>
<P CLASS="Body">
<A NAME="pgfId-1461397"></A>For ARM based systems please refer to links to ACPI-Related Documents (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;ARM FFH Specification&#8221;. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461398"></A><EM CLASS="Bold">
Residency and Entry Counter Registers</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461399"></A>LPI state descriptions may optionally provide Residency and Usage Count registers to allow the OSPM to gather statistics about the platform usage of a given local state. Both registers provide running counts of their respective statistics. To measure a statistic over some time window, OSPM should sample at the beginning and end and calculate the delta. Whether the counters restart from 0 on various flavors of reset/S-state exit is implementation defined so OSPM should resynchronize its baseline on any reset or Sx exit.</P>
<P CLASS="Body">
<A NAME="pgfId-1461400"></A>The registers are optional, and if the feature is not present the platform must use a NULL register of the following form:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461401"></A><EM CLASS="SC-13-266245">
		ResourceTemplate() {Register {(SystemMemory, 0, 0, 0, 0)}}</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1461403"></A>The Usage Count register counts how many times the local state has been used.  Whether it counts entries or exits is implementation defined.</P>
<P CLASS="Body">
<A NAME="pgfId-1461404"></A>The Residency register counts how long the hierarchy node has been in the given LPI state, at a rate given by LPI&#8217;s Residency Counter Frequency field. A frequency of 0 indicates that the counter runs at an architecture-specific frequency. Whether the Residency counter runs continuously while in a local state or updates only on exit is implementation defined.  If OSPM wants to guarantee that the reading for a particular state is current, it should read from that processor itself (or one of the underlying child processors in the case of a higher level idle state).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461405"></A><EM CLASS="SC-13-266245">
Wake from LPI States</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461406"></A>With _LPI, the platform can describe deep S0-idle states which may turn off fundamental resources like bus clocks, interrupt controllers, etc. so special care must be taken to ensure that the platform can be woken from these states. This section describes handling for device initiated wakes.  There are other wake sources such as timers, which are described elsewhere.</P>
<P CLASS="Body">
<A NAME="pgfId-1461408"></A>For device wakes, the requirement is that OSPM must not enter any LPI state that would prevent a device enabled for wake from waking the system. This means not entering any LPI state for which any Power Resource listed in _RDI (see the _RDI section <A HREF="Processor_Configuration_and_Control.htm#94531" CLASS="XRef">See _RDI (Resource Dependencies for Idle).</A>) is required to be ON. Note that on a platform coordinated system, the OSPM may choose to enter an _LPI state even if there are resources listed in its companion RDI that are still on. However, if the OSPM has already enabled a device for wake, and ensured the power resources needed for wake are on, the platform will demote the LPI state to one where said resources remain on.</P>
<P CLASS="Body">
<A NAME="pgfId-1461409"></A> The wake device uses the standard _PRx and _PRW methods to describe power resources it requires to be ON based on its D-state and wake enabled status. This further implies that any device enabled for wake which depends on a resource which may be turned off as part of an LPI state must describe that dependency via _PRx/_PRW =&gt; _RDI =&gt; _LPI.</P>
<P CLASS="Body">
<A NAME="pgfId-1461410"></A>This is illustrated in the following example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461412"></A><EM CLASS="SC-13-266245">
PowerResource(PWRA,0,0) {...}</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461413"></A><EM CLASS="SC-13-266245">
PowerResource(PWRB,0,0) {...}</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461414"></A><EM CLASS="SC-13-266245">
PowerResource(PWRC,0,0) {...}</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461415"></A><EM CLASS="SC-13-266245">
PowerResource(PWRD,0,0) {...}   </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461416"></A><EM CLASS="SC-13-266245">
PowerResource(PWRE,0,1) {...}   </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461417"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461418"></A><EM CLASS="SC-13-266245">
Device (FOO) {</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461419"></A><EM CLASS="SC-13-266245">
      Name(_S0W, 4)                   //Device in D3Cold can wake system from S0-idle</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461420"></A><EM CLASS="SC-13-266245">
      Name(_PR0,Package(){PWRA, PWRB, PWRC})</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461421"></A><EM CLASS="SC-13-266245">
      Name(_PR2,Package(){PWRA, PWRB})</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461422"></A><EM CLASS="SC-13-266245">
      Name(_PR3,Package(){PWRA})</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461423"></A><EM CLASS="SC-13-266245">
      Name(_PRE,Package(){PWRD})</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461424"></A><EM CLASS="SC-13-266245">
      Name(_PRW,Package(){0, 0, PWRD} // PWRD must be ON for FOO to wake system</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461425"></A><EM CLASS="SC-13-266245">
}</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461426"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461427"></A><EM CLASS="SC-13-266245">
Device (BAR) {</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461428"></A><EM CLASS="SC-13-266245">
      Name(_S0W, 3)                   // Device in D3Hot can wake system from S0-idle</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461429"></A><EM CLASS="SC-13-266245">
      Name(_PR0,Package(){PWRA, PWRB})</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461430"></A><EM CLASS="SC-13-266245">
      Name(_PR3,Package(){PWRC})</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461431"></A><EM CLASS="SC-13-266245">
      Name(_PRW,Package(){PWRC})      // PWRC must be ON for BAR to wake system</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461432"></A><EM CLASS="SC-13-266245">
	</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461433"></A><EM CLASS="SC-13-266245">
	</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461434"></A><EM CLASS="SC-13-266245">
}</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461435"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461436"></A><EM CLASS="SC-13-266245">
Device (BAH) {</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461437"></A><EM CLASS="SC-13-266245">
       Name(_S0W, 0)                  // This device can only wake the system from </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461438"></A><EM CLASS="SC-13-266245">
                                      // S0-idle if it is in D0</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461439"></A><EM CLASS="SC-13-266245">
       Name(_PR0,Package(){PWRA, PWRB, PWRC})  </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461440"></A><EM CLASS="SC-13-266245">
}</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461441"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461442"></A><EM CLASS="SC-13-266245">
Device (SYM) {</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461443"></A><EM CLASS="SC-13-266245">
       Name(_RDI, </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461444"></A><EM CLASS="SC-13-266245">
             Package() {</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461445"></A><EM CLASS="SC-13-266245">
                    0, // Version</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461446"></A><EM CLASS="SC-13-266245">
                    Package(){}       // Local State 1 is Shallow; </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461447"></A><EM CLASS="SC-13-266245">
                                      // Devices FOO, BAR and BAH can wake</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461448"></A><EM CLASS="SC-13-266245">
                                      // the system if enabled for wake</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461449"></A><EM CLASS="SC-13-266245">
                    Package(){PWRA, PWRB}  // RDI for Local State 2. State is deeper</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461450"></A><EM CLASS="SC-13-266245">
                                      // Device BAH cannot wake the system if this</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461451"></A><EM CLASS="SC-13-266245">
                                      // state is used, as it needs PWRA and PWRB</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461452"></A><EM CLASS="SC-13-266245">
                                      // to be able to wake the system</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461453"></A><EM CLASS="SC-13-266245">
                    Package(){PWRA, PWRB, PWRC}  // RDI for Local State 3. </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461454"></A><EM CLASS="SC-13-266245">
                                          // Devices BAH and BAR cannot wake </EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461455"></A><EM CLASS="SC-13-266245">
                                          // the system, BAH needs PWRA, PWRB</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461456"></A><EM CLASS="SC-13-266245">
                                          // and PWRC, and BAR needs PWRC</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461457"></A><EM CLASS="SC-13-266245">
                                          // for all devices</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461458"></A><EM CLASS="SC-13-266245">
                    Package(){PWRA, PWRB, PWRC, PWRD} // None of the devices listed</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461459"></A><EM CLASS="SC-13-266245">
                                                      // above could wake the system</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461460"></A><EM CLASS="SC-13-266245">
                    })</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461461"></A><EM CLASS="SC-13-266245">
                ...</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1461463"></A><EM CLASS="SC-13-266245">
</EM>
The example above declares a set of power resources (PWRA/B/C/D). Additionally, it has four system level local states that have the following dependencies:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1461465"></A><EM CLASS="SC-13-266245">
LPI 1: Has no power resources dependencies</EM>
</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1461466"></A><EM CLASS="SC-13-266245">
LPI 2: Requires PWRA and PWRB to be off</EM>
</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1461467"></A><EM CLASS="SC-13-266245">
LPI 3: Requires PWRA, PWRB and PWRC to be off</EM>
</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1461468"></A><EM CLASS="SC-13-266245">
LPI 4: Requires all of the power resources in the example to be off</EM>
</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1461470"></A><EM CLASS="SC-13-266245">
</EM>
Device BAH can only wake the system if it is in the D0 state. To be in D0 it requires PWRA, PWRB and PWRC to be on. Therefore device BAH could only wake the system from LPI 1. If this device is enabled for wake, then the platform must not enter LPI 2 or deeper.</P>
<P CLASS="Body">
<A NAME="pgfId-1461471"></A>Device BAR can wake the system in whilst it is in any device state other than D3Cold. However, to do so, it requires PWRC to be on. Therefore it can only wake the system from LPI 1 or LPI 2. If this device is enabled for wake, then the platform must not enter LPI 3 or deeper.</P>
<P CLASS="Body">
<A NAME="pgfId-1461472"></A>Device FOO can wake the system whilst it is in any device state. However to do so, it requires PWRD to be on. Therefore it can only wake the system from LPI 1 or LPI 2 or LPI 3. If this device is enabled for wake, then the platform must not enter LPI 4.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461474"></A><EM CLASS="SC-13-266245">
Default Idle State</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-1461475"></A>The shallowest idle state for each leaf node in the hierarchy is the &#8220;default&#8221; idle state for that processor and is assumed to always be enterable. The worst case wakeup latency and minimum residency for this state must be low enough that OSPM need not consider them when deciding whether to use it.  Aside from putting the processor in a power state, this state has no other software-visible effects.  For example, it does not lose any context that OSPM must save/restore or have any <EM CLASS="SC-13-266245">
device dependencies.</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1461884"></A><A NAME="94531"></A>_RDI (Resource Dependencies for Idle)</H6>
<P CLASS="Body">
<A NAME="pgfId-1461885"></A>Some platforms may have power resources that are shared between devices and processors.  Abstractly, these resources are managed in two stages. First, the OS does normal power resource reference counting to detect when all device dependencies have been satisfied and the resource may be power managed from the device perspective. Then, when the processors also go idle, the OS requests entry into specific LPI states and the platform physically power manages the resources as part of the transition. The dependency between the power resources and the LPI state is described in _RDI.</P>
<P CLASS="Body">
<A NAME="pgfId-1461886"></A>_RDI objects may only be present at the root processor container that describes the processor hierarchy of the system. _RDI is not supported in a system that has more than one root node. _RDI is valid only in a singular top level container which encompasses all processors in the system.  </P>
<P CLASS="Body">
<A NAME="pgfId-1461887"></A>The OSPM will ignore _RDI objects that are present at any node other than the root node. This simplification avoids complicated races between processors in one part of the hierarchy choosing idle states with resource dependencies while another processor is changing device states/power resources.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="SP-24-217121">
<A NAME="pgfId-1461888"></A><EM CLASS="SC-13-266245">
Arguments:</EM>
</H4>
<P CLASS="Body">
<A NAME="pgfId-1461889"></A><EM CLASS="SC-13-266245">
None</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="SP-24-217121">
<A NAME="pgfId-1461890"></A><EM CLASS="SC-13-266245">
Return Value:</EM>
</H4>
<P CLASS="Body">
<A NAME="pgfId-1461891"></A>A variable-length <EM CLASS="SC-13-266245">
Package</EM>
 containing the resource dependencies with the following format: </P>
<P CLASS="Normal">
<A NAME="pgfId-1461892"></A><EM CLASS="SC-13-266245">
Return Value Information</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461893"></A><EM CLASS="SC-13-266245">
 </EM>
 Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461894"></A>    Revision, // Integer (WORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461895"></A>    RDI[1],   // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461896"></A>    ...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461897"></A>    RDI[N]    // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461898"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461899"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461900"></A>	 </P>
<P CLASS="Normal">
<A NAME="pgfId-1461926"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1461903"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1461905"></A>Object Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1461907"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461909"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461911"></A>Integer (WORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461913"></A>The revision number of the _RDI object. Current revision is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461915"></A>RDI[1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461917"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461919"></A>A variable length Package containing the power resource dependencies of system level power state 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461921"></A>RDI[N]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461923"></A>Package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1461925"></A>A variable length Package containing the power resource dependencies of system level power state N.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1461929"></A><EM CLASS="SC-13-266245">
Each RDI[x] sub-Package contains a variable number of References to power resources: </EM>
</P>
<P CLASS="Normal">
<A NAME="pgfId-1461930"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461931"></A><EM CLASS="SC-13-266245">
  </EM>
Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461932"></A>     Resource[0], // Object Reference to a Power Resource Object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461933"></A>     ...	</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461934"></A>     Resource[M]  // Object Reference to a Power Resource Object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461935"></A>}</P>
<P CLASS="Normal">
<A NAME="pgfId-1461936"></A><EM CLASS="SC-13-266245">
</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1461937"></A>The <EM CLASS="Bold">
Package</EM>
 contains as many RDI packages as there are system level power states in the root processor container node&#8217;s _LPI object. The indexing of LPI power states in this _LPI object matches the indexing of the RDI packages in the _RDI object. Thus the nth LPI state at the system level has resource dependencies listed in the nth RDI. Each RDI package returns a list of the power resource objects (passive or standard power resources) that must be in an OFF state to allow the platform to enter the LPI state. If a system level LPI does not have any resource dependencies, the corresponding RDI should be an empty <EM CLASS="Bold">
Package</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-1461938"></A>Both traditional and passive power resources can be listed as dependencies in _RDI. For traditional power resources, OSPM should ensure that the resource is OFF before requesting a dependent LPI state. For passive power resources, there are no _ON/_OFF/_STA methods so the only requirement is to check that the reference count is 0 before requesting a dependent LPI state.</P>
<P CLASS="Body">
<A NAME="pgfId-1461939"></A>OSPM requirements for ordering between device/power resource transitions and power resource dependent LPI states differ based on the coordination scheme.</P>
<P CLASS="Body">
<A NAME="pgfId-1461940"></A>In a platform coordinated system the platform must guarantee correctness and demote the requested power state to one that will satisfy the resource and processor dependencies. OSPM may use the dependency info in _RDI as it sees fit, and may select a dependent LPI state even if resources remain ON.</P>
<P CLASS="Body">
<A NAME="pgfId-1461941"></A>In an OS initiated system, OSPM must guarantee that all power resources are off (or reference counts are 0, for passive power resources) before requesting a dependent LPI state.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1461942"></A>Example</H6>
<P CLASS="Body">
<A NAME="pgfId-1461943"></A>The following ASL describes a system that uses _RDI to describe the dependencies between three power resources and system level power states:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461944"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461945"></A>PowerResource(PWRA,0,0) {     // power rail local to DEVA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461946"></A>       Method(_ON) {...}        // active power resource (_OFF turns rail off)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461947"></A>       Method(_OFF) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461948"></A>       Method(_STA) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461949"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461950"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461951"></A>PowerResource(PWRB,0,0) {     // power rail shared between DEVB and the processor</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461952"></A>       Method(_ON) {...}        // active power resource (_OFF drives platform vote)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461953"></A>       Method(_OFF) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461954"></A>       Method(_STA) {...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461955"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461956"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461957"></A>PowerResource(PWRC,0,0) {}    // clock rail shared between DEVC and the processor</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461958"></A>                              // passive power resource</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461959"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461960"></A>Device (DEVA) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461961"></A>       Name(_PR0,Package(){PWRA})  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461962"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461963"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461964"></A>Device (DEVB) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461965"></A>       Name(_PR0,Package(){PWRB})  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461966"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461967"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461968"></A>Device (DEVC) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461969"></A>       Name(_PR0,Package(){PWRC})  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461970"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461971"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461972"></A>Device (SYM) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461973"></A>       Name(_RDI, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461974"></A>              Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461975"></A>                     0,                    // Revision</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461976"></A>                     Package(){}           // Local State 1 has no power resource</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461977"></A>                                           // dependencies </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461978"></A>                     Package(){PWRA}       // Local State 2 cannot be entered if DEVA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461979"></A>                                           // is in D0 due to PWRA </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461980"></A>                     Package(){PWRA, PWRB, PWRC} // Local State 3 cannot be entered if</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461981"></A>                                                 // DEVA is in D0 (due to PWRA), DEVB is in</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461982"></A>                                            // D0 (due to PWRB) or DEVC is in D0 </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1476325"></A>                                            // (due to PWRC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461984"></A>                     })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1461985"></A>              ...</P>
<P CLASS="Body">
<A NAME="pgfId-1461987"></A>OSPM will turn the traditional power resource (PWRA) ON or OFF by waiting for the reference count to reach 0 (meaning DEVA has left D0) and running the _OFF method. Similarly, PWRB is turned ON or OFF based on the state of DEVB. Note that because the CPUs require the shared power rail to be ON while they are running, PWRB&#8217;s _ON and _OFF drive a vote rather than the physical HW controls for the power rail. In this case, _STA reflects the status of the vote rather than the physical state of PWRB.</P>
<P CLASS="Body">
<A NAME="pgfId-1461989"></A>OSPM guarantees ordering between PWRA/PWRB&#8217;s _ON and _OFF transitions and DEVA/DEVB&#8217;s D-state transitions. That is, PWRA can only be turned OFF after DEVA has left D0, and must be turned ON before transitioning DEVA to D0. However, the OS requirements for ordering between power resource transitions and power resource dependent LPI states differ based on the coordination scheme.</P>
<P CLASS="Body">
<A NAME="pgfId-1461991"></A>In a platform coordinated system, OSPM may or may not track the power state of PWRA before selecting local state 2 or 3. The platform must independently guarantee that PWRA is OFF before entering local state 2 or 3, and must demote to a shallower state if OSPM selects local state 2 or 3 when PWRA is still on. Note that because OSPM is required to correctly sequence power resource transitions with device power transitions, the platform does not need to check the state of DEVA; it can rely on the state of PWRA to infer that DEVA is in an appropriate D-state.</P>
<P CLASS="Body">
<A NAME="pgfId-1461993"></A>Similarly, OSPM may or may not track the state of PWRB and PWRC before selecting local state 3, and the platform must independently guarantee that PWRB is off before entering either state. Because PWRC is a passive power resource, the platform does not know when the reference count on the power resource reaches 0 and instead must track DEVC&#8217;s state itself. Unless the platform has other mechanisms to track the state of DEVC, PWRC should be defined as a traditional power resource so that the platform can use its _ON and _OFF methods to guarantee correctness of operation.</P>
<P CLASS="Body">
<A NAME="pgfId-1461995"></A>In an OS initiated system, OSPM is required to guarantee that PWRA is OFF before selecting either local state 2 or 3. OSPM may meet this guarantee by waiting until it believes a processor is the last man down in the system, before checking the state of PWRA, and only selecting local state 2 or 3 in this case. If the processor was the last man down, then the request to enter local state 2 or 3 is legal and the platform can honor it. If another processor woke up in the meantime and turned PWRA on, then this becomes a race between processors which is addressed in the OS Initiated Request Semantics section (<A HREF="Processor_Configuration_and_Control.htm#59068" CLASS="XRef">See OS Initiated Request Semantics.</A>). Similarly, OSPM must guarantee PWRB is off and PWRC&#8217;s reference count is 0 before selecting local state 3.</P>
<P CLASS="Body">
<A NAME="pgfId-1461654"></A>In an OS initiated system, because OSPM guarantees that power resources are in their correct states before selecting system power states, the platform should use passive power resources unless there is additional runtime power savings to turning a power resource OFF. On a platform that only supports OS Initiated transitions, PWRB should be defined as a passive power resource because it is shared with processors and can only be turned off when the system power state is entered.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1461476"></A>Compatibility</H6>
<P CLASS="Body">
<A NAME="pgfId-1461477"></A>In order to support older operating systems which do not support the new idle management infrastructure, the _OSC method can be used to detect whether the OSPM supports parsing processor containers and objects associated with LPIs and (_LPI, _RDI). This is described in <A HREF="Device_Configuration.htm#94454" CLASS="XRef">See Rules for Evaluating _OSC.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1460815"></A>A platform may choose to expose both _CST and _LPI for backward compatibility with operating systems which do not support _LPI. In this case, if OSPM supports _LPI, then it should be used in preference to _CST. At run time only one idle<EM CLASS="SC-13-266245">
 state methodology should be used across the entire processor hierarchy - _LPI or _CST, but not a mixture of both.</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1376395"></A><A NAME="_Toc202341611"></A><A NAME="_Toc258262349"></A>Processor Throttling Controls</H6>
<P CLASS="Body">
<A NAME="pgfId-1376396"></A>ACPI defines two processor throttling (T state) control interfaces. These are:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1376397"></A>The Processor Register Block&#8217;s (P_BLK&#8217;s) P_CNT register.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1376398"></A> The combined _PTC, _TSS, and _TPC objects in the processor&#8217;s object list.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1376399"></A>P_BLK based throttling state controls are described in <A HREF="ACPI Hardware Specification.htm#44941" CLASS="XRef">See ACPI Hardware Specification.</A>, &#8220;ACPI Hardware Specification&#8221; and <A HREF="Processor_Configuration_and_Control.htm#76331" CLASS="XRef">See Processor Power State C0.</A>, &#8220;Processor Power State C0&#8221;. Combined _PTC, _TSS, and _TPC based throttling state controls expand the functionality of the P_BLK based control allowing the number of T states to be dynamic and accommodate CPU architecture specific T state control mechanisms as indicated by registers defined using the Functional Fixed Hardware address space. While platform definition of the _PTC, _TSS, and _TPC objects is optional, all three objects must exist under a processor for OSPM to successfully perform processor throttling via these controls.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376409"></A><A NAME="_Toc489256115"></A><A NAME="_Toc489268039"></A><A NAME="_Toc489272592"></A><A NAME="RSVD_PTC"></A>_PTC (Processor Throttling Control)<A NAME="marker-1376405"></A><A NAME="marker-1376406"></A><A NAME="marker-1376407"></A><A NAME="marker-1376408"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376410"></A>_PTC is an optional object that defines a processor throttling control interface alternative to the I/O address spaced-based P_BLK throttling control register (P_CNT) described in <A HREF="ACPI Hardware Specification.htm#44941" CLASS="XRef">See ACPI Hardware Specification.</A>, &#8220;ACPI Hardware Specification&#8221;. The processor throttling control register mechanism remains as defined in <A HREF="Processor_Configuration_and_Control.htm#76331" CLASS="XRef">See Processor Power State C0.</A>, &#8220;Processor Power State C0.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1376411"></A>OSPM performs processor throttling control by writing the Control field value for the target throttling state (T-state), retrieved from the Throttling Supported States object (_TSS), to the Throttling Control Register (THROTTLE_CTRL) defined by the _PTC object. OSPM may select any processor throttling state indicated as available by the value returned by the _TPC control method. </P>
<P CLASS="Body">
<A NAME="pgfId-1376412"></A>Success or failure of the processor throttling state transition is determined by reading the Throttling Status Register (THROTTLE_STATUS) to determine the processor&#8217;s current throttling state. If the transition was successful, the value read from THROTTLE_STATUS will match the &#8220;Status&#8221; field in the _TSS entry that corresponds to the targeted processor throttling state.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376413"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376414"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376415"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376416"></A>A Package as described below</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376417"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1450060"></A>Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376420"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376421"></A>    ControlRegister        // Buffer (Resource Descriptor)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376422"></A>    StatusRegister         // Buffer (Resource Descriptor)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376423"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376424"></A>PTC Package Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1454812"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1454814"></A>Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1454816"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376433"></A>Control Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376435"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376437"></A>Contains a Resource Descriptor with a single Register() descriptor that describes the throttling control register.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376439"></A>Status Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376441"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376443"></A>Contains a Resource Descriptor with a single Register() descriptor that describes the throttling status register.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1376446"></A>The platform must expose a _PTC object for either all or none of its processors. Notice that if the _PTC object exists, the specified register is used instead of the P_CNT register specified in the Processor term. Also notice that if the _PTC object exists and the _CST object does not exist, OSPM will use the processor control register from the _PTC object and the P_LVLx registers from the P_BLK.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376447"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1454831"></A>This is an example usage of the _PTC object in a Processor object list:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1454832"></A>Processor ( </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376451"></A>        &#92;_SB.CPU0,               // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376452"></A>        1,                       // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376453"></A>        0x120,                   // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376454"></A>        6 )                      // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376455"></A>    {                            // Object List</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376456"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376457"></A>        Name(_PTC, Package ()    // Processor Throttling Control object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376458"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376459"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},       // Throttling_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376460"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)}        // Throttling_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376461"></A>        })                       // End of _PTC object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376462"></A>    }                            // End of Object List</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376464"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1376465"></A>This is an example usage of the _PTC object using the values defined in ACPI 1.0. This is an illustrative example to demonstrate the mechanism with well-known values.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376467"></A>   </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450088"></A> Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376468"></A>        &#92;_SB.CPU0,               // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376469"></A>        1,                       // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376470"></A>        0x120,                   // PBLK system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376471"></A>        6 )                      // PBLK Len</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376472"></A>    {                            // Object List</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376473"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376476"></A><A NAME="OLE_LINK57"></A><A NAME="OLE_LINK58"></A>        Name(_PTC, Package ()    // Processor Throttling Control object - </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376477"></A>                                 // 32 bit wide IO space-based register at the &lt;P_BLK&gt; address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376478"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376479"></A>            ResourceTemplate(){Register(SystemIO, 32, 0, 0x120)},  // Throttling_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376480"></A>            ResourceTemplate(){Register(SystemIO, 32, 0, 0x120)}   // Throttling_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376481"></A>        })                       // End of _PTC object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376482"></A>    }                            // End of Object List</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376486"></A>_<A NAME="RSVD_TSS"></A>TSS (Throttling Supported States)</H6>
<P CLASS="Body">
<A NAME="pgfId-1376487"></A>This optional object indicates to OSPM the number of supported processor throttling states that a platform supports. This object evaluates to a packaged list of information about available throttling states including percentage of maximum internal CPU core frequency, maximum power dissipation, control register values needed to transition between throttling states, and status register values that allow OSPM to verify throttling state transition status after any OS-initiated transition change request. The list is sorted in descending order by power dissipation. As a result, the zeroth entry describes the highest performance throttling state (no throttling applied) and the &#8216;nth&#8217; entry describes the lowest performance throttling state (maximum throttling applied).</P>
<P CLASS="Body">
<A NAME="pgfId-1376489"></A>When providing the _TSS, the platform must supply a _TSS entry whose Percent field value is 100. This provides a means for OSPM to disable throttling and achieve maximum performance.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376490"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376491"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376492"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376493"></A>A variable-length Package containing a list of Tstate sub-packages as described below</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376494"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1376496"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450102"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376497"></A>    TState [0]                // Package - Throttling state 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376498"></A>    ....</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376499"></A>    TState [n]                // Package - Throttling state n</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376500"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450109"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1376501"></A>Each Tstate sub-Package contains the elements described below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376503"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450116"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376504"></A>    Percent                    // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376505"></A>    Power                      // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376506"></A>    Latency                    // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376507"></A>    Control                    // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376508"></A>    Status                     // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376509"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376510"></A>TState Package Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1454845"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1454847"></A>Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1454849"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376519"></A>Percent</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376521"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376523"></A>Indicates the percent of the core CPU operating frequency that will be available when this throttling state is invoked. The range for this field is 1-100. This percentage applies independent of the processor&#8217;s performance state (P-state). That is, this throttling state will invoke the percentage of maximum frequency indicated by this field as applied to the CoreFrequency field of the _PSS entry corresponding to the P-state for which the processor is currently resident.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376525"></A>Power</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376527"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376529"></A>Indicates the throttling state&#8217;s maximum power dissipation (in milliWatts). OSPM ignores this field on platforms the support P-states, which provide power dissipation information via the _PSS object.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376531"></A>Latency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376533"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376535"></A>Indicates the worst-case latency in microseconds that the CPU is unavailable during a transition from any throttling state to this throttling state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376537"></A>Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376539"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376541"></A>Indicates the value to be written to the Processor Control Register (THROTTLE_CTRL) in order to initiate a transition to this throttling state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376543"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376545"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376547"></A>Indicates the value that OSPM will compare to a value read from the Throttle Status Register (THROTTLE_STATUS) to ensure that the transition to the throttling state was successful. OSPM may always place the CPU in the lowest power throttling state, but additional states are only available when indicated by the _TPC control method. A value of zero indicates the transition to the Throttling state is asynchronous, and as such no status value comparison is required.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376552"></A><A NAME="97960"></A>_TPC (Throttling Present Capabilities)</H6>
<P CLASS="Body">
<A NAME="pgfId-1376553"></A>This optional object is a method that dynamically indicates to OSPM the number of throttling states currently supported by the platform. This method returns a number that indicates the _TSS entry number of the highest power throttling state that OSPM can use at a given time. OSPM may choose the corresponding state entry in the _TSS as indicated by the value returned by the _TPC method or any lower power (higher numbered) state entry in the _TSS. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376554"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376555"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376556"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376557"></A>An Integer containing the number of states supported:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376558"></A>0 - states 0 ... nth state available (all states available)</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376559"></A>1 - state 1 ... nth state available</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376560"></A>2 - state 2 ... nth state available</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376561"></A>...</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376562"></A>n - state n available only</P>
<P CLASS="Body">
<A NAME="pgfId-1376563"></A>In order to support dynamic changes of _TPC object, Notify events on the processor object of type 0x82 will cause OSPM to reevaluate any _TPC object in the processor&#8217;s object list. This allows AML code to notify OSPM when the number of supported throttling states may have changed as a result of an asynchronous event. OSPM ignores _TPC Notify events on platforms that support P-states unless the platform has limited OSPM&#8217;s use of P-states to the lowest power P-state. OSPM may choose to disregard any platform conveyed T-state limits when the platform enables OSPM usage of other than the lowest power P-state.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376738"></A>_<A NAME="RSVD_TSD"></A>TSD (T-State Dependency)<A NAME="marker-1376736"></A><A NAME="marker-1376737"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376739"></A>This optional object provides T-state control cross logical processor dependency information to OSPM. The _TSD object evaluates to a packaged list containing a single entry that expresses the T-state control dependency among a set of logical processors.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376740"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376741"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376742"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376743"></A>A Package containing a single entry consisting of a T-state dependency Package as described below.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376744"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1376746"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450339"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376747"></A>    TStateDependency[0]    // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376750"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1469572"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1469570"></A>The TStateDependency sub-Package contains the elements described below: </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1469591"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376753"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376754"></A>    NumEntries             // Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376755"></A>    Revision               // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376756"></A>    Domain                 // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376757"></A>    CoordType              // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376758"></A>    NumProcessors          // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376759"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376760"></A>TStateDependency Package Values</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376763"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376765"></A>Object Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376767"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376769"></A>NumEntries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376771"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376773"></A>The number of entries in the TStateDependency package including this field. Current value is 5.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376775"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376777"></A>Integer<BR>
(BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376779"></A>The revision number of the TStateDependency package format. Current value is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376781"></A>Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376783"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376785"></A>The dependency domain number to which this T state entry belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376787"></A>CoordType</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376789"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376791"></A>The type of coordination that exists (hardware) or is required (software) as a result of the underlying hardware dependency. Could be either 0xFC (SW_ALL), 0xFD (SW_ANY) or 0xFE (HW_ALL) indicating whether OSPM is responsible for coordinating the T-state transitions among processors with dependencies (and needs to initiate the transition on all or any processor in the domain) or whether the hardware will perform this coordination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376793"></A>Num Processors</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376795"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376797"></A>The number of processors belonging to the domain for this logical processor&#8217;s T-states. OSPM will not start performing power state transitions to a particular T-state until this number of processors belonging to the same domain have been detected and started.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376801"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1376802"></A>This is an example usage of the _TSD structure in a Processor structure in the namespace. The example represents a two processor configuration with three T-states per processor. For all T-states, there exists dependence between the two processors, such that one processor transitioning to a particular T-state, causes the other processor to transition to the same T-state. OSPM will be required to coordinate the T-state transitions between the two processors and can initiate a transition on either processor to cause both to transition to the common target T-state.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376803"></A>    Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376805"></A>        &#92;_SB.CPU0,                       // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376806"></A>        1,                               // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1444046"></A>        0x120,                           // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1444047"></A>        6)                               // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1444048"></A>    { //Object List</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376810"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376811"></A>        Name(_PTC, Package () // Processor Throttling Control object - </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376812"></A>                              // 32 bit wide IO space-based register at the &lt;P_BLK&gt; address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376813"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376814"></A>            ResourceTemplate(){Register(SystemIO, 32, 0, 0x120)}, // Throttling_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376815"></A>            ResourceTemplate(){Register(SystemIO, 32, 0, 0x120)}  // Throttling_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376816"></A>        }) // End of _PTC object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376817"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376818"></A>        Name (_TSS, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376819"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376820"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376821"></A>                0x64,                   // Frequency Percentage (100%, Throttling OFF state)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376822"></A>                0x0,                    // Power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376823"></A>                0x0,                    // Transition Latency</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376824"></A>                0x7,                    // Control THT_EN:0 THTL_DTY:111</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376825"></A>                0x0,                    // Status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376826"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376827"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376828"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376829"></A>                0x58,                   // Frequency Percentage (87.5%)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376830"></A>                0x0,                    // Power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1443837"></A>                0x0,                    // Transition Latency</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1443838"></A>                0xF,                    // Control THT_EN:1 THTL_DTY:111</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1443839"></A>                0x0,                    // Status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1443840"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376835"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376836"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376837"></A>                0x4B,                   // Frequency Percentage (75%)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376838"></A>                0x0,                    // Power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376839"></A>                0x0,                    // Transition Latency</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376840"></A>                0xE,                    // Control THT_EN:1 THTL_DTY:110</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376841"></A>                0x0,                    // Status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376842"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376843"></A>        })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376844"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376845"></A>        Name (_TSD, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376846"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376847"></A>            Package(){5, 0, 0, 0xFD, 2}  // 5 entries, Revision 0, Domain 0,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376848"></A>                                         // OSPM Coordinate, 2 Procs</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376849"></A>        })                               // End of _TSD object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376850"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376851"></A>        Method (_TPC, 0)                 // Throttling Present Capabilities method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376852"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376853"></A>            If (&#92;_SB.AC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376854"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376855"></A>                Return(0)                // All Throttle States are available for use.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376856"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376857"></A>            Else</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376858"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376859"></A>                Return(2)                // Throttle States 0 an 1 won&#8217;t be used.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376860"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376861"></A>        } // End of _TPC method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376862"></A>    } // End of processor object list</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376863"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376864"></A>    Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376865"></A>        &#92;_SB.CPU1,                     // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376866"></A>        2,                             // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376867"></A>        ,                              // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376868"></A>        )                              // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376869"></A>    { //Object List</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376870"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376871"></A>        Name(_PTC, Package ()          // Processor Throttling Control object - </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376872"></A>                                       // 32 bit wide IO space-based register at the</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376873"></A>                                       // &lt;P_BLK&gt; address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376874"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376875"></A>            ResourceTemplate(){Register(SystemIO, 32, 0, 0x120)}, // Throttling_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376876"></A>            ResourceTemplate(){Register(SystemIO, 32, 0, 0x120)}  // Throttling_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376877"></A>        })                             // End of _PTC object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376878"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376879"></A>        Name (_TSS, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376880"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376881"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376882"></A>                0x64,                  // Frequency Percentage (100%, Throttling OFF state)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376883"></A>                0x0,                   // Power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376884"></A>                0x0,                   // Transition Latency</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376885"></A>                0x7,                   // Control THT_EN:0 THTL_DTY:111</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376886"></A>                0x0,                   // Status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376887"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376888"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376889"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376890"></A>                0x58,                  // Frequency Percentage (87.5%)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376891"></A>                0x0,                   // Power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376892"></A>                0x0,                   // Transition Latency</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376893"></A>                0xF,                   // Control THT_EN:1 THTL_DTY:111</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376894"></A>                0x0,                   // Status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376895"></A>            }`</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376896"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376897"></A>            Package() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376898"></A>                0x4B,                   // Frequency Percentage (75%)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376899"></A>                0x0,                    // Power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376900"></A>                0x0,                    // Transition Latency</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376901"></A>                0xE,                    // Control THT_EN:1 THTL_DTY:110</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376902"></A>                0x0,                    // Status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376903"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376904"></A>        })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376905"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376906"></A>        Name (_TSD, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376907"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376908"></A>            Package(){5, 0, 0, 0xFD, 2}  // 5 entries, Revision 0, Domain 0,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376909"></A>                                         // OSPM Coordinate, 2 Procs</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376910"></A>        })                               // End of _TSD object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376911"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376912"></A>        Method (_TPC, 0)                 // Throttling Present Capabilities method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376913"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376914"></A>            If (&#92;_SB.AC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376915"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376916"></A>                Return(0)                // All Throttle States are available for use.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376917"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376918"></A>            Else</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376919"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376920"></A>                Return(2)                // Throttle States 0 an 1 won&#8217;t be used.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376921"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376922"></A>        } // End of _TPC method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376923"></A>    } // End of processor object list</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376926"></A><A NAME="24576"></A>   _TDL (T-state Depth Limit)</H6>
<P CLASS="Body">
<A NAME="pgfId-1376927"></A>This optional object evaluates to the _TSS entry number of the lowest power throttling state that OSPM may use. _TDL enables the platform to limit the amount of performance reduction that OSPM may invoke using processor throttling controls in an attempt to alleviate an adverse thermal condition. OSPM may choose the corresponding state entry in the _TSS as indicated by the value returned by the _TDL object or a higher performance (lower numbered) state entry in the _TSS down to and including the _TSS entry number returned by the _TPC object or the first entry in the table (if _TPC is not implemented).  The value returned by the _TDL object must be greater than or equal to the value returned by the _TPC object or the corresponding value to the last entry in the _TSS if _TPC is not implemented. In the event of a conflict between the values returned by the evaluation of the _TDL and _TPC objects, OSPM gives precedence to the _TPC object, limiting power consumption.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376928"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376929"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376930"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376931"></A>An Integer containing the Throttling Depth Limit _TSS entry number:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376932"></A>0 - throttling disabled. </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376933"></A>1 - state 1 is the lowest power T-state available.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376934"></A>2 - state 2 is the lowest power T-state available.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376935"></A>...</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1376936"></A>n - state n is the lowest power T-state available.</P>
<P CLASS="Body">
<A NAME="pgfId-1376937"></A>In order for the platform to dynamically indicate the limit of performance reduction that is available for OSPM use, Notify events on the processor object of type 0x82 will cause OSPM to reevaluate any _TDL object in the processor&#8217;s object list. This allows AML code to notify OSPM when the number of supported throttling states may have changed as a result of an asynchronous event. OSPM ignores _TDL Notify events on platforms that support P-states unless the platform has limited OSPM&#8217;s use of P-states to the lowest power P-state. OSPM may choose to disregard any platform conveyed T-state depth limits when the platform enables OSPM usage of other than the lowest power P-state.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1376961"></A><A NAME="_Toc489256117"></A><A NAME="_Toc489268041"></A><A NAME="_Toc489272594"></A><A NAME="_Toc202341612"></A><A NAME="_Toc258262350"></A>Processor Performance Control<A NAME="marker-1376959"></A><A NAME="marker-1376960"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376962"></A>Processor performance control is implemented through three optional objects whose presence indicates to OSPM that the platform and CPU are capable of supporting multiple performance states. The platform must supply all three objects if processor performance control is implemented. The platform must expose processor performance control objects for either all or none of its processors. The processor performance control objects define the supported processor performance states, allow the processor to be placed in a specific performance state, and report the number of performance states currently available on the system. </P>
<P CLASS="Body">
<A NAME="pgfId-1379018"></A>In a multiprocessing environment, all CPUs must support the same number of performance states and each processor performance state must have identical performance and power-consumption parameters. Performance objects must be present under each processor object in the system for OSPM to utilize this feature.</P>
<P CLASS="Body">
<A NAME="pgfId-1376970"></A>Processor performance control objects include the &#8216;_PCT&#8217; package, &#8216;_PSS&#8217; package, and the &#8216;_PPC&#8217; method as detailed below.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376978"></A>_<A NAME="RSVD_PCT"></A>PCT (Performance Control)<A NAME="marker-1376976"></A><A NAME="marker-1376977"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376979"></A>This optional object declares an interface that allows OSPM to transition the processor into a performance state. OSPM performs processor performance transitions by writing the performance state-specific control value to a Performance Control Register (PERF_CTRL). </P>
<P CLASS="Body">
<A NAME="pgfId-1376980"></A>OSPM may select a processor performance state as indicated by the performance state value returned by the _PPC method, or any lower power (higher numbered) state. The control value to write is contained in the corresponding _PSS entry&#8217;s &#8220;Control&#8221; field.</P>
<P CLASS="Body">
<A NAME="pgfId-1376981"></A>Success or failure of the processor performance transition is determined by reading a Performance Status Register (PERF_STATUS) to determine the processor&#8217;s current performance state. If the transition was successful, the value read from PERF_STATUS will match the &#8220;Status&#8221; field in the _PSS entry that corresponds to the desired processor performance state.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376982"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376983"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1376984"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1376985"></A>A Package as described below</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1376986"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1376988"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450137"></A>Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376989"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376990"></A>    ControlRegister        // Buffer (Resource Descriptor)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376991"></A>    StatusRegister         // Buffer (Resource Descriptor)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1376992"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450144"></A>&nbsp;</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376993"></A>PCT Package Values</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376996"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376998"></A>Object Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377000"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377002"></A>Control Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377004"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377006"></A>Contains a Resource Descriptor with a single Register() descriptor that describes the performance control register.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377008"></A>Status Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377010"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377012"></A>Contains a Resource Descriptor with a single Register() descriptor that describes the performance status register.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377016"></A>Example</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1377017"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377018"></A>Name (_PCT, Package() </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377019"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377020"></A>    ResourceTemplate(){Perf_Ctrl_Register},        //Generic Register Descriptor</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377021"></A>    ResourceTemplate(){Perf_Status_Register}        //Generic Register Descriptor</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377022"></A>}) // End of _PCT</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1377030"></A>_<A NAME="RSVD_PSS"></A>PSS (Performance Supported States)<A NAME="marker-1377028"></A><A NAME="marker-1377029"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377031"></A>This optional object indicates to OSPM the number of supported processor performance states that any given system can support. This object evaluates to a packaged list of information about available performance states including internal CPU core frequency, typical power dissipation, control register values needed to transition between performance states, and status register values that allow OSPM to verify performance transition status after any OS-initiated transition change request. The list is sorted in descending order by typical power dissipation. As a result, the zeroth entry describes the highest performance state and the &#8216;nth&#8217; entry describes the lowest performance state.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377032"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377033"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377034"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377035"></A>A variable-length Package containing a list of Pstate sub-packages as described below</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377036"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1377038"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377039"></A>    PState [0]                // Package - Performance state 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377040"></A>    ....</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377041"></A>    PState [n]                // Package - Performance state n</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377042"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450151"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377043"></A>Each Pstate sub-Package contains the elements described below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377045"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450165"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377046"></A>    CoreFrequency           // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377047"></A>    Power                   // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377048"></A>    Latency                 // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377049"></A>    BusMasterLatency        // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377050"></A>    Control                 // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377051"></A>    Status                  // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377052"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1377053"></A>PState Package Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1444371"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1444373"></A>Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1444375"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377062"></A>Core Frequency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377064"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377066"></A>Indicates the core CPU operating frequency (in MHz).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377068"></A>Power</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377070"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377072"></A>Indicates the performance state&#8217;s maximum power dissipation (in milliwatts).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377074"></A>Latency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377076"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377078"></A>Indicates the worst-case latency in microseconds that the CPU is unavailable during a transition from any performance state to this performance state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377080"></A>Bus Master Latency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377082"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377084"></A>Indicates the worst-case latency in microseconds that Bus Masters are prevented from accessing memory during a transition from any performance state to this performance state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377086"></A>Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377088"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377090"></A>Indicates the value to be written to the Performance Control Register (PERF_CTRL) in order to initiate a transition to the performance state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377092"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377094"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377096"></A>Indicates the value that OSPM will compare to a value read from the Performance Status Register (PERF_STATUS) to ensure that the transition to the performance state was successful. OSPM may always place the CPU in the lowest power state, but additional states are only available when indicated by the _PPC method.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1377106"></A>_<A NAME="RSVD_PPC"></A>PPC (Performance Present Capabilities)<A NAME="marker-1377104"></A><A NAME="marker-1377105"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377107"></A>This optional object is a method that dynamically indicates to OSPM the number of performance states currently supported by the platform. This method returns a number that indicates the _PSS entry number of the highest performance state that OSPM can use at a given time. OSPM may choose the corresponding state entry in the _PSS as indicated by the value returned by the _PPC method or any lower power (higher numbered) state entry in the _PSS. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377108"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377109"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377110"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1379119"></A>An Integer containing the range of states supported</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379120"></A>0 -    States 0 through nth state are available (all states available) </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1379121"></A>1 -    States 1 through nth state are available</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377114"></A>2 -    States 2 through nth state are available</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377115"></A>...</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377116"></A>n -    State n is available only</P>
<P CLASS="Body">
<A NAME="pgfId-1377117"></A>In order to support dynamic changes of _PPC object, Notify events on the processor object are allowed. Notify events of type 0x80 will cause OSPM to reevaluate any _PPC objects residing under the particular processor object notified. This allows AML code to notify OSPM when the number of supported states may have changed as a result of an asynchronous event (AC insertion/removal, docked, undocked, and so on).</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1377118"></A> OSPM _OST Evaluation</H6>
<P CLASS="Body">
<A NAME="pgfId-1377119"></A>When processing of the _PPC object evaluation completes, OSPM evaluates the _OST object, if present under the Processor device, to convey _PPC evaluation status to the platform. _OST arguments specific to _PPC evaluation are described below.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377120"></A>Arguments: (2)</H4>
<P CLASS="Body">
<A NAME="pgfId-1451891"></A>Arg0 - Source Event (Integer) : 0x80</P>
<P CLASS="Body">
<A NAME="pgfId-1377122"></A>Arg1 - Status Code (Integer) : see below</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377123"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377124"></A>None</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377125"></A>Argument Information:</H3>
<P CLASS="Body">
<A NAME="pgfId-1377126"></A>Arg1 - Status Code</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1451882"></A>0: Success - OSPM is now using the performance states specified</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1454861"></A>1: Failure - OSPM has not changed the number of performance states in use.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1377128"></A> Processor Performance Control Example</H6>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377129"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1377130"></A>This is an example of processor performance control objects in a processor object list.</P>
<P CLASS="Body">
<A NAME="pgfId-1377131"></A>In this example, a uniprocessor platform that has processor performance capabilities with support for three performance states as follows:</P>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1377132"></A>500 MHz (8.2W) supported at any time</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1377133"></A>600 MHz (14.9W) supported only when AC powered</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1377134"></A>650 MHz (21.5W) supported only when docked</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1377141"></A>It takes no more than 500 microseconds to transition from one performance state to any other performance state.</P>
<P CLASS="Body">
<A NAME="pgfId-1377142"></A>During a performance transition, bus masters are unable to access memory for a maximum of 300 microseconds.</P>
<P CLASS="Body">
<A NAME="pgfId-1377143"></A>The PERF_CTRL and PERF_STATUS registers are implemented as Functional Fixed Hardware.</P>
<P CLASS="Body">
<A NAME="pgfId-1377144"></A>The following ASL objects are implemented within the system:</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1377145"></A>&#92;_SB.DOCK:    Evaluates to 1 if system is docked, zero otherwise.</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1377146"></A>&#92;_SB.AC:    Evaluates to 1 if AC is connected, zero otherwise.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377148"></A>    Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377149"></A>        &#92;_SB.CPU0,                                             // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377150"></A>        1,                                                     // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377151"></A>        0x120,                                                 // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377152"></A>        6 )                                                    // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377153"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377154"></A>        Name(_PCT, Package ()                                  // Performance Control object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377155"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377156"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},   // PERF_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377157"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)}    // PERF_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377158"></A>        }) // End of _PCT object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377159"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377160"></A>        Name (_PSS, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377161"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377162"></A>            Package(){650, 21500, 500, 300, 0x00, 0x08},       // Performance State zero (P0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377163"></A>            Package(){600, 14900, 500, 300, 0x01, 0x05},       // Performance State one (P1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377164"></A>            Package(){500, 8200,  500, 300, 0x02, 0x06}        // Performance State two (P2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377165"></A>        }) // End of _PSS object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377166"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377167"></A>        Method (_PPC, 0)        // Performance Present Capabilities method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377168"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377169"></A>            If (&#92;_SB.DOCK)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377170"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377171"></A>                Return(0)        // All _PSS states available (650, 600, 500).</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377172"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377173"></A>            If (&#92;_SB.AC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377174"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377175"></A>                Return(1)        // States 1 and 2 available (600, 500).</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377176"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377177"></A>            Else</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377178"></A>            {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377179"></A>                Return(2)        // State 2 available (500)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377180"></A>            }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377181"></A>        } // End of _PPC method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377182"></A>    } // End of processor object list</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450172"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377183"></A>The platform will issue a Notify(&#92;_SB.CPU0, 0x80) to inform OSPM to re-evaluate this object when the number of available processor performance states changes.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1377189"></A>_<A NAME="RSVD_PSD"></A>PSD (P-State Dependency)<A NAME="marker-1377187"></A><A NAME="marker-1377188"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1377190"></A>This optional object provides performance control, P-state or CPPC, logical processor dependency information to OSPM. The _PSD object evaluates to a packaged list containing a single entry that expresses the performance control dependency among a set of logical processors. </P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377191"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377192"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377193"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377194"></A>A Package with a single entry consisting of a P-state dependency Package as described below.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377195"></A>Return Value Information</H3>
<P CLASS="CodeExample">
<A NAME="pgfId-1377197"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450179"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377198"></A>    PStateDependency[0]    // Package</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377201"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450186"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377202"></A>The PStateDependency sub-Package contains the elements described below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377204"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450193"></A>Package { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377205"></A>    NumEntries             // Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377206"></A>    Revision               // Integer (BYTE)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377207"></A>    Domain                 // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377208"></A>    CoordType              // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377209"></A>    NumProcessors          // Integer (DWORD)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377210"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1450200"></A>&nbsp;</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1377211"></A>PStateDependency Package Values</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377214"></A>Element</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377216"></A>Object Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377218"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377220"></A>NumEntries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377222"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377224"></A>The number of entries in the PStateDependency package including this field. Current value is 5.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377226"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377228"></A>Integer<BR>
(BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377230"></A>The revision number of the PStateDependency package format. Current value is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377232"></A>Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377234"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377236"></A>The dependency domain number to which this P state entry belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377238"></A>CoordType</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377240"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377242"></A>The type of coordination that exists (hardware) or is required (software) as a result of the underlying hardware dependency. Could be either 0xFC (SW_ALL), 0xFD (SW_ANY) or 0xFE (HW_ALL) indicating whether OSPM is responsible for coordinating the P-state transitions among processors with dependencies (and needs to initiate the transition on all or any processor in the domain) or whether the hardware will perform this coordination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377244"></A>Num Processors</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377246"></A>Integer<BR>
(DWORD)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377248"></A>The number of processors belonging to the domain for this logical processor&#8217;s P-states. OSPM will not start performing power state transitions to a particular P-state until this number of processors belonging to the same domain have been detected and started.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377252"></A>Example</H3>
<P CLASS="Body">
<A NAME="pgfId-1454876"></A>This is an example usage of the _PSD structure in a Processor structure in the namespace. The example represents a two processor configuration with three performance states per processor. For all performance states, there exists dependence between the two processors, such that one processor transitioning to a particular performance state, causes the other processor to transition to the same performance state. OSPM will be required to coordinate the P-state transitions between the two processors and can initiate a transition on either processor to cause both to transition to the common target P-state.</P>
<P CLASS="Body">
<A NAME="pgfId-1454885"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1454877"></A>    Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377256"></A>        &#92;_SB.CPU0,               // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377257"></A>        1,                       // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377258"></A>        0x120,                   // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377259"></A>        6 )                      // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377260"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377261"></A>        Name(_PCT, Package ()    // Performance Control object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377262"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377263"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},        // PERF_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377264"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)}         // PERF_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377265"></A>        }) // End of _PCT object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377266"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377267"></A>        Name (_PSS, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377268"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377269"></A>            Package(){650, 21500, 500, 300, 0x00, 0x08},    // Performance State zero (P0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377270"></A>            Package(){600, 14900, 500, 300, 0x01, 0x05},    // Performance State one (P1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377271"></A>            Package(){500, 8200,  500, 300, 0x02, 0x06}     // Performance State two (P2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377272"></A>        }) // End of _PSS object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377273"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377274"></A>        Method (_PPC, 0)        // Performance Present Capabilities method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377275"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377276"></A>        } // End of _PPC method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377277"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377278"></A>        Name (_PSD, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377279"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377280"></A>            Package(){5, 0, 0, 0xFD, 2}    // 5 entries, Revision 0), Domain 0, OSPM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377281"></A>                                           // Coordinate, Initiate on any Proc, 2 Procs</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377282"></A>        }) // End of _PSD object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377283"></A>    } // End of processor object list</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377284"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377285"></A>    Processor (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377286"></A>        &#92;_SB.CPU1,                // Processor Name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377287"></A>        2,                        // ACPI Processor number</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377288"></A>        ,                         // PBlk system IO address</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377289"></A>        )                         // PBlkLen</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377290"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377291"></A>        Name(_PCT, Package ()     // Performance Control object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377292"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377293"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)},  // PERF_CTRL</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377294"></A>            ResourceTemplate(){Register(FFixedHW, 0, 0, 0)}   // PERF_STATUS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377295"></A>        }) // End of _PCT object</P>
<P CLASS="Body">
<A NAME="pgfId-1377296"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377297"></A>        Name (_PSS, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377298"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377299"></A>            Package(){650, 21500, 500, 300, 0x00, 0x08},    // Performance State zero (P0)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377300"></A>            Package(){600, 14900, 500, 300, 0x01, 0x05},    // Performance State one (P1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377301"></A>            Package(){500, 8200,  500, 300, 0x02, 0x06}     // Performance State two (P2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377302"></A>        }) // End of _PSS object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1444376"></A>  </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1444377"></A>        Method (_PPC, 0)                   // Performance Present Capabilities method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1444378"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377306"></A>        }                                  // End of _PPC method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377307"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377308"></A>        Name (_PSD, Package()</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377309"></A>        {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377310"></A>            Package(){5, 0, 0, 0xFD, 2}    // 5 entries, Revision 0, Domain 0, OSPM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377311"></A>                                           // Coordinate, Initiate on any Proc, 2 Procs</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377312"></A>        }) // End of _PSD object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1377313"></A>    } // End of processor object list</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1377316"></A><A NAME="49360"></A>   _PDL (P-state Depth Limit)</H6>
<P CLASS="Body">
<A NAME="pgfId-1377317"></A>This optional object evaluates to the _PSS entry number of the lowest performance P-state that OSPM may use when performing passive thermal control. OSPM may choose the corresponding state entry in the _PSS as indicated by the value returned by the _PDL object or a higher performance (lower numbered) state entry in the _PSS down to and including the _PSS entry number returned by the _PPC object or the first entry in the table (if _PPC is not implemented). The value returned by the _PDL object must be greater than or equal to the value returned by the _PPC object or the corresponding value to the last entry in the _PSS if _PPC is not implemented. In the event of a conflict between the values returned by the evaluation of the _PDL and _PPC objects, OSPM gives precedence to the _PPC object, limiting power consumption.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377318"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377319"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377320"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377321"></A>An Integer containing the P-state Depth Limit _PSS entry number:</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377322"></A>0 - P0 is the only P-state available for OSPM use </P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377323"></A>1 - state 1 is the lowest power P-state available</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377324"></A>2 - state 2 is the lowest power P-state available</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377325"></A>...</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377326"></A>n - state n is the lowest power P-state available</P>
<P CLASS="Body">
<A NAME="pgfId-1377327"></A>In order for the platform to dynamically indicate a change in the P-state depth limit, Notify events on the processor object of type 0x80 will cause OSPM to reevaluate any _PDL object in the processor&#8217;s object list. This allows AML code to notify OSPM when the number of supported performance states may have changed as a result of an asynchronous event.&#92;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1450561"></A><A NAME="30073"></A>Collaborative Processor Performance Control</H6>
<P CLASS="Body">
<A NAME="pgfId-1450562"></A>Collaborative processor performance control defines an abstracted and flexible mechanism for OSPM to collaborate with an entity in the platform to manage the performance of a logical processor. In this scheme, the platform entity is responsible for creating and maintaining a performance definition that backs a continuous, abstract, unit-less performance scale. During runtime, OSPM requests desired performance on this abstract scale and the platform entity is responsible for translating the OSPM performance requests into actual hardware performance states. The platform may also support the ability to autonomously select a performance level appropriate to the current workload. In this case, OSPM conveys information to the platform that guides the platform's performance level selection. </P>
<P CLASS="Body">
<A NAME="pgfId-1455251"></A>Prior processor performance controls (P-states and T-states) have described their effect on processor performance in terms of processor frequency. While processor frequency is a rough approximation of the speed at which the processor completes work, workload performance isn&#8217;t guaranteed to scale with frequency. Therefore, rather than prescribe a specific metric for processor performance, Collaborative Processor Performance Control leaves the definition of the exact performance metric to the platform. The platform may choose to use a single metric such as processor frequency, or it may choose to blend multiple hardware metrics to create a synthetic measure of performance. In this way the platform is free to deliver the OSPM requested performance level without necessarily delivering a specific processor frequency. OSPM must make no assumption about the exact meaning of the performance values presented by the platform, or how they may correlate to specific hardware metrics like processor frequency. </P>
<P CLASS="Body">
<A NAME="pgfId-1459662"></A>Platforms must use the same performance scale for all processors in the system. On platforms with heterogeneous processors, the performance characteristics of all processors may not be identical. In this case, the platform must synthesize a performance scale that adjusts for differences in processors, such that any two processors running the same workload at the same performance level will complete in approximately the same time. The platform should expose different capabilities for different classes of processors, so as to accurately reflect the performance characteristics of each processor.</P>
<P CLASS="Body">
<A NAME="pgfId-1455252"></A>The control mechanisms are abstracted by the _CPC object method, which describes how to control and monitor processor performance in a generic manner. The register methods may be implemented in the Platform Communications Channel (PCC) interface (see <A HREF="Platform_Comm_Channel.htm#68313" CLASS="XRef">See Platform Communications Channel (PCC).</A>). This provides sufficient flexibility that the entity OSPM communicates with may be the processor itself, the platform chipset, or a separate entity (e.g., a BMC).</P>
<P CLASS="Body">
<A NAME="pgfId-1470127"></A>In order to provide backward compatibility with existing tools that report  processor performance as frequencies,  the _CPC object can optionally provide processor frequency range values for use by the OS.  If these frequency values are provided, the restrictions on _CPC information usage still remain: the OSPM must make no assumption about the exact meaning of the performance values presented by the platform, and all functional decisions and interaction with the platform still happen using the abstract performance scale.  The frequency values are only contained in the _CPC object  to allow the OS  to present performance data in  a simple frequency range, when frequency is not discoverable from the platform via another mechanism.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1452097"></A><A NAME="91893"></A>   _CPC (Continuous Performance Control)</H6>
<P CLASS="Body">
<A NAME="pgfId-1457086"></A>This optional object declares an interface that allows OSPM to transition the processor into a performance state based on a continuous range of allowable values. OSPM writes the desired performance value to the Desired Performance Register, and the platform maps the desired performance to an internal performance state.. If supported by the platform, OSPM may alternatively enable autonomous performance level selection while specifying minimum and maximum performance requirements.</P>
<P CLASS="Body">
<A NAME="pgfId-1459409"></A>Optional _CPC package fields that are not supported by the platform should be encoded as follows:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1459410"></A>Integer fields: Integer 0</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1459411"></A>Register fields: the following NULL register descriptor should be used:</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1459442"></A> &nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1455950"></A>ResourceTemplate() {Register {(SystemMemory, 0, 0, 0, 0)}} </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1455951"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1455730"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1455767"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1455733"></A>A Package containing the performance control information.</P>
<P CLASS="Body">
<A NAME="pgfId-1455735"></A>The performance control package contains the elements described below:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452099"></A>Package</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452100"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452101"></A>        NumEntries,                                    // Integer</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452102"></A>        Revision,                                      // Integer</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452103"></A>        HighestPerformance,                            // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452104"></A>        NominalPerformance,                            // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452105"></A>        LowestNonlinearPerformance,                    // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452106"></A>        LowestPerformance,                             // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452107"></A>        GuaranteedPerformanceRegister,                 // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452108"></A>        DesiredPerformanceRegister	,                    // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452109"></A>        MinimumPerformanceRegister	,                    // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452327"></A>        MaximumPerformanceRegister	,                    // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452328"></A>        PerformanceReductionToleranceRegister,         // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452329"></A>        TimeWindowRegister,                            // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456290"></A>        CounterWraparoundTime,                         // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456291"></A>        ReferencePerformanceCounterRegister,           // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456292"></A>        DeliveredPerformanceCounterRegister,           // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456285"></A>        PerformanceLimitedRegister,                    // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456286"></A>        CPPCEnableRegister                             // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456304"></A>        AutonomousSelectionEnable,                     // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457154"></A>        AutonomousActivityWindowRegister,              // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457155"></A>        EnergyPerformancePreferenceRegister,           // Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457192"></A>        ReferencePerformance                           // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1470168"></A>        LowestFrequency,																 // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1470143"></A>        NominalFrequency																 // Integer or Buffer (Resource Descriptor)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456287"></A>}</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1452119"></A>Continuous Performance Control Package Values</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1452279"></A>Element</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1452281"></A>Object Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1452283"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452128"></A>NumEntries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452130"></A>Integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452132"></A>The number of entries in the _CPC package, including this one. Current value is 23.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452134"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452136"></A>Integer (BYTE)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452138"></A>The revision number of the _CPC package format. Current value is 3.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452140"></A>Highest Performance</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452142"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452144"></A>Indicates the highest level of performance the processor is theoretically capable of achieving, given ideal operating conditions. If this element is an Integer, OSPM reads the integer value directly. If this element is a Buffer, it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452146"></A>Nominal Performance</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452148"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452150"></A>Indicates the highest sustained performance level of the processor. If this element is an Integer, OSPM reads the integer value directly. If this element is a Buffer, it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452152"></A>Lowest Nonlinear Performance</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452154"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452156"></A>Indicates the lowest performance level of the processor with non-linear power savings. If this element is an Integer, OSPM reads the integer value directly. If this element is a Buffer, it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452158"></A>Lowest Performance</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452160"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452162"></A>Indicates the lowest performance level of the processor. If this element is an Integer, OSPM reads the integer value directly. If this element is a Buffer, it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452164"></A>Guaranteed Performance Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452166"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452168"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes the register to read the current guaranteed performance from. See the section &#8220;Performance Limiting&#8221; for more details. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452170"></A>Desired Performance Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452172"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452174"></A>Contains a resource descriptor with a single Register() descriptor that describes the register to write the desired performance level. This register is optional when OSPM indicates support for CPPC2 in the platform-wide _OSC capabilities and the Autonomous Selection Enable register is Integer 1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452176"></A>Minimum Performance Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452178"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452180"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes the register to write the minimum allowable performance level to. The value 0 is equivalent to Lowest Performance (no limit).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452182"></A>Maximum Performance Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452184"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452186"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes the register to write the maximum allowable performance level to. All 1s is equivalent to Highest Performance (no limit).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452188"></A>Performance Reduction Tolerance Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452190"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452192"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes the register to write the performance reduction tolerance.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452194"></A>Time Window Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452196"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452198"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes the register to write the nominal length of time (in ms) between successive reads of the platform&#8217;s delivered performance register. See the section &#8220;Time Window Register&#8221; for more details.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452200"></A>Counter Wraparound Time</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452202"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452204"></A>Optional. If supported, indicates the minimum time to counter wraparound, in seconds. If this element is an Integer, OSPM reads the integer value directly. If this element is a Buffer (and supported), it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452206"></A>Reference Performance Counter Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452208"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452210"></A>Contains a resource descriptor with a single Register() descriptor that describes the register to read a counter that accumulates at a rate proportional the reference performance of the processor.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452212"></A>Delivered Performance Counter Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452214"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452216"></A>Contains a resource descriptor with a single Register() descriptor that describes the register to read a counter that accumulates at a rate proportional to the delivered performance of the processor.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452218"></A>Performance Limited Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452220"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452222"></A>Contains a resource descriptor with a single Register() descriptor that describes the register to read to determine if performance was limited. A nonzero value indicates performance was limited. This register is sticky, and will remain set until reset or OSPM clears it by writing 0. See the section &#8220;Performance Limiting&#8221; for more details.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452224"></A>CPPC EnableRegister</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452226"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1452228"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes a register to which OSPM writes a One to enable CPPC on this processor. Before this register is set, the processor will be controlled by legacy mechanisms (ACPI P-states, firmware, etc.).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457531"></A>Autonomous Selection Enable </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457684"></A>Integer (DWORD) or Buffer</P>
<P CLASS="TableBody">
<A NAME="pgfId-1457533"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457535"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes a register to which OSPM writes a One to enable autonomous performance level selection. Platforms that exclusively support Autonomous Selection must populate this field as an Integer with a value of 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457537"></A>AutonomousActivityWindowRegister</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457539"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457541"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes a register to which OSPM writes a time value that indicates a moving utilization sensitivity window for the autonomous selection policy.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457543"></A>EnergyPerformancePreferenceRegister</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457545"></A>Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1457547"></A>Optional. If supported, contains a resource descriptor with a single Register() descriptor that describes a register to which OSPM writes a value to control the Energy vs. Performance preference of the platform's energy efficiency and performance optimization policies when Autonomous Selection is enabled</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1456388"></A>Reference Performance </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1456390"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1456392"></A>Optional. If supported, indicates the performance level at which the Reference Performance Counter accumulates.  If  not supported, The Reference Performance Counter accumulates at the Nominal performance level. If this element is an Integer, OSPM reads the integer value directly. If this element is a Buffer (and supported), it must contain a Resource Descriptor with a single Register() to read the value from</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1470233"></A>Lowest Frequency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1470235"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1470293"></A>Optional.  If supported, indicates the lowest  frequency for this processor in MHz.  It should correspond roughly to the Lowest Performance value, but is not guaranteed to have any precise correlation.  This value should only  be used for the purpose of reporting processor performance in absolute frequency rather than on an abstract scale, and not for functional decisions or platform communication.   If this element is an Integer, OSPM reads the integer value directly.  If this element is a Buffer (and supported), it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1470239"></A>Nominal Frequency</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1470241"></A>Integer (DWORD) or Buffer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1470366"></A>Optional.  If supported, indicates the nominal frequency for this processor in MHz.  It should correspond roughly to the Nominal Performance value, but is not guaranteed to have any precise correlation.  This value should only  be used for the purpose of reporting processor performance in absolute frequency rather than on an abstract scale, and not for functional decisions or platform communication.    If this element is an Integer, OSPM reads the integer value directly.  If this element is a Buffer (and supported), it must contain a Resource Descriptor with a single Register() to read the value from.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1452089"></A>The _CPC object provides OSPM with platform-specific performance capabilities / thresholds and control registers that OSPM uses to control the platform&#8217;s processor performance settings. These are described in the following sections. While the platform may specify register sizes within an allowable range, the size of the capabilities / thresholds registers must be compatible with the size of the control registers. If the platform supports CPPC, the _CPC object must exist under all processor objects. That is, OSPM is not expected to support mixed mode (CPPC &amp; legacy PSS, _PCT, _PPC) operation.</P>
<P CLASS="Body">
<A NAME="pgfId-1470535"></A>Starting with ACPI Specification 6.2, all _CPC registers can be in PCC, System Memory, System IO, or Functional Fixed Hardware address spaces. OSPM support for this more flexible register space scheme is indicated by the &#8220;Flexible Address Space for CPPC Registers&#8221; _OSC bit.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1450565"></A><A NAME="84785"></A>Performance Capabilities / Thresholds</H6>
<P CLASS="Body">
<A NAME="pgfId-1451433"></A>Performance-based controls operate on a continuous range of processor performance levels, not discrete processor states. As a result, platform capabilities and OSPM requests are specified in terms of performance thresholds. <A HREF="Processor_Configuration_and_Control.htm#31458" CLASS="XRef">See Platform performance thresholds.</A> outlines the static performance thresholds of the platform and the dynamic guaranteed performance threshold.</P>
<P CLASS="Body">
<A NAME="pgfId-1455321"></A>&nbsp;</P>
<DIV>
<IMG SRC="Processor_Configuration_and_Control-11.gif" ALT="">
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1458992"></A><A NAME="31458"></A>Platform performance thresholds</H6>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1459020"></A>Not all performance levels need be unique. A platform's nominal performance level may also be its highest performance level, for example.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1459013"></A>Highest performance</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452588"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452622"></A>Attribute:          Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452623"></A>Size:               8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1451428"></A>Highest performance is the absolute maximum performance an individual processor may reach, assuming ideal conditions. This performance level may not be sustainable for long durations, and may only be achievable if other platform components are in a specific state; for example, it may require other processors be in an idle state. </P>
<P CLASS="Body">
<A NAME="pgfId-1470896"></A>Notify events of type 0x85 to the processor device object cause OSPM to re-evaluate the Highest Performance Register, but only when it is encoded as a buffer. Note: OSPM will not re-evaluate the _CPC object as a result of the notification.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1452657"></A><A NAME="13950"></A>Nominal Performance</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452761"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452763"></A>Attribute:           Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452764"></A>Size:                8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1452735"></A>Nominal Performance is the maximum sustained performance level of the processor, assuming ideal operating conditions. In absence of an external constraint (power, thermal, etc.) this is the performance level the platform is expected to be able to maintain continuously. All processors are expected to be able to sustain their nominal performance state simultaneously.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1457739"></A>Reference Performance</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457741"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457830"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457832"></A>Attribute:             Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1457745"></A>Size:                  8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1459387"></A>If supported by the platform, Reference Performance is the rate at which the Reference Performance Counter increments. If not implemented (or zero), the Reference Performance Counter increments at a rate corresponding to the Nominal Performance level.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1459388"></A>Lowest Nonlinear Performance</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453488"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452800"></A>Attribute:             Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452801"></A>Size:                  8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1452746"></A>Lowest Nonlinear Performance is the lowest performance level at which nonlinear power savings are achieved, for example, due to the combined effects of voltage and frequency scaling. Above this threshold, lower performance levels should be generally more energy efficient than higher performance levels. In traditional terms, this represents the P-state range of performance levels.</P>
<P CLASS="Body">
<A NAME="pgfId-1457817"></A>This register effectively conveys the most efficient performance level to OSPM.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1450640"></A><A NAME="95958"></A>Lowest Performance</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452835"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452823"></A>Attribute:             Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452824"></A>Size:                  8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1453481"></A>Lowest Performance is the absolute lowest performance level of the platform. Selecting a performance level lower than the lowest nonlinear performance level may actually cause an efficiency penalty, but should reduce the instantaneous power consumption of the processor. In traditional terms, this represents the T-state range of performance levels.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1452843"></A>Guaranteed Performance Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453502"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452875"></A>Attribute:             Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452876"></A>Size:                  8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1452849"></A>Guaranteed Performance Register conveys to OSPM a Guaranteed Performance level, which is the current maximum sustained performance level of a processor, taking into account all known external constraints (power budgeting, thermal constraints, AC vs DC power source, etc.). All processors are expected to be able to sustain their guaranteed performance levels simultaneously. The guaranteed performance level is required to fall in the range [Lowest Performance, Nominal performance], inclusive.</P>
<P CLASS="Body">
<A NAME="pgfId-1452850"></A>If this register is not implemented, and Autonomous Selection is not enabled, OSPM assumes guaranteed performance is always equal to nominal performance.</P>
<P CLASS="Body">
<A NAME="pgfId-1452851"></A>Notify events of type 0x83 to the processor device object will cause OSPM to re-evaluate the Guaranteed Performance Register. Changes to guaranteed performance should not be more frequent than once per second. If the platform is not able to guarantee a given performance level for a sustained period of time (greater than one second), it should guarantee a lower performance level and opportunistically enter the higher performance level as requested by OSPM and allowed by current operating conditions.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1470396"></A>Lowest Frequency and Nominal Frequency</H6>
<P CLASS="Body">
<A NAME="pgfId-1470426"></A><EM CLASS="CodeCharacter">
Optional</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1470427"></A><EM CLASS="CodeCharacter">
Register or DWORD</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1470429"></A><EM CLASS="CodeCharacter">
Attribute:	Read</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1470430"></A><EM CLASS="CodeCharacter">
Size:		32 bits</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1470431"></A>If supported by the platform, Lowest Frequency and Nominal Frequency values convey are the lowest and nominal CPU frequencies of the platform, respectively, in megahertz (MHz).   They should correspond roughly to Lowest Performance and Nominal Performance on the CPPC abstract performance scale but precise correlation is not guaranteed. See <A HREF="Processor_Configuration_and_Control.htm#95958" CLASS="XRef">See Lowest Performance.</A> and <A HREF="Processor_Configuration_and_Control.htm#13950" CLASS="XRef">See Nominal Performance.</A> for definitions of lowest and nominal performance.</P>
<P CLASS="Body">
<A NAME="pgfId-1470415"></A>These values should not be used for functional decision making or platform communication which are based on the CPPC abstract performance scale.  They are only intended to enable CPPC platforms to be backwards compatible with OSs that report performance as CPU frequencies.  The OS should use Lowest Frequency/Performance and Nominal Frequency/Performance as anchor points to create a linear mapping of CPPC abstract performance to CPU frequency, interpolating between Lowest and Nominal, and extrapolating from Nominal to Highest.  Note that this mapping is not guaranteed to be accurate since CPPC abstract performance is not required to be based purely on CPU frequency, but it is better than no data if the OS must report performance as CPU frequency.  Platforms should provide these values when they must work with OSs which need to report CPU frequency, and there is no alternate mechanism to discover this information.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1452852"></A>Performance Controls</H6>
<P CLASS="Body">
<A NAME="pgfId-1451556"></A>Under CPPC, OSPM has several performance settings it may use in conjunction to control/influence the performance of the platform. These control inputs are outlined in <A HREF="Processor_Configuration_and_Control.htm#54518" CLASS="XRef">See OSPM performance controls.</A>.</P>
<DIV>
<IMG SRC="Processor_Configuration_and_Control-12.gif" ALT="">
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1450699"></A><A NAME="54518"></A>OSPM performance controls</H6>
<P CLASS="Body">
<A NAME="pgfId-1452934"></A>OSPM may select any performance value within the continuous range of values supported by the platform. Internally, the platform may implement a small number of discrete performance states and may not be capable of operating at the exact performance level desired by OSPM. If a platform-internal state does not exist that matches OSPM&#8217;s desired performance level, the platform should round desired performance as follows:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1452935"></A>If OSPM has selected a desired performance level greater than or equal to guaranteed performance, the platform may round up or down. The result of rounding must not be less than guaranteed performance.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1452936"></A>If OSPM has selected a desired performance level less than guaranteed performance and a maximum performance level not less than guaranteed performance, the platform must round up. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1452937"></A>If OSPM has selected both desired performance level and maximum performance level less than guaranteed performance, the platform must round up if rounding up does not violate the maximum performance level. Otherwise, round down. OSPM must tolerate the platform rounding down if it chooses to set the maximum performance level less than guaranteed performance.This approach favors performance, except in the case where performance has been limited due to a platform or OSPM constraint.</P>
<P CLASS="Body">
<A NAME="pgfId-1457989"></A>When Autonomous Selection  is enabled, OSPM limits the processor's performance selection by writing appropriate constraining values to the Minimum and Maximum Performance registers. Setting Minimum and Maximum to the same value effectively disables Autonomous selection. </P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1459058"></A>When processors are within the same dependency domain, Maximum performance may only be actually limited when allowed by hardware coordination.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1452939"></A>Maximum Performance Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453518"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452943"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452944"></A>Size:              8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1452945"></A>Maximum Performance Register conveys the maximum performance level at which the platform may run. Maximum performance may be set to any performance value in the range [Lowest Performance, Highest Performance], inclusive.</P>
<P CLASS="Body">
<A NAME="pgfId-1458041"></A>The value written to the Maximum Performance Register conveys a request to limit maximum performance for the purpose of energy efficiency or thermal control and the platform limits its performance accordingly as possible. However, the platform may exceed the requested limit in the event it is necessitated by internal package optimization. For Example, hardware coordination among multiple logical processors with interdependencies.</P>
<P CLASS="Body">
<A NAME="pgfId-1458042"></A>OSPM's use of this register to limit performance for the purpose of thermal control must comprehend multiple logical processors with interdependencies. i.e. the same value must be written to all processors within a domain to achieve the desired result.</P>
<P CLASS="Body">
<A NAME="pgfId-1452946"></A>The platform must implement either both the Minimum Performance and Maximum Performance registers or neither register. If neither register is implemented and Autonomous Selection is disabled, the platform must always deliver the desired performance.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1452947"></A>Minimum Performance Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453534"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453536"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453537"></A>Size:              8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1458087"></A>The Minimum Performance Register allows OSPM to convey the minimum performance level at which the platform may run. Minimum performance may be set to any performance value in the range [Lowest Performance, Highest Performance], inclusive but must be set to a value that is less than or equal to that specified by the Maximum Performance Register.</P>
<P CLASS="Body">
<A NAME="pgfId-1458088"></A>In the presence of a physical constraint, for example a thermal excursion, the platform may not be able to successfully maintain minimum performance in accordance with that set via the Minimum Performance Register. In this case, the platform issues a Notify event of type 0x84 to the processor device object and sets the Minimum_Excursion bit within the Performance Limited Register.</P>
<P CLASS="Body">
<A NAME="pgfId-1452953"></A>The platform must implement either both the Minimum Performance and Maximum Performance registers or neither register. If neither register is implemented and Autonomous Selection is disabled, the platform must always deliver the desired performance.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1453461"></A>Desired Performance Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458169"></A>Optional (depending on Autonomous Selection support) </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458171"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458172"></A>Size:              8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1452960"></A>When Autonomous Selection is disabled, the Desired Performance Register is required and conveys the performance level OSPM is requesting from the platform. Desired performance may be set to any performance value in the range [Minimum Performance, Maximum Performance], inclusive. Desired performance may take one of two meanings, depending on whether the desired performance is above or below the guaranteed performance level.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1452961"></A>Below the guaranteed performance level, desired performance expresses the average performance level the platform must provide subject to the Performance Reduction Tolerance. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1452962"></A>Above the guaranteed performance level, the platform must provide the guaranteed performance level. The platform should attempt to provide up to the desired performance level, if current operating conditions allow for it, but it is not required to do so</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1458351"></A>When Autonomous Selection is enabled, it is not necessary for OSPM to assess processor workload performance demand and convey a corresponding performance delivery request to the platform via the Desired Register. If the Desired Performance Register exists, OSPM may provide an explicit performance requirement hint to the platform by writing a non-zero value. In this case, the delivered performance is not bounded by the Performance Reduction Tolerance Register, however, OSPM can influence the delivered performance by writing appropriate values to the Energy Performance Preference Register. Writing a zero value to the Desired Performance Register or the non-existence of the Desired Performance Register causes the platform to autonomously select a performance level appropriate to the current workload.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1459362"></A>The Desired Performance Register is optional only when OPSM indicates support for CPPC2 in the platform-wide _OSC capabilities and the Autonomous Selection Enable field is encoded as an Integer with a value of 1. <A NAME="marker-1459363"></A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1459364"></A>Performance Reduction Tolerance Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453567"></A></P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453568"></A>Optional </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453570"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453571"></A>Size:              8-32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1452969"></A>The Performance Reduction Tolerance Register is used by OSPM to convey the deviation below the Desired Performance that is tolerable. It is expressed by OSPM as an absolute value on the performance scale. Performance Tolerance must be less than or equal to the Desired Performance. If the platform supports the Time Window Register, the Performance Reduction Tolerance conveys the minimal performance value that may be delivered on average over the Time Window. If this register is not implemented, the platform must assume Performance Reduction Tolerance = Desired Performance.</P>
<P CLASS="Body">
<A NAME="pgfId-1458394"></A>When Autonomous Selection is enabled, values written to the Performance Reduction Tolerance Register are ignored.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1452970"></A>Time Window Register</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1453583"></A></P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453584"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453586"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453587"></A>Size:              8-32 bits</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1452976"></A>Units:             milliseconds</P>
<P CLASS="Body">
<A NAME="pgfId-1452978"></A>When Autonomous Selection is not enabled, OSPM may write a value to the Time Window Register to indicate a time window over which the platform must provide the desired performance level (subject to the Performance Reduction Tolerance). OSPM sets the time window when electing a new desired performance The time window represents the minimum time duration for OSPM&#8217;s evaluation of the platform&#8217;s delivered performance (see <A HREF="Processor_Configuration_and_Control.htm#60497" CLASS="XRef">See Performance Counters.</A> &#8220;Performance Counters&#8221; for details on how OSPM computes delivered performance). If OSPM evaluates delivered performance over an interval smaller than the specified time window, it has no expectations of the performance delivered by the platform. For any evaluation interval equal to or greater than the time window, the platform must deliver the OSPM desired performance within the specified tolerance bound. </P>
<P CLASS="Body">
<A NAME="pgfId-1452979"></A>If OSPM specifies a time window of zero or if the platform does not support the time window register, the platform must deliver performance within the bounds of Performance Reduction Tolerance irrespective of the duration of the evaluation interval. </P>
<P CLASS="Body">
<A NAME="pgfId-1458425"></A>When Autonomous Selection is enabled, values written to the Time Window Register are ignored. Reads of the Time Window register indicate minimum length of time (in ms) between successive reads of the platform's performance counters. If the Time Window register is not supported then there is no minimum time requirement between successive reads of the platform's performance counters.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1452980"></A>Performance Feedback</H6>
<P CLASS="Body">
<A NAME="pgfId-1452981"></A>The platform provides performance feedback via set of  performance counters, and a performance limited indicator.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1452982"></A><A NAME="60497"></A>Performance Counters</H6>
<P CLASS="Body">
<A NAME="pgfId-1452983"></A>To determine the actual performance level delivered over time, OSPM may read a set of performance counters from the Reference Performance Counter Register and the Delivered Performance Counter Register. </P>
<P CLASS="Body">
<A NAME="pgfId-1456920"></A>OSPM calculates the delivered performance over a given time period by taking a beginning and ending snapshot of both the reference and delivered performance counters, and calculating:</P>
<P CLASS="Body">
<A NAME="pgfId-1456950"></A><IMG SRC="Processor_Configuration_and_Control-13.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1456952"></A>The delivered performance should always fall in the range [Lowest Performance, Highest Performance], inclusive. OSPM may use the delivered performance counters as a feedback mechanism to refine the desired performance state it selects.</P>
<P CLASS="Body">
<A NAME="pgfId-1452990"></A>When Autonomous Selection is not enabled, there are constraints that govern how and when the performance delivered by the platform may deviate from the OSPM Desired Performance. Corresponding to OSPM setting a Desired Performance: at any time after that, the following constraints on delivered performance apply</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1452991"></A>Delivered performance can be higher than the OSPM requested desired performance if the platform is able to deliver the higher performance at same or lower energy than if it were delivering the desired performance. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1452992"></A>Delivered performance may be higher or lower than the OSPM desired performance if the platform has discrete performance states and needed to round down performance to the nearest supported performance level in accordance to the algorithm prescribed in the OSPM controls section.  </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1452993"></A>Delivered performance may be lower than the OSPM desired performance if the platform&#8217;s efficiency optimizations caused the delievered performance to be less than desired performance. However, the delivered performance should never be lower than the OSPM specified. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1459522"></A>Performance Reduction Tolerance. The Performance Reduction Tolerance provides a bound to the platform on how aggressive it can be when optimizing performance delivery. The platform should not perform any optimization that would cause delivered performance to be lower than the OSPM specified Performance Reduction Tolerance. </LI>
</UL>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1459530"></A>Reference Performance Counter Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453000"></A>Attribute:         Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453001"></A>Size:              32 or 64 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1458555"></A>The Reference Performance Counter Register counts at a fixed rate any time the processor is active. It is not affected by changes to Desired Performance, processor throttling, etc. If Reference Performance is supported, the Reference Performance Counter accumulates at a rate corresponding to the Reference Performance level. Otherwise, the Reference Performance Counter accumulates at the Nominal performance level.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1458552"></A>Delivered Performance Counter Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1456627"></A>Attribute:         Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453008"></A>Size:              32 or 64 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1453009"></A>The Delivered Performance Counter Register increments any time the processor is active, at a rate proportional to the current performance level, taking into account changes to Desired Performance. When the processor is operating at its reference performance level, the delivered performance counter must increment at the same rate as the reference performance counter.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1453011"></A>Counter Wraparound Time</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453680"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453014"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453016"></A>Attribute:         Read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453017"></A>Size:              32 or 64 bits</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453018"></A>Units:             seconds</P>
<P CLASS="Body">
<A NAME="pgfId-1453019"></A>Counter Wraparound Time provides a means for the  platform to specify a rollover time for the Reference/Delivered performance counters. If greater than this time period elapses between OSPM querying the feedback counters, the counters may wrap without OSPM being able to detect that they have done so.</P>
<P CLASS="Body">
<A NAME="pgfId-1453020"></A>If not implemented (or zero), the performance counters are assumed to never wrap during the lifetime of the platform.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1453428"></A>Performance Limited Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453025"></A>Attribute:          Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453026"></A>Size:               &gt;=2 bit(s)</P>
<P CLASS="Body">
<A NAME="pgfId-1453027"></A>In the event that the platform must constrain the delivered performance to less than the minimum performance or the desired performance (or, less than the guaranteed performance, if desired performance is greater than guaranteed performance) due to an unpredictable event, the platform must set the performance limited indicator to a non-zero value. This indicates to OSPM that an unpredictable event has limited processor performance, and the delivered performance may be less than desired / minimum performance. </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1458642"></A>Performance Limited Register Status Bits<A NAME="marker-1458641"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1458645"></A>Bit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1458647"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1458649"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458651"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458654"></A>Desired_Excursion<A NAME="marker-1458653"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1458656"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458658"></A>Set when Delivered Performance has been constrained to less than Desired Performance (or, less than the guaranteed performance, if desired performance is greater than guaranteed performance). This bit is not utilized when Autonomous Selection is enabled.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458660"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458662"></A>Minimum_Excursion</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458664"></A>Set when Delivered Performance has been constrained to less than Minimum Performance</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458666"></A>2-n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458668"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1458670"></A>Reserved</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1459118"></A>Bits within the Performance Limited Register are sticky, and will remain non-zero until OSPM clears the bit. The platform should only issue a Notify when Minimum Excursion transitions from 0 to 1 to avoid repeated events when there is sustained or recurring limiting but OSPM has not cleared the previous indication.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1459128"></A>All accesses to the Performance Limited Register must be made using interlocked operations, by both accessing entities.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1453028"></A>The performance limited register should only be used to report short term, unpredictable events (e.g., PROCHOT being asserted). If the platform is capable of identifying longer term, predictable events that limit processor performance, it should use the guaranteed performance register to notify OSPM of this limitation. Changes to guaranteed performance should not be more frequent than once per second. If the platform is not able to guarantee a given performance level for a sustained period of time (greater than one second), it should guarantee a lower performance level and opportunistically enter the higher performance level as requested by OSPM and allowed by current operating conditions.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1453416"></A>CPPC Enable Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453731"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453033"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1453034"></A>Size:              &gt;=1 bit(s)</P>
<P CLASS="Body">
<A NAME="pgfId-1453035"></A>If supported by the platform, OSPM writes a one to this register to enable CPPC on this processor.</P>
<P CLASS="Body">
<A NAME="pgfId-1453036"></A>If not implemented, OSPM assumes the platform always has CPPC enabled.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1458753"></A>Autonomous Selection Enable Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458755"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458756"></A>Register or DWORD</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458758"></A>Attribute:			Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458759"></A>Size:				&gt;=1 bit(s)</P>
<P CLASS="Body">
<A NAME="pgfId-1458760"></A>If supported by the platform, OSPM writes a one to this register to enable Autonomous Performance Level Selection on this processor. CPPC must be enabled via the CPPC Enable Register to enable Autonomous Performance Level Selection. Platforms that exclusively support Autonomous Selection must populate this field as an Integer with a value of 1.</P>
<P CLASS="Body">
<A NAME="pgfId-1458761"></A>When Autonomous Selection is enabled, the platform is responsible for selecting performance states. OSPM is not required to assess processor workload performance demand and convey a corresponding performance delivery request to the platform via the Desired Performance Register.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1458763"></A> Autonomous Activity Window Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458823"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458838"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458839"></A>Size:              10 bit(s)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458861"></A>Units:             Bits 06:00 - Significand, Bits 09:07 - Exponent, Base_Time_Unit = 1E-6 seconds (1 microsecond) </P>
<P CLASS="Body">
<A NAME="pgfId-1458771"></A>If supported by the platform, OSPM may write a time value (10^3-bit exp * 7-bit mantissa in 1&#181;sec units: 1us to 1270 sec) to this field to indicate a moving utilization sensitivity window to the platform's autonomous selection policy. Combined with the Energy Performance Preference Register value, the Activity Window influences the rate of performance increase / decrease of the platform's autonomous selection policy. OSPM writes a zero value to this register to enable the platform to determine an appropriate Activity Window depending on the workload.</P>
<P CLASS="Body">
<A NAME="pgfId-1458772"></A>Writes to this register only have meaning when Autonomous Selection is enabled.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1458774"></A>Energy Performance Preference Register</H6>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458915"></A>Optional</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458917"></A>Attribute:         Read/Write</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1458931"></A>Size:              4-8 bit(s</P>
<P CLASS="Body">
<A NAME="pgfId-1458780"></A>If supported by the platform, OSPM may write a range of values from 0 (performance preference) to 0xFF (energy efficiency preference) that influences the rate of performance increase /decrease and the result of the hardware's energy efficiency and performance optimization policies.This provides a means for OSPM to limit the energy efficiency impact of the platform's performance-related optimizations / control policy and the performance impact of the platform's energy efficiency-related optimizations / control policy.</P>
<P CLASS="Body">
<A NAME="pgfId-1458781"></A>Writes to this register only have meaning when Autonomous Selection is enabled.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1453404"></A>OSPM Control Policy</H6>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1453038"></A>   In-Band Thermal Control</H6>
<P CLASS="Body">
<A NAME="pgfId-1459169"></A>A processor using performance controls may be listed in a thermal zone&#8217;s _PSL list. If it is and the thermal zone engages passive cooling as a result of passing the _PSV threshold, OSPM will apply the &#8710;P[%]  to modify the value in the desired performance register. Any time that passive cooling is engaged, OSPM must also set the maximum performance register equal to the desired performance register, to enforce the platform does not exceed the desired performance opportunistically.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1459178"></A>In System-on-Chip-based platforms where the SoC is comprised of multiple device components in addition to the processor, OSPM&#8217;s use of the Desired and Maximum registers for thermal control may not produce an optimal result because of SoC device interaction. The use of proprietary package level thermal controls (if they exist) may produce more optimal results.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1453040"></A><A NAME="73784"></A>   Using PCC Registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1455442"></A>If the PCC register space is used, all PCC registers, for all processors in the same performance domain (as defined by _PSD), must be defined to be in the same subspace. If _PSD is not used, the restriction applies to all registers within a given _CPC object. OSPM will write registers by filling in the register value and issuing a PCC write command (see <A HREF="Processor_Configuration_and_Control.htm#89554" CLASS="XRef">See PCC Commands Codes used by Collaborative Processor Performance Control .</A>). It may read static registers, counters, and the performance limited register by issuing a read command (see <A HREF="Processor_Configuration_and_Control.htm#89554" CLASS="XRef">See PCC Commands Codes used by Collaborative Processor Performance Control .</A>). To amortize the cost of PCC transactions, OSPM should read or write all PCC registers via a single read or write command when possible. </P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1454988"></A><A NAME="89554"></A>PCC Commands Codes used by Collaborative Processor Performance Control </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1455195"></A>Command</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1455197"></A> Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1455199"></A>0x00</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1455201"></A>Read registers. Executed to request the platform update all registers for all enabled processors with their current value. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1455203"></A>0x01</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1455205"></A>Write registers. Executed to notify the platform one or more read/write registers for an enabled processor has been updated.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1455356"></A>0x02-0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1455358"></A>All other values are reserved.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1453042"></A><A NAME="47698"></A>   Relationship to other ACPI-defined Objects and Notifications</H6>
<P CLASS="Body">
<A NAME="pgfId-1453043"></A> If _CPC is present, its use supersedes the use of the following existing ACPI objects:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1453044"></A>The P_BLK P_CNT register</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453045"></A>_PTC</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453046"></A>_TSS</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453047"></A>_TPC</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453048"></A>_TSD</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453049"></A>_TDL</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453050"></A>_PCT</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453051"></A>_PSS</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453052"></A>_PPC</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453053"></A>_PDL</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453054"></A>Notify 0x80 on the processor device</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1453055"></A>Notify 0x82 on the processor device</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1453056"></A>The _PSD object may be used to specify domain dependencies between processors. On a system with heterogeneous processors, all processors within a single domain must have the same performance capabilities.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1453057"></A><A NAME="14651"></A>_CPC Implementation Example</H6>
<P CLASS="Body">
<A NAME="pgfId-1453058"></A>This example shows a two processor implementation of the _CPC interface via the PCC interface, in PCC subspace 2. This implementation uses registers to describe the processor&#8217;s capabilities, and does not support the Minimum Performance, Maximum Performance, or Time Window registers.</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469359"></A>Processor (&#92;_SB.CPU0, 1, 0, 0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469360"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469361"></A>	Name(_CPC, Package()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469362"></A>	{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469363"></A>		21,	// NumEntries</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469364"></A>		2,	// Revision</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469365"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x120, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469366"></A>			// Highest Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469367"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x124, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469368"></A>			// Nominal Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469369"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x128, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469370"></A>			// Lowest Nonlinear Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469371"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x12C, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469372"></A>			// Lowest Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469373"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x130, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469374"></A>			// Guaranteed Performance Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469375"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x110, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469376"></A>			// Desired Performance Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469377"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469378"></A>			// Minimum Performance Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469379"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469380"></A>			// Maximum Performance Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469381"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469382"></A>			// Performance Reduction Tolerance Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469383"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469384"></A>			// Time Window Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469385"></A>		ResourceTemplate(){Register(PCC, 8, 0, 0x11B, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469386"></A>			// Counter Wraparound Time</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469387"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x114, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469388"></A>			// Reference Performance Counter Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469389"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x116, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469390"></A>			// Delivered Performance Counter Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469391"></A>		ResourceTemplate(){Register(PCC, 8, 0, 0x11A, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469392"></A>			// Performance Limited Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469393"></A>		ResourceTemplate(){Register(PCC, 1, 0, 0x100, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469394"></A>			// CPPC Enable Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469395"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469396"></A>			// Autonomous Selection Enable </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469397"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469398"></A>			// Autonomous Activity Window Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469399"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469400"></A>			// Energy Performance Preference Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469401"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469402"></A>			// Reference Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469403"></A>	})</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469404"></A>}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469405"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469406"></A>Processor (&#92;_SB.CPU1, 2, 0, 0)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469407"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469408"></A>	Name(_CPC, Package()</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469409"></A>	{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469410"></A>		21,	// NumEntries</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469411"></A>		2,	// Revision</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469412"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x220, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469413"></A>			// Highest Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469414"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x224, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469415"></A>			// Nominal Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469416"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x228, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469417"></A>			// Lowest Nonlinear Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469418"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x22C, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469419"></A>			// Lowest Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469420"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x230, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469421"></A>			// Guaranteed Performance Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469422"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x210, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469423"></A>			// Desired Performance Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469424"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469425"></A>			// Minimum Performance Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469426"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469427"></A>			// Maximum Performance Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469428"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469429"></A>			// Performance Reduction Tolerance Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469430"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469431"></A>			// Time Window Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469432"></A>		ResourceTemplate(){Register(PCC, 8, 0, 0x21B, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469433"></A>			// Counter Wraparound Time</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469434"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x214, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469435"></A>			// Reference Performance Counter Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469436"></A>		ResourceTemplate(){Register(PCC, 32, 0, 0x216, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469437"></A>			// Delivered Performance Counter Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469438"></A>		ResourceTemplate(){Register(PCC, 8, 0, 0x21A, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469439"></A>			// Performance Limited Register </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469440"></A>		ResourceTemplate(){Register(PCC, 1, 0, 0x200, 2)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469441"></A>			// CPPC Enable Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469442"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469443"></A>			// Autonomous Selection Enable </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469444"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469445"></A>			// Autonomous Activity Window Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469446"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)},</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469447"></A>			// Energy Performance Preference Register</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469448"></A>		ResourceTemplate(){Register(SystemMemory, 0, 0, 0, 0)}</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469449"></A>			// Reference Performance</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1469450"></A>	})</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1454668"></A>_<A NAME="_Toc258262351"></A>PPE (Polling for Platform Errors) </H6>
<P CLASS="Body">
<A NAME="pgfId-1382351"></A>This optional object, when present, is evaluated by OSPM to determine if the processor should be polled to retrieve corrected platform error information. This object augments /overrides information provided in the CPEP , if supplied. See <A HREF="ACPI_Software_Programming_Model.htm#_Toc258262228" CLASS="XRef">See Corrected Platform Error Polling Table (CPEP).</A> &#8220;Corrected Platform Error Polling Table (CPEP)&#8221;.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377334"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377335"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377336"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377337"></A>An Integer containing the recommended polling interval in milliseconds.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377338"></A>0 -                              OSPM should not poll this processor.</P>
<P CLASS="ArgDefinitionBullet">
<A NAME="pgfId-1377339"></A>Other values -            OSPM should poll this processor at &lt;= the specified interval.</P>
<P CLASS="Body">
<A NAME="pgfId-1377340"></A>OSPM evaluates the _PPE object during processor object initialization and Bus Check notification processing. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1377343"></A><A NAME="81958"></A><A NAME="27320"></A>P<A NAME="_Toc258262352"></A>rocessor Aggregator Device</H2>
<P CLASS="Body">
<A NAME="pgfId-1377345"></A>The following section describes the definition and operation of the optional Processor Aggregator device.<A NAME="marker-1377344"></A> The Processor Aggregator Device provides a control point that enables the platform to perform specific processor configuration and control that applies to all processors in the platform. </P>
<P CLASS="Body">
<A NAME="pgfId-1377346"></A>The Plug and Play ID of the Processor Aggregator Device is ACPI000C.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1379376"></A> Processor Aggregator Device Objects</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377350"></A>Object</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1377352"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377354"></A>_PUR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1377356"></A>Requests a number of logical processors to be placed in an idle state</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1377361"></A>Logical Processor Idling</H6>
<P CLASS="Body">
<A NAME="pgfId-1377362"></A>In order to reduce the platform&#8217;s power consumption, the platform may direct OSPM to remove a logical processor from the operating system scheduler&#8217;s list of processors where non-processor affinitized work is dispatched. This capability is known as Logical Processor Idling and provides a means to reduce platform power consumption without undergoing processor ejection / insertion processing overhead. Interrupts directed to a logical processor and processor affinitized workloads will impede the effectiveness of logical processor idling in reducing power consumption as OSPM is not expected to re-target this work when a logical processor is idled. </P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1377365"></A><A NAME="48673"></A> PUR (Processor Utilization Request)</H6>
<P CLASS="Body">
<A NAME="pgfId-1377366"></A>The _PUR object is an optional object that may be declared under the Processor Aggregator Device and provides a means for the platform to indicate to OSPM the  number of logical processors to be idled. OSPM evaluates the _PUR object as a result of the processing of a Notify event on the Processor Aggregator device object of type 0x80.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377367"></A>Arguments:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377368"></A>None</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377369"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377370"></A>A Package as described below.</P>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377371"></A>Return Value Information</H3>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1450234"></A>Package</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1454767"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1454768"></A>    RevisionID         // Integer: Current value is 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1454769"></A>    NumProcessors      // Integer</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1377377"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1377378"></A>The NumProcessors package element conveys the number of logical processors that the platform wants OSPM to idle. This number is an absolute value. OSPM increments or decrements the number of logical processors placed in the idle state to equal the NumProcessors value as possible. A NumProcessors value of zero causes OSPM to place all logical processor in the active state as possible.</P>
<P CLASS="Body">
<A NAME="pgfId-1454944"></A>OSPM uses internal logical processor to physical core and package topology knowledge to idle logical processors successively in an order that maximizes power reduction benefit from idling requests. For example, all SMT threads constituting logical processors on a single processing core should be idled to allow the core to enter a low power state before idling SMT threads constituting logical processors on another core.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1454945"></A>OSPM _OST Evaluation</H6>
<P CLASS="Body">
<A NAME="pgfId-1454946"></A>When processing of the _PUR object evaluation completes, OSPM evaluates the _OST object, if present under the Processor Aggregator device, to convey _PUR evaluation status to the platform. _OST arguments specific to _PUR evaluation are described below.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377382"></A>Arguments: (3)</H4>
<P CLASS="Body">
<A NAME="pgfId-1377383"></A>Arg0 - Source Event (Integer) : 0x80</P>
<P CLASS="Body">
<A NAME="pgfId-1377384"></A>Arg1 - Status Code (Integer) : see below</P>
<P CLASS="Body">
<A NAME="pgfId-1377385"></A>Arg2 - Idled Procs (Buffer) : see below</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1377386"></A>Return Value:</H4>
<P CLASS="Body">
<A NAME="pgfId-1377387"></A>None</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="SubHeading">
<A NAME="pgfId-1377388"></A>Argument Information:</H3>
<P CLASS="Body">
<A NAME="pgfId-1377389"></A>Arg1 - Status Code</P>
<P CLASS="Body">
<A NAME="pgfId-1377390"></A>0: success - OSPM idled the number of logical processors indicated by the value of Arg2<BR>
1: no action was performed</P>
<P CLASS="Body">
<A NAME="pgfId-1377391"></A>Arg2 - A 4-byte buffer that represents a DWORD that is the number of logical processors that are now idled)</P>
<P CLASS="Body">
<A NAME="pgfId-1451935"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1377393"></A>The platform may request a number of logical processors to be idled that exceeds the available number of logical processors that can be idled from an OSPM context for the following reasons:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1377394"></A>The requested number is larger than the number of logical processors currently defined.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1377395"></A>Not all the defined logical processors were onlined by the OS (for example. for licensing reasons)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1354807"></A>Logical processors critical to OS function (for example, the BSP) cannot be idled.</P>
</DIV>
</DIV>
</DIV>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
1.</SPAN>
<A NAME="pgfId-1449962"></A> A thermal warning leaves room for operating system tradeoffs to occur (to start the fan or to reduce performance), but a critical thermal alert does not occur. </P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
2.</SPAN>
<A NAME="pgfId-1382288"></A> Notice that these CPU states map into the G0 working state. The state of the CPU is undefined in the G3 sleeping state, the Cx states only apply to the G0 state.</P>
<P CLASS="footnote-text">
<A NAME="pgfId-1382281"></A>&nbsp;</P>
</DIV>
</DIV>
</BODY>
</HTML>
