<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2016/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="ACPI_Software_Programming_Model.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 5 ACPI Software Programming Model</TITLE></HEAD>
<BODY>
<DIV>
<H1 CLASS="Heading-1">
<A NAME="pgfId-1354804"></A><A NAME="20338"></A>ACPI Software Programming Model<DIV>
<IMG SRC="ACPI_Software_Programming_Model-1.gif" ALT="">
</DIV>
</H1>
<P CLASS="Body">
<A NAME="pgfId-1357270"></A><A NAME="OLE_LINK7"></A><A NAME="OLE_LINK8"></A>ACPI defines a hardware register interface that an ACPI-compatible OS uses to control core power management features of a machine, as described in <A HREF="ACPI Hardware Specification.htm#44941" CLASS="XRef">See ACPI Hardware Specification.</A>, &#8220;ACPI Hardware Specification.&#8221; ACPI also provides an abstract interface for controlling the power management and configuration of an ACPI system. Finally, ACPI defines an interface between an ACPI-compatible OS and the platform runtime firmware.</P>
<P CLASS="Body">
<A NAME="pgfId-1357271"></A>To give hardware vendors flexibility in choosing their implementation, ACPI uses tables to describe system information, features, and methods for controlling those features. These tables list devices on the system board or devices that cannot be detected or power managed using some other hardware standard, plus their capabilities as described in <A HREF="ACPI_Concepts.htm#32302" CLASS="XRef">See ACPI Concepts.</A>, &#8220;Overview.&#8221; They also list system capabilities such as the sleeping power states supported, a description of the power planes and clock sources available in the system, batteries, system indicator lights, and so on. This enables OSPM to control system devices without needing to know how the system controls are implemented.</P>
<P CLASS="Body">
<A NAME="pgfId-1357273"></A>Topics covered in this section are:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357274"></A>The ACPI system description table architecture is defined, and the role of OEM-provided definition blocks in that architecture is discussed.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357275"></A>The concept of the ACPI Namespace is discussed.</LI>
</UL>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1357301"></A><A NAME="_Toc489256002"></A><A NAME="_Toc489267926"></A><A NAME="_Toc489272479"></A><A NAME="_Ref42580419"></A><A NAME="_Toc202340527"></A><A NAME="_Toc258262208"></A>Overview of the System Description Table Architecture <A NAME="marker-1357297"></A><A NAME="marker-1357298"></A><A NAME="marker-1357299"></A><A NAME="marker-1357300"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1357304"></A><A NAME="_Toc354805266"></A><A NAME="_Toc357858987"></A>The Root System Description Pointer (RSDP) structure is located in the system&#8217;s memory address space and is setup by the platform firmware. This structure contains the address of the Extended System Description Table (XSDT), which references other description tables that provide data to OSPM, supplying it with knowledge of the base system&#8217;s implementation and configuration (see <A HREF="ACPI_Software_Programming_Model.htm#68545" CLASS="XRef">See Root System Description Pointer and Table.</A>).</P>
<DIV>
<H6 CLASS="Art">
<A NAME="pgfId-1357308"></A><IMG SRC="ACPI_Software_Programming_Model-2.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H6>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1357311"></A><A NAME="68545"></A>Root System Description Pointer and Table</H6>
<P CLASS="Body">
<A NAME="pgfId-1357312"></A>All system description tables start with identical headers. The primary purpose of the system description tables is to define for OSPM various industry-standard implementation details. Such definitions enable various portions of these implementations to be flexible in hardware requirements and design, yet still provide OSPM with the knowledge it needs to control hardware directly.<A NAME="marker-1357313"></A><A NAME="marker-1357314"></A><A NAME="marker-1357315"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1374822"></A>The Extended System Description Table (XSDT) points to other tables in memory. Always the first table, it points to the Fixed ACPI Description table (FADT). The data within this table includes various fixed-length entries that describe the fixed ACPI features of the hardware. The FADT table always refers to the Differentiated System Description Table (DSDT), which contains information and descriptions for various system features. The relationship between these tables is shown in <A HREF="ACPI_Software_Programming_Model.htm#30898" CLASS="XRef">See Description Table Structures.</A>.<A NAME="marker-1357328"></A></P>
<DIV>
<H6 CLASS="spacing">
<A NAME="pgfId-1357332"></A>&nbsp;</H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Art">
<A NAME="pgfId-1357336"></A><IMG SRC="ACPI_Software_Programming_Model-3.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H6>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1357337"></A><A NAME="30898"></A>Description Table Structures</H6>
<P CLASS="Body">
<A NAME="pgfId-1357338"></A>OSPM finds the RSDP structure as described in <A HREF="ACPI_Software_Programming_Model.htm#87780" CLASS="XRef">See Finding the RSDP on IA-PC Systems.</A> (&#8220;Finding the RSDP on IA-PC Systems&#8221;) or <A HREF="ACPI_Software_Programming_Model.htm#84588" CLASS="XRef">See Finding the RSDP on UEFI Enabled Systems.</A> (&#8220;Finding the RSDP on UEFI Enabled Systems&#8221;).</P>
<P CLASS="Body">
<A NAME="pgfId-1357339"></A>When OSPM locates the structure, it looks at the physical address for the Root System Description Table or the Extended System Description Table. The Root System Description Table starts with the signature &#8220;RSDT&#8221;, while the Extended System Description Table starts with the signature &#8220;XSDT&#8221;. These tables contain one or more physical pointers to other system description tables that provide various information about the system. As shown in <A HREF="ACPI_Software_Programming_Model.htm#30898" CLASS="XRef">See Description Table Structures.</A>, there is always a physical address in the Root System Description Table for the Fixed ACPI Description table (FADT).</P>
<P CLASS="Body">
<A NAME="pgfId-1357340"></A>When OSPM follows a physical pointer to another table, it examines each table for a known signature. Based on the signature, OSPM can then interpret the implementation-specific data within the description table.<A NAME="marker-1357341"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1739593"></A>The purpose of the FADT is to define various static system information related to configuration and power management. The Fixed ACPI Description Table starts with the &#8220;FACP&#8221; signature. The FADT describes the implementation and configuration details of the ACPI hardware registers on the platform.</P>
<P CLASS="Body">
<A NAME="pgfId-1357350"></A>For a specification of the ACPI Hardware Register Blocks (PM1a_EVT_BLK, PM1b_EVT_BLK, PM1a_CNT_BLK, PM1b_CNT_BLK, PM2_CNT_BLK, PM_TMR_BLK, GP0_BLK, GP1_BLK, and one or more P_BLKs), see <A HREF="ACPI Hardware Specification.htm#_Toc489255996" CLASS="XRef">See ACPI Register Model.</A>, &#8220;ACPI Register Model.&#8221; The PM1a_EVT_BLK, PM1b_EVT_BLK, PM1a_CNT_BLK, PM1b_CNT_BLK, PM2_CNT_BLK, and PM_TMR_BLK blocks are for controlling low-level ACPI system functions.</P>
<P CLASS="Body">
<A NAME="pgfId-1357351"></A>The GPE0_BLK and GPE1_BLK blocks provide the foundation for an interrupt-processing model for Control Methods. The P_BLK blocks are for controlling processor features.</P>
<P CLASS="Body">
<A NAME="pgfId-1357352"></A>Besides ACPI Hardware Register implementation information, the FADT also contains a physical pointer to a data structure known as the Differentiated System Description Table (DSDT), which is encoded in Definition Block format (See <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256014" CLASS="XRef">See Definition Blocks.</A>, &#8220;Definition Blocks&#8221;). </P>
<P CLASS="Body">
<A NAME="pgfId-1357353"></A>A Definition Block contains information about the platform&#8217;s hardware implementation details in the form of data objects arranged in a hierarchical (tree-structured) entity known as the &#8220;ACPI namespace&#8221;, which represents the platform&#8217;s  hardware configuration.  All definition blocks loaded by OSPM combine to form one namespace that represents the platform. Data objects are encoded in a format known as ACPI Machine Language or AML for short. Data objects encoded in AML are &#8220;evaluated&#8221;  by an OSPM entity known as the AML interpreter. Their values may be static or dynamic. The AML interpreter&#8217;s dynamic data object evaluation capability includes support for programmatic evaluation, including accessing address spaces (for example, I/O or memory accesses), calculation, and logical evaluation, to determine the result. Dynamic namespace objects are known as &#8220;control methods&#8221;. OSPM &#8220;loads&#8221; an entire definition block as a logical unit - adding to or removing the associated objects from the namespace. The DSDT contains a Definition Block named the Differentiated Definition Block that contains implementation and configuration information OSPM can use to perform power management, thermal management, or Plug and Play functionality that goes beyond the information described by the ACPI hardware registers.<A NAME="marker-1357356"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357357"></A>Definition Blocks can either define new system attributes or, in some cases, build on prior definitions. A Definition Block can be loaded from system memory address space. One use of a Definition Block is to describe and distribute platform version changes.</P>
<P CLASS="Body">
<A NAME="pgfId-1357359"></A><A NAME="_Ref360197230"></A>Definition blocks enable wide variations of hardware platform implementations to be described to the ACPI-compatible OS while confining the variations to reasonable boundaries. Definition blocks enable simple platform implementations to be expressed by using a few well-defined object names. In theory, it might be possible to define a PCI configuration space-like access method within a Definition Block, by building it from I/O space, but that is not the goal of the Definition Block specification. Such a space is usually defined as a &#8220;built in&#8221; operator.</P>
<P CLASS="Body">
<A NAME="pgfId-1357362"></A><A NAME="_Ref369312458"></A><A NAME="_Ref369313863"></A>Some operators perform simple functions and others encompass complex functions. The power of the Definition Block comes from its ability to allow these operations to be glued together in numerous ways, to provide functionality to OSPM. The operators present are intended to allow many useful hardware designs to be ACPI-expressed, not to allow all hardware designs to be expressed.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357375"></A>Address Space Translation</H6>
<P CLASS="Body">
<A NAME="pgfId-1357376"></A>Some platforms may contain bridges that perform translations as I/O and/or Memory cycles pass through the bridges. This translation can take the form of the addition or subtraction of an offset. Or it can take the form of a conversion from I/O cycles into Memory cycles and back again. When translation takes place, the addresses placed on the processor bus by the processor during a read or write cycle are not the same addresses that are placed on the I/O bus by the I/O bus bridge. The address the processor places on the processor bus will be known here as the processor-relative address. And the address that the bridge places on the I/O bus will be known as the bus-relative address. Unless otherwise noted, all addresses used within this section are processor-relative addresses.<A NAME="marker-1357377"></A><A NAME="marker-1357378"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357379"></A>For example, consider a platform with two root PCI buses. The platform designer has several choices. One solution would be to split the 16-bit I/O space into two parts, assigning one part to the first root PCI bus and one part to the second root PCI bus. Another solution would be to make both root PCI buses decode the entire 16-bit I/O space, mapping the second root PCI bus&#8217;s I/O space into memory space. In this second scenario, when the processor needs to read from an I/O register of a device underneath the second root PCI bus, it would need to perform a memory read within the range that the root PCI bus bridge is using to map the I/O space.<A NAME="marker-1357380"></A></P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1357381"></A>Industry standard PCs do not provide address space translations because of historical compatibility issues.</LI>
</UL>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1357399"></A><A NAME="61173"></A>ACPI System Description Tables</H2>
<P CLASS="Body">
<A NAME="pgfId-1357400"></A>This section specifies the structure of the system description tables:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357401"></A>Root System Description Pointer (RSDP)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357402"></A>System Description Table Header</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357403"></A>Root System Description Table (RSDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357404"></A>Fixed ACPI Description Table (FADT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357405"></A>Firmware ACPI Control Structure (FACS)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357406"></A>Differentiated System Description Table (DSDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357407"></A>Secondary System Description Table (SSDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357408"></A>Multiple APIC Description Table (MADT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357409"></A>Smart Battery Table (SBST)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357410"></A>Extended System Description Table (XSDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357411"></A>Embedded Controller Boot Resources Table (ECDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357412"></A>System Locality Distance Information Table (SLIT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1738975"></A>System Resource Affinity Table (SRAT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1738995"></A>Corrected Platform Error Polling Table (CPEP)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1738976"></A>Maximum System Characteristics Table (MSCT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1738977"></A>ACPI RAS Feature Table (RASF)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1738978"></A>Memory Power StateTable (MPST)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1742140"></A>Platform Memory Topology Table (PMTT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1738979"></A>Boot Graphics Resource Table (BGRT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357413"></A>Firmware Performance Data Table (FPDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1742163"></A> Generic Timer Description Table (GTDT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1762490"></A>NVDIMM Firmware Interface Table (NFIT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1809857"></A>Heterogeneous Memory Attributes Table (HMAT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1824818"></A>Platform Debug Trigger Table (PDTT)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1807535"></A>Processor Properties Topology Table (PPTT)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1357414"></A>All numeric values in ACPI-defined tables, blocks, and structures are always encoded in little endian format. Signature values are <A NAME="_Toc459452659"></A>stored as fixed-length strings.<A NAME="marker-1762612"></A><A NAME="marker-1762613"></A><A NAME="marker-1762614"></A></P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357434"></A><A NAME="_Toc489256005"></A><A NAME="_Toc489267929"></A><A NAME="_Toc489272482"></A><A NAME="_Toc202340530"></A><A NAME="_Toc258262211"></A>Reserved Bits and Fields<A NAME="marker-1357431"></A><A NAME="marker-1357432"></A><A NAME="marker-1357433"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1357435"></A>For future expansion, all data items marked as reserved in this specification have strict meanings. This section lists software requirements for reserved fields. Notice that the list contains terms such as ACPI tables and AML code defined later in thi<A NAME="_Toc459452660"></A>s section of the specification.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357441"></A>Reserved Bits and Software Components</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357442"></A>OEM implementations of software and AML code return the bit value of 0 for all reserved bits in ACPI tables or in other software values, such as resource descriptors.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357443"></A>For all reserved bits in ACPI tables and registers, OSPM implementations must:</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357444"></A>Ignore all reserved bits that are read.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357445"></A>Preserve reserved bit values of read/write data items (for example, OSPM writes back reserved bit values it reads).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357446"></A>Write zeros to reserved bits in write-only data items.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357452"></A><A NAME="61520"></A>Reserved Values and Software Components</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357453"></A>OEM implementations of software and AML code return only defined values and do not return reserved values.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357454"></A>OSPM implementations write only defined values and do not write reserved values.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357460"></A>Reserved Hardware Bits and Software Components</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357461"></A>Software ignores all reserved bits read from hardware enable or status registers.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357462"></A>Software writes zero to all reserved bits in hardware enable registers. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357463"></A>Software ignores all reserved bits read from hardware control and status registers.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357464"></A>Software preserves the value of all reserved bits in hardware control registers by writing back read values.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357470"></A> Ignored Hardware Bits and Software Components</H6>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357471"></A>Software handles ignored bits in ACPI hardware registers the same way it handles reserved bits in these same types of registers.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357492"></A><A NAME="marker-1357489"></A>Compatibility</H6>
<P CLASS="Body">
<A NAME="pgfId-1357493"></A>All versions of the ACPI tables must maintain backward compatibility. To accomplish this, modifications of the tables consist of redefinition of previously reserved fields and values plus appending data to the 1.0 tables. Modifications of the ACPI tables require that the version numbers of the modified tables be incremented. The length field in the tables includes all additions and the checksum is maintained for the entire length of the table. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357510"></A><A NAME="_Toc489256007"></A><A NAME="_Toc489267931"></A><A NAME="_Toc489272484"></A><A NAME="_Toc202340532"></A><A NAME="_Toc258262213"></A>Address Format<A NAME="marker-1357508"></A><A NAME="marker-1357509"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1746060"></A>Addresses used in the ACPI 1.0 system description tables were expressed as either system memory or I/O space. This was targeted at the IA-32 environment. Newer architectures require addressing mechanisms beyond that defined in ACPI 1.0. To support these architectures ACPI must support 64-bit addressing and it must allow the placement of control registers in address spaces other than System I/O. </P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1746072"></A>Functional Fixed Hardware</H6>
<P CLASS="Body">
<A NAME="pgfId-1746073"></A>ACPI defines the fixed hardware low-level interfaces as a means to convey to the system OEM the minimum interfaces necessary to achieve a level of capability and quality for motherboard configuration and system power management. Additionally, the definition of these interfaces, as well as others defined in this specification, conveys to OS Vendors (OSVs) developing ACPI-compatible operating systems, the necessary interfaces that operating systems must manipulate to provide robust support for system configuration and power management.<A NAME="marker-1746074"></A><A NAME="marker-1746075"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1746076"></A>While the definition of low-level hardware interfaces defined by ACPI 1.0 afforded OSPM implementations a certain level of stability, controls for existing and emerging diverse CPU architectures cannot be accommodated by this model as they can require a sequence of hardware manipulations intermixed with native CPU instructions to provide the ACPI-defined interface function. In this case, an ACPI-defined fixed hardware interface can be functionally implemented by the CPU manufacturer through an equivalent combination of both hardware and software and is defined by ACPI as Functional Fixed Hardware.<A NAME="marker-1746077"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1746078"></A>In IA-32-based systems, functional fixed hardware can be accommodated in an OS independent manner by using System Management Mode (SMM) based system firmware. Unfortunately, the nature of SMM-based code makes this type of OS independent implementation difficult if not impossible to debug. As such, this implementation approach is not recommended. In some cases, Functional Fixed Hardware implementations may require coordination with other OS components. As such, an OS independent implementation may not be viable.<A NAME="marker-1746079"></A><A NAME="marker-1746080"></A><A NAME="marker-1746081"></A><A NAME="marker-1746082"></A><A NAME="marker-1746083"></A><A NAME="marker-1746084"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1746085"></A>OS-specific implementations of functional fixed hardware can be implemented using technical information supplied by the CPU manufacturer. The downside of this approach is that functional fixed hardware support must be developed for each OS. In some cases, the CPU manufacturer may provide a software component providing this support. In other cases support for the functional fixed hardware may be developed directly by the OS vendor.<A NAME="marker-1746086"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1746087"></A>The hardware register definition was expanded, in ACPI 2.0, to allow registers to exist in address spaces other than the System I/O address space. This is accomplished through the specification of an address space ID in the register definition (see <A HREF="ACPI_Software_Programming_Model.htm#_Ref42578254" CLASS="XRef">See Generic Address Structure.</A>, &#8220;Generic Address Structure,&#8221; for more information). When specifically directed by the CPU manufacturer, the system firmware may define an interface as functional fixed hardware by indicating 0x7F (Functional Fixed Hardware), in the address space ID field for register definitions. It is emphasized that functional fixed hardware definitions may be declared in the ACPI system firmware only as indicated by the CPU Manufacturer for specific interfaces as the use of functional fixed hardware requires specific coordination with the OS vendor. <A NAME="marker-1746091"></A><A NAME="marker-1746092"></A> <A NAME="marker-1746093"></A><A NAME="marker-1746094"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1746124"></A>Only certain ACPI-defined interfaces may be implemented using functional fixed hardware and only when the interfaces are common across machine designs for example, systems sharing a common CPU architecture that does not support fixed hardware implementation of an ACPI-defined interface. OEMs are cautioned not to anticipate that functional fixed hardware support will be provided by OSPM differently on a system-by-system basis. The use of functional fixed hardware carries with it a reliance on OS specific software that must be considered. OEMs should consult OS vendors to ensure that specific functional fixed hardware interfaces are supported by specific operating systems.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1746125"></A>FFH is permitted and applicable to both full and HW-reduced ACPI implementations.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1746130"></A>G<A NAME="_Ref42578254"></A>eneric Address Structure<A NAME="marker-1746127"></A><A NAME="marker-1746128"></A><A NAME="marker-1746129"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1357525"></A>The Generic Address Structure (GAS) provides the platform with a robust means to describe register locations. This structure, described below (<A HREF="ACPI_Software_Programming_Model.htm#79748" CLASS="XRef">See Generic Address Structure (GAS).</A>), is used to express register addresses within tables defined by ACPI .</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1357526"></A><A NAME="79748"></A>Generic Address Structure (GAS)</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739611"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739613"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739615"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739617"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357537"></A>Address Space ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357539"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357541"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357543"></A>The address space where the data structure or register exists.<BR>
Defined values are:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357544"></A>0x00		System Memory space</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357545"></A>0x01		System I/O space</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357546"></A>0x02		PCI Configuration space</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357547"></A>0x03		Embedded Controller</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357548"></A>0x04	                SMBus</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357549"></A>0x05                       SystemCMOS</P>
<P CLASS="TableBody">
<A NAME="pgfId-1835664"></A>0x06                       PciBarTarget</P>
<P CLASS="TableBody">
<A NAME="pgfId-1835714"></A>0x07                       IPMI</P>
<P CLASS="TableBody">
<A NAME="pgfId-1835748"></A>0x08                       General PurposeIO</P>
<P CLASS="TableBody">
<A NAME="pgfId-1835798"></A>0x09                       GenericSerialBus</P>
<P CLASS="TableBody">
<A NAME="pgfId-1739483"></A>0x0A		Platform Communications Channel (PCC)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1739484"></A>0x0B to 0x7E 	      Reserved</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357550"></A>0x7F		Functional Fixed Hardware</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357551"></A>0x80 to 0xBF 	      Reserved</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357552"></A>0xC0 to 0xFF	       OEM Defined</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357554"></A>Register Bit Width</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357556"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357558"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357560"></A>The size in bits of the given register. When addressing a data structure, this field must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357562"></A>Register Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357564"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357566"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357568"></A>The bit offset of the given register at the given address. When addressing a data structure, this field must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357570"></A>Access Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357572"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357574"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357576"></A>Specifies access size. Unless otherwise defined by the Address Space ID:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357577"></A>0	Undefined (legacy reasons)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357578"></A>1	Byte access</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357579"></A>2	Word access</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357580"></A>3	Dword access</P>
<P CLASS="TableBody">
<A NAME="pgfId-1357581"></A>4	QWord access</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357583"></A>Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357585"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357587"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357589"></A>The 64-bit address of the data structure or register in the given address space (relative to the processor). (See below for specific formats.)</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1357598"></A><A NAME="59940"></A>Address Space Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685511"></A>Address Space</P>
</TH>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1685513"></A>Format</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357607"></A>0-System Memory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1357609"></A>The 64-bit physical memory address (relative to the processor) of the register. 32-bit platforms must have the high DWORD set to 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357613"></A>1-System I/O</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1357615"></A>The 64-bit I/O address (relative to the processor) of the register. 32-bit platforms must have the high DWORD set to 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="7" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357619"></A>2-PCI Configuration Space</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1357622"></A>PCI Configuration space addresses must be confined to devices on<A NAME="OLE_LINK53"></A><A NAME="OLE_LINK54"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1357625"></A>PCI Segment Group 0, bus 0. This restriction exists to accommodate access to fixed hardware prior to PCI bus enumeration. The format of addresses are defined as follows:</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357631"></A>WORD Location</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357633"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357637"></A>Highest WORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357639"></A>Reserved (must be 0)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357643"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357645"></A>PCI Device number on bus 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357649"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357651"></A>PCI Function number</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357655"></A>Lowest WORD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357657"></A>Offset in the configuration space header</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1357661"></A>For example: Offset 23h of Function 2 on device 7 on bus 0 segment 0 would be represented as: 0x0000000700020023.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357665"></A>0x7F-Functional Fixed Hardware</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1357667"></A>Use of GAS fields other than Address_Space_ID is specified by the CPU manufacturer. The use of functional fixed hardware carries with it a reliance on OS specific software that must be considered. OEMs should consult OS vendors to ensure that specific functional fixed hardware interfaces are supported by specific operating systems.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787199"></A> 0x0A-PCC </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1787201"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357688"></A><A NAME="_Toc202340533"></A><A NAME="_Toc258262214"></A>Universally Unique Identifiers (UUIDs)</H6>
<P CLASS="Body">
<A NAME="pgfId-1357689"></A>UUIDs (Universally Unique IDentifiers), also known as GUIDs (Globally Unique IDentifiers) are 128 bit long values that extremely likely to be different from all other UUIDs generated until 3400 A.D. UUIDs are used to distinguish between callers of ASL methods, such as _DSM and _OSC.</P>
<P CLASS="Body">
<A NAME="pgfId-1357690"></A>The format of both the binary and string representations of UUIDs along with an algorithm to generate them is specified in <EM CLASS="contenttitle">
ISO/IEC 11578:1996 </EM>
<EM CLASS="Italic">
Information technology - Open Systems Interconnection - Remote Procedure Call (RPC) </EM>
<EM CLASS="contenttitle">
and </EM>
can be found as part of the Distributed Computing Environment 1.1: Remote Procedure Call specification, which can be found in &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Universal Uniform Identifiers (UUID)&quot;.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1357698"></A><A NAME="_Toc489256008"></A><A NAME="_Toc489267932"></A><A NAME="_Toc489272485"></A><A NAME="_Toc202340534"></A><A NAME="_Toc258262215"></A>Root System Description Pointer (RSDP)<A NAME="marker-1357697"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1357699"></A>During OS initialization, OSPM must obtain the Root System Description Pointer (RSDP) structure from the platform. When OSPM locates the Root System Description Pointer (RSDP) structure, it then locates the Root System Description Table (RSDT) or the Extended Root System Description Table (XSDT) using the physical system address supplied in the RSDP.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357700"></A><A NAME="87780"></A>Finding the RSDP on IA-PC Systems</H6>
<P CLASS="Body">
<A NAME="pgfId-1357704"></A>OSPM finds the Root System Desc<A NAME="marker-1357703"></A>ription Pointer (RSDP) structure by searching physical memory ranges on 16-byte boundaries for a valid Root System Description Pointer structure signature and checksum match as follows: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357705"></A>The first 1 KB of the Extended BIOS Data Area (EBDA). For EISA or MCA systems, the EBDA can be found in the two-byte location 40:0Eh on the BIOS data area.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357706"></A>The BIOS read-only memory space between 0E0000h and 0FFFFFh.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357707"></A><A NAME="84588"></A>Finding the RSDP on UEFI Enabled Systems</H6>
<P CLASS="Body">
<A NAME="pgfId-1357711"></A>In Unified Extensible Firmware Interfa<A NAME="marker-1357710"></A>ce (UEFI) enabled systems, a pointer to the RSDP structure exists within the EFI System Table. The OS loader is provided a pointer to the EFI System Table at invocation. The OS loader must retrieve the pointer to the RSDP structure from the EFI System Table and convey the pointer to OSPM, using an OS dependent data structure, as part of the hand off of control from the OS loader to the OS. </P>
<P CLASS="Body">
<A NAME="pgfId-1357712"></A>The OS loader locates the pointer to the RSDP structure by examining the EFI Configuration Table within the EFI System Table. EFI Configuration Table entries consist of Globally Unique Identifier (GUID)/table pointer pairs. The UEFI specification defines two GUIDs for ACPI; one for ACPI 1.0 and the other for ACPI 2.0 or later specification revisions. </P>
<P CLASS="Body">
<A NAME="pgfId-1357713"></A>The EFI GUID for a pointer to the ACPI 1.0 specification RSDP structure is: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1739002"></A><EM CLASS="SC-9-2876">
eb9d2d30</EM>
-<EM CLASS="SC-9-2876">
2d88</EM>
-11d3-<EM CLASS="SC-9-2876">
9a16</EM>
-0090273fc14d.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1357714"></A>The EFI GUID for a pointer to the ACPI 2.0 or later specification RSDP structure is: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1739013"></A>8868e871-e4f1-11d3-bc22-0080c73c8881.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1357715"></A>The OS loader for an ACPI-compatible OS will search for an RSDP structure pointer (<A HREF="ACPI_Software_Programming_Model.htm#10798" CLASS="XRef">See RSDP Structure.</A>) using the current revision GUID first and if it finds one, will use the corresponding RSDP structure pointer. If the GUID is not found then the OS loader will search for the RSDP structure pointer using the ACPI 1.0 version GUID.</P>
<P CLASS="Body">
<A NAME="pgfId-1357716"></A>The OS loader must retrieve the pointer to the RSDP structure from the EFI System Table before assuming platform control via the EFI ExitBootServices interface. See the UEFI Specification for more information.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357717"></A>Root System Description Pointer (RSDP) Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1357722"></A>The revisio<A NAME="marker-1816634"></A><A NAME="marker-1816635"></A>n number contained within the structure indicates the size of the table structure.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1357723"></A><A NAME="10798"></A>RSDP Structure<A NAME="marker-1357837"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684419"></A><A NAME="_Ref369314841"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684421"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684423"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684425"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357735"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357737"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357739"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357741"></A>&#8220;RSD PTR &#8221; (Notice that this signature must contain a trailing blank character.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357743"></A>Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357745"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357747"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357749"></A>This is the checksum of the fields defined in the ACPI 1.0 specification. This includes only the first 20 bytes of this table, bytes 0 to 19, including the checksum field. These bytes must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357751"></A>OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357753"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357755"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357757"></A>An OEM-supplied string that identifies the OEM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357759"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357761"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357763"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357765"></A>The revision of this structure. Larger revision numbers are backward compatible to lower revision numbers. The ACPI version 1.0 revision number of this table is zero. The ACPI version 1.0 RSDP Structure only includes the first 20 bytes of this table, bytes 0 to 19. It does not include the Length field and beyond. The current value for this field is 2.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357767"></A>RsdtAddress</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357769"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357771"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357773"></A>32 bit physical address of the RSDT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357775"></A>Length*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357777"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357779"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357781"></A>The length of the table, in bytes, including the header, starting from offset 0. This field is used to record the size of the entire table. This field is not available in the ACPI version 1.0 RSDP Structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357783"></A>XsdtAddress*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357785"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357787"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357789"></A>64 bit physical address of the XSDT. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357791"></A>Extended Checksum*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357793"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357795"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357797"></A>This is a checksum of the entire table, including both checksum fields.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357799"></A><EM CLASS="Italic">
Reserved*</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357801"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357803"></A>33</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357805"></A>Reserved field</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1801232"></A>* These fields are only valid when the Revision value is 2 or above. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1368542"></A><A NAME="92684"></A>System Description Table Header</H6>
<P CLASS="Body">
<A NAME="pgfId-1368565"></A>All system description tables begin with the structure shown in <A HREF="ACPI_Software_Programming_Model.htm#70006" CLASS="XRef">See DESCRIPTION_HEADER Fields.</A>. The Signature field determines the content of the system description table. System description table signatures defined by this specification are listed in <A HREF="ACPI_Software_Programming_Model.htm#95136" CLASS="XRef">See DESCRIPTION_HEADER Signatures for tables defined by ACPI.</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1357841"></A><A NAME="70006"></A>DESCRIPTION_HEADER Fields</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1831290"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831292"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831294"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831296"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357852"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357854"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357856"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357858"></A>The ASCII string representation of the table identifier. Notice that if OSPM finds a signature in a table that is not listed in <A HREF="ACPI_Software_Programming_Model.htm#95136" CLASS="XRef">See DESCRIPTION_HEADER Signatures for tables defined by ACPI.</A>, OSPM ignores the entire table (it is not loaded into ACPI namespace); OSPM ignores the table even though the values in the Length and Checksum fields are correct.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357860"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357862"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357864"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357866"></A>The length of the table, in bytes, including the header, starting from offset 0. This field is used to record the size of the entire table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357868"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357870"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357872"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357874"></A>The revision of the structure corresponding to the signature field for this table. Larger revision numbers are backward compatible to lower revision numbers with the same signature.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357876"></A>Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357878"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357880"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357882"></A>The entire table, including the checksum field, must add to zero to be considered valid.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357884"></A>OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357886"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357888"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357890"></A>An OEM-supplied string that identifies the OEM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357892"></A>OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357894"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357896"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357898"></A>An OEM-supplied string that the OEM uses to identify the particular data table. This field is particularly useful when defining a definition block to distinguish definition block functions. The OEM assigns each dissimilar table a new OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357900"></A>OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357902"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357904"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357906"></A>An OEM-supplied revision number. Larger numbers are assumed to be newer revisions.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357908"></A>Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357910"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357912"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357914"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357916"></A>Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357918"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357920"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1357922"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1357925"></A>For OEMs, good design practices will ensure consistency when assigning OEMID and OEM Table ID fields in any table. The intent of these fields is to allow for a binary control system that support services can use. Because many support functions can be automated, it is useful when a tool can programmatically determine which table release is a compatible and more recent revision of a prior table on the same OEMID and OEM Table ID.</P>
<P CLASS="Body">
<A NAME="pgfId-1357926"></A><A HREF="ACPI_Software_Programming_Model.htm#95136" CLASS="XRef">See DESCRIPTION_HEADER Signatures for tables defined by ACPI.</A> and <A HREF="ACPI_Software_Programming_Model.htm#84652" CLASS="XRef">See DESCRIPTION_HEADER Signatures for tables reserved by ACPI.</A> contain the system description table signatures defined by this specification. These system description tables may be defined by ACPI and documented within this specification (<A HREF="ACPI_Software_Programming_Model.htm#95136" CLASS="XRef">See DESCRIPTION_HEADER Signatures for tables defined by ACPI.</A>) or they may be simply reserved by ACPI and defined by other industry specifications (<A HREF="ACPI_Software_Programming_Model.htm#84652" CLASS="XRef">See DESCRIPTION_HEADER Signatures for tables reserved by ACPI.</A>). This allows OS and platform specific tables to be defined and pointed to by the RSDT/XSDT as needed. For tables defined by other industry specifications, the ACPI specification acts as gatekeeper to avoid collisions in table signatures. </P>
<P CLASS="Body">
<A NAME="pgfId-1357927"></A>Table signatures will be reserved by the ACPI promoters and posted independently of this specification in ACPI errata and clarification documents on the ACPI web site. Requests to reserve a 4-byte alphanumeric table signature should be sent to the email address info@acpi.info and should include the purpose of the table and reference URL to a document that describes the table format. Tables defined outside of the ACPI specification may define data value encodings in either little endian or big endian format. For the purpose of clarity, external table definition documents should include the endian-ness of their data value encodings. </P>
<P CLASS="Body">
<A NAME="pgfId-1739032"></A>Since reference URLs can change over time and may not always be up-to-date in this specification, a separate document containing the latest known reference URLs can be found at &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
), which should conspicuously be placed in the same location as this specification.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1739212"></A><A NAME="95136"></A>DESCRIPTION_HEADER Signatures for tables defined by ACPI<A NAME="marker-1739034"></A><A NAME="marker-1739035"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739039"></A><A NAME="_Ref359951113"></A>Signature</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739041"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739043"></A>Reference</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739045"></A>&#8220;APIC&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739047"></A>Multiple APIC Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739052"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc258262222" CLASS="XRef">See Multiple APIC Description Table (MADT).</A>, &#8220;Multiple APIC Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739054"></A>&#8220;BERT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739056"></A>Boot Error Record Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739061"></A><A HREF="ACPI_PLatform_Error_Interfaces.htm#_Toc258262559" CLASS="XRef">See Boot Error Source.</A>, &#8220;Boot Error Source&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739249"></A>&#8220;BGRT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739251"></A>Boot Graphics Resource Table </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739253"></A><A HREF="ACPI_Software_Programming_Model.htm#89334" CLASS="XRef">See Boot Graphics Resource Table (BGRT).</A>, &#8220;Boot Graphics Resource Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739063"></A>&#8220;CPEP&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739065"></A>Corrected Platform Error Polling Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739070"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc258262228" CLASS="XRef">See Corrected Platform Error Polling Table (CPEP).</A>, &#8220;Corrected Platform Error Polling Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739072"></A>&#8220;DSDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739074"></A>Differentiated System Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739079"></A><A HREF="ACPI_Software_Programming_Model.htm#94664" CLASS="XRef">See Differentiated System Description Table (DSDT).</A>, &#8220;Differentiated System Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739081"></A>&#8220;ECDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739083"></A>Embedded Controller Boot Resources Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739088"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc489256017" CLASS="XRef">See Embedded Controller Boot Resources Table (ECDT).</A> &#8220;Embedded Controller Boot Resources Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739090"></A>&#8220;EINJ&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739092"></A>Error Injection Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739097"></A><A HREF="ACPI_PLatform_Error_Interfaces.htm#_Toc258262567" CLASS="XRef">See Error Injection Table (EINJ).</A>, &#8220;Error Injection Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739099"></A>&#8220;ERST&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739101"></A>Error Record Serialization Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739106"></A><A HREF="ACPI_PLatform_Error_Interfaces.htm#_Toc258262563" CLASS="XRef">See Error Serialization.</A>, &#8220;Error Serialization&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739108"></A>&#8221;FACP&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739110"></A>Fixed ACPI Description Table (FADT)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739115"></A><A HREF="ACPI_Software_Programming_Model.htm#64460" CLASS="XRef">See Fixed ACPI Description Table (FADT).</A>, &#8220;Fixed ACPI Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739117"></A>&#8220;FACS&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739119"></A>Firmware ACPI Control Structure</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739124"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc489256013" CLASS="XRef">See Firmware ACPI Control Structure (FACS).</A>, &#8220;Firmware ACPI Control Structure&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739287"></A>&#8220;FPDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739289"></A>Firmware Performance Data Table </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739291"></A><A HREF="ACPI_Software_Programming_Model.htm#89858" CLASS="XRef">See Firmware Performance Data Table (FPDT).</A>, &#8220;Firmware Performance Data Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742187"></A>&#8220;GTDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742189"></A>Generic Timer Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742191"></A><A HREF="ACPI_Software_Programming_Model.htm#44426" CLASS="XRef">See Generic Timer Description Table (GTDT).</A>, &#8220;Generic Timer Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739126"></A>&#8220;HEST&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739128"></A>Hardware Error Source Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739133"></A><A HREF="ACPI_PLatform_Error_Interfaces.htm#_Toc258262560" CLASS="XRef">See ACPI Error Source.</A>, &#8220;ACPI Error Source&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739135"></A>&#8220;MSCT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739137"></A>Maximum System Characteristics Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739142"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc258262229" CLASS="XRef">See Maximum System Characteristics Table (MSCT).</A>, &#8220;Maximum System Characteristics Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739321"></A>&#8220;MPST&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739323"></A>Memory Power StateTable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739325"></A><A HREF="ACPI_Software_Programming_Model.htm#66239" CLASS="XRef">See Memory Power State Table (MPST).</A>, &#8220;Memory Power StateTable&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787475"></A>&#8220;NFIT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787477"></A>NVDIMM Firmware Interface Table </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787479"></A><A HREF="ACPI_Software_Programming_Model.htm#24805" CLASS="XRef">See NVDIMM Firmware Interface Table (NFIT).</A>, &#8220;NVDIMM Firmware Interface Table (NFIT)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739144"></A>&#8220;OEMx&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739146"></A>OEM Specific Information Tables</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739148"></A>OEM Specific tables. All table signatures starting with &#8220;OEM&#8221; are reserved for OEM use. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1773651"></A>&#8220;PCCT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1773653"></A>Platform Communications Channel Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1773655"></A><A HREF="Platform_Comm_Channel.htm#59683" CLASS="XRef">See Platform Communications Channel Table.</A> &#8220;Platform Communications Channel Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742181"></A>&#8220;PMTT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742183"></A>Platform Memory Topology Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742185"></A><A HREF="ACPI_Software_Programming_Model.htm#30717" CLASS="XRef">See Memory Topology Table (PMTT).</A>, Memory Topology Table (PMTT)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739150"></A>&#8220;PSDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739152"></A>Persistent System Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739157"></A><A HREF="ACPI_Software_Programming_Model.htm#56903" CLASS="XRef">See Persistent System Description Table (PSDT).</A>, &#8220;Persistent System Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739353"></A>&#8220;RASF&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739355"></A>ACPI RAS FeatureTable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739357"></A><A HREF="ACPI_Software_Programming_Model.htm#95954" CLASS="XRef">See RASF Communication Channel.</A>, &#8220;ACPI RAS Feature Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739159"></A>&#8220;RSDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739161"></A>Root System Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739166"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc489267934" CLASS="XRef">See Root System Description Table (RSDT).</A>, &#8220;Root System Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739168"></A>&#8220;SBST&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739170"></A>Smart Battery Specification Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739175"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc489256016" CLASS="XRef">See Smart Battery Table (SBST).</A>, &#8220;Smart Battery Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1819797"></A>&#8220;SDEV&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1819799"></A>Secure DEVices Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1819808"></A><A HREF="ACPI_Software_Programming_Model.htm#82207" CLASS="XRef">See Secure Devices (SDEV) ACPI Table.</A> &#8220;Secure Devices (SDEV) Table&#8221;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1819795"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739177"></A>&#8220;SLIT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739179"></A>System Locality Distance Information Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739184"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc202340545" CLASS="XRef">See Generic Initiator Affinity Structure.</A>, &#8220;System Locality Distance Information Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739186"></A>&#8220;SRAT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739188"></A>System Resource Affinity Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739193"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc202340544" CLASS="XRef">See System Resource Affinity Table (SRAT).</A>, &#8220;System Resource Affinity Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739195"></A>&#8220;SSDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739197"></A>Secondary System Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739202"></A><A HREF="ACPI_Software_Programming_Model.htm#34381" CLASS="XRef">See Secondary System Description Table (SSDT).</A>, &#8220;Secondary System Description Table&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739204"></A>&#8220;XSDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739206"></A>Extended System Description Table</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739211"></A><A HREF="ACPI_Software_Programming_Model.htm#43085" CLASS="XRef">See Extended System Description Table (XSDT).</A>, &#8220;Extended System Description Table&#8221;</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1368401"></A><A NAME="84652"></A>DESCRIPTION_HEADER Signatures for tables reserved by ACPI<A NAME="marker-1368399"></A><A NAME="marker-1368400"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730919"></A>Signature</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730921"></A>Description and External Reference</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730786"></A>&#8220;BOOT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730788"></A>Reserved Signature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837731"></A>&#8220;CDIT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837733"></A>Component Distance Information Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1844002"></A>See &quot;Links to ACPI-Related Documents&quot; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Component Distance Information Table&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837735"></A>&#8220;CRAT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837737"></A>Component Resource Attribute Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1843956"></A>See &quot;Links to ACPI-Related Documents&quot; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Component Resource Attribute Table&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730791"></A>&#8220;CSRT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730793"></A>Core System Resource Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730794"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Core System Resource Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730797"></A>&#8220;DBG2&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730799"></A>Debug Port Table 2</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730800"></A>Microsoft Debug Port Table 2 Specification</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730801"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Debug Port Table 2&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730803"></A>&#8220;DBGP&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730805"></A>Debug Port Table<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Debug Port Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730812"></A>&#8220;DMAR&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730814"></A>DMA Remapping Table<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &#8220;DMA Remapping Table&#8221;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1821002"></A>&#8220;DPPT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1821017"></A>DMA Protection Policy Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1821004"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi)</EM>
 under the heading &#8220;DMA Protection Policy Table&#8221;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1745483"></A>&#8220;DRTM&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1745485"></A>Dynamic Root of Trust for Measurement Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1745844"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &#8220;TCG D-RTM Architecture Specification&#8221;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730817"></A>&#8220;ETDT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730819"></A>Event Timer Description Table (Obsolete)<BR>
IA-PC Multimedia Timers Specification. This signature has been superseded by &#8220;HPET&#8221; and is now obsolete.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730821"></A>&#8220;HPET&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730823"></A>IA-PC High Precision Event Timer Table<BR>
IA-PC High Precision Event Timer Specification<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;IA-PC High Precision Event Timer Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730826"></A>&#8220;IBFT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730828"></A>iSCSI Boot Firmware Table<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;iSCSI Boot Firmware Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761554"></A>&quot;IORT&quot;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761576"></A>I/O Remapping Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1761577"></A>See &quot;Links to ACPI-Related Documents&quot; (http://uefi.org/acpi) under the heading &quot;I/O Remapping Table&quot;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730831"></A>&#8220;IVRS&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730833"></A>I/O Virtualization Reporting Structure<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;I/O Virtualization Reporting Structure&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757737"></A>&quot;LPIT&quot;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757739"></A>Low Power Idle Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1757761"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Low Power Idle Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730836"></A>&#8220;MCFG&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730838"></A>PCI Express memory mapped configuration space base address Description Table<BR>
PCI Firmware Specification, Revision 3.0<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;PCI Sig&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730841"></A>&#8220;MCHI&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730843"></A>Management Controller Host Interface Table<BR>
DSP0256 Management Component Transport Protocol (MCTP) Host Interface Specification<BR>
See&#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Management Controller Host Interface Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730846"></A>&#8220;MSDM&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730848"></A>Microsoft Data Management Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730849"></A>See: Microsoft Data Management Table Specification</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730850"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Microsoft Data Management Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806065"></A>&#8220;SDEI&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806067"></A>Software Delegated Exceptions Interface</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806103"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Software Delegated Exceptions Interface.&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730852"></A>&#8220;SLIC&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730854"></A>Microsoft Software Licensing Table Specification</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730856"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Microsoft Software Licensing Table Specification&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730858"></A>&#8220;SPCR&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730860"></A>Serial Port Console Redirection Table<BR>
Microsoft Serial Port Console Redirection Table<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Serial Port Console Redirection Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730866"></A>&#8220;SPMI&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730868"></A>Server Platform Management Interface Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1742994"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Server Platform Management Interface Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1767620"></A>&#8220;STAO&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1767626"></A>_STA Override Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1769054"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;_STA Override Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730871"></A>&#8220;TCPA&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730873"></A>Trusted Computing Platform Alliance Capabilities Table<BR>
TCPA PC Specific Implementation Specification<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Trusted Computing Platform Alliance Capabilities Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1743291"></A>TPM2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1743300"></A>Trusted Platform Module 2 Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1743301"></A>See: Trusted Platform Module 2 Table Specification</P>
<P CLASS="TableBody">
<A NAME="pgfId-1743293"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Trusted Platform Module 2 Table&quot;. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730876"></A>&#8220;UEFI&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730878"></A>UEFI ACPI Data Table<BR>
UEFI Specification<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Unified Extensible Firmware Interface Specifications&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730881"></A>&#8220;WAET&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730883"></A>Windows ACPI Emulated Devices Table<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Windows ACPI Emulated Devices Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730886"></A>&#8220;WDAT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730888"></A>Watch Dog Action Table<BR>
Requirements for Hardware Watchdog Timers Supported by Windows - Design Specification<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Watchdog Action Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730891"></A>&#8220;WDRT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730893"></A>Watchdog Resource Table<BR>
Watchdog Timer Hardware Requirements for Windows Server 2003<BR>
See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Watchdog Timer Resource Table (WDRT)&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730896"></A>&#8220;WPBT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730898"></A>Windows Platform Binary Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1730900"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Windows Platform Binary Table&quot;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1816707"></A>&#8220;WSMT&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1816709"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &#8220;Windows SMM Security Mitigation Table (WSMT).&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1767653"></A>&quot;XENV&quot;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1767671"></A>Xen Project Table</P>
<P CLASS="TableBody">
<A NAME="pgfId-1769016"></A>See &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Xen Project Table&quot;.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358180"></A><A NAME="_Toc489267934"></A><A NAME="_Toc489272487"></A><A NAME="_Toc202340536"></A><A NAME="_Toc258262217"></A>Root System Description Table (RSDT<A NAME="marker-1358176"></A><A NAME="marker-1358177"></A><A NAME="marker-1358178"></A>)</H6>
<P CLASS="Body">
<A NAME="pgfId-1358182"></A><A NAME="_Ref359951246"></A>OSPM locates that Root System Description Table by following the pointer in the RSDP structure. The RSDT, shown in <A HREF="ACPI_Software_Programming_Model.htm#12144" CLASS="XRef">See Root System Description Table Fields (RSDT).</A>, starts with the signature &#8216;RSDT&#8217; followed by an array of physical pointers to other system description tables that provide various information on other standards defined on the current system. OSPM examines each table for a known signature. Based on the signature, OSPM can then interpret the implementation-specific data within the table.<A NAME="marker-1358183"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1368627"></A>Platforms provide the RSDT to enable compatibility with ACPI 1.0 operating systems. The XSDT, described in the next section, supersedes RSDT functionality.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1368733"></A><A NAME="12144"></A>Root System Description Table Fields (RSDT)<A NAME="marker-1368732"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1831386"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831388"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831390"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831392"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368645"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368647"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368649"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368651"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368653"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368655"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368657"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368659"></A>&#8216;RSDT&#8217; Signature for the Root System Description Table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368661"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368663"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368665"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368667"></A>Length, in bytes, of the entire RSDT. The length implies the number of Entry fields (n) at the end of the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368669"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368671"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368673"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368675"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368677"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368679"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368681"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368683"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368685"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368687"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368689"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368691"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368693"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368695"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368697"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368699"></A>For the RSDT, the table ID is the manufacture model ID. This field must match the OEM Table ID in the FADT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368701"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368703"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368705"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368707"></A>OEM revision of RSDT table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368709"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368711"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368713"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368715"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368717"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368719"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368721"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368723"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368725"></A>Entry</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368727"></A>4*n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368729"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1368731"></A>An array of 32-bit physical addresses that point to other DESCRIPTION_HEADERs. OSPM assumes at least the DESCRIPTION_HEADER is addressable, and then can further address the table based upon its Length field.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1368734"></A><A NAME="43085"></A>Extended System Description Table (XSDT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1368739"></A>The XSDT provides identical functionality to the RSDT but accommodates physical addresses of DESCRIPTION HEADERs that are larger than 32 bits. Notice that both the XSDT and the RSDT can be pointed to by the RSDP structure. An ACPI-compatible OS must use the XSDT if present.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1358328"></A>Extended System Description Table Fields (XSDT)</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739637"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739639"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739641"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739643"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358339"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358341"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358343"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358345"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358347"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358349"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358351"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358353"></A>&#8216;XSDT&#8217;. Signature for the Extended System Description Table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358355"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358357"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358359"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358361"></A>Length, in bytes, of the entire table. The length implies the number of Entry fields (n) at the end of the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358363"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358365"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358367"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358369"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358371"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358373"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358375"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358377"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358379"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358381"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358383"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358385"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358387"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358389"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358391"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358393"></A>For the XSDT, the table ID is the manufacture model ID. This field must match the OEM Table ID in the FADT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358395"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358397"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358399"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358401"></A>OEM revision of XSDT table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358403"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358405"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358407"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358409"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358411"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358413"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358415"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358417"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358419"></A>Entry</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358421"></A>8*n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358423"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358425"></A>An array of 64-bit physical addresses that point to other DESCRIPTION_HEADERs. OSPM assumes at least the DESCRIPTION_HEADER is addressable, and then can further address the table based upon its Length field.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1358453"></A><A NAME="marker-1358452"></A><A NAME="64460"></A>Fixed ACPI Description Table (FADT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1358454"></A>The Fixed ACPI Description Table (FADT) defines various fixed hardware ACPI information vital to an ACPI-compatible OS, such as the base address for the following hardware registers blocks: PM1a_EVT_BLK, PM1b_EVT_BLK, PM1a_CNT_BLK, PM1b_CNT_BLK, PM2_CNT_BLK, PM_TMR_BLK, GPE0_BLK, and GPE1_BLK.</P>
<P CLASS="Body">
<A NAME="pgfId-1358455"></A>The FADT also has a pointer to the DSDT that contains the Differentiated Definition Block, which in turn provides variable information to an ACPI-compatible OS concerning the base system design.</P>
<P CLASS="Body">
<A NAME="pgfId-1358456"></A>All fields in the FADT that provide hardware addresses provide processor-relative physical addresses.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1720656"></A>If the HW_REDUCED_ACPI flag in the table is set, OSPM will ignore fields related to the ACPI HW register interface: Fields at offsets 46 through 108 and 148 through 232, as well as FADT Flag bits 1, 2, 3,7,8,13, 14, 16, and 17).</LI>
<LI CLASS="Note">
<A NAME="pgfId-1815887"></A>In all cases where the FADT contains a 32-bit field and a corresponding 64-bit field the 64-bit field should always be preferred by the OSPM if the 64-bit field contains a non-zero value which can be used by the OSPM. In this case, the 32-bit field must be ignored regardless of whether or not it is zero, and whether or not it is the same value as the 64-bit field. The 32-bit field should only be used if the corresponding 64-bit field contains a zero value, or if the 64-bit value can not be used by the OSPM subject to e.g. CPU addressing limitations.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1358458"></A><A NAME="66696"></A>FADT Format </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684443"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684445"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684447"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684449"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358469"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358471"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358473"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358475"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358477"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358479"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358481"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358483"></A>&#8216;FACP&#8217;. Signature for the Fixed ACPI Description Table. (This signature predates ACPI 1.0, explaining the mismatch with this table's name.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358485"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358487"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358489"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358491"></A>Length, in bytes, of the entire FADT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358493"></A>    FADT Major Version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358495"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358497"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358499"></A>6</P>
<P CLASS="TableBody">
<A NAME="pgfId-1747971"></A>Major Version of this FADT structure, in &quot;Major.Minor&quot; form, where 'Minor' is the value in the Minor Version Field (Byte offset 131 in this table)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358501"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358503"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358505"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358507"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358509"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358511"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358513"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358515"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358517"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358519"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358521"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358523"></A>For the FADT, the table ID is the manufacture model ID. This field must match the OEM Table ID in the RSDT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358525"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358527"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358529"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358531"></A>OEM revision of FADT for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358533"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358535"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358537"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358539"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358541"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358543"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358545"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358547"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358549"></A>FIRMWARE_CTRL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358551"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358553"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358555"></A>Physical memory address of the FACS, where OSPM and Firmware exchange control information. See <A HREF="ACPI_Software_Programming_Model.htm#92684" CLASS="XRef">See System Description Table Header.</A>, &#8220;Root System Description Table,&#8221; for a description of the FACS. If the X_FIRMWARE_CTRL field contains a non zero value which can be used by the OSPM, then this field must be ignored by the OSPM. If the HARDWARE_REDUCED_ACPI flag is set, and both this field and the X_FIRMWARE_CTRL field are zero, there is no FACS available.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358557"></A>DSDT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358559"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358561"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358563"></A>Physical memory address of the DSDT. If the X_DSDT field contains a non-zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358565"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358567"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358569"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358571"></A>ACPI 1.0 defined this offset as a field named INT_MODEL, which was eliminated in ACPI 2.0. Platforms should set this field to zero but field values of one are also allowed to maintain compatibility with ACPI 1.0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358573"></A>Preferred_PM_Profile</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358575"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358577"></A>45</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358579"></A>This field is set by the OEM to convey the preferred power management profile to OSPM. OSPM can use this field to set default power management policy parameters during OS installation.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358580"></A>Field Values:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358581"></A>0	Unspecified</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358582"></A>1	Desktop</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358583"></A>2	Mobile</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358584"></A>3	Workstation</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358585"></A>4	Enterprise Server</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358586"></A>5	SOHO Server</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358587"></A>6	Appliance PC</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358588"></A>7	Performance Server</P>
<P CLASS="TableBody">
<A NAME="pgfId-1720700"></A>8)           Tablet</P>
<P CLASS="TableBody">
<A NAME="pgfId-1720707"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358589"></A>&gt;8	Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358591"></A>SCI_INT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358593"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358595"></A>46</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358597"></A>System vector the SCI interrupt is wired to in 8259 mode. On systems that do not contain the 8259, this field contains the Global System interrupt number of the SCI interrupt. OSPM is required to treat the ACPI SCI interrupt as a sharable, level, active low interrupt.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358599"></A>SMI_CMD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358601"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358603"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358605"></A>System port address of the SMI Command Port. During ACPI OS initialization, OSPM can determine that the ACPI hardware registers are owned by SMI (by way of the SCI_EN bit), in which case the ACPI OS issues the ACPI_ENABLE command to the SMI_CMD port. The SCI_EN bit effectively tracks the ownership of the ACPI hardware registers. OSPM issues commands to the SMI_CMD port synchronously from the boot processor. This field is reserved and must be zero on system that does not support System Management mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358607"></A>ACPI_ENABLE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358609"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358611"></A>52</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358613"></A>The value to write to SMI_CMD to disable SMI ownership of the ACPI hardware registers. The last action SMI does to relinquish ownership is to set the SCI_EN bit. During the OS initialization process, OSPM will synchronously wait for the transfer of SMI ownership to complete, so the ACPI system releases SMI ownership as quickly as possible. This field is reserved and must be zero on systems that do not support Legacy Mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358615"></A>ACPI_DISABLE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358617"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358619"></A>53</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358621"></A>The value to write to SMI_CMD to re-enable SMI ownership of the ACPI hardware registers. This can only be done when ownership was originally acquired from SMI by OSPM using ACPI_ENABLE. An OS can hand ownership back to SMI by relinquishing use to the ACPI hardware registers, masking off all SCI interrupts, clearing the SCI_EN bit and then writing ACPI_DISABLE to the SMI_CMD port from the boot processor. This field is reserved and must be zero on systems that do not support Legacy Mode.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358623"></A>S4BIOS_REQ</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358625"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358627"></A>54</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358629"></A>The value to write to SMI_CMD to enter the S4BIOS state. The S4BIOS state provides an alternate way to enter the S4 state where the firmware saves and restores the memory context. A value of zero in S4BIOS_F indicates S4BIOS_REQ is not supported. (See <A HREF="ACPI_Software_Programming_Model.htm#34632" CLASS="XRef">See Firmware ACPI Control Structure (FACS).</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358631"></A>PSTATE_CNT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358633"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358635"></A>55</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358637"></A>If non-zero, this field contains the value OSPM writes to the SMI_CMD register to assume processor performance state control responsibility.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358639"></A>PM1a_EVT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358641"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358643"></A>56</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358645"></A>System port address of the PM1a Event Register Block. See <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping,&#8221; for a hardware description layout of this register block. This is a required field. If the X_PM1a_CNT_BLK field contains a non zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358647"></A>PM1b_EVT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358649"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358651"></A>60</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358653"></A>System port address of the PM1b Event Register Block. See <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping,&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If the X_PM1b_EVT_BLK field contains a non zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358655"></A>PM1a_CNT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358657"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358659"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358661"></A>System port address of the PM1a Control Register Block. See <A HREF="ACPI Hardware Specification.htm#79611" CLASS="XRef">See PM1 Control Grouping.</A>, &#8220;PM1 Control Grouping,&#8221; for a hardware description layout of this register block. This is a required field. If the X_PM1a_CNT_BLK field contains a non zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358663"></A>PM1b_CNT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358665"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358667"></A>68</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358669"></A>System port address of the PM1b Control Register Block. See <A HREF="ACPI Hardware Specification.htm#79611" CLASS="XRef">See PM1 Control Grouping.</A>, &#8220;PM1 Control Grouping,&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If the X_PM1b_CNT_BLK field contains a non zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358671"></A>PM2_CNT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358673"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358675"></A>72</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358677"></A>System port address of the PM2 Control Register Block. See <A HREF="ACPI Hardware Specification.htm#89118" CLASS="XRef">See PM2 Control (PM2_CNT).</A>, &#8220;PM2 Control (PM2_CNT),&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If the X_PM2_CNT_BLK field contains a non zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358679"></A>PM_TMR_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358681"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358683"></A>76</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358685"></A>System port address of the Power Management Timer Control Register Block. See <A HREF="ACPI Hardware Specification.htm#54017" CLASS="XRef">See Power Management Timer (PM_TMR).</A>, &#8220;Power Management Timer (PM_TMR),&#8221; for a hardware description layout of this register block. This is an optional field; if this register block is not supported, this field contains zero. If the X_PM2_CNT_BLK field contains a non-zero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358687"></A>GPE0_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358689"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358691"></A>80</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358693"></A>System port address of General-Purpose Event 0 Register Block. See <A HREF="ACPI Hardware Specification.htm#58185" CLASS="XRef">See General-Purpose Event Register Blocks.</A>, &#8220;General-Purpose Event Register Blocks,&#8221; for a hardware description of this register block. This is an optional field; if this register block is not supported, this field contains zero. If the X_GPE0_BLK field contains a nonzero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358695"></A>GPE1_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358697"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358699"></A>84</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358701"></A>System port address of General-Purpose Event 1 Register Block. See <A HREF="ACPI Hardware Specification.htm#58185" CLASS="XRef">See General-Purpose Event Register Blocks.</A>, &#8220;General-Purpose Event Register Blocks,&#8221; for a hardware description of this register block. This is an optional field; if this register block is not supported, this field contains zero. If the X_GPE1_BLK field contains a nonzero value which can be used by the OSPM, then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358703"></A>PM1_EVT_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358705"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358707"></A>88</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358709"></A>Number of bytes decoded by PM1a_EVT_BLK and, if supported, PM1b_ EVT_BLK. This value is &#8805; 4.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358711"></A>PM1_CNT_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358713"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358715"></A>89</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358717"></A>Number of bytes decoded by PM1a_CNT_BLK and, if supported, PM1b_CNT_BLK. This value is &#8805; 2.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358719"></A>PM2_CNT_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358721"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358723"></A>90</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358725"></A>Number of bytes decoded by PM2_CNT_BLK. Support for the PM2 register block is optional. If supported, this value is &#8805; 1. If not supported, this field contains zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358727"></A>PM_TMR_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358729"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358731"></A>91</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358733"></A>Number of bytes decoded by PM_TMR_BLK. If the PM Timer is supported, this field&#8217;s value must be 4. If not supported, this field contains zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358735"></A>GPE0_BLK_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358737"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358739"></A>92</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358741"></A>Number of bytes decoded by GPE0_BLK. The value is a non-negative multiple of 2.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358743"></A>GPE1_BLK_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358745"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358747"></A>93</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358749"></A>Number of bytes decoded by GPE1_BLK. The value is a non-negative multiple of 2.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358751"></A>GPE1_BASE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358753"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358755"></A>94</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358757"></A>Offset within the ACPI general-purpose event model where GPE1 based events start.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358759"></A>CST_CNT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358761"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358763"></A>95</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358765"></A>If non-zero, this field contains the value OSPM writes to the SMI_CMD register to indicate OS support for the _CST object and C States Changed notification.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358767"></A>P_LVL2_LAT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358769"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358771"></A>96</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358773"></A>The worst-case hardware latency, in microseconds, to enter and exit a C2 state. A value &gt; 100 indicates the system does not support a C2 state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358775"></A>P_LVL3_LAT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358777"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358779"></A>98</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358781"></A>The worst-case hardware latency, in microseconds, to enter and exit a C3 state. A value &gt; 1000 indicates the system does not support a C3 state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358783"></A>FLUSH_SIZE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358785"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358787"></A>100</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358789"></A>If WBINVD=0, the value of this field is the number of flush strides that need to be read (using cacheable addresses) to completely flush dirty lines from any processor&#8217;s memory caches. Notice that the value in FLUSH_STRIDE is typically the smallest cache line width on any of the processor&#8217;s caches (for more information, see the FLUSH_STRIDE field definition). If the system does not support a method for flushing the processor&#8217;s caches, then FLUSH_SIZE and WBINVD are set to zero. Notice that this method of flushing the processor caches has limitations, and WBINVD=1 is the preferred way to flush the processors caches. This value is typically at least 2 times the cache size. The maximum allowed value for FLUSH_SIZE multiplied by FLUSH_STRIDE is 2 MB for a typical maximum supported cache size of 1 MB. Larger cache sizes are supported using WBINVD=1. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1358790"></A>This value is ignored if WBINVD=1.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358791"></A>This field is maintained for ACPI 1.0 processor compatibility on existing systems. Processors in new ACPI-compatible systems are required to support the WBINVD function and indicate this to OSPM by setting the WBINVD field = 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358793"></A>FLUSH_STRIDE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358795"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358797"></A>102</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358799"></A>If WBINVD=0, the value of this field is the cache line width, in bytes, of the processor&#8217;s memory caches. This value is typically the smallest cache line width on any of the processor&#8217;s caches. For more information, see the description of the FLUSH_SIZE field.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358800"></A>This value is ignored if WBINVD=1.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358801"></A>This field is maintained for ACPI 1.0 processor compatibility on existing systems. Processors in new ACPI-compatible systems are required to support the WBINVD function and indicate this to OSPM by setting the WBINVD field = 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358803"></A>DUTY_OFFSET</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358805"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358807"></A>104</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358809"></A>The zero-based index of where the processor&#8217;s duty cycle setting is within the processor&#8217;s P_CNT register.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358811"></A>DUTY_WIDTH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358813"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358815"></A>105</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358817"></A>The bit width of the processor&#8217;s duty cycle setting value in the P_CNT register. Each processor&#8217;s duty cycle setting allows the software to select a nominal processor frequency below its absolute frequency as defined by:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358818"></A>THTL_EN = 1</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358819"></A>BF * DC/(2DUTY_WIDTH)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358820"></A>    Where:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358821"></A>BF-Base frequency</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358822"></A>DC-Duty cycle setting</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358823"></A>When THTL_EN is 0, the processor runs at its absolute BF. A DUTY_WIDTH value of 0 indicates that processor duty cycle is not supported and the processor continuously runs at its base frequency.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358825"></A>DAY_ALRM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358827"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358829"></A>106</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358831"></A>The RTC CMOS RAM index to the day-of-month alarm value. If this field contains a zero, then the RTC day of the month alarm feature is not supported. If this field has a non-zero value, then this field contains an index into RTC RAM space that OSPM can use to program the day of the month alarm. See <A HREF="ACPI Hardware Specification.htm#36703" CLASS="XRef">See Real Time Clock Alarm.</A> &#8220;Real Time Clock Alarm,&#8221; for a description of how the hardware works.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358833"></A>MON_ALRM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358835"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358837"></A>107</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358839"></A>The RTC CMOS RAM index to the month of year alarm value. If this field contains a zero, then the RTC month of the year alarm feature is not supported. If this field has a non-zero value, then this field contains an index into RTC RAM space that OSPM can use to program the month of the year alarm. If this feature is supported, then the DAY_ALRM feature must be supported also.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358841"></A>CENTURY</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358843"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358845"></A>108</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358847"></A>The RTC CMOS RAM index to the century of data value (hundred and thousand year decimals). If this field contains a zero, then the RTC centenary feature is not supported. If this field has a non-zero value, then this field contains an index into RTC RAM space that OSPM can use to program the centenary field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358849"></A>IAPC_BOOT_ARCH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358851"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358853"></A>109</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358855"></A>IA-PC Boot Architecture Flags. See <A HREF="ACPI_Software_Programming_Model.htm#38560" CLASS="XRef">See Fixed ACPI Description Table Boot IA-PC Boot Architecture Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358857"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358859"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358861"></A>111</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358863"></A>Must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358865"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358867"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358869"></A>112</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358871"></A>Fixed feature flags. See <A HREF="ACPI_Software_Programming_Model.htm#50808" CLASS="XRef">See Fixed ACPI Description Table Fixed Feature Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358873"></A>RESET_REG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358875"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358877"></A>116</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358879"></A>The address of the reset register represented in Generic Address Structure format (See <A HREF="ACPI Hardware Specification.htm#61654" CLASS="XRef">See Reset Register.</A>, &#8220;Reset Register,&#8221; for a description of the reset mechanism.)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1358880"></A>Note: Only System I/O space, System Memory space and PCI Configuration space (bus #0) are valid for values for Address_Space_ID. Also, Register_Bit_Width must be 8 and Register_Bit_Offset must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358882"></A>RESET_VALUE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358884"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358886"></A>128</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358888"></A>Indicates the value to write to the RESET_REG port to reset the system. (See <A HREF="ACPI Hardware Specification.htm#61654" CLASS="XRef">See Reset Register.</A>, &#8220;Reset Register,&#8221; for a description of the reset mechanism.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747973"></A>ARM_BOOT_ARCH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747975"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747977"></A>129</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748022"></A>ARM Boot Architecture Flags. See <A HREF="ACPI_Software_Programming_Model.htm#50446" CLASS="XRef">See Fixed ACPI Description Table ARM Boot Architecture Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358890"></A><EM CLASS="Italic">
FADT Minor Version</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358892"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358894"></A>131</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748006"></A>3</P>
<P CLASS="TableBody">
<A NAME="pgfId-1748007"></A>Minor Version of this FADT structure, in &quot;Major.Minor&quot; form, where 'Major' is the value in the Major Version Field (Byte offset 8 in this table).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358898"></A>X_FIRMWARE_CTRL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358900"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358902"></A>132</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358904"></A>Extended physical address of the FACS. If this field contains a nonzero value which can be used by the OSPM, then the FIRMWARE_CTRL field must be ignored by the OSPM.  If the HARDWARE_REDUCED_ACPI flag is set, and both this field and the FIRMWARE_CTRL field are zero, there is no FACS available.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358906"></A>X_DSDT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358908"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358910"></A>140</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358912"></A>Extended physical address of the DSDT. If this field contains a nonzero value which can be used by the OSPM, then the DSDT field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358914"></A>X_PM1a_EVT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358916"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358918"></A>148</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1815758"></A>Extended address of the PM1a Event Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping,&#8221; for a hardware description layout of this register block. This is a required field. If this field contains a nonzero value which can be used by the OSPM, then the PM1a_EVT_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358922"></A>X_PM1b_EVT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358924"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358926"></A>160</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1815773"></A>Extended address of the PM1b Event Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping,&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If this field contains a nonzero value which can be used by the OSPM, then the PM1b_EVT_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358930"></A>X_PM1a_CNT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358932"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358934"></A>172</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358936"></A>Extended address of the PM1a Control Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#79611" CLASS="XRef">See PM1 Control Grouping.</A>, &#8220;PM1 Control Grouping,&#8221; for a hardware description layout of this register block. This is a required field. If this field contains a nonzero value which can be used by the OSPM, then the PM1a_CNT_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358938"></A>X_PM1b_CNT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358940"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358942"></A>184</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358944"></A>Extended address of the PM1b Control Register Block, represented in Generic Address Structure format. See  <A HREF="ACPI Hardware Specification.htm#79611" CLASS="XRef">See PM1 Control Grouping.</A>, &#8220;PM1 Control Grouping,&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If this field contains a nonzero value which can be used by the OSPM, then the PM1b_CNT_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358946"></A>X_PM2_CNT_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358948"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358950"></A>196</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358952"></A>Extended address of the PM2 Control Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#89118" CLASS="XRef">See PM2 Control (PM2_CNT).</A> &#8220;PM2 Control (PM2_CNT),&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If this field contains a nonzero value which can be used by the OSPM, then the PM2_CNT_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358954"></A>X_PM_TMR_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358956"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358958"></A>208</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358960"></A>Extended address of the Power Management Timer Control Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#54017" CLASS="XRef">See Power Management Timer (PM_TMR).</A>, &#8220;Power Management Timer (PM_TMR),&#8221; for a hardware description layout of this register block. This field is optional; if this register block is not supported, this field contains zero. If this field contains a nonzero value which can be used by the OSPM, then the PM_TMR_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358962"></A>X_GPE0_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358964"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358966"></A>220</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358968"></A>Extended address of the General-Purpose Event 0 Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#58185" CLASS="XRef">See General-Purpose Event Register Blocks.</A> &#8220;General-Purpose Event Register Blocks,&#8221; for a hardware description of this register block. This is an optional field; if this register block is not supported, this field contains zero. If this field contains a nonzero value which can be used by the OSPM, then the GPE0_BLK field must be ignored by the OSPM.ns a non-zero value then this field must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358970"></A>X_GPE1_BLK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358972"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358974"></A>232</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358976"></A>Extended address of the General-Purpose Event 1 Register Block, represented in Generic Address Structure format. See <A HREF="ACPI Hardware Specification.htm#58185" CLASS="XRef">See General-Purpose Event Register Blocks.</A> &#8220;General-Purpose Event Register Blocks,&#8221; for a hardware description of this register block. This is an optional field; if this register block is not supported, this field contains zero. If this field contains a nonzero value which can be used by the OSPM, then the GPE1_BLK field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720723"></A>SLEEP_CONTROL_REG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720775"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720727"></A>244</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720781"></A>The address of the Sleep register, represented in Generic Address Structure format (See  <A HREF="ACPI Hardware Specification.htm#78810" CLASS="XRef">See Sleep Control and Status Registers.</A>, &quot;Sleep Control and Status Registers,&quot; for a description of the sleep mechanism.)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1720782"></A>Note: Only System I/O space, System Memory space and PCI Configuration space (bus #0) are valid for values for Address_Space_ID. Also, Register_Bit_Width must be 8 and Register_Bit_Offset must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720763"></A>SLEEP_STATUS_REG</P>
<P CLASS="TableBody">
<A NAME="pgfId-1720715"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720777"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720719"></A>256</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720802"></A>The address of the Sleep status register, represented in Generic Address Structure format (See <A HREF="ACPI Hardware Specification.htm#78810" CLASS="XRef">See Sleep Control and Status Registers.</A>, &quot;Sleep Control and Status Registers,&quot; for a description of the sleep mechanism.)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1720803"></A>Note: Only System I/O space, System Memory space and PCI Configuration space (bus #0) are valid for values for Address_Space_ID. Also, Register_Bit_Width must be 8 and Register_Bit_Offset must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1768067"></A>Hypervisor Vendor Identity </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1768069"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1768071"></A>268</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1768093"></A>64-bit identifier of hypervisor vendor.  All bytes in this field are considered part of the vendor identity. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1768094"></A>These identifiers are defined independently by the vendors themselves, usually following the name of the hypervisor product.  </P>
<P CLASS="TableBody">
<A NAME="pgfId-1768095"></A>Version information should NOT be included in this field - this shall simply denote the vendor's name or identifier.  Version information can be communicated through a supplemental vendor-specific hypervisor API.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1768096"></A>Firmware implementers would place zero bytes into this field, denoting that no hypervisor is present in the actual firmware.</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1768120"></A>[Hypervisor Vendor Identity ] A firmware implementer would place zero bytes into this field, denoting that no hypervisor is present in the actual firmware.  </LI>
<LI CLASS="Note">
<A NAME="pgfId-1768121"></A>[Hypervisor Vendor Identity ] A hypervisor vendor that presents ACPI tables of its own construction to a guest (for 'virtual' firmware or its 'virtual' platform), would provide its identity in this field.  </LI>
<LI CLASS="Note">
<A NAME="pgfId-1768122"></A>[Hypervisor Vendor Identity ] If a guest operating system is aware of this field it can consult it and act on the result, based on whether it recognized the vendor and knows how to use the API that is defined by the vendor.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1358983"></A><A NAME="_Ref369779603"></A><A NAME="50808"></A>Fixed ACPI Description Table Fixed Feature Flags</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684463"></A>FACP - Flag</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684465"></A>Bit Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684467"></A>Bit Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684469"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358994"></A>WBINVD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358996"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1358998"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359000"></A>Processor properly implements a functional equivalent to the WBINVD IA-32 instruction.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359001"></A>If set, signifies that the WBINVD instruction correctly flushes the processor caches, maintains memory coherency, and upon completion of the instruction, all caches for the current processor contain no cached data other than what OSPM references and allows to be cached. If this flag is not set, the ACPI OS is responsible for disabling all ACPI features that need this function. This field is maintained for ACPI 1.0 processor compatibility on existing systems. Processors in new ACPI-compatible systems are required to support this function and indicate this to OSPM by setting this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359003"></A>WBINVD_FLUSH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359005"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359007"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359009"></A>If set, indicates that the hardware flushes all caches on the WBINVD instruction and maintains memory coherency, but does not guarantee the caches are invalidated. This provides the complete semantics of the WBINVD instruction, and provides enough to support the system sleeping states. If neither of the WBINVD flags is set, the system will require FLUSH_SIZE and FLUSH_STRIDE to support sleeping states. If the FLUSH parameters are also not supported, the machine cannot support sleeping states S1, S2, or S3.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359011"></A>PROC_C1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359013"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359015"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359017"></A>A one indicates that the C1 power state is supported on all processors. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359019"></A>P_LVL2_UP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359021"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359023"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359025"></A>A zero indicates that the C2 power state is configured to only work on a uniprocessor (UP) system. A one indicates that the C2 power state is configured to work on a UP or multiprocessor (MP) system.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359027"></A>PWR_BUTTON</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359029"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359031"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359033"></A>A zero indicates the power button is handled as a fixed feature programming model; a one indicates the power button is handled as a control method device. If the system does not have a power button, this value would be &#8220;1&#8221; and no power button device would be present. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1359034"></A>Independent of the value of this field, the presence of a power button device in the namespace indicates to OSPM that the power button is handled as a control method device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359036"></A>SLP_BUTTON</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359038"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359040"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359042"></A>A zero indicates the sleep button is handled as a fixed feature programming model; a one indicates the sleep button is handled as a control method device.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359043"></A>If the system does not have a sleep button, this value would be &#8220;1&#8221; and no sleep button device would be present.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359044"></A>Independent of the value of this field, the presence of a sleep button device in the namespace indicates to OSPM that the sleep button is handled as a control method device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359046"></A>FIX_RTC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359048"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359050"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359052"></A>A zero indicates the RTC wake status is supported in fixed register space; a one indicates the RTC wake status is not supported in fixed register space.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359054"></A>RTC_S4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359056"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359058"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359060"></A>Indicates whether the RTC alarm function can wake the system from the S4 state. The RTC must be able to wake the system from an S1, S2, or S3 sleep state. The RTC alarm can optionally support waking the system from the S4 state, as indicated by this value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359062"></A>TMR_VAL_EXT </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359064"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359066"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359068"></A>A zero indicates TMR_VAL is implemented as a 24-bit value. A one indicates TMR_VAL is implemented as a 32-bit value. The TMR_STS bit is set when the most significant bit of the TMR_VAL toggles.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359070"></A>DCK_CAP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359072"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359074"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359076"></A>A zero indicates that the system cannot support docking. A one indicates that the system can support docking. Notice that this flag does not indicate whether or not a docking station is currently present; it only indicates that the system is capable of docking.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359078"></A>RESET_REG_SUP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359080"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359082"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359084"></A>If set, indicates the system supports system reset via the FADT RESET_REG as described in <A HREF="ACPI Hardware Specification.htm#61654" CLASS="XRef">See Reset Register.</A>, &#8220;Reset Register.&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359086"></A>SEALED_CASE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359088"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359090"></A>11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359092"></A>System Type Attribute. If set indicates that the system has no internal expansion capabilities and the case is sealed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359094"></A>HEADLESS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359096"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359098"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359100"></A>System Type Attribute. If set indicates the system cannot detect the monitor or keyboard / mouse devices.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359102"></A>CPU_SW_SLP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359104"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359106"></A>13</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359108"></A>If set, indicates to OSPM that a processor native instruction must be executed after writing the SLP_TYPx register.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359110"></A>PCI_EXP_WAK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359112"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359114"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359116"></A>If set, indicates the platform supports the PCIEXP_WAKE_STS bit in the PM1 Status register and the PCIEXP_WAKE_EN bit in the PM1 Enable register. This bit must be set on platforms containing chipsets that implement PCI Express and supports PM1 PCIEXP_WAK bits. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359118"></A>USE_PLATFORM_CLOCK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359120"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359122"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359124"></A>A value of one indicates that OSPM should use a platform provided timer to drive any monotonically non-decreasing counters, such as OSPM performance counter services. Which particular platform timer will be used is OSPM specific, however, it is recommended that the timer used is based on the following algorithm: If the HPET is exposed to OSPM, OSPM should use the HPET. Otherwise, OSPM will use the ACPI power management timer. A value of one indicates that the platform is known to have a correctly implemented ACPI power management timer.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359125"></A>A platform may choose to set this flag if a internal processor clock (or clocks in a multi-processor configuration) cannot provide consistent monotonically non-decreasing counters.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359126"></A>Note: If a value of zero is present, OSPM may arbitrarily choose to use an internal processor clock or a platform timer clock for these operations. That is, a zero does not imply that OSPM will necessarily use the internal processor clock to generate a monotonically non-decreasing counter to the system.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359128"></A>S4_RTC_STS_VALID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359130"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359132"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359134"></A>A one indicates that the contents of the RTC_STS flag is valid when waking the system from S4. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1359135"></A>See <A HREF="ACPI Hardware Specification.htm#12599" CLASS="XRef">See PM1 Status Registers Fixed Hardware Feature Status Bits.</A> - PM1 Status Registers Fixed Hardware Feature Status Bits for more information. Some existing systems do not reliably set this input today, and this bit allows OSPM to differentiate correctly functioning platforms from platforms with this errata.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359137"></A>REMOTE_POWER_ON_CAPABLE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359139"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359141"></A>17</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359143"></A>A one indicates that the platform is compatible with remote power- on.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359144"></A>That is, the platform supports OSPM leaving GPE wake events armed prior to an S5 transition. Some existing platforms do not reliably transition to S5 with wake events enabled (for example, the platform may immediately generate a spurious wake event after completing the S5 transition). This flag allows OSPM to differentiate correctly functioning platforms from platforms with this type of errata.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359146"></A>FORCE_ APIC_CLUSTER_MODEL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359148"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359150"></A>18</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359152"></A>A one indicates that all local APICs must be configured for the cluster destination model when delivering interrupts in logical mode.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359153"></A>If this bit is set, then logical mode interrupt delivery operation may be undefined until OSPM has moved all local APICs to the cluster model.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359154"></A>Note that the cluster destination model doesn&#8217;t apply to Itanium&#8482; Processor Family (IPF)  local SAPICs. This bit is intended for xAPIC based machines that require the cluster destination model even when 8 or fewer local APICs are present in the machine.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359156"></A>FORCE_APIC_PHYSICAL_DESTINATION_MODE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359158"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359160"></A>19</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359162"></A>A one indicates that all local xAPICs must be configured for physical destination mode. If this bit is set, interrupt delivery operation in logical destination mode is undefined. On machines that contain fewer than 8 local xAPICs or that do not use the xAPIC architecture, this bit is ignored.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720826"></A>HW_REDUCED_ACPI*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720828"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720830"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720832"></A>A one indicates that the Hardware-Reduced ACPI (section 4.1) is implemented, therefore software-only alternatives are used for supported fixed-features defined in chapter 4.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720818"></A>LOW_POWER_S0_IDLE_CAPABLE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720820"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720822"></A>21</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720824"></A>A one informs OSPM that the platform is able to achieve power savings in S0 similar to or better than those typically achieved in S3.  In effect, when this bit is set it indicates that the system will achieve no power benefit by making a sleep transition to S3.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359164"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359166"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359168"></A>22</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359170"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1801430"></A> * The description of HW_REDUCED_ACPI provided here applies to ACPI specifications 5.0 and later.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359189"></A>Preferred PM Profile System Types</H6>
<P CLASS="Body">
<A NAME="pgfId-1359194"></A>The following descriptions of <A NAME="marker-1359192"></A><A NAME="marker-1359193"></A>preferred power management profile system types are to be used as a guide for setting the Preferred_PM_Profile field in the FADT. OSPM can use this field to set default power management policy parameters during OS installation.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359195"></A>Desktop</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368810"></A>A single user, full featured, stationary computing device that resides on or near an individual&#8217;s work area. Most often contains one processor. Must be connected to AC power to function. This device is used to perform work that is considered mainstream corporate or home computing (for example, word processing, Internet browsing, spreadsheets, and so on).<A NAME="marker-1359196"></A></P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359197"></A>Mobile</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368817"></A>A single-user, full-featured, portable computing device that is capable of running on batteries or other power storage devices to perform its normal functions. Most often contains one processor. This device performs the same task set as a desktop. However it may have limitations dues to its size, thermal requirements, and/or power source life.<A NAME="marker-1359198"></A></P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359199"></A>Workstation</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368824"></A> A single-user, full-featured, stationary computing device that resides on or near an individual&#8217;s work area. Often contains more than one processor. Must be connected to AC power to function. This device is used to perform large quantities of computations in support of such work as CAD/CAM and other graphics-intensive applications.<A NAME="marker-1359200"></A></P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359201"></A>Enterprise Server</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368831"></A>A multi-user, stationary computing device that frequently resides in a separate, often specially designed, room. Will almost always contain more than one processor. Must be connected to AC power to function. This device is used to support large-scale networking, database, communications, or financial operations within a corporation or government.<A NAME="marker-1359202"></A></P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359203"></A>SOHO Server</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368838"></A>A multi-user, stationary computing device that frequently resides in a separate area or room in a small or home office. May contain more than one processor. Must be connected to AC power to function. This device is generally used to support all of the networking, database, communications, and financial operations of a small office or home office.<A NAME="marker-1359204"></A></P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359205"></A>Appliance PC</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368845"></A>A device specifically designed to operate in a low-noise, high-availability environment such as a consumer&#8217;s living rooms or family room. Most often contains one processor. This category also includes home Internet gateways, Web pads, set top boxes and other devices that support ACPI. Must be connected to AC power to function. Normally they are sealed case style and may only perform a subset of the tasks normally associated with today&#8217;s personal computers.</P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1359206"></A>Performance Server</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1368852"></A>A multi-user stationary computing device that frequently resides in a separate, often specially designed room. Will often contain more than one processor. Must be connected to AC power to function. This device is used in an environment where power savings features are willing to be sacrificed for better performance and quicker responsiveness.<A NAME="marker-1359207"></A></P>
</DIV>
<DIV>
<H4 CLASS="GlossTerm">
<A NAME="pgfId-1720913"></A>Tablet</H4>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1720932"></A>A full-featured, highly mobile computing device which resembles writing tablets and which users interact with primarily through a touch interface.  The touch digitizer is the primary user input device, although a keyboard and/or mouse may be present.  Tablet devices typically run on battery power and are generally only plugged into AC power in order to charge.  This device performs many of the same tasks as Mobile; however battery life expectations of Tablet devices generally require more aggressive power savings especially for managing display and touch components.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359208"></A>System Type Attributes</H6>
<P CLASS="Body">
<A NAME="pgfId-1359212"></A>This set of flags is<A NAME="marker-1359211"></A> used by the OS to assist in determining assumptions about power and device management. These flags are read at boot time and are used to make decisions about power management and device settings. For example, a system that has the SEALED_CASE bit set may take a very aggressive low noise policy toward thermal management. In another example an OS might not load video, keyboard or mouse drivers on a HEADLESS system.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359221"></A>I<A NAME="_Ref42580444"></A>A-PC Boot Architecture Flags<A NAME="marker-1359216"></A><A NAME="marker-1359217"></A><A NAME="marker-1359218"></A><A NAME="marker-1359219"></A><A NAME="marker-1359220"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1359222"></A>This set of flags is used by an OS to guide the assumptions it can make in initializing hardware on IA-PC platforms. These flags are used by an OS at boot time (before the OS is capable of providing an operating environment suitable for parsing the ACPI namespace) to determine the code paths to take during boot. In IA-PC platforms with reduced legacy hardware, the OS can skip code paths for legacy devices if none are present. For example, if there are no ISA devices, an OS could skip code that assumes the presence of these devices and their associated resources. These flags are used independently of the ACPI namespace. The presence of other devices must be described in the ACPI namespace as specified in <A HREF="Device_Configuration.htm#99580" CLASS="XRef">See Device Configuration.</A>, &#8220;Configuration.&#8221; These flags pertain only to IA-PC platforms. On other system architectures, the entire field should be set to 0. </P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359223"></A><A NAME="38560"></A>Fixed ACPI Description Table Boot IA-PC Boot Architecture Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359226"></A>IAPC_BOOT_ARCH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359228"></A>Bit length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359230"></A>Bit offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359232"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359234"></A>LEGACY_DEVICES</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359236"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359238"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359240"></A>If set, indicates that the motherboard supports user-visible devices on the LPC or ISA bus. User-visible devices are devices that have end-user accessible connectors (for example, LPT port), or devices for which the OS must load a device driver so that an end-user application can use a device. If clear, the OS may assume there are no such devices and that all devices in the system can be detected exclusively via industry standard device enumeration mechanisms (including the ACPI namespace). </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359242"></A>8042</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359244"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359246"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359248"></A>If set, indicates that the motherboard contains support for a port 60 and 64 based keyboard controller, usually implemented as an 8042 or equivalent micro-controller.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359250"></A>VGA Not Present</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359252"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359254"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359256"></A>If set, indicates to OSPM that it must not blindly probe the VGA hardware (that responds to MMIO addresses A0000h-BFFFFh and IO ports 3B0h-3BBh and 3C0h-3DFh) that may cause machine check on this system. If clear, indicates to OSPM that it is safe to probe the VGA hardware.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359258"></A>MSI Not Supported</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359260"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359262"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359264"></A>If set, indicates to OSPM that it must not enable Message Signaled Interrupts (MSI) on this platform.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359266"></A>PCIe ASPM Controls</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359268"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359270"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359272"></A>If set, indicates to OSPM that it must not enable OSPM ASPM control on this platform.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720945"></A>CMOS RTC Not Present</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720947"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720949"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720951"></A>If set, indicates that the CMOS RTC is either not implemented, or does not exist at the legacy addresses. OSPM uses the Control Method Time and Alarm Namespace device instead.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359274"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359276"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359278"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359280"></A>Must be 0.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1759731"></A>ARM Architecture boot flags</H6>
<P CLASS="Body">
<A NAME="pgfId-1759758"></A>These flags are used by an OS at boot time (before the OS is capable of providing an operating environment suitable for parsing the ACPI namespace) to determine the code paths to take during boot. For the PSCI flags, specifically, the flags describe if the platform is compliant with the PSCI specification. The PSCI specification is found at Links to ACPI-Related Document&quot; <EM CLASS="Hyperlink">
(http://uefi.org/acpi)</EM>
 under the heading<EM CLASS="Hyperlink">
 </EM>
PSCI Specification.</P>
<P CLASS="Body">
<A NAME="pgfId-1759754"></A>The ARM Architecture boot flags are described in <A HREF="ACPI_Software_Programming_Model.htm#50446" CLASS="XRef">See Fixed ACPI Description Table ARM Boot Architecture Flags.</A>:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1748073"></A><A NAME="50446"></A>Fixed ACPI Description Table ARM Boot Architecture Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1748076"></A>ARM_BOOT_ARCH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1748078"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1748080"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1748082"></A>Description	</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748084"></A>PSCI_COMPLIANT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748086"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748088"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748090"></A>1 if PSCI is implemented.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748092"></A>PSCI_USE_HVC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748094"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748096"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748098"></A>1 if HVC must be used as the PSCI conduit.instead of SMC.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748100"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748102"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748104"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1748106"></A>This value is zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1359298"></A><A NAME="_Toc489256013"></A><A NAME="_Toc489267937"></A><A NAME="_Toc489272490"></A><A NAME="_Ref42578342"></A><A NAME="_Ref42580696"></A><A NAME="_Toc202340539"></A><A NAME="_Toc258262220"></A>Firmware ACPI Control Structure (FACS)<A NAME="marker-1359295"></A><A NAME="marker-1359296"></A><A NAME="marker-1359297"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1359299"></A>The Firmware ACPI Control Structure (FACS) is a structure in read/write memory that the platform boot firmware reserves for ACPI usage. This structure is optional if and only if the HARDWARE_REDUCED_ACPI flag in the FADT is set. The FACS is passed to an ACPI-compatible OS using the FADT. For more information about the FADT FIRMWARE_CTRL field, see <A HREF="ACPI_Software_Programming_Model.htm#64460" CLASS="XRef">See Fixed ACPI Description Table (FADT).</A>, &#8220;Fixed ACPI Description Table (FADT).&#8221; </P>
<P CLASS="Body">
<A NAME="pgfId-1359300"></A>The platform boot firmware aligns the FACS on a 64-byte boundary anywhere within the system&#8217;s memory address space. The memory where the FACS structure resides must not be reported as system AddressRangeMemory in the system address map. For example, the E820 address map reporting interface would report the region as AddressRangeReserved. For more information about system address map reporting interfaces, see <A HREF="Sys_Address_Map_Interfaces.htm#68313" CLASS="XRef">See System Address Map Interfaces.</A>, &#8220;System Address Map Interfaces.&#8221;<A NAME="marker-1359301"></A></P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359302"></A><A NAME="34632"></A>Firmware ACPI Control Structure (FACS)</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684482"></A><A NAME="_Ref359952179"></A><A NAME="_Ref368038035"></A><A NAME="_Ref369315960"></A>&nbsp;</P>
<P CLASS="TableHeading">
<A NAME="pgfId-1684483"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684485"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684487"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684489"></A>&nbsp;</P>
<P CLASS="TableHeading">
<A NAME="pgfId-1684490"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359318"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359320"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359322"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359324"></A>&#8216;FACS&#8217;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359326"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359328"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359330"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359332"></A>Length, in bytes, of the entire Firmware ACPI Control Structure. This value is 64 bytes or larger.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359334"></A>Hardware Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359336"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359338"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359340"></A>The value of the system's &quot;hardware signature&quot; at last boot. This value is calculated by the platform boot firmware on a best effort basis to indicate the base hardware configuration of the system such that different base hardware configurations can have different hardware signature values. Although memory described using or EfiPersistentMemory (<A HREF="Sys_Address_Map_Interfaces.htm#68313" CLASS="XRef">See System Address Map Interfaces.</A>) iis not saved/restored by OS during S4, any change to persistent memory that impacts any OS visible firmware interfaces must change hardware signature. Any change to the data in Persistent Memory itself should not be included in computing the hardware signature.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1761417"></A>OSPM uses this information in waking from an S4 state, by comparing the current hardware signature to the signature values saved in the non-volatile sleep image. If the values are not the same, OSPM assumes that the saved non-volatile image is from a different hardware configuration and cannot be restored.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359342"></A>Firmware Waking Vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359344"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359346"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359348"></A>This field is superseded by the X_Firmware_Waking_Vector field.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359349"></A>The 32-bit address field where OSPM puts its waking vector. Before transitioning the system into a global sleeping state, OSPM fills in this field with the physical memory address of an OS-specific wake function. During POST, the platform firmware first checks if the value of the X_Firmware_Waking_Vector field is non-zero and if so transfers control to OSPM as outlined in the X_Firmware_Waking_vector field description below. If the X_Firmware_Waking_Vector field is zero then the platform firmware checks the value of this field and if it is non-zero, transfers control to the specified address.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359350"></A>On PCs, the wake function address is in memory below 1 MB and the control is transferred while in real mode. OSPM&#8217;s wake function restores the processors&#8217; context.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359351"></A>For IA-PC platforms, the following example shows the relationship between the physical address in the Firmware Waking Vector and the real mode address the BIOS jumps to. If, for example, the physical address is 0x12345, then the BIOS must jump to real mode address 0x1234:0x0005. In general this relationship is </P>
<P CLASS="TableBody">
<A NAME="pgfId-1359352"></A>   Real-mode address = </P>
<P CLASS="TableBody">
<A NAME="pgfId-1359353"></A>   Physical address&gt;&gt;4 : Physical address and 0x000F</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359354"></A>Notice that on IA-PC platforms, A20 must be enabled when the BIOS jumps to the real mode address derived from the physical address stored in the Firmware Waking Vector. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369095"></A>Global Lock</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369097"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369099"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369101"></A>This field contains the Global Lock used to synchronize access to shared hardware resources between the OSPM environment and an external controller environment (for example, the SMI environment). This lock is owned exclusively by either OSPM or the firmware at any one time. When ownership of the lock is attempted, it might be busy, in which case the requesting environment exits and waits for the signal that the lock has been released. For example, the Global Lock can be used to protect an embedded controller interface such that only OSPM or the firmware will access the embedded controller interface at any one time. See <A HREF="ACPI_Software_Programming_Model.htm#18034" CLASS="XRef">See Global Lock.</A>, &#8220;Global Lock,&#8221; for more information on acquiring and releasing the Global Lock. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369103"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369105"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369107"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369109"></A>Firmware control structure flags. See <A HREF="ACPI_Software_Programming_Model.htm#52773" CLASS="XRef">See Firmware Control Structure Feature Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369111"></A>X Firmware Waking Vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369113"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369115"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369117"></A>64-bit physical address of OSPM&#8217;s Waking Vector.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369118"></A>Before transitioning the system into a global sleeping state, OSPM fills in this field and the OSPM Flags field to describe the waking vector. OSPM populates this field with the physical memory address of an OS-specific wake function. During POST, the platform firmware checks if the value of this field is non-zero and if so transfers control to OSPM by jumping to this address after creating the appropriate execution environment, which  must be configured as follows:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369119"></A>For 64-bit Itanium&#8482; Processor Family (IPF) -based platforms:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369120"></A>Interrupts must be disabled</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369121"></A>The processor must have psr.i set to 0. See the Intel&#174; ItaniumTM Architecture Software Developer&#8217;s Manual for more information.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369122"></A>Memory address translation must be disabled</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369123"></A>The processor must have psr.it, psr.dt, and psr.rt set to 0. See the Intel&#174; ItaniumTM Architecture Software Developer&#8217;s Manual for more information.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369124"></A>For IA 32 and x64 platforms, platform firmware is required to support a 32 bit execution environment. Platform firmware can additionally support a 64 bit execution environment. If platform firmware supports a 64 bit execution environment, firmware inspects the OSPM Flags during POST. If the 64BIT_WAKE_F flag is set, the platform firmware creates a 64 bit execution environment. Otherwise, the platform firmware creates a 32 bit execution environment. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1369125"></A>For 64 bit execution environment:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369126"></A>Interrupts must be disabled</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369127"></A>EFLAGS.IF set to 0</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369128"></A>Long mode enabled</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369129"></A>Paging mode is enabled and physical memory for waking vector is identity mapped (virtual address equals physical address)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369130"></A>Waking vector must be contained within one physical page</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369131"></A>Selectors are set to be flat and are otherwise not used</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369132"></A>For 32 bit execution environment:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369133"></A>Interrupts must be disabled</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369134"></A>EFLAGS.IF set to 0</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369135"></A>Memory address translation / paging must be disabled</P>
<P CLASS="TableBody">
<A NAME="pgfId-1369136"></A>4 GB flat address space for all segment registers</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369138"></A>Version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369140"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369142"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369144"></A>2-Version of this table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369146"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369148"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369150"></A>33</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369152"></A>This value is zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369154"></A>OSPM Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369156"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369158"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369160"></A>OSPM enabled firmware control structure flags.  Platform firmware must initialize this field to zero.  See <A HREF="ACPI_Software_Programming_Model.htm#16096" CLASS="XRef">See OSPM Enabled Firmware Control Structure Feature Flags.</A> for a description of the OSPM control structure feature flags.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369162"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369164"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369166"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369168"></A>This value is zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359449"></A><A NAME="52773"></A>Firmware Control Structure Feature Flags<A NAME="marker-1359447"></A><A NAME="marker-1359448"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684492"></A>FACS - Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684494"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684496"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684498"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684500"></A>S4BIOS_F</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684502"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684504"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684506"></A>Indicates whether the platform supports S4BIOS_REQ. If S4BIOS_REQ is not supported, OSPM must be able to save and restore the memory state in order to use the S4 state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684508"></A>64BIT_WAKE_SUPPORTED_F</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684510"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684512"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684514"></A>Indicates that the platform firmware supports a 64 bit execution environment for the waking vector.  When set and the OSPM additionally set 64BIT_WAKE_F, the platform firmware will create a 64 bit execution environment before transferring control to the X_Firmware_Waking_Vector. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684516"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684518"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684520"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1684522"></A>The value is zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359487"></A><A NAME="16096"></A>OSPM Enabled Firmware Control Structure Feature Flags<A NAME="marker-1359485"></A><A NAME="marker-1359486"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359490"></A>FACS - Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359492"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359494"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359496"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359498"></A>64BIT_WAKE_F</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359500"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359502"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359504"></A>OSPM sets this bit to indicate to platform firmware that the X_Firmware_Waking_Vector requires a 64 bit execution environment.  </P>
<P CLASS="TableBody">
<A NAME="pgfId-1359505"></A>This flag can only be set if platform firmware sets 64BIT_WAKE_SUPPORTED_F in the FACS flags field.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1359506"></A>This bit field has no affect on ItaniumTM Processor Family (IPF) -based platforms, which require a 64 bit execution environment.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359508"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359510"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359512"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359514"></A>The value is zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359518"></A><A NAME="18034"></A>Global Lock</H6>
<P CLASS="Body">
<A NAME="pgfId-1359524"></A>The pur<A NAME="marker-1359521"></A><A NAME="marker-1359522"></A><A NAME="marker-1359523"></A>pose of the ACPI Global Lock is to provide mutual exclusion between the host OS and the platform runtime firmware. The Global Lock is a 32-bit (DWORD) value in read/write memory located within the FACS and is accessed and updated by both the OS environment and the SMI environment in a defined manner to provide an exclusive lock. Note: this is not a pointer to the Global Lock, it is the actual memory location of the lock. The FACS and Global Lock may be located anywhere in physical memory. </P>
<P CLASS="Body">
<A NAME="pgfId-1359525"></A>By convention, this lock is used to ensure that while one environment is accessing some hardware, the other environment is not. By this convention, when ownership of the lock fails because the other environment owns it, the requesting environment sets a &#8220;pending&#8221; state within the lock, exits its attempt to acquire the lock, and waits for the owning environment to signal that the lock has been released before attempting to acquire the lock again. When releasing the lock, if the pending bit in the lock is set after the lock is released, a signal is sent via an interrupt mechanism to the other environment to inform it that the lock has been released. During interrupt handling for the &#8220;lock released&#8221; event within the corresponding environment, if the lock ownership were still desired an attempt to acquire the lock would be made. If ownership is not acquired, then the environment must again set &#8220;pending&#8221; and wait for another &#8220;lock release&#8221; signal.</P>
<P CLASS="Body">
<A NAME="pgfId-1359526"></A>The table below shows the encoding of the Global Lock DWORD in memory.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359529"></A>Global Lock Structure within the FACS<A NAME="marker-1359528"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359532"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359534"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359536"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359538"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359540"></A>Pending</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359542"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359544"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359546"></A>Non-zero indicates that a request for ownership of the Global Lock is pending.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359548"></A>Owned</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359550"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359552"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359554"></A>Non-zero indicates that the Global Lock is Owned.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359556"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359558"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359560"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359562"></A>Reserved for future use.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1359566"></A>The following code sequence is used by both OSPM and the firmware to acquire ownership of the Global Lock. If non-zero is returned by the function, the caller has been granted ownership of the Global Lock and can proceed. If zero is returned by the function, the caller has not been granted ownership of the Global Lock, the &#8220;pending&#8221; bit has been set, and the caller must wait until it is signaled by an interrupt event that the lock is available before attempting to acquire access again.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1359567"></A> In the examples that follow, the &#8220;GlobalLock&#8221; variable is a pointer that has been previously initialized to point to the 32-bit Global Lock location within the FACS.</LI>
</UL>
<P CLASS="CodeExample">
<A NAME="pgfId-1359569"></A>AcquireGlobalLock:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659340"></A>           mov    ecx, GlobalLock           ; ecx = Address of Global Lock in FACS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659341"></A>acq10:     mov    eax, [ecx]                ; Get current value of Global Lock</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659342"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359573"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359574"></A>           mov    edx, eax</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359575"></A>           and    edx, not 1                 ; Clear pending bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359576"></A>           bts    edx, 1                     ; Check and set owner bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359577"></A>           adc    edx, 0                     ; If owned, set pending bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359578"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359579"></A>           lock cmpxchg dword ptr[ecx], edx  ; Attempt to set new value</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359580"></A>           jnz  short acq10                  ; If not set, try again</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359581"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359582"></A>           cmp    dl, 3                      ; Was it acquired or marked pending?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359583"></A>           sbb    eax, eax                   ; acquired = -1, pending = 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359584"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359585"></A>           ret</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359586"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1359587"></A>The following code sequence is used by OSPM and the firmware to release ownership of the Global Lock. If non-zero is returned, the caller must raise the appropriate event to the other environment to signal that the Global Lock is now free. Depending on the environment, this signaling is done by setting the either the GBL_RLS or BIOS_RLS within their respective hardware register spaces. This signal only occurs when the other environment attempted to acquire ownership while the lock was owned.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359588"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359589"></A>ReleaseGlobalLock:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359590"></A>           mov   ecx, GlobalLock             ; ecx = Address of Global Lock in FACS</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359591"></A>rel10:	     mov   eax, [ecx]                  ; Get current value of Global Lock</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359592"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359593"></A>           mov   edx, eax 			</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359594"></A>           and   edx, not 03h                ; Clear owner and pending field</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359595"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359596"></A>           lock cmpxchg dword ptr[ecx], edx  ; Attempt to set it</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359597"></A>           jnz  short rel10                  ; If not set, try again</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359598"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359599"></A>           and  eax, 1                       ; Was pending set?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359600"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359601"></A>           ; If one is returned (we were pending) the caller must signal that the</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359602"></A>           ; lock has been released using either GBL_RLS or BIOS_RLS as appropriate </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359603"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359604"></A>           ret</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711318"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1359610"></A><A NAME="_Ref359951441"></A><A NAME="_Ref368036492"></A><A NAME="_Ref368036549"></A><A NAME="_Ref368037434"></A>Although using the Global Lock allows various hardware resources to be shared, it is important to notice that its usage when there is ownership contention could entail a significant amount of system overhead as well as waits of an indeterminate amount of time to acquire ownership of the Global Lock. For this reason, implementations should try to design the hardware to keep the required usage of the Global Lock to a minimum. </P>
<P CLASS="Body">
<A NAME="pgfId-1359611"></A>The Global Lock is required whenever a logical register in the hardware is shared. For example, if bit 0 is used by ACPI (OSPM) and bit 1 of the same register is used by SMI, then access to that register needs to be protected under the Global Lock, ensuring that the register&#8217;s contents do not change from underneath one environment while the other is making changes to it. Similarly if the entire register is shared, as the case might be for the embedded controller interface, access to the register needs to be protected under the Global Lock.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1359634"></A><A NAME="_Toc489256014"></A><A NAME="_Toc489267938"></A><A NAME="_Toc489272491"></A><A NAME="_Toc202340540"></A><A NAME="_Toc258262221"></A>Definition Blocks<A NAME="marker-1359632"></A><A NAME="marker-1359633"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1359635"></A>A Definition Block consists of data in AML format (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256021" CLASS="XRef">See Definition Block Encoding.</A> &#8220;Definition Block Encoding&#8221;) and contains information about hardware implementation details in the form of AML objects that contain data, AML code, or other AML objects. The top-level organization of this information after a definition block is loaded is name-tagged in a hierarchical namespace.</P>
<P CLASS="Body">
<A NAME="pgfId-1359636"></A>OSPM &#8220;loads&#8221; or &#8220;unloads&#8221; an entire definition block as a logical unit. OSPM will load a definition block either as a result of executing the AML Load() or LoadTable() operator or encountering a table definition during initialization. During initialization, OSPM loads the Differentiated System Description Table (DSDT), which contains the Differentiated Definition Block, using the DSDT pointer retrieved from the FADT. OSPM will load other definition blocks during initialization as a result of encountering Secondary System Description Table (SSDT) definitions in the RSDT/XSDT. The DSDT and SSDT are described in the following sections. </P>
<P CLASS="Body">
<A NAME="pgfId-1359637"></A>As mentioned, the AML Load() and LoadTable() operators make it possible for a Definition Block to load other Definition Blocks, either statically or dynamically, where they in turn can either define new system attributes or, in some cases, build on prior definitions. Although this gives the hardware the ability to vary widely in implementation, it also confines it to reasonable boundaries. In some cases, the Definition Block format can describe only specific and well-understood variances. In other cases, it permits implementations to be expressible only by means of a specified set of &#8220;built in&#8221; operators. For example, the Definition Block has built in operators for I/O space.</P>
<P CLASS="Body">
<A NAME="pgfId-1359638"></A>In theory, it might be possible to define something like PCI configuration space in a Definition Block by building it from I/O space, but that is not the goal of the definition block. Such a space is usually defined as a &#8220;built in&#8221; operator.</P>
<P CLASS="Body">
<A NAME="pgfId-1359639"></A>Some AML operators perform simple functions, and others encompass complex functions. The power of the Definition block comes from its ability to allow these operations to be glued together in numerous ways, to provide functionality to OSPM.</P>
<P CLASS="Body">
<A NAME="pgfId-1359640"></A>The AML operators defined in this specification are intended to allow many useful hardware designs to be easily expressed, not to allow all hardware designs to be expressed.</P>
<P CLASS="Body">
<A NAME="pgfId-1359641"></A>Note: To accommodate addressing beyond 32 bits, the integer type was expanded to 64 bits in ACPI 2.0, see <A HREF="ACPI_Source_Language_Reference.htm#_Toc4819446" CLASS="XRef">See ASL Data Types.</A>, &#8220;ASL Data Types&#8221;. Existing ACPI definition block implementations may contain an inherent assumption of a 32-bit integer width. Therefore, to maintain backwards compatibility, OSPM uses the Revision field, in the header portion of system description tables containing Definition Blocks, to determine whether integers declared within the Definition Block are to be evaluated as 32-bit or 64-bit values. A Revision field value greater than or equal to 2 signifies that integers declared within the Definition Block are to be evaluated as 64-bit values. The ASL writer specifies the value for the Definition Block table header&#8217;s Revision field via the ASL Definition Block&#8217;s ComplianceRevision field. See <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341980" CLASS="XRef">See DefinitionBlock (Declare Definition Block).</A>, &#8220;DefinitionBlock (Declare Definition Block)&#8221;, for more information. It is the responsibility of the ASL writer to ensure the Definition Block&#8217;s compatibility with the corresponding integer width when setting the ComplianceRevision field.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359655"></A><A NAME="94664"></A>Differentiated System Description Table (DSDT<A NAME="marker-1359654"></A>)<A NAME="marker-1359656"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1359660"></A><A NAME="_Ref359951377"></A>The Differentiated System Description Table (DSDT) is part of the system fixed description. The DSDT is comprised of a system description table header followed by data in Definition Block format. See <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256014" CLASS="XRef">See Definition Blocks.</A>, &#8220;Definition Blocks,&#8221; for a description of Definition Blocks. During initialization, OSPM finds the pointer to the DSDT in the Fixed ACPI Description Table (using the FADT&#8217;s DSDT or X_DSDT fields) and then loads the DSDT to create the ACPI Namespace.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359661"></A>Differentiated System Description Table Fields (DSDT)</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684536"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684538"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684540"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684542"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359672"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359674"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359676"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359678"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359680"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359682"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359684"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359686"></A>&#8216;DSDT&#8217; Signature for the Differentiated System Description Table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359688"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359690"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359692"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359694"></A>Length, in bytes, of the entire DSDT (including the header).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359696"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359698"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359700"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359702"></A>2. This field also sets the global integer width for the AML interpreter. Values less than two will cause the interpreter to use 32-bit integers and math. Values of two and greater will cause the interpreter to use full 64-bit integers and math.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359704"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359706"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359708"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359710"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359712"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359714"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359716"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359718"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359720"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359722"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359724"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359726"></A>The manufacture model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359728"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359730"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359732"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359734"></A>OEM revision of DSDT for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359736"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359738"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359740"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359742"></A>Vendor ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359744"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359746"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359748"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359750"></A>Revision number of the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359752"></A>Definition Block</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359754"></A>n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359756"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359758"></A>n bytes of AML code (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256021" CLASS="XRef">See Definition Block Encoding.</A>, &#8220;Definition Block Encoding&#8221;)</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359774"></A><A NAME="34381"></A>Secondary System Description Table (SSDT<A NAME="marker-1359773"></A>)<A NAME="marker-1359775"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1359778"></A>Secondary System Description Tables (SSDT) are a continuation of the DSDT. The SSDT is comprised of a system description table header followed by data in Definition Block format. There can be multiple SSDTs present. After OSPM loads the DSDT to create the ACPI Namespace, each secondary system description table listed in the RSDT/XSDT with a unique OEM Table ID is loaded. </P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1375953"></A>Additional tables can only add data; they cannot overwrite data from previous tables.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1359779"></A>This allows the OEM to provide the base support in one table and add smaller system options in other tables. For example, the OEM might put dynamic object definitions into a secondary table such that the firmware can construct the dynamic information at boot without needing to edit the static DSDT. A SSDT can only rely on the DSDT being loaded prior to it. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1359780"></A>Secondary System Description Table Fields (SSDT)</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359783"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359785"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359787"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1359789"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359791"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359793"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359795"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359797"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359799"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359801"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359803"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359805"></A>&#8216;SSDT&#8217; Signature for the Secondary System Description Table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359807"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359809"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359811"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359813"></A>Length, in bytes, of the entire SSDT (including the header).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359815"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359817"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359819"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359821"></A>2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359823"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359825"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359827"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359829"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359831"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359833"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359835"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359837"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359839"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359841"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359843"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359845"></A>The manufacture model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359847"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359849"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359851"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359853"></A>OEM revision of DSDT for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359855"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359857"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359859"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359861"></A>Vendor ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359863"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359865"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359867"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359869"></A>Revision number of the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359871"></A>Definition Block</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359873"></A>n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359875"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1359877"></A>n bytes of AML code (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256021" CLASS="XRef">See Definition Block Encoding.</A> , &#8220;Definition Block Encoding&#8221;)</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1359894"></A><A NAME="56903"></A>Persistent System Description Table (PSDT<A NAME="marker-1359893"></A>)<A NAME="marker-1359895"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1359898"></A>The table signature, &#8220;PSDT&#8221; refers to the Persistent System Description Table (PSDT) defined in the ACPI 1.0 specification. The PSDT was judged to provide no specific benefit and as such has been deleted from follow-on versions of the ACPI specification. OSPM will evaluate a table with the &#8220;PSDT&#8221; signature in like manner to the evaluation of an SSDT as described in <A HREF="ACPI_Software_Programming_Model.htm#34381" CLASS="XRef">See Secondary System Description Table (SSDT).</A>, &#8220;Secondary System Description Table.&#8221;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1359911"></A>M<A NAME="_Toc258262222"></A>ultiple APIC Description Table (MADT)<A NAME="marker-1359909"></A><A NAME="marker-1359910"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1712357"></A>The ACPI interrupt model describes all interrupts for the entire system in a uniform interrupt model implementation. Supported interrupt models include the PC-AT-compatible dual 8259 interrupt controller, for Intel processor-based systems, the Intel Advanced Programmable Interrupt Controller (APIC) and Intel Streamlined Advanced Programmable Interrupt Controller (SAPIC), and, for ARM processor-based systems, the Generic Interrupt Controller (GIC). The choice of the interrupt model(s) to support is up to the platform designer. The interrupt model cannot be dynamically changed by the system firmware; OSPM will choose which model to use and install support for that model at the time of installation. If a platform supports multiple models, an OS will install support for only one of the models; it will not mix models. Multi-boot capability is a feature in many modern operating systems. This means that a system may have multiple operating systems or multiple instances of an OS installed at any one time. Platform designers must allow for this.</P>
<P CLASS="Body">
<A NAME="pgfId-1712358"></A>This section describes the format of the Multiple APIC Description Table (MADT), which provides OSPM with information necessary for operation on systems with APIC,  SAPIC or GIC implementations.</P>
<P CLASS="Body">
<A NAME="pgfId-1359916"></A>ACPI represents all interrupts as &quot;flat&quot; values known as global system interrupts. Therefore to support APICs, SAPICs or GICs on an ACPI-enabled system, each used interrupt input must be mapped to the global system interrupt value used by ACPI. See <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256015" CLASS="XRef">See Global System Interrupts.</A>. Global System Interrupts,&#8221; for a description of Global System Interrupts.</P>
<P CLASS="Body">
<A NAME="pgfId-1359918"></A>Additional support is required to handle various multi-processor functions that implementations might support (for example, identifying each processor's local interrupt controller ID).</P>
<P CLASS="Body">
<A NAME="pgfId-1712386"></A>All addresses in the MADT are processor-relative physical addresses.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1369559"></A>Multiple APIC Description Table (MADT) Format<A NAME="marker-1832932"></A><A NAME="marker-1832933"></A><A NAME="marker-1832934"></A><A NAME="_Ref374118614"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684552"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684554"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684556"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684558"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369456"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369458"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369460"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369462"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369464"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369466"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369468"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369470"></A>&#8216;APIC&#8217; Signature for the Multiple APIC Description Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369472"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369474"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369476"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369478"></A>Length, in bytes, of the entire MADT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369480"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369482"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369484"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369486"></A>5</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369488"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369490"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369492"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369494"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369496"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369498"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369500"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369502"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369504"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369506"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369508"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369510"></A>For the MADT, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369512"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369514"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369516"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369518"></A>OEM revision of MADT for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369520"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369522"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369524"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369526"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369528"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369530"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369532"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369534"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369536"></A>Local Interrupt Controller Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369538"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369540"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369542"></A>The 32-bit physical address at which each processor can access its local interrupt controller.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369544"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369546"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369548"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369550"></A>Multiple APIC flags. See <A HREF="ACPI_Software_Programming_Model.htm#49510" CLASS="XRef">See Multiple APIC Flags.</A> for a description of this field. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369552"></A>Interrupt Controller Structure[n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369554"></A>--</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369556"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369558"></A>A list of interrupt controller structures for this implementation. This list will contain all of the structures from <A HREF="ACPI_Software_Programming_Model.htm#49253" CLASS="XRef">See Interrupt Controller Structure Types.</A> needed to support this platform. These structures are described in the following sections.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1369564"></A><A NAME="49510"></A>Multiple APIC Flags<A NAME="marker-1369562"></A><A NAME="marker-1369563"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360045"></A>Multiple APIC Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360047"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360049"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360051"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360053"></A>PCAT_COMPAT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360055"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360057"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360059"></A>A one indicates that the system also has a PC-AT-compatible dual-8259 setup. The 8259 vectors must be disabled (that is, masked) when enabling the ACPI APIC operation.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360061"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360063"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360065"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360067"></A>This value is zero.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1360070"></A>Immediately after the Flags value in the MADT is a list of interrupt controller structures that declare the interrupt features of the machine. The first byte of each structure declares the type of that structure and the second byte declares the length of that structure.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360072"></A><A NAME="49253"></A>Interrupt Controller Structure Types<A NAME="marker-1360071"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1784972"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1784974"></A>Description</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1784976"></A>_MAT for Processor object <EM CLASS="Superscript">
a</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1784978"></A>_MAT for an I/O APIC object b</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1784980"></A>Reference</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784982"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784984"></A>Processor Local APIC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784986"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784988"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784990"></A><A HREF="ACPI_Software_Programming_Model.htm#33354" CLASS="XRef">See Processor Local APIC Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784992"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784994"></A>I/O APIC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784996"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1784998"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785000"></A><A HREF="ACPI_Software_Programming_Model.htm#82632" CLASS="XRef">See I/O APIC Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785002"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785004"></A>Interrupt Source Override</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785006"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785008"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785010"></A><A HREF="ACPI_Software_Programming_Model.htm#49857" CLASS="XRef">See Interrupt Source Override Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785012"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785014"></A>Non-maskable Interrupt (NMI) Source</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785016"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785018"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785020"></A><A HREF="ACPI_Software_Programming_Model.htm#78712" CLASS="XRef">See Non-Maskable Interrupt (NMI) Source Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785022"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785024"></A>Local APIC NMI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785026"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785028"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785030"></A><A HREF="ACPI_Software_Programming_Model.htm#82067" CLASS="XRef">See Local APIC NMI Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785032"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785034"></A>Local APIC Address Override</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785036"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785038"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785040"></A><A HREF="ACPI_Software_Programming_Model.htm#_Toc459452690" CLASS="XRef">See Local APIC Address Override Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785042"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785044"></A>I/O SAPIC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785046"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785048"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785050"></A><A HREF="ACPI_Software_Programming_Model.htm#51165" CLASS="XRef">See I/O SAPIC Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785052"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785054"></A>Local SAPIC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785056"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785058"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785060"></A><A HREF="ACPI_Software_Programming_Model.htm#51165" CLASS="XRef">See I/O SAPIC Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785062"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785064"></A>Platform Interrupt Sources</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785066"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785068"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785070"></A><A HREF="ACPI_Software_Programming_Model.htm#53754" CLASS="XRef">See Platform Interrupt Source Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785072"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785074"></A>Processor Local x2APIC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785076"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785078"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785080"></A><A HREF="ACPI_Software_Programming_Model.htm#38264" CLASS="XRef">See Processor Local x2APIC Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785082"></A>0xA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785084"></A>Local x2APIC NMI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785086"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785088"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785090"></A><A HREF="ACPI_Software_Programming_Model.htm#30225" CLASS="XRef">See Local x2APIC NMI Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785092"></A>0xB</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785094"></A>GIC CPU Interface (GICC) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785096"></A>yes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785098"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785100"></A><A HREF="ACPI_Software_Programming_Model.htm#81013" CLASS="XRef">See GIC CPU Interface (GICC) Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785102"></A>0xC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785104"></A>GIC Distributor (GICD) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785106"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785108"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785110"></A><A HREF="ACPI_Software_Programming_Model.htm#31257" CLASS="XRef">See GIC Distributor (GICD) Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785112"></A>0xD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785114"></A>GIC MSI Frame</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785116"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785118"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785120"></A><A HREF="ACPI_Software_Programming_Model.htm#90220" CLASS="XRef">See GIC MSI Frame Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785122"></A>0xE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785124"></A>GIC Redistributor (GICR) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785126"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785128"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785130"></A><A HREF="ACPI_Software_Programming_Model.htm#62903" CLASS="XRef">See GIC Redistributor (GICR) Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785132"></A>0xF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785134"></A>GIC Interrupt Translation Service (ITS) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785136"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785138"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785140"></A><A HREF="ACPI_Software_Programming_Model.htm#45360" CLASS="XRef">See GIC Interrupt Translation Service (ITS) Structure.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785142"></A>0x10-0x7F</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785144"></A>Reserved. OSPM skips structures of the reserved type.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785146"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785148"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785150"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785152"></A>0x80-0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785154"></A>Reserved for OEM use</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785156"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785158"></A>no</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1785160"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="5">
<P CLASS="TableBody">
<A NAME="pgfId-1785162"></A><EM CLASS="Superscript">
a</EM>
 When _MAT (see <A HREF="Device_Configuration.htm#_Toc489256054" CLASS="XRef">See _MAT (Multiple APIC Table Entry).</A>) appears under a Processor Device object (see <A HREF="Processor_Configuration_and_Control.htm#_Toc202341607" CLASS="XRef">See Declaring Processors.</A>), OSPM processes the Interrupt Controller Structures returned by _MAT with the types labeled &quot;yes&quot; and ignores other types.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1785163"></A><EM CLASS="Superscript">
b </EM>
When _MAT appears under an I/O APIC Device (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#_Toc202341731" CLASS="XRef">See I/O APIC Device.</A>), OSPM processes the Interrupt Controller Structures returned by _MAT with the types labeled &quot;yes&quot; and ignores other types.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360143"></A><A NAME="_Toc374252776"></A><A NAME="_Toc374852675"></A><A NAME="_Toc375382466"></A><A NAME="_Toc375924698"></A><A NAME="_Toc423759907"></A><A NAME="_Toc459174148"></A><A NAME="_Toc459452684"></A><A NAME="_Toc462735417"></A><A NAME="_Toc466180905"></A><A NAME="_Toc469220344"></A> MADT Processor Local APIC / SAPIC Structure Entry Order</H6>
<P CLASS="Body">
<A NAME="pgfId-1360144"></A>OSPM implementations may limit the number of supported processors on multi-processor platforms. OSPM executes on the boot processor to initialize the platform including other processors. To ensure that the boot processor is supported post initialization, two guidelines should be followed. The first is that OSPM should initialize processors in the order that they appear in the MADT. The second is that platform firmware should list the boot processor as the first processor entry in the MADT.</P>
<P CLASS="Body">
<A NAME="pgfId-1360145"></A>The advent of multi-threaded processors yielded multiple logical processors executing on common processor hardware. ACPI defines logical processors in an identical manner as physical processors. To ensure that non multi-threading aware OSPM implementations realize optimal performance on platforms containing multi-threaded processors, two guidelines should be followed. The first is the same as above,  that is, OSPM should initialize processors in the order that they appear in the MADT. The second is that platform firmware should list the first logical processor of each of the individual multi-threaded processors in the MADT before listing any of the second logical processors. This approach should be used for all successive logical processors.</P>
<P CLASS="Body">
<A NAME="pgfId-1360146"></A>Failure of OSPM implementations and platform firmware to abide by these guidelines can result in both unpredictable and non optimal platform operation.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360148"></A><A NAME="33354"></A> Processor Local APIC Structure<A NAME="marker-1360147"></A><A NAME="marker-1360149"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1360152"></A>When using the APIC interrupt model, each processor in the system is required to have a Processor Local APIC record in the MADT, and a processor device object in the DSDT. OSPM does not expect the information provided in this table to be updated if the processor information changes during the lifespan of an OS boot. While in the sleeping state, processors are not allowed to be added, removed, nor can their APIC ID or Flags change. When a processor is not present, the Processor Local APIC information is either not reported or flagged as disabled.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1369721"></A>Processor Local APIC Structure <A NAME="marker-1369671"></A><A NAME="_Ref374118641"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1369674"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1369676"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1369678"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1369680"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369682"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369684"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369686"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369688"></A>0	Processor Local APIC structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369690"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369692"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369694"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369696"></A>8</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369698"></A>ACPI Processor UID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369700"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369702"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369704"></A>The OS associates this Local APIC Structure with a processor object in the namespace when the _UID child object of the processor's device object (or the  ProcessorId listed in the Processor declaration operator) evaluates to a numeric value that matches the numeric value in this field. Note that the use of the Processor declaration operator is deprecated. See the compatibility note in <A HREF="ACPI_Software_Programming_Model.htm#33354" CLASS="XRef">See Processor Local APIC Structure.</A> and  see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267442" CLASS="XRef">See Processor (Declare Processor).</A>, &#8220;Processor (Declare Processor).&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369706"></A>APIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369708"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369710"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369712"></A>The processor&#8217;s local APIC ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369714"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369716"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369718"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1369720"></A>Local APIC flags. See <A HREF="ACPI_Software_Programming_Model.htm#34770" CLASS="XRef">See Local APIC Flags.</A> for a description of this field.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1369725"></A><A NAME="34770"></A>Local APIC Flags<A NAME="marker-1369724"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360212"></A>LocalAPIC Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360214"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360216"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360218"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360220"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360222"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360224"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842480"></A>If this bit is set the processor is ready for use.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1842481"></A>If this bit is clear and the Online Capable bit is set, system hardware supports enabling this processor during OS runtime.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1842482"></A>If this bit is clear and the Online Capable bit is also clear, this processor is unusable, and OSPM shall ignore the contents of the Processor Local APIC Structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842495"></A>Online Capbable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842497"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842499"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842528"></A>The information conveyed by this bit depends on the value of the Enabled bit.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1842529"></A>If the Enabled bit is set, this bit is reserved and must be zero.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1842530"></A>Otherwise, if this this bit is set, system hardware supports enabling this processor during OS runtime.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360241"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="_Toc374252777"></A><A NAME="_Toc374852676"></A><A NAME="_Toc375382467"></A><A NAME="_Toc375924699"></A><A NAME="_Toc423759908"></A><A NAME="_Toc459174149"></A><A NAME="_Toc459452685"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360243"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360245"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360247"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360255"></A><A NAME="82632"></A>I/O APIC Structur<A NAME="marker-1360254"></A>e</H6>
<P CLASS="Body">
<A NAME="pgfId-1360259"></A><A NAME="marker-1360256"></A>In an APIC implementation, there are one or more I/O APICs. Each I/O APIC has a series of interrupt inputs, referred to as INTIn, where the value of n is from 0 to the number of the last interrupt input on the I/O APIC. The I/O APIC structure declares which global system interrupts are uniquely associated with the I/O APIC interrupt inputs. There is one I/O APIC structure for each I/O APIC in the system. For more information on global system interrupts see <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256015" CLASS="XRef">See Global System Interrupts.</A>, &#8220;Global System Interrupts.&#8221;</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360261"></A>I/O APIC Structure <A NAME="marker-1360260"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360264"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360266"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360268"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360270"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360272"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360274"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360276"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360278"></A>1	I/O APIC structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360280"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360282"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360284"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360286"></A>12</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360288"></A>I/O APIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360290"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360292"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360294"></A>The I/O APIC&#8217;s ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360296"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360298"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360300"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360302"></A>0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360304"></A>I/O APIC Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360306"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360308"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360310"></A>The 32-bit physical address to access this I/O APIC. Each I/O APIC resides at a unique address.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360312"></A>Global System Interrupt Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360314"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360316"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360318"></A>The global system interrupt number where this I/O APIC&#8217;s interrupt inputs start. The number of interrupt inputs is determined by the I/O APIC&#8217;s Max Redir Entry register.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360328"></A>Platforms with APIC and Dual 8259 Support</H6>
<P CLASS="Body">
<A NAME="pgfId-1360333"></A>Systems that support both APIC and dua<A NAME="marker-1360331"></A><A NAME="marker-1360332"></A>l 8259 interrupt models must map global system interrupts 0-15 to the 8259 IRQs 0-15, except where Interrupt Source Overrides are provided (see <A HREF="ACPI_Software_Programming_Model.htm#49857" CLASS="XRef">See Interrupt Source Override Structure.</A>, &#8220;Interrupt Source Override Structure&#8221; below). This means that I/O APIC interrupt inputs 0-15 must be mapped to global system interrupts 0-15 and have identical sources as the 8259 IRQs 0-15 unless overrides are used. This allows a platform to support OSPM implementations that use the APIC model as well as OSPM implementations that use the 8259 model (OSPM will only use one model; it will not mix models<A NAME="marker-1360334"></A><A NAME="marker-1360335"></A><A NAME="marker-1360336"></A><A NAME="marker-1360337"></A>).</P>
<P CLASS="Body">
<A NAME="pgfId-1375992"></A>When OSPM supports the 8259 model, it will assume that all interrupt descriptors reporting global system interrupts 0-15 correspond to 8259 IRQs. In the 8259 model all global system interrupts greater than 15 are ignored. If OSPM implements APIC support, it will enable the APIC as described by the APIC specification and will use all reported global system interrupts that fall within the limits of the interrupt inputs defined by the I/O APIC structures. For more information on hardware resource configuration see <A HREF="Device_Configuration.htm#99580" CLASS="XRef">See Device Configuration.</A>, &#8220;Configuration.&#8221;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1375995"></A><A NAME="49857"></A>Interrupt Source Override Structur<A NAME="marker-1375994"></A>e</H6>
<P CLASS="Body">
<A NAME="pgfId-1375996"></A>Interrupt Source Overrides are necessary to describe variances between the IA-PC standard dual 8259 interrupt definition and the platform&#8217;s implementation. <A NAME="marker-1375997"></A><A NAME="marker-1375998"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1360355"></A>It is assumed that the ISA interrupts will be identity-mapped into the first I/O APIC sources. Most existing APIC designs, however, will contain at least one exception to this assumption. The Interrupt Source Override Structure is provided in order to describe these exceptions. It is not necessary to provide an Interrupt Source Override for every ISA interrupt. Only those that are not identity-mapped onto the APIC interrupt inputs need be described.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1360357"></A>This specification only supports overriding ISA interrupt sources.<A NAME="marker-1360356"></A></LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1360358"></A>For example, if your machine has the ISA Programmable Interrupt Timer (PIT) connected to ISA IRQ 0, but in APIC mode, it is connected to I/O APIC interrupt input 2, then you would need an Interrupt Source Override where the source entry is &#8216;0&#8217; and the Global System Interrupt is &#8216;2.&#8217;</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360359"></A>Interrupt Source Override Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360362"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360364"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360366"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360368"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360370"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360372"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360374"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360376"></A>2	Interrupt Source Override</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360378"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360380"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360382"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360384"></A>10</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360386"></A>Bus</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360388"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360390"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360392"></A>0	Constant, meaning ISA</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360394"></A>Source</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360396"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360398"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360400"></A>Bus-relative interrupt source (IRQ)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360402"></A>Global System Interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360404"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360406"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360408"></A>The Global System Interrupt that this bus-relative interrupt source will signal.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360410"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360412"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360414"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360416"></A>MPS INTI flags. See <A HREF="ACPI_Software_Programming_Model.htm#16844" CLASS="XRef">See MPS INTI Flags.</A> for a description of this field.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1360419"></A>The MPS INTI flags listed in <A HREF="ACPI_Software_Programming_Model.htm#16844" CLASS="XRef">See MPS INTI Flags.</A> are identical to the flags used in Table 4-10 of the MPS version 1.4 specifications. The Polarity flags are the PO bits and the Trigger Mode flags are the EL bits.<A NAME="marker-1360420"></A><A NAME="marker-1360421"></A></P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360422"></A><A NAME="16844"></A>MPS INTI Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360425"></A>Local APIC - Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360427"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360429"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360431"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360434"></A>Polarity<A NAME="marker-1360433"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1360436"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360438"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360440"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360442"></A>Polarity of the APIC I/O input signals:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360443"></A>00	Conforms to the specifications of the bus</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360444"></A>(For example, EISA is active-low for level-triggered interrupts)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360445"></A>01	Active high</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360446"></A>10	<EM CLASS="Italic">
Reserved</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360447"></A>11	Active low</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360450"></A>Trigger Mode<A NAME="marker-1360449"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1360452"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360454"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360456"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360458"></A>Trigger mode of the APIC I/O Input signals:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360459"></A>00	Conforms to specifications of the bus </P>
<P CLASS="TableBody">
<A NAME="pgfId-1360460"></A>(For example, ISA is edge-triggered)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360461"></A>01	Edge-triggered</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360462"></A>10	<EM CLASS="Italic">
Reserved</EM>
</P>
<P CLASS="TableBody">
<A NAME="pgfId-1360463"></A>11	Level-triggered</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360465"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360467"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360469"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360471"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1360474"></A>Interrupt Source Overrides are also necessary when an identity mapped interrupt input has a non-standard polarity.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1360475"></A>You must have an interrupt source override entry for the IRQ mapped to the SCI interrupt if this IRQ is not identity mapped. This entry will override the value in SCI_INT in FADT. For example, if SCI is connected to IRQ 9 in PIC mode and IRQ 9 is connected to INTIN11 in APIC mode, you should have 9 in SCI_INT in the FADT and an interrupt source override entry mapping IRQ 9 to INTIN11.<A NAME="marker-1360476"></A><A NAME="marker-1360477"></A></LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360487"></A><A NAME="78712"></A>Non-Maskable Interrupt (NMI) Source Structur<A NAME="marker-1360486"></A>e<A NAME="marker-1360488"></A><A NAME="marker-1360489"></A><A NAME="marker-1360490"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1360493"></A>This structure allows a platform designer to specify which I/O (S)APIC interrupt inputs should be enabled as non-maskable. Any source that is non-maskable will not be available for use by devices.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360495"></A><A NAME="62866"></A>NMI Source Structure <A NAME="marker-1360494"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360498"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360500"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360502"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360504"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360506"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360508"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360510"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360512"></A>3	NMI Source</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360514"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360516"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360518"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360520"></A>8</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360522"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360524"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360526"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360528"></A>Same as MPS INTI flags</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360530"></A>Global System Interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360532"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360534"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360536"></A>The Global System Interrupt that this NMI will signal.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360546"></A><A NAME="82067"></A>Local APIC NMI Structur<A NAME="marker-1360545"></A>e<A NAME="marker-1360547"></A><A NAME="marker-1360548"></A><A NAME="marker-1360549"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1360552"></A>This structure describes the Local APIC interrupt input (LINTn) that NMI is connected to for each of the processors in the system where such a connection exists. This information is needed by OSPM to enable the appropriate local APIC entry. <A NAME="marker-1360553"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1360554"></A>Each Local APIC NMI connection requires a separate Local APIC NMI structure. For example, if the platform has 4 processors with ID 0-3 and NMI is connected LINT1 for processor 3 and 2, two Local APIC NMI entries would be needed in the MADT.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360555"></A><A NAME="58000"></A>Local APIC NMI Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360558"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360560"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360562"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360564"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360566"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360568"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360570"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360572"></A>4	Local APIC NMI Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360574"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360576"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360578"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360580"></A>6</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360582"></A>ACPI Processor UID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360584"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360586"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1762361"></A>Value corresponding to the _UID listed in the processor&#8217;s device object, or the Processor ID corresponding to the ID listed in the processor object. A value of 0xFF signifies that this applies to all processors in the machine.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1762381"></A>Note that the use of the Processor declaration operator is deprecated. See the compatibility note in <A HREF="ACPI_Software_Programming_Model.htm#38264" CLASS="XRef">See Processor Local x2APIC Structure.</A> and  see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267442" CLASS="XRef">See Processor (Declare Processor).</A>, &#8220;Processor (Declare Processor).&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360590"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360592"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360594"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360596"></A>MPS INTI flags. See <A HREF="ACPI_Software_Programming_Model.htm#16844" CLASS="XRef">See MPS INTI Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360598"></A>Local APIC LINT#</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360600"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360602"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360604"></A>Local APIC interrupt input LINTn to which NMI is connected.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360606"></A><A NAME="_Toc459452690"></A><A NAME="_Toc462735423"></A><A NAME="_Toc466180911"></A><A NAME="_Toc469220350"></A>L<A NAME="_Ref42578472"></A>ocal APIC Address Override Structure </H6>
<P CLASS="Body">
<A NAME="pgfId-1360615"></A>This optional structure supports 64-bit systems by providing an override of the physical address of the local APIC in the MADT&#8217;s table header, which is defined as a 32-bit field.</P>
<P CLASS="Body">
<A NAME="pgfId-1360616"></A>If defined, OSPM must use the address specified in this structure for all local APICs (and local SAPICs), rather than the address contained in the MADT&#8217;s table header. Only one Local APIC Address Override Structure may be defined.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360617"></A>Local APIC Address Override Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360620"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360622"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360624"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360626"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360628"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360630"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360632"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360634"></A>5	Local APIC Address Override Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360636"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360638"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360640"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360642"></A>12</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360644"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360646"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360648"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360650"></A>Reserved (must be set to zero)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360652"></A>Local APIC Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360654"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360656"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360658"></A>Physical address of Local APIC. For Itanium&#8482; Processor Family (IPF)-based platforms, this field contains the starting address of the Processor Interrupt Block. See the Intel&#174; ItaniumTM Architecture Software Developer&#8217;s Manual for more information.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360666"></A><A NAME="51165"></A>I/O SAPIC Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1360671"></A>The I/O SAPIC st<A NAME="marker-1360669"></A><A NAME="marker-1360670"></A>ructure is very similar to the I/O APIC structure. If both I/O APIC and I/O SAPIC structures exist for a specific APIC ID, the information in the I/O SAPIC structure must be used.</P>
<P CLASS="Body">
<A NAME="pgfId-1360672"></A>The I/O SAPIC structure uses the I/O APIC ID field as defined in the I/O APIC table. The Global System Interrupt Base field remains unchanged but has been moved. The I/O APIC Address field has been deleted. A new address and reserved field have been added.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360674"></A>I/O SAPIC Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360677"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360679"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360681"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360683"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360685"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360687"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360689"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360691"></A>6	I/O SAPIC Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360693"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360695"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360697"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360699"></A>16</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360701"></A>I/O APIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360703"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360705"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360707"></A>I/O SAPIC ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360709"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360711"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360713"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360715"></A>Reserved (must be zero)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360717"></A>Global System Interrupt Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360719"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360721"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360723"></A>The global system interrupt number where this I/O SAPIC&#8217;s interrupt inputs start. The number of interrupt inputs is determined by the I/O SAPIC&#8217;s Max Redir Entry register.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360725"></A>I/O SAPIC Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360727"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360729"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360731"></A>The 64-bit physical address to access this I/O SAPIC. Each I/O SAPIC resides at a unique address. </P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1360734"></A>If defined, OSPM must use the information contained in the I/O SAPIC structure instead of the information from the I/O APIC structure.</P>
<P CLASS="Body">
<A NAME="pgfId-1360735"></A>If both I/O APIC and an I/O SAPIC structures exist in an MADT, the OEM/platform firmware writer must prevent &#8220;mixing&#8221; I/O APIC and I/O SAPIC addresses. This is done by ensuring that there are at least as many I/O SAPIC structures as I/O APIC structures and that every I/O APIC structure has a corresponding I/O SAPIC structure (same APIC ID).<A NAME="marker-1360736"></A><A NAME="marker-1360737"></A><A NAME="marker-1360738"></A><A NAME="marker-1360739"></A></P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360749"></A>L<A NAME="_Ref42580768"></A>ocal SAPIC Structure<A NAME="marker-1360747"></A><A NAME="marker-1360748"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1360750"></A>The Processor local SAPIC structure is very similar to the processor local APIC structure. When using the SAPIC interrupt model, each processor in the system is required to have a Processor Local SAPIC record in the MADT, and a processor device object in the DSDT. OSPM does not expect the information provided in this table to be updated if the processor information changes during the lifespan of an OS boot. While in the sleeping state, processors are not allowed to be added, removed, nor can their SAPIC ID or Flags change. When a processor is not present, the Processor Local SAPIC information is either not reported or flagged as disabled.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1360751"></A><A NAME="95975"></A>Processor Local SAPIC Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360754"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360756"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360758"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1360760"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360762"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360764"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360766"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360768"></A>7	Processor Local SAPIC structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360770"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360772"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360774"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360776"></A>Length of the Local SAPIC Structure in bytes.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360778"></A>ACPI Processor ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360780"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360782"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360784"></A>OSPM associates the Local SAPIC Structure with a processor object declared in the namespace using the Processor statement by matching the processor object&#8217;s ProcessorID value with this field. The use of the Processor statement is deprecated. See the compatibility note in <A HREF="ACPI_Software_Programming_Model.htm#38264" CLASS="XRef">See Processor Local x2APIC Structure.</A>, and <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267442" CLASS="XRef">See Processor (Declare Processor).</A>, &#8220;Processor (Declare Processor).&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360786"></A>Local SAPIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360788"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360790"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360792"></A>The processor&#8217;s local SAPIC ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360794"></A>Local SAPIC EID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360796"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360798"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360800"></A>The processor&#8217;s local SAPIC EID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360802"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360804"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360806"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360808"></A>Reserved (must be set to zero)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360810"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360812"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360814"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360816"></A> Local SAPIC flags. See <A HREF="ACPI_Software_Programming_Model.htm#34770" CLASS="XRef">See Local APIC Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360818"></A>ACPI Processor UID Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360820"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360822"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360824"></A>OSPM associates the Local SAPIC Structure with a processor object declared in the namespace using the Device statement, when the _UID child object of the processor device evaluates to a numeric value, by matching the numeric value with this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360826"></A>ACPI Processor UID String</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360828"></A>&gt;=1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360830"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1360832"></A>OSPM associates the Local SAPIC Structure with a processor object declared in the namespace using the Device statement, when the _UID child object of the processor device evaluates to a string, by matching the string with this field. This value is stored as a null-terminated ASCII string.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360840"></A><A NAME="53754"></A>Platform Interrupt Source Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1360845"></A>The Platform Interrupt Source st<A NAME="marker-1360843"></A><A NAME="marker-1360844"></A>ructure is used to communicate which I/O SAPIC interrupt inputs are connected to the platform interrupt sources.</P>
<P CLASS="Body">
<A NAME="pgfId-1360846"></A>Platform Management Interrupts (PMIs) are used to invoke platform firmware to handle various events (similar to SMI in IA-32). The Intel&#174; ItaniumTM architecture permits the I/O SAPIC to send a vector value in the interrupt message of the PMI type. This value is specified in the I/O SAPIC Vector field of the Platform Interrupt Sources Structure. <A NAME="marker-1360847"></A><A NAME="marker-1360848"></A><A NAME="marker-1360849"></A><A NAME="marker-1360850"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1360851"></A>INIT messages cause processors to soft reset. </P>
<P CLASS="Body">
<A NAME="pgfId-1360858"></A>If a platform can generate an interrupt after correcting platform errors (e.g., single bit error correction), the interrupt input line used to signal such corrected errors is specified by the Global System Interrupt field in the following table. Some systems may restrict the retrieval of corrected platform error information to a specific processor. In such cases, the firmware indicates the processor that can retrieve the corrected platform error information through the Processor ID and EID fields in the structure below. OSPM is required to program the I/O SAPIC redirection table entries with the Processor ID, EID values specified by the ACPI system firmware. On platforms where the retrieval of corrected platform error information can be performed on any processor, the firmware indicates this capability by setting the CPEI Processor Override flag in the Platform Interrupt Source Flags field of the structure below. If the CPEI Processor Override Flag is set, OSPM uses the processor specified by Processor ID, and EID fields of the structure below only as a target processor hint and the error retrieval can be performed on any processor in the system. However, firmware is required to specify valid values in Processor ID, EID fields to ensure backward compatibility. </P>
<P CLASS="Body">
<A NAME="pgfId-1360859"></A>If the CPEI Processor Override flag is clear, OSPM may reject a ejection request for the processor that is targeted for the corrected platform error interrupt. If the CPEI Processor Override flag is set, OSPM can retarget the corrected platform error interrupt to a different processor when the target processor is ejected.</P>
<P CLASS="Body">
<A NAME="pgfId-1360860"></A>Note that the _MAT object can return a buffer containing Platform Interrupt Source Structure entries. It is allowed for such an entry to refer to a Global System Interrupt that is already specified by a Platform Interrupt Source Structure provided through the static MADT table, provided the value of platform interrupt source flags are identical.</P>
<P CLASS="Body">
<A NAME="pgfId-1360861"></A>Refer to the ItaniumTM Processor Family System Abstraction Layer (SAL) Specification for details on handling the Corrected Platform Error Interrupt.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1739731"></A><A NAME="52028"></A>Platform Interrupt Source Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739649"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739651"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739653"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739655"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739657"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739659"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739661"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739663"></A>8	Platform Interrupt Source structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739665"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739667"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739669"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739671"></A>16</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739673"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739675"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739677"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739679"></A>MPS INTI flags. See <A HREF="ACPI_Software_Programming_Model.htm#16844" CLASS="XRef">See MPS INTI Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739681"></A>Interrupt Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739683"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739685"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739687"></A>1	PMI</P>
<P CLASS="TableBody">
<A NAME="pgfId-1739688"></A>2	INIT</P>
<P CLASS="TableBody">
<A NAME="pgfId-1739689"></A>3	Corrected Platform Error Interrupt</P>
<P CLASS="TableBody">
<A NAME="pgfId-1739690"></A>All other values are reserved.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739692"></A>Processor ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739694"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739696"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739698"></A>Processor ID of destination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739700"></A>Processor EID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739702"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739704"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739706"></A>Processor EID of destination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739708"></A>I/O SAPIC Vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739710"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739712"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739714"></A>Value that OSPM must use to program the vector field of the I/O SAPIC redirection table entry for entries with the PMI interrupt type.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739716"></A>Global System Interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739718"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739720"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739722"></A>The Global System Interrupt that this platform interrupt will signal.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739724"></A>Platform Interrupt Source Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739726"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739728"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739730"></A>Platform Interrupt Source Flags. See <A HREF="ACPI_Software_Programming_Model.htm#49919" CLASS="XRef">See Platform Interrupt Source Flags.</A> for a description of this field</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1739763"></A><A NAME="49919"></A>Platform Interrupt Source Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739737"></A>Platform Interrupt Source Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739739"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739741"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739743"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739745"></A>CPEI Processor Override</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739747"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739749"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739751"></A>When set, indicates that retrieval of error information is allowed from any processor and OSPM is to use the information provided by the processor ID, EID fields of the Platform Interrupt Source Structure (<A HREF="ACPI_Software_Programming_Model.htm#52028" CLASS="XRef">See Platform Interrupt Source Structure.</A>) as a target processor hint.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739756"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739758"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739760"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739762"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1360979"></A><A NAME="38264"></A> Processor Local x2APIC Structure<A NAME="marker-1360978"></A><A NAME="marker-1360980"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1762445"></A>The Processor X2APIC structure is very similar to the processor local APIC structure. When using the X2APIC interrupt model, logical processors are required to have a processor device object in the DSDT and must convey the processor's APIC information to OSPM using the Processor Local X2APIC structure.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1762446"></A>[Compatibility note] On some legacy OSes, Logical processors with APIC ID values less than 255 (whether in XAPIC or X2APIC mode) must use the Processor Local APIC structure to convey their APIC information to OSPM, and those processors must be declared in the DSDT using the Processor() keyword. Logical processors with APIC ID values 255 and greater must use the Processor Local x2APIC structure and be declared using the Device() keyword. See <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267442" CLASS="XRef">See Processor (Declare Processor).</A> &quot;Processor (Declare Processor)&quot; for more information.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1762441"></A>OSPM does not expect the information provided in this table to be updated if the processor information changes during the lifespan of an OS boot. While in the sleeping state, logical processors must not be added or removed, nor can their X2APIC ID or x2APIC Flags change. When a logical processor is not present, the processor local X2APIC information is either not reported or flagged as disabled. </P>
<P CLASS="Body">
<A NAME="pgfId-1360985"></A>The format of x2APIC structure is listed in <A HREF="ACPI_Software_Programming_Model.htm#84052" CLASS="XRef">See Processor Local x2APIC Structure.</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1370014"></A><A NAME="84052"></A>Processor Local x2APIC Structure <A NAME="marker-1370013"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1370017"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1370019"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1370021"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1370023"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370025"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370027"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370029"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370031"></A>9	Processor Local x2APIC structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370033"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370035"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370037"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370039"></A>16</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370041"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370043"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370045"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370047"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370049"></A>X2APIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370051"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370053"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370055"></A>The processor&#8217;s local x2APIC ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370057"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370059"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370061"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370063"></A>Same as Local APIC flags. See <A HREF="ACPI_Software_Programming_Model.htm#34770" CLASS="XRef">See Local APIC Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370065"></A>ACPI Processor UID </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370067"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370069"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370071"></A>OSPM associates the X2APIC Structure with a processor object declared in the namespace using the Device statement, when the _UID child object of the processor device evaluates to a numeric value, by matching the numeric value with this field</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1747857"></A><A NAME="30225"></A>Local x2APIC NMI Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1361055"></A>The Local APIC NMI a<A NAME="marker-1361053"></A><A NAME="marker-1361054"></A>nd Local x2APIC NMI structures describe the interrupt input (LINTn) that NMI is connected to for each of the logical processors in the system where such a connection exists. Each NMI connection to a processor requires a separate NMI structure. This information is needed by OSPM to enable the appropriate APIC entry. </P>
<P CLASS="Body">
<A NAME="pgfId-1361056"></A>NMI connection to a logical processor with local x2APIC ID 255 and greater requires an X2APIC NMI structure. NMI connection to a logical processor with an x2APIC ID less than 255 requires a Local APIC NMI structure. For example, if the platform contains 8 logical processors with x2APIC IDs 0-3 and 256-259 and NMI is connected LINT1 for processor 3, 2, 256 and 257 then two Local APIC NMI entries and two X2APIC NMI entries must be provided in the MADT.</P>
<P CLASS="Body">
<A NAME="pgfId-1729791"></A> The Local APIC NMI structure is used to specify global LINTx for all processors if all logical processors have x2APIC ID less than 255. If the platform contains any logical processors with an x2APIC ID of 255 or greater then the Local X2APIC NMI structure must be used to specify global LINTx for ALL logical processors. The format of x2APIC NMI structure is listed in <A HREF="ACPI_Software_Programming_Model.htm#49009" CLASS="XRef">See Local x2APIC NMI Structure.</A>. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1729853"></A><A NAME="49009"></A>Local x2APIC NMI Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729798"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729800"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729802"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729804"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729806"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729808"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729810"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729812"></A>0AH	Local x2APIC NMI Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729814"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729816"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729818"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729820"></A>12</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729822"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729824"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729826"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729828"></A>Same as MPS INTI flags. See <A HREF="ACPI_Software_Programming_Model.htm#16844" CLASS="XRef">See MPS INTI Flags.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729830"></A>ACPI Processor UID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729832"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729834"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729836"></A>UID corresponding to the ID listed in the processor Device object. A value of 0xFFFFFFFF signifies that this applies to all processors in the machine.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729838"></A>Local x2APIC LINT#</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729840"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729842"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729844"></A>Local x2APIC interrupt input LINTn to which NMI is connected.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729846"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729848"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729850"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729852"></A>Reserved - Must be zero.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1729857"></A><IMG SRC="ACPI_Software_Programming_Model-4.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1729670"></A><A NAME="26741"></A>APIC-Global System Interrupts</H6>
<P CLASS="Body">
<A NAME="pgfId-1842366"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1729990"></A><A NAME="81013"></A>GIC CPU Interface (GICC) Structure<A NAME="marker-1729988"></A><A NAME="marker-1729989"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1729991"></A>In the GIC interrupt model, logical processors are required to have a Processor Device object in the DSDT, and must convey each processor&#8217;s GIC information to the OS using the GICC structure.</P>
<P CLASS="Body">
<A NAME="pgfId-1730222"></A>The format of the GICC structure is shown in <A HREF="ACPI_Software_Programming_Model.htm#20483" CLASS="XRef">See GICC Structure.</A>.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1730089"></A><A NAME="20483"></A>GICC Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757981"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757983"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757985"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757987"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757989"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757991"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757993"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757995"></A>0xB	GICC structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757997"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757999"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758001"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758003"></A>80</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758005"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758007"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758009"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758011"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758072"></A>CPU Interface Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758074"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758076"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758094"></A>GIC's CPU Interface Number. In GICv1/v2 implementations, this value matches the bit index of the associated processor in the GIC distributor's GICD_ITARGETSR register.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758095"></A>For GICv3/4 implementations this field must be provided by the platform, if compatibility mode is supported. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1759933"></A>If it is not supported by the implementation, then this field must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758021"></A>ACPI Processor UID </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758023"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758025"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758027"></A>The OS associates this GICC Structure with a processor device object in the namespace when the _UID child object of the processor device evaluates to a numeric value that matches the numeric value in this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758029"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758031"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758033"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758038"></A>See <A HREF="ACPI_Software_Programming_Model.htm#46141" CLASS="XRef">See GICC CPU Interface Flags.</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758040"></A>Parking Protocol Version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758042"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758044"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758046"></A>Version of the ARM-Processor Parking Protocol implemented. See  <EM CLASS="Hyperlink">
http://uefi.org/acpi.</EM>
 The document  link is listed under &quot;Multiprocessor Startup for ARM Platforms&quot; </P>
<P CLASS="TableBody">
<A NAME="pgfId-1759420"></A>For systems that support PSCI exclusively and do not support the parking protocol, this field must be set to 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758048"></A>Performance Interrupt GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758050"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758052"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758054"></A>The GSIV used for Performance Monitoring Interrupts</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758056"></A>Parked Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758058"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758060"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758062"></A>The 64-bit physical address of the processor&#8217;s Parking Protocol mailbox</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758064"></A>Physical Base Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758066"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758068"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758070"></A>On GICv1/v2 systems and GICv3/4 systems in GICv2 compatibility mode, this field holds the 64-bit physical address at which the processor can access this GIC CPU Interface. If provided here, the &quot;Local Interrupt Controller Address&quot; field in the MADT must be ignored by the OSPM. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758165"></A>GICV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758167"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758169"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758171"></A>Address of the GIC virtual CPU interface registers. If the platform is not presenting a GICv2 with virtualization extensions this field can be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758157"></A>GICH</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758159"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758161"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758163"></A>Address of the GIC virtual interface control block registers. If the platform is not presenting a GICv2 with virtualization extensions this field can be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758149"></A>VGIC Maintenance interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758151"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758153"></A>56</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758155"></A>GSIV for Virtual GIC maintenance interrupt</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758141"></A>GICR Base Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758143"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758145"></A>60</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758147"></A>On systems supporting GICv3 and above, this field holds the 64-bit physical address of the associated Redistributor. If all of the GIC Redistributors are in the always-on power domain, GICR structures should be used to describe the Redistributors instead, and this field must be set to 0. If a GICR structure is present in the MADT then this field must be ignored by the OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758133"></A>MPIDR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758135"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758137"></A>68</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758223"></A>This fields follows the MPIDR formatting of ARM architecture. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1758224"></A>If the implements ARMv7 architecure then the format must be:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758225"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758226"></A>Bits [63:24] Must be zero</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758227"></A>Bits [23:16] Aff2 : Match Aff2 of target processor MPIDR</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758228"></A>Bits [15:8] Aff1 : Match Aff1 of target processor MPIDR</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758229"></A>Bits [7:0] Aff0 : Match Aff0 of target processor MPIDR</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758230"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758231"></A>For platforms implementing ARMv8 the format must be:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758232"></A>Bits [63:40] Must be zero</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758233"></A>Bits [39:32] Aff3 : Match Aff3 of target processor MPIDR</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758234"></A>Bits [31:24] Must be zero</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758235"></A>Bits [23:16] Aff2 : Match Aff2 of target processor MPIDR</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758236"></A>Bits [15:8] Aff1 : Match Aff1 of target processor MPIDR</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758237"></A>Bits [7:0] Aff0 : Match Aff0 of target processor MPIDR</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761478"></A>Processor Power Efficiency Class</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761480"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761482"></A>76</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761484"></A>Describes the relative power efficiency of the associated processor. Lower efficiency class numbers are more efficient than higher ones (e.g. efficiency class 0 should be treated as more efficient than efficiency class 1). </P>
<P CLASS="TableBody">
<A NAME="pgfId-1761519"></A>However, absolute values of this number have no meaning: 2 isn't necessarily half as efficient as 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761470"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761472"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761474"></A>77</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761476"></A>Must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842223"></A>SPE overflow Interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842225"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842227"></A>78</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842229"></A>Statistical Profiling Extension buffer overflow GSIV. This interrupt is a level triggered PPI. Zero if SPE is not supported by this processor.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1730091"></A><A NAME="46141"></A>GICC CPU Interface Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730095"></A>GIC Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730097"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730099"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730101"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730103"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730105"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730107"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730109"></A>If zero, this processor is unusable, and the operating system support will not attempt to use it.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739521"></A>Performance Interrupt Mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739523"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739525"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1739527"></A>0 - Level-triggered </P>
<P CLASS="TableBody">
<A NAME="pgfId-1739558"></A>1 - Edge-Triggered</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758387"></A>VGIC Maintenance interrupt Mode  Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758389"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758391"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758434"></A>0 - Level-triggered </P>
<P CLASS="TableBody">
<A NAME="pgfId-1758435"></A>1 - Edge-Triggered</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730111"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730113"></A>29</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730115"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1730117"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1730272"></A><A NAME="31257"></A>GIC Distributor (GICD) Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1824905"></A>ACPI represents all wired interrupts as &#8220;flat&#8221; values known as global system interrupts (GSIVs) as described in <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256015" CLASS="XRef">See Global System Interrupts.</A>. On ARM-based systems the Generic Interrupt Controller  (GIC) manages interrupts on the system. Each interrupt is identified in the GIC by an interrupt identifier (INTID). ACPI GSIVs map one to one to GIC INTIDs for peripheral interrupts, whether shared (SPI) or private (PPI). The GIC distributor structure describes the GIC distributor to the OS. One, and only one, GIC distributor structure must be present in the MADT for an ARM based system.</P>
<P CLASS="Body">
<A NAME="pgfId-1759943"></A>The format of the GICD structure is listed in <A HREF="ACPI_Software_Programming_Model.htm#99894" CLASS="XRef">See GICD Structure.</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1759940"></A><A NAME="99894"></A>GICD Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759949"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759951"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759953"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759955"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759957"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759959"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759961"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759963"></A>0xC	GICD structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759965"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759967"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759969"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759971"></A>24</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759973"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759975"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759977"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759979"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759981"></A>GIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759983"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759985"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759987"></A>This GIC Distributor&#8217;s hardware ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759989"></A>Physical Base Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759991"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759993"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759995"></A>The 64-bit physical address for this Distributor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759997"></A>System Vector Base </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759999"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760001"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1820983"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760609"></A>GIC version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760611"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760613"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760633"></A>0x00: No GIC version is specified, fall back to hardware discovery for GIC version</P>
<P CLASS="TableBody">
<A NAME="pgfId-1777820"></A>0x01: GICv1</P>
<P CLASS="TableBody">
<A NAME="pgfId-1760634"></A>0x02: GICv2</P>
<P CLASS="TableBody">
<A NAME="pgfId-1760635"></A>0x03: GICv3</P>
<P CLASS="TableBody">
<A NAME="pgfId-1760636"></A>0x04: GICv4</P>
<P CLASS="TableBody">
<A NAME="pgfId-1760637"></A>0x05-0xFF, Reserved for future use. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760005"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760007"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760009"></A>21</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760011"></A>Must be zero</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1758473"></A><A NAME="90220"></A>GIC MSI Frame Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1758492"></A>Each GICv2m MSI frame consists of a 4k page which includes registers to generate message signaled interrupts to an associated GIC distributor. The frame also includes registers to discover the set of distributor lines which may be signaled by MSIs from that frame. A system may have multiple MSI frames, and separate frames may be defined for secure and non-secure access. This structure must only be used to describe non-secure MSI frames.</P>
<P CLASS="Body">
<A NAME="pgfId-1730274"></A>The format of the GIC MSI Frame Structure is listed in <A HREF="ACPI_Software_Programming_Model.htm#42083" CLASS="XRef">See GIC MSI Frame Structure.</A>. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1758732"></A><A NAME="42083"></A>GIC MSI Frame Structure </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758677"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758679"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758681"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758683"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758685"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758687"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758689"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758691"></A>0xD	GIC MSI Frame structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758693"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758695"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758697"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758699"></A>24</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758701"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758703"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758705"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758707"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758717"></A>GIC MSI Frame ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758719"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758721"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758723"></A>GIC MSI Frame ID. In a system with multiple GIC MSI frames, this value must be unique to each one.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758725"></A>Physical Base Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758727"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758729"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758731"></A>The 64-bit physical address for this MSI Frame</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758892"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758894"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758896"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758898"></A>GIC MSI Frame Flags. See <A HREF="ACPI_Software_Programming_Model.htm#75893" CLASS="XRef">See GIC MSI Frame Flags.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758906"></A>SPI Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758886"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758888"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758890"></A>SPI Count used by this frame. Unless the SPI Count Select flag is set to 1 this value should match the lower 16 bits of the MSI_TYPER register in the frame.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758876"></A>SPI Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758878"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758880"></A>22</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758882"></A>SPI Base used by this frame. Unless the SPI Base Select flag is set to 1 this value should match the upper 16 bits of the MSI_TYPER register in the frame.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1758956"></A><A NAME="75893"></A>GIC MSI Frame Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758963"></A>GIC MSI Frame Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758965"></A>Bit </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1758966"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758968"></A>Bit </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1758969"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758971"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758973"></A>SPI Count/Base Select</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758975"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758977"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758979"></A>0: The SPI Count and Base fields should be ignored, and the actual values should be queried from the MSI_TYPER register in the associated GIC MSI frame.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1758980"></A>1: The SPI Count and Base values override the values specified in the MSI_TYPER register in the associated GIC MSI frame.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758982"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758984"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758986"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758988"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1758855"></A><A NAME="62903"></A>GIC Redistributor (GICR) Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1758856"></A>The GICR Structure is described in <A HREF="ACPI_Software_Programming_Model.htm#89366" CLASS="XRef">See GICR Structure .</A>. This structure enables the discovery of GIC Redistributor base addresses by providing the Physical Base Address of a page range containing the GIC Redistributors. More than one GICR Structure may be presented in the MADT. GICR structures should only be used when describing GIC implementations which conform to version 3 or higher of the GIC architecture and which place all Redistributors in the always-on power domain.When a GICR structure is presented, the OSPM must ignore the GICR Base Address field of the GICC structures (see <A HREF="ACPI_Software_Programming_Model.htm#20483" CLASS="XRef">See GICC Structure.</A>).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1758830"></A><A NAME="89366"></A>GICR Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758741"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758743"></A>Byte </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1758744"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758746"></A>Byte </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1758747"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1758749"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758751"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758753"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758755"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758757"></A>0xE	GICR structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758759"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758761"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758763"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758765"></A>16</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758767"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758769"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758771"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758773"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758775"></A>Discovery Range Base Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758777"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758779"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758781"></A>The 64-bit physical address of a page range containing all GIC Redistributors</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758783"></A>Discovery Range Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758785"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758787"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1758789"></A>Length of the GIC Redistributor Discovery page range.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1761958"></A><A NAME="45360"></A>GIC Interrupt Translation Service (ITS) Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1761959"></A>The GIC ITS is optionally supported in GICv3/v4 implementations. The format of the GIC ITS Structure is listed in <A HREF="ACPI_Software_Programming_Model.htm#32004" CLASS="XRef">See GIC ITS Structure .</A>: </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1761960"></A><A NAME="32004"></A>GIC ITS Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1761963"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1761965"></A>Byte </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1761966"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1761968"></A>Byte </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1761969"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1761971"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761973"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761975"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761977"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761979"></A>0xF	GIC ITS structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761981"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761983"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761985"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761987"></A>20</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761989"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761991"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761993"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761995"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761997"></A>GIC ITS ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1761999"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762001"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762003"></A>GIC ITS ID. In a system with multiple GIC ITS units, this value must be unique to each one.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762005"></A>Physical Base </P>
<P CLASS="TableBody">
<A NAME="pgfId-1762006"></A>Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762008"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762010"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762012"></A>The 64-bit physical address for the Interrupt Translation Service</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762014"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762016"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762018"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762020"></A>Reserved - Must be zero</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1729973"></A><A NAME="_Toc489256015"></A><A NAME="_Toc489267939"></A><A NAME="_Toc489272492"></A><A NAME="_Toc202340541"></A><A NAME="_Toc258262223"></A>Global System Interrupts</H6>
<P CLASS="Body">
<A NAME="pgfId-1361140"></A>Global System Interrupts can be thought of as ACPI Plug and Play IRQ numbers. They are used to virtualize interrupts in tables and in ASL methods that perform resource allocation of interrupts. Do not confuse global system interrupts with ISA IRQs although in the case of the IA-PC 8259 interrupts they correspond in a one-to-one fashion.<A NAME="marker-1361141"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1361143"></A>There are two interrupt models used in ACPI-enabled systems.<A NAME="marker-1361142"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1361144"></A>The first model is the APIC model. In the APIC model, the number of interrupt inputs supported by each I/O APIC can vary. OSPM determines the mapping of the Global System Interrupts by determining how many interrupt inputs each I/O APIC supports and by determining the global system interrupt base for each I/O APIC as specified by the I/O APIC Structure. OSPM determines the number of interrupt inputs by reading the Max Redirection register from the I/O APIC. The global system interrupts mapped to that I/O APIC begin at the global system interrupt base and extending through the number of interrupts specified in the Max Redirection register. This mapping is depicted in <A HREF="ACPI_Software_Programming_Model.htm#26741" CLASS="XRef">See APIC-Global System Interrupts.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1361146"></A>There is exactly one I/O APIC structure per I/O APIC in the system. <A NAME="marker-1361145"></A></P>
<P CLASS="Caption2">
<A NAME="pgfId-1361150"></A><IMG SRC="ACPI_Software_Programming_Model-5.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1376156"></A><A NAME="11592"></A>8259-Global System Interrupts</H6>
<P CLASS="Body">
<A NAME="pgfId-1376157"></A>The other interrupt model is the standard AT style mentioned above which uses ISA IRQs attached to a master slave pair of 8259 PICs. The system vectors correspond to the ISA IRQs. The ISA IRQs and their mappings to the 8259 pair are part of the AT standard and are well defined. This mapping is depicted in <A HREF="ACPI_Software_Programming_Model.htm#11592" CLASS="XRef">See 8259-Global System Interrupts.</A>.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361174"></A><A NAME="marker-1361153"></A><A NAME="_Toc489256016"></A><A NAME="_Toc489267940"></A><A NAME="_Toc489272493"></A><A NAME="_Toc202340542"></A><A NAME="_Toc258262224"></A>Smart Battery Table (SBST)<A NAME="marker-1361173"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1376027"></A>If the platform supports batteries as defined by the Smart Battery Specification 1.0 or 1.1, then an Smart Battery Table (SBST) is present. This table indicates the energy level trip points that the platform requires for placing the system into the specified sleeping state and the suggested energy levels for warning the user to transition the platform into a sleeping state. Notice that while Smart Batteries can report either in current (mA/mAh) or in energy (mW/mWh), OSPM must set them to operate in energy (mW/mWh) mode so that the energy levels specified in the SBST can be used. OSPM uses these tables with the capabilities of the batteries to determine the different trip points. For more precise definitions of these levels, see <A HREF="ACPI_Concepts.htm#_Toc489255977" CLASS="XRef">See Battery Gas Gauge.</A>, &#8220;Battery Gas Gauge.&#8221;<A NAME="marker-1376028"></A><A NAME="marker-1376029"></A></P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376144"></A><A NAME="marker-1376030"></A>Smart Battery Description Table (SBST) Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685493"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685495"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685497"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685499"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376041"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376043"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376045"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376047"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376049"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376051"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376053"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376055"></A>&#8216;SBST&#8217; Signature for the Smart Battery Description Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376057"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376059"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376061"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376063"></A>Length, in bytes, of the entire SBST</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376065"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376067"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376069"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376071"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376073"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376075"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376077"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376079"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376081"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376083"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376085"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376087"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376089"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376091"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376093"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376095"></A>For the SBST, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376097"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376099"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376101"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376103"></A>OEM revision of SBST for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376105"></A>   Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376107"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376109"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376111"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376113"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376115"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376117"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376119"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376121"></A>Warning Energy Level</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376123"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376125"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376127"></A>OEM suggested energy level in milliWatt-hours (mWh) at which OSPM warns the user.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376129"></A>Low Energy Level</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376131"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376133"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376135"></A>OEM suggested platform energy level in mWh at which OSPM will transition the system to a sleeping state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376137"></A>Critical Energy Level</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376139"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376141"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376143"></A>OEM suggested platform energy level in mWh at which OSPM performs an emergency shutdown. </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361319"></A><A NAME="_Toc489256017"></A><A NAME="_Toc489267941"></A><A NAME="_Toc489272494"></A><A NAME="_Ref42414133"></A><A NAME="_Toc202340543"></A><A NAME="_Toc258262225"></A>Embedded Controller Boot Resources Table (ECDT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1361320"></A>This optional table provides the processor-relative, translated resources of an Embedded Controller. The presence of this table allows OSPM to provide Embedded Controller operation region space access before the namespace has been evaluated. If this table is not provided, the Embedded Controller region space will not be available until the Embedded Controller device in the AML namespace has been discovered and enumerated. The availability of the region space can be detected by providing a _REG method object underneath the Embedded Controller device.<A NAME="marker-1361321"></A><A NAME="marker-1361322"></A><A NAME="marker-1361323"></A><A NAME="marker-1361324"></A><A NAME="marker-1361325"></A></P>
<DIV>
<H6 CLASS="Pb">
<A NAME="pgfId-1361331"></A>&nbsp;</H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1370329"></A><A NAME="98574"></A>Embedded Controller Boot Resources Table Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685532"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685534"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685536"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685538"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370210"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370212"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370214"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370216"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370218"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370220"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370222"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370224"></A>&#8216;ECDT&#8217; Signature for the Embedded Controller Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370226"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370228"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370230"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370232"></A>Length, in bytes, of the entire Embedded Controller Table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370234"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370236"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370238"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370240"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370242"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370244"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370246"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370248"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370250"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370252"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370254"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370256"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370258"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370260"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370262"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370264"></A>For the Embedded Controller Table, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370266"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370268"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370270"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370272"></A>OEM revision of Embedded Controller Table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370274"></A>   Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370276"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370278"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370280"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370282"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370284"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370286"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370288"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370290"></A>EC_CONTROL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370292"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370294"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370296"></A>Contains the processor relative address, represented in Generic Address Structure format, of the Embedded Controller Command/Status register.<BR>
Note: Only System I/O space and System Memory space are valid for values for Address_Space_ID. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370298"></A>EC_DATA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370300"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370302"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370304"></A>Contains the processor-relative address, represented in Generic Address Structure format, of the Embedded Controller Data register.<BR>
Note: Only System I/O space and System Memory space are valid for values for Address_Space_ID. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370306"></A>UID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370308"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370310"></A>60</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370312"></A>Unique ID-Same as the value returned by the _UID under the device in the namespace that represents this embedded controller.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370314"></A>GPE_BIT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370316"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370318"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370320"></A>The bit assignment of the SCI interrupt within the GPEx_STS register of a GPE block described in the FADT that the embedded controller triggers.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370322"></A>EC_ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370324"></A>Variable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370326"></A>65</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1370328"></A>ASCII, null terminated, string that contains a fully qualified reference to the namespace object that is this embedded controller device (for example, &#8220;&#92;&#92;_SB.PCI0.ISA.EC&#8221;). Quotes are omitted in the data field.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1370330"></A>ACPI OSPM implementations supporting Embedded Controller devices must also support the ECDT. ACPI 1.0 OSPM implementation will not recognize or make use of the ECDT. The following example code shows how to detect whether the Embedded Controller operation regions are available in a manner that is backward compatible with prior versions of ACPI/OSPM.</P>
<DIV>
<H6 CLASS="spacing">
<A NAME="pgfId-1361471"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1361472"></A>Device(EC0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361473"></A>     Name(REGC,Ones)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361474"></A>     Method(_REG,2) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361475"></A>         If(Lequal(Arg0, 3)) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361476"></A>             Store(Arg1, REGC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361477"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361478"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361479"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361480"></A>Method(ECAV,0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361481"></A>     If(Lequal(REGC,Ones)) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361482"></A>         If(LgreaterEqual(_REV,2)) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361483"></A>             Return(One)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361484"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361485"></A>         Else {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361486"></A>             Return(Zero)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361487"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1745464"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1745450"></A>     Else {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1746011"></A>         Return(REGC)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1746013"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361490"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361491"></A>To detect the availability of the region, call the ECAV method. For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361492"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361493"></A>If (&#92;_SB.PCI0.EC0.ECAV()) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361494"></A>     ...regions are available...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361495"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361496"></A>else {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361497"></A>     ...regions are not available...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1361498"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1841786"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711329"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1361502"></A><A NAME="_Toc202340544"></A><A NAME="_Toc258262226"></A>System Resource Affinity Table (SRAT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1361503"></A>This optional table provides information that allows OSPM to associate the following types of devices with system locality / proximity domains and clock domains: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1840545"></A>processors,</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1840571"></A>memory ranges (including those provided by hot-added memory devices), and </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1840575"></A>generic initiators (e.g. heterogeneous processors and accelerators, GPUs, and I/O devices with integrated compute or DMA engines). </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1840578"></A>On NUMA platforms, SRAT information enables OSPM to optimally configure the operating system during a point in OS initialization when evaluation of objects in the ACPI Namespace is not yet possible. </P>
<P CLASS="Body">
<A NAME="pgfId-1835286"></A>OSPM evaluates the SRAT only during OS initialization. The Local APIC ID / Local SAPIC ID / Local x2APIC ID or the GICC ACPI Processor UID of all processors started at boot time must be present in the SRAT. If the Local APIC ID / Local SAPIC ID / Local x2APIC ID or the GICC ACPI Processor UID of a dynamically added processor is not present in the SRAT, a _PXM object must exist for the processor&#8217;s device or one of its ancestors in the ACPI Namespace.</P>
<P CLASS="Body">
<A NAME="pgfId-1840655"></A>Note:  SRAT is the place where proximity domains are defined, and _PXM provides a mechanism to associate a device object (and its children) to an SRAT-defined proximity domain. </P>
<P CLASS="Body">
<A NAME="pgfId-1840676"></A>See <A HREF="Device_Configuration.htm#81577" CLASS="XRef">See _PXM (Proximity).</A> (_PXM Proximity) for more information. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1835377"></A>Static Resource Affinity Table Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1831557"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831559"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831561"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831563"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361515"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361517"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361519"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361521"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361523"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361525"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361527"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361529"></A>&#8216;SRAT&#8217;. Signature for the System Resource Affinity Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361531"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361533"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361535"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361537"></A>Length, in bytes, of the entire SRAT. The length implies the number of Entry fields at the end of the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361539"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361541"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361543"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361545"></A>3</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361547"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361549"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361551"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361553"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361555"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361557"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361559"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361561"></A>OEM ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361563"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361565"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361567"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361569"></A>For the System Resource Affinity Table, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361571"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361573"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361575"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361577"></A>OEM revision of System Resource Affinity Table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361579"></A>   Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361581"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361583"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361585"></A>Vendor ID of utility that created the table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361587"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361589"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361591"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361593"></A>Revision of utility that created the table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361595"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361597"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361599"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361601"></A>Reserved to be 1 for backward compatibility</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361603"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361605"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361607"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361609"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361611"></A>Static Resource Allocation Structure[n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361613"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361615"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361617"></A>A list of static resource allocation structures for the platform. See <A HREF="ACPI_Software_Programming_Model.htm#67033" CLASS="XRef">See Processor Local APIC/SAPIC Affinity Structure.</A>,&#8221;Processor Local APIC/SAPIC Affinity Structure&#8221;, <A HREF="ACPI_Software_Programming_Model.htm#70197" CLASS="XRef">See Memory Affinity Structure.</A> &#8220;Memory Affinity Structure&#8221;, <A HREF="ACPI_Software_Programming_Model.htm#22951" CLASS="XRef">See Processor Local x2APIC Affinity Structure.</A> &#8220;Processor Local x2APIC Affinity Structure&#8221;, and <A HREF="ACPI_Software_Programming_Model.htm#99979" CLASS="XRef">See GICC Affinity Structure.</A>, &#8220;GICC Affinity Structure.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1361621"></A><A NAME="67033"></A>Processor Local APIC/SAPIC Affinity Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1361622"></A>The Processor Local APIC/SAPIC Affinity structure provides the association between the APIC ID or SAPIC ID/EID of a processor and the proximity domain to which the processor belongs. <A HREF="ACPI_Software_Programming_Model.htm#90551" CLASS="XRef">See Processor Local APIC/SAPIC Affinity Structure.</A> provides the details of the Processor Local APIC/SAPIC Affinity structure.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361623"></A><A NAME="90551"></A>Processor Local APIC/SAPIC Affinity Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684620"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684622"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684624"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684626"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361634"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361636"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361638"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361640"></A>0 	Processor Local APIC/SAPIC Affinity Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361642"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361644"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361646"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361648"></A>16</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361650"></A>Proximity Domain [7:0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361652"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361654"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361656"></A>Bit [7:0] of the proximity domain to which the processor belongs. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361658"></A>APIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361660"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361662"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361664"></A>The processor local APIC ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361666"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361668"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361670"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361672"></A>Flags - Processor Local APIC/SAPIC Affinity Structure. See <A HREF="ACPI_Software_Programming_Model.htm#89738" CLASS="XRef">See Flags - Processor Local APIC/SAPIC Affinity Structure.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361674"></A>Local SAPIC EID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361676"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361678"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361680"></A>The processor local SAPIC EID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361682"></A>Proximity Domain [31:8]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361684"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361686"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361688"></A>Bit [31:8] of the proximity domain to which the processor belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361690"></A>Clock Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361692"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361694"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361696"></A>The clock domain to which the processor belongs. See <A HREF="Device_Configuration.htm#38150" CLASS="XRef">See _CDM (Clock Domain).</A>, &#8220;_CDM (Clock Domain)&#8221;.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361700"></A><A NAME="89738"></A>Flags - Processor Local APIC/SAPIC Affinity Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361703"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361705"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361707"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361709"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361711"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361713"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361715"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361717"></A>If clear, the OSPM ignores the contents of the Processor Local APIC/SAPIC Affinity Structure. This allows system firmware to populate the SRAT with a static number of structures but only enable them as necessary.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361719"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361721"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361723"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361725"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1361728"></A><A NAME="70197"></A>Memory Affinity Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1361729"></A>The Memory Affinity structure provides the following topology information statically to the operating system:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1361730"></A>The association between a range of memory and the proximity domain to which it belongs</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1361731"></A>Information about whether the range of memory can be hot-plugged.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1361732"></A><A HREF="ACPI_Software_Programming_Model.htm#12710" CLASS="XRef">See Memory Affinity Structure.</A> provides the details of the Memory Affinity structure.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376299"></A><A NAME="12710"></A>Memory Affinity Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684636"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684638"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684640"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684642"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376212"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376214"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376216"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376218"></A>1	 Memory Affinity Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376220"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376222"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376224"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376226"></A>40</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376228"></A>Proximity Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376230"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376232"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376234"></A>Integer that represents the proximity domain to which the &quot;range of memory&quot; belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376236"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376238"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376240"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376242"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376244"></A>Base Address Low</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376246"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376248"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376250"></A>Low 32 Bits of the Base Address of the memory range</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376252"></A>Base Address High</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376254"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376256"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376258"></A>High 32 Bits of the Base Address of the memory range</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376260"></A>Length Low</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376262"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376264"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376266"></A>Low 32 Bits of the length of the memory range.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376268"></A>Length High</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376270"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376272"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376274"></A>High 32 Bits of the length of the memory range.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376276"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376278"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376280"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376282"></A>Reserved.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376284"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376286"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376288"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376290"></A>Flags - Memory Affinity Structure. Indicates whether the region of memory is enabled and can be hot plugged. See <A HREF="ACPI_Software_Programming_Model.htm#83295" CLASS="XRef">See Flags - Memory Affinity Structure.</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376292"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376294"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376296"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376298"></A>Reserved.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1376347"></A><A NAME="83295"></A>Flags - Memory Affinity Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376302"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376304"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376306"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1376308"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376310"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376312"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376314"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376316"></A>If clear, the OSPM ignores the contents of the Memory Affinity Structure. This allows system firmware to populate the SRAT with a static number of structures but only enable then as necessary.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376321"></A>Hot Pluggable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376323"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376325"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376327"></A>The information conveyed by this bit depends on the value of the Enabled bit.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1376328"></A>If the Enabled bit is set and the Hot Pluggable bit is also set. The system hardware supports hot-add and hot-remove of this memory region</P>
<P CLASS="TableBody">
<A NAME="pgfId-1376329"></A>If the Enabled bit is set and the Hot Pluggable bit is clear, the system hardware does not support hot-add or hot-remove of this memory region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1376330"></A>If the Enabled bit is clear, the OSPM will ignore the contents of the Memory Affinity Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376332"></A>NonVolatile</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376334"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376336"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376338"></A>If set, the memory region represents Non-Volatile memory</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376340"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376342"></A>29</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376344"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1376346"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1376348"></A><A NAME="22951"></A>Processor Local x2APIC Affinity Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1361887"></A>The Processor Local x2APIC Affinity structure provides the association between the local x2APIC ID of a processor and the proximity domain to which the processor belongs. <A HREF="ACPI_Software_Programming_Model.htm#22849" CLASS="XRef">See Processor Local x2APIC Affinity Structure.</A> provides the details of the Processor Local x2APIC Affinity structure.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361888"></A><A NAME="22849"></A>Processor Local x2APIC Affinity Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361891"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361893"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361895"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1361897"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361899"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361901"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361903"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361905"></A>2 	Processor Local x2APIC Affinity Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361907"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361909"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361911"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361913"></A>24</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361915"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361917"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361919"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361921"></A>Reserved - Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361923"></A>Proximity Domain </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361925"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361927"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361929"></A>The proximity domain to which the logical processor belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361931"></A>X2APIC ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361933"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361935"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361937"></A>The processor local x2APIC ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361939"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361941"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361943"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361945"></A>Same as Processor Local APIC/SAPIC Affinity Structure flags. See <A HREF="ACPI_Software_Programming_Model.htm#89738" CLASS="XRef">See Flags - Processor Local APIC/SAPIC Affinity Structure.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361947"></A>Clock Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361949"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361951"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361953"></A>The clock domain to which the logical processor belongs. See <A HREF="Device_Configuration.htm#38150" CLASS="XRef">See _CDM (Clock Domain).</A>, &#8220;_CDM (Clock Domain)&#8221;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361955"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361957"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361959"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361961"></A>Reserved.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1747514"></A> On x86-based platforms, the OSPM uses the Hot Pluggable bit to determine whether it should shift into PAE mode to allow for insertion of hot-plug memory with physical addresses over 4 GB.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1747523"></A><A NAME="99979"></A>GICC Affinity Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1759169"></A>The GICC Affinity Structure provides the association between the ACPI Processor UID of a processor and the proximity domain to which the processor belongs. <A HREF="ACPI_Software_Programming_Model.htm#41635" CLASS="XRef">See GICC Affinity Structure.</A> provides the details of the GICC Affinity structure.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1846798"></A>GICC Affinity Structure<A NAME="41635"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747545"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747547"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747549"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747551"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747407"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747409"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747411"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747413"></A>3	GICC Affinity Structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747415"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747417"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747419"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747421"></A>18</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747423"></A>Proximity Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747425"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747427"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747429"></A>The proximity domain to which the logical processor belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747431"></A>ACPI Processor UID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747433"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747435"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747437"></A>The ACPI Processor UID of the associated GICC.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747439"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747441"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747443"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747445"></A>Flags - GICC Affinity Structure. See <A HREF="ACPI_Software_Programming_Model.htm#47256" CLASS="XRef">See Flags - GICC Affinity Structure.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747447"></A>Clock Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747449"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747451"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747453"></A>The clock domain to which the logical processor belongs. See <A HREF="Device_Configuration.htm#38150" CLASS="XRef">See _CDM (Clock Domain).</A>, &#8220;_CDM (Clock Domain)&#8221;.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1747456"></A><A NAME="47256"></A>Flags - GICC Affinity Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747553"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747555"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747557"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1747559"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747468"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747470"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747472"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747474"></A>If clear, the OSPM ignores the contents of the GICC Affinity Structure. This allows system firmware to populate the SRAT with a static number of structures but only enable them as necessary.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747476"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747478"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747480"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1747482"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1804597"></A>GIC Interrupt Translation Service (ITS) Affinity Structure </H6>
<P CLASS="Body">
<A NAME="pgfId-1804572"></A>The GIC ITS Affinity Structure provides the association between a GIC ITS and a proximity domain. This enables the OSPM to discover the memory that is closest to the ITS, and use that in allocating its management tables and command queue. The ITS is identified using an ID matching a declaration of a GIC ITS in the MADT, see <A HREF="ACPI_Software_Programming_Model.htm#45360" CLASS="XRef">See GIC Interrupt Translation Service (ITS) Structure.</A> for details. The following table provides the details of the GIC ITS Affinity structure.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1804626"></A>Architecture Specific Affinity Structure</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1804679"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1804681"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1804683"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1804685"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804687"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804689"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804691"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804693"></A>4	GIC ITS Affinity Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804695"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804697"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804699"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804701"></A>12</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804703"></A>Proximity domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804705"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804707"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804709"></A>Integer that represents the proximity domain to which the GIC ITS belongs to.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804711"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804713"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804715"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804717"></A>Reserved  must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804719"></A>ITS ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804721"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804723"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1804725"></A>ITS ID matching a GIC ITS entry in the MADT</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1361968"></A><A NAME="_Toc202340545"></A><A NAME="_Toc258262227"></A>Generic Initiator Affinity Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1840821"></A>The Generic Initiator Affinity Structure provides the association between a generic initiator and the proximity domain to which the initiator belongs. See <A HREF="ACPI_Software_Programming_Model.htm#33799" CLASS="XRef">See Generic Initiator Affinity Structure.</A> for details.</P>
<P CLASS="Body">
<A NAME="pgfId-1842437"></A>Support of Generic Initiator Affinity Structures by OSPM is optional, and the platform may query whether the OS supports it via the _OSC method. See <A HREF="Device_Configuration.htm#73116" CLASS="XRef">See Platform-Wide OSPM Capabilities.</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1840824"></A><A NAME="33799"></A>Generic Initiator Affinity Structure</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840828"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840830"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840832"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840834"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840836"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840838"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840840"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840842"></A>5    Generic Initiator Structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840844"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840846"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840848"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840850"></A>32</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840852"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840854"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840856"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840858"></A>Reserved and must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840860"></A>Device Handle Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840862"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840864"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840866"></A>Device Handle Type:</P>
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840867"></A>0 - ACPI Device Handle</P>
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840868"></A>1 - PCI Device Handle</P>
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840869"></A>2-255 - Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840871"></A>Proximity Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840873"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840875"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840877"></A>The proximity domain to which the generic initiator belongs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840879"></A>Device Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840881"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840883"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840885"></A>Device Handle of the Generic Initiator. See <A HREF="ACPI_Software_Programming_Model.htm#66948" CLASS="XRef">See Device Handle - ACPI.</A> for a description of the ACPI Device Handle, and <A HREF="ACPI_Software_Programming_Model.htm#76595" CLASS="XRef">See Device Handle - PCI.</A> for a description of the PCI Device Handle.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840887"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840889"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840891"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840893"></A>Flags - Generic Initiator Affinity Structure. See <A HREF="ACPI_Software_Programming_Model.htm#38696" CLASS="XRef">See Flags - Generic Initiator Affinity Structure.</A> for a description of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840895"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840897"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840899"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840901"></A>Reserved and must be zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1854559"></A><A NAME="66948"></A>Device Handle - ACPI</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854528"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854530"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854532"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854534"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854536"></A>ACPI _HID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854538"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854540"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854542"></A>The _HID value</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854544"></A>ACPI _UID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854546"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854548"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854550"></A>The _UID value</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854552"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854554"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854556"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854558"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1854621"></A><A NAME="76595"></A>Device Handle - PCI</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854587"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854589"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854591"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854593"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854595"></A>PCI Segment</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854597"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854599"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1854601"></A> PCI segment number.  </P>
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854602"></A>For systems with fewer than 255 PCI buses, <BR>
this number must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854604"></A>PCI BDF Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854606"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854608"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854610"></A>PCI Bus Number (Bits 7:0 of Byte 2)</P>
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854611"></A>PCI Device Number (Bits 7:3 of Byte 3)</P>
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854612"></A>PCI Function Number (Bits 2:0 of Byte 3)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854614"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854616"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854618"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1854620"></A>Must be zero</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1840905"></A><A NAME="38696"></A>Flags - Generic Initiator Affinity Structure</H6>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840909"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840911"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840913"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840915"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1841850"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1841852"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1841854"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1841856"></A>If clear, the OSPM ignores the contents of the Generic Initiator Affinity Structure. This allows system firmware to populate the SRAT with a static number of structures but only enable then as necessary.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840925"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840927"></A>31</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840929"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Paragraph">
<A NAME="pgfId-1840931"></A>Must be zero.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1841021"></A>Note for Implementors</P>
<P CLASS="Body">
<A NAME="pgfId-1840800"></A>If a generic device with coherent memory is attached to the system, it is recommended to define affinity structures for both the device and memory associated with the device. They both may have the same proximity domain.</P>
<P CLASS="Body">
<A NAME="pgfId-1841996"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1840738"></A>System Locality Distance Information Table (SLIT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1361969"></A>This optional table provides a matrix that describes the relative distance (memory latency) between all System Localities, which are also referred to as Proximity Domains. Systems employing a Non Uniform Memory Access (NUMA) architecture contain collections of hardware resources including for example, processors, memory, and I/O buses, that comprise what is known as a &#8220;NUMA node&#8221;. Processor accesses to memory or I/O resources within the local NUMA node is generally faster than processor accesses to memory or I/O resources outside of the local NUMA node. </P>
<P CLASS="Body">
<A NAME="pgfId-1361970"></A>The value of each Entry[i,j] in the SLIT table, where i represents a row of a matrix and j represents a column of a matrix, indicates the relative distances from System Locality / Proximity Domain i to every other System Locality j in the system (including itself). </P>
<P CLASS="Body">
<A NAME="pgfId-1376378"></A>The i,j row and column values correlate to Proximity Domain values in the System Resource Affinity Table (SRAT), and to values returned by _PXM objects in the ACPI namespace. See <A HREF="ACPI_Software_Programming_Model.htm#_Toc202340544" CLASS="XRef">See System Resource Affinity Table (SRAT).</A>, &#8220;System Resource Affinity Table (SRAT)&#8221;, and <A HREF="Device_Configuration.htm#81577" CLASS="XRef">See _PXM (Proximity).</A>, &#8220;_PXM (Proximity)&#8221; for more information.</P>
<P CLASS="Body">
<A NAME="pgfId-1376379"></A>The entry value is a one-byte unsigned integer. The relative distance from System Locality i to System Locality j is the i*N + j entry in the matrix, where N is the number of System Localities. Except for the relative distance from a System Locality to itself, each relative distance is stored twice in the matrix. This provides the capability to describe the scenario where the relative distances for the two directions between System Localities is different.</P>
<P CLASS="Body">
<A NAME="pgfId-1361973"></A>The diagonal elements of the matrix, the relative distances from a System Locality to itself are normalized to a value of 10. The relative distances for the non-diagonal elements are scaled to be relative to 10. For example, if the relative distance from System Locality i to System Locality j is 2.4, a value of 24 is stored in table entry i*N+ j and in j*N+ i, where N is the number of System Localities. </P>
<P CLASS="Body">
<A NAME="pgfId-1361974"></A>If one locality is unreachable from another, a value of 255 (0xFF) is stored in that table entry. Distance values of 0-9 are reserved and have no meaning.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1361975"></A>SLIT Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684652"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684654"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684656"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684658"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361986"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361988"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361990"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361992"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361994"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361996"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1361998"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362000"></A>&#8216;SLIT&#8217;. Signature for the System Locality Distance Information Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362002"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362004"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362006"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362008"></A>Length, in bytes, of the entire System Locality Distance Information Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362010"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362012"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362014"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362016"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362018"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362020"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362022"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362024"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362026"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362028"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362030"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362032"></A>OEM ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362034"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362036"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362038"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362040"></A>For the System Locality Information Table, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362042"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362044"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362046"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362048"></A>OEM revision of System Locality Information Table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362050"></A>   Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362052"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362054"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362056"></A>Vendor ID of utility that created the table. For the DSDT, RSDT, SSDT, and PSDT tables, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362058"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362060"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362062"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362064"></A>Revision of utility that created the table. For the DSDT, RSDT, SSDT, and PSDT tables, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362066"></A>Number of System Localities</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362068"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362070"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362072"></A>Indicates the number of System Localities in the system.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362074"></A>Entry[0][0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362076"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362078"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362080"></A>Matrix entry (0,0), contains a value of 10.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362082"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362084"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362086"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362088"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362090"></A>Entry[0][Number of System Localities-1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362092"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362094"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362096"></A>Matrix entry (0, Number of System Localities-1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362098"></A>Entry[1][0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362100"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362102"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362104"></A>Matrix entry (1,0)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362106"></A>......</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362108"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362110"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362112"></A>......</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362114"></A>Entry[Number of System Localities-1][Number of System Localities-1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362116"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362118"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362120"></A>Matrix entry (Number of System Localities-1, Number of System Localities-1), contains a value of 10</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362126"></A>C<A NAME="_Toc258262228"></A>orrected Platform Error Polling Table (CPEP)</H6>
<P CLASS="Body">
<A NAME="pgfId-1362127"></A>Platforms may contain the ability to detect and correct certain operational errors while maintaining platform function. These errors may be logged by the platform for the purpose of retrieval. Depending on the underlying hardware support, the means for retrieving corrected platform error information varies. If the platform hardware supports interrupt-based signaling of corrected platform errors, the MADT Platform Interrupt Source Structure describes the Corrected Platform Error Interrupt (CPEI). See <A HREF="ACPI_Software_Programming_Model.htm#53754" CLASS="XRef">See Platform Interrupt Source Structure.</A>,&#8221;Platform Interrupt Source Structure&#8221;. Alternatively, OSPM may poll processors for corrected platform error information. Error log information retrieved from a processor may contain information for all processors within an error reporting group.  As such, it may not be necessary for OSPM to poll all processors in the system to retrieve complete error information. This optional table provides information that allows OSPM to poll only the processors necessary for a complete report of the platform&#8217;s corrected platform error information.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362128"></A>Corrected Platform Error Polling Table Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684668"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684670"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684672"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684674"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362139"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362141"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362143"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362145"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362147"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362149"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362151"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362153"></A>&#8216;CPEP&#8217;. Signature for the Corrected Platform Error Polling Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362155"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362157"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362159"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362161"></A>Length, in bytes, of the entire CPET. The length implies the number of Entry fields at the end of the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362163"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362165"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362167"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362169"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362171"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362173"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362175"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362177"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362179"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362181"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362183"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362185"></A>OEM ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362187"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362189"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362191"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362193"></A>For the Corrected Platform Error Polling Table, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362195"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362197"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362199"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362201"></A>OEM revision of Corrected Platform Error Polling Table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362203"></A>   Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362205"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362207"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362209"></A>Vendor ID of utility that created the table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362211"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362213"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362215"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362217"></A>Revision of utility that created the table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362219"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362221"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362223"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362225"></A>Reserved, must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362227"></A>CPEP Processor Structure[n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362229"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362231"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362233"></A>A list of Corrected Platform Error Polling Processor structures for the platform. See <A HREF="ACPI_Software_Programming_Model.htm#21681" CLASS="XRef">See Corrected Platform Error Polling Processor Structure.</A>,&#8221; Corrected Platform Error Polling Processor Structure&#8221;.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1362237"></A><A NAME="21681"></A>Corrected Platform Error Polling Processor Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1362238"></A>The Corrected Platform Error Polling Processor structure provides information on the specific processors OSPM polls for error information. <A HREF="ACPI_Software_Programming_Model.htm#54396" CLASS="XRef">See Corrected Platform Error Polling Processor Structure.</A> provides the details of the Corrected Platform Error Polling Processor structure.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362239"></A><A NAME="54396"></A>Corrected Platform Error Polling Processor Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1362242"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1362244"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1362246"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1362248"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362250"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362252"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362254"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362256"></A>0 	Corrected Platform Error Polling Processor structure for APIC/SAPIC based processors</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362258"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362260"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362262"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362264"></A>8</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362266"></A>Processor ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362268"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362270"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362272"></A>Processor ID of destination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362274"></A>Processor EID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362276"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362278"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362280"></A>Processor EID of destination.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362282"></A>Polling Interval</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362284"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362286"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362288"></A>Platform-suggested polling interval (in milliseconds)</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362297"></A>M<A NAME="_Toc258262229"></A>aximum System Characteristics Table (MSCT)<A NAME="marker-1362295"></A><A NAME="marker-1362296"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1362298"></A>This section describes the format of the Maximum System Characteristic Table (MSCT), which provides OSPM with information characteristics of a system&#8217;s maximum topology capabilities.  If the system maximum topology is not known up front at boot time, then this table is not present. OSPM will use information provided by the MSCT only when the System Resource Affinity Table (SRAT) exists. The MSCT must contain all proximity and clock domains defined in the SRAT.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362302"></A>Maximum System Characteristics Table (MSCT) Format<A NAME="marker-1362299"></A><A NAME="marker-1362300"></A><A NAME="marker-1362301"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684684"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684686"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684688"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1684690"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362313"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362315"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362317"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362319"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362321"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362323"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362325"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362327"></A>&#8216;MSCT&#8217; Signature for the Maximum System Characteristics Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362329"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362331"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362333"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362335"></A>Length, in bytes, of the entire MSCT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362337"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362339"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362341"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362343"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362345"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362347"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362349"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362351"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362353"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362355"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362357"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362359"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362361"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362363"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362365"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362367"></A>For the MSCT, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362369"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362371"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362373"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362375"></A>OEM revision of MSCT for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362377"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362379"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362381"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362383"></A>Vendor ID of utility that created the table. For tables containing Definition Blocks, this is the ID for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362385"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362387"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362389"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362391"></A>Revision of utility that created the table. For tables containing Definition Blocks, this is the revision for the ASL Compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362393"></A>Offset to Proximity Domain Information Structure [OffsetProxDomInfo]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362395"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362397"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362399"></A>Offset in bytes to the Proximity Domain Information Structure table entry. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362401"></A>Maximum Number of Proximity Domains</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362403"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362405"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362407"></A>Indicates the maximum number of Proximity Domains ever possible in the system. The number reported in this field is (maximum domains - 1). For example if there are 0x10000 possible domains in the system, this field would report 0xFFFF. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362409"></A>Maximum Number of Clock Domains</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362411"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362413"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362415"></A>Indicates the maximum number of Clock Domains ever possible in the system. The number reported in this field is (maximum domains - 1). See <A HREF="Device_Configuration.htm#38150" CLASS="XRef">See _CDM (Clock Domain).</A>, &#8220;_CDM (Clock Domain)&#8221;.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362417"></A>Maximum Physical Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362419"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362421"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362423"></A>Indicates the maximum Physical Address ever possible in the system. Note: this is the top of the reachable physical address.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362425"></A>Proximity Domain Information Structure[Maximum Number of Proximity Domains]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362427"></A>--</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362429"></A>[OffsetProxDomInfo]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362431"></A>A list of Proximity Domain Information for this implementation. The structure format is defined in the Maximum Proximity Domain Information Structure section.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1362437"></A><A NAME="marker-1362433"></A><A NAME="marker-1362434"></A>   Maximum Proximity Domain Information Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1362438"></A>The Maximum Proximity Domain Information Structure is used to report system maximum characteristics. It is likely that these characteristics may be the same for many proximity domains, but they can vary from one proximity domain to another. This structure optimizes to cover the former case, while allowing the flexibility for the latter as well. These structures must be organized in ascending order of the proximity domain enumerations. All proximity domains within the Maximum Number of Proximity Domains reported in the MSCT must be covered by one of these structures.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1729498"></A>Maximum Proximity Domain Information Structure </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729443"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729445"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729447"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729449"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729451"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729453"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729455"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729457"></A>1	</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729459"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729461"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729463"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729465"></A>22</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729467"></A>Proximity Domain Range (low) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729469"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729471"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729473"></A>The starting proximity domain for the proximity domain range that this structure is providing information. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729475"></A>Proximity Domain Range (high)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729477"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729479"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729481"></A>The ending proximity domain for the proximity domain range that this structure is providing information.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729483"></A>Maximum Processor Capacity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729485"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729487"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729489"></A>The Maximum Processor Capacity of each of the Proximity Domains specified in the range. A value of 0 means that the proximity domains do not contain processors. This field must be &gt;= the number of  processor entries for the domain in the SRAT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729491"></A>Maximum Memory Capacity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729493"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729495"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729497"></A>The Maximum Memory Capacity (size in bytes) of the Proximity Domains specified in the range. A value of 0 means that the proximity domains do not contain memory.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1729499"></A><A NAME="16530"></A>ACPI RAS Feature Table (RASF)</H6>
<P CLASS="Body">
<A NAME="pgfId-1729500"></A>The following table describes the structure of ACPI RAS Feature Table.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1727676"></A><A NAME="65111"></A>RASF Table format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727573"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727575"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727577"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727579"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727581"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727583"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727585"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727587"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727589"></A>     Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727591"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727593"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727595"></A> &#8216;RASF&#8217; is Signature for RAS Feature Table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727597"></A>     Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727599"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727601"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727603"></A>Length in bytes for entire RASF.  The length implies the number of Entry fields at the end of the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727605"></A>     Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727607"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727609"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727611"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727613"></A>     Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727615"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727617"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727619"></A>Entire table must sum to zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727621"></A>     OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727623"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727625"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727627"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727629"></A>     OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727631"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727633"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727635"></A>The table ID is the manufacturer model ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727637"></A>     OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727639"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727641"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727643"></A>OEM revision of table for supplied OEM Table ID </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727645"></A>     Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727647"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727649"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727651"></A>Vendor ID of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727653"></A>     Creator Revision </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727655"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727657"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727659"></A>Revision of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727661"></A>RASF Specific Entries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727663"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727665"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727667"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727669"></A>RASF Platform Communication Channel Identifier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727671"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727673"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727675"></A>Identifier of the RASF Platform Communication Channel. OSPM should use this value to identify the PCC Sub channel structure in the RASF table</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1727677"></A>RASF PCC Sub Channel Identifier</H6>
<P CLASS="Body">
<A NAME="pgfId-1727678"></A>RASF PCC Sub Channel Identifier is used by the OSPM to identify the PCC Sub channel structure.  RASF table references its PCC Subspace by this identifier as shown in <A HREF="ACPI_Software_Programming_Model.htm#65111" CLASS="XRef">See RASF Table format.</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1727682"></A>Using PCC registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1727683"></A>OSPM will write PCC registers by filling in the register value in PCC sub channel space and issuing a PCC Execute command. See <A HREF="ACPI_Software_Programming_Model.htm#54210" CLASS="XRef">See PCC Command Codes used by RASF Platform Communication Channel .</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1727684"></A>To minimize the cost of PCC transactions, OSPM should read or write all registers in the same PCC subspace via a single read or write command.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1727685"></A><A NAME="95954"></A>RASF Communication Channel</H6>
<P CLASS="Body">
<A NAME="pgfId-1727686"></A>RASF Action Entries are defined in the PCC sub channel as below.  </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1727782"></A>RASF Platform Communication Channel Shared Memory Region</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730364"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730366"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730368"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730370"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727697"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727699"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727701"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727703"></A>The PCC Signature of 0x52415346 (corresponds to ASCII signature of RASF)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727705"></A>Command</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727707"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727709"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727711"></A>PCC command field; see <A HREF="ACPI_Software_Programming_Model.htm#54210" CLASS="XRef">See PCC Command Codes used by RASF Platform Communication Channel .</A> and <A HREF="Platform_Comm_Channel.htm#68313" CLASS="XRef">See Platform Communications Channel (PCC).</A>. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727713"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727715"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727717"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744102"></A>PCC status field, see <A HREF="Platform_Comm_Channel.htm#68313" CLASS="XRef">See Platform Communications Channel (PCC).</A>. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727721"></A>Communication Space</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727723"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727725"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727727"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727729"></A>Version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727731"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727733"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727735"></A>Byte 0 - Minor Version</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727736"></A>Byte 1 - Major Version</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727738"></A>RAS Capabilities</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727740"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727742"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727744"></A>Bit Map describing the platform RAS capabilities as shown in <A HREF="ACPI_Software_Programming_Model.htm#53676" CLASS="XRef">See Platform RAS Capabilities.</A>.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727748"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727749"></A>The Platform populates this field. The OSPM uses this field to determine the RAS capabilities of the platform.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727751"></A>Set RAS Capabilities</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727753"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727755"></A>26</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727757"></A>Bit Map of the RAS features for which the OSPM is invoking the command. The Bit Map is described in <A HREF="ACPI_Software_Programming_Model.htm#53676" CLASS="XRef">See Platform RAS Capabilities.</A>. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729507"></A>OSPM sets the bit corresponding to a RAS capability to invoke a command on that capability. The bitmap implementation allows OSPM to invoke a command on each RAS feature supported by the platform at the same time.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727763"></A>Number of RASF Parameter blocks</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727765"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727767"></A>42</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727769"></A>The Number of parameter blocks will depend on how many RAS Capabilities the Platform Supports. Typically, there will be one Parameter Block per RAS Feature, using which that feature can be managed by OSPM. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744383"></A>Set RAS Capabilities Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744385"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744387"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744425"></A>Status</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744426"></A>0000b = Success </P>
<P CLASS="TableBody">
<A NAME="pgfId-1744427"></A>0001b = Not Valid</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744428"></A>0010b = Not Supported</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744429"></A>0011b = Busy</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744430"></A>0100b = Failed</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744431"></A>0101b = Aborted</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744432"></A>0110b = Invalid Data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727771"></A>Parameter Blocks</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727773"></A>Varies (N Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727775"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727777"></A>Start of the parameter blocks, the structure of which is shown in <A HREF="ACPI_Software_Programming_Model.htm#60258" CLASS="XRef">See Parameter Block Structure for PATROL_SCRUB.</A>.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727778"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727779"></A>These parameter blocks are used as communication mailbox between the OSPM and the platform, and there is 1 parameter block for each RAS feature. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1727780"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727781"></A>NOTE:  There can  be only on parameter block per type.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1744458"></A><A NAME="54210"></A>PCC Command Codes used by RASF Platform Communication Channel </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1744496"></A>Command</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1744498"></A> Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744465"></A>0x00</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744467"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744469"></A>0x01</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744471"></A>Execute RASF Command.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744473"></A>0x02-0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744475"></A>All other values are reserved.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1727889"></A><A NAME="53676"></A>Platform RAS Capabilities</H6>
<P CLASS="Body">
<A NAME="pgfId-1727890"></A>The following table defines the Platform RAS capabilities:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1727917"></A><A NAME="95796"></A>Platform RAS Capabilities Bitmap</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727894"></A>Bit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727896"></A>RAS Feature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1727898"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727900"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727902"></A>Hardware based patrol scrub supported </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727904"></A>Indicates that the platform supports hardware based patrol scrub of DRAM memory </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727906"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727908"></A>Hardware based patrol scrub supported and exposed to software </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727910"></A>Indicates that the platform supports hardware based patrol scrub of DRAM memory and platform exposes this capability to software using this RASF mechanism </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727912"></A>2-127</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727914"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727916"></A>Reserved for future use</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1727918"></A>Parameter Block</H6>
<P CLASS="Body">
<A NAME="pgfId-1727919"></A>The following table describes the Parameter Blocks. The structure is used to pass parameters for controlling the corresponding RAS Feature. </P>
<P CLASS="Body">
<A NAME="pgfId-1727920"></A>Each RAS Feature is assigned a TYPE number, which is the bit index into the RAS capabilities bitmap described in <A HREF="ACPI_Software_Programming_Model.htm#95796" CLASS="XRef">See Platform RAS Capabilities Bitmap.</A>. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728030"></A><A NAME="60258"></A>Parameter Block Structure for PATROL_SCRUB</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729525"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729527"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729529"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729531"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727934"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727936"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727938"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727940"></A>0x0000 - Patrol scrub</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727942"></A>Version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727944"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727946"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727948"></A>Byte 0 - Minor Version</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727949"></A>Byte 1 - Major Version</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727951"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727953"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727955"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727957"></A>Length, in bytes of the entire parameter block structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727959"></A>Patrol Scrub Command</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727960"></A>(INPUT)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727962"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727964"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727966"></A>0x01 -  GET_PATROL_PARAMETERS</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727967"></A>0x02 -  START_PATROL_SCRUBBER</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727968"></A>0x03 - STOP_PATROL_SCRUBBER</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727970"></A>Requested Address Range</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727971"></A>(INPUT)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727973"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727975"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727977"></A>OSPM Specifies the BASE (Bytes 7-0) and SIZE (Bytes 15-8) of the address range to be patrol scrubbed.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727978"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727979"></A>OSPM sets this parameter for the following commands </P>
<P CLASS="TableBody">
<A NAME="pgfId-1727980"></A>GET_PATROL_PARAMETERS</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727981"></A>START_PATROL_SCRUBBER </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727983"></A>Actual Address Range</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727984"></A>(OUTPUT)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727986"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727988"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727990"></A>The platform returns this value in response to GET_PATROL_PARAMETERS. The platform calculates the nearest patrol scrub boundary address from where it can start. This range should be a superset of the Requested Address Range. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1727991"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1727992"></A>BASE (Bytes 7-0) and SIZE (Bytes 15-8) of the address</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727994"></A>Flags (OUTPUT)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727996"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1727998"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728000"></A>The platform returns this value in response to GET_PATROL_PARAMETERS</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728001"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728002"></A>Bit [0]: Will be set if patrol scrubber is already running for address range specified in &#8220;Actual Address Range&#8221;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728003"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728004"></A>Bits [3:1]: Current Patrol Speeds, if Bit [0] is set</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728005"></A>000b - Slow</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728006"></A>100b - Medium</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728007"></A>111b - Fast </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728008"></A>All other combinations are reserved. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728009"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728010"></A>Bits [15:4]: RESERVED</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728012"></A>Requested Speed (INPUT)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728014"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728016"></A>42</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728018"></A>The OSPM Sets this field as follows, for the START_PATROL_SCRUBBER command</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728019"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728020"></A>Bit [0]: Will be set if patrol scrubber is already running for address range specified in &#8220;Actual Address Range&#8221;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728021"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728022"></A>Bits [2:0]: Requested Patrol Speeds </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728023"></A>000b - Slow</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728024"></A>100b - Medium</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728025"></A>111b - Fast </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728026"></A>All other combinations are reserved. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728027"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728028"></A>Bits [7:3]: RESERVED</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1728031"></A>Sequence of Operations:</H6>
<P CLASS="Body">
<A NAME="pgfId-1728032"></A>The following sequence documents the steps for OSPM to identify whether the platform supports hardware based patrol scrub and invoke commands to request hardware to patrol scrub the specified address range.</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1728033"></A>Identify whether the platform supports hardware based patrol scrub and exposes the support to software by reading the RAS capabilities bitmap in RASF table </H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728034"></A>Call GET_PATROL_PARAMETERS, by setting the Requested Address Range.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728035"></A>Platform Returns Actual Address Range and Flags.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728036"></A>Based on the above two data, if the OPSM decides to start the patrol scrubber or change the speed of the patrol scrubber, then the OSPM calls START_PATROL_SCRUBBER, by setting the Requested Address Range and Requested Speed.</LI>
</OL>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1728037"></A><A NAME="66239"></A>Memory Power State Table (MPST)</H6>
<P CLASS="Body">
<A NAME="pgfId-1728038"></A>The following table describes the structure of new ACPI memory power state table (MPST). This table defines the memory power node topology of the configuration, as described earlier in <A HREF="Introduction.htm#66527" CLASS="XRef">See Introduction.</A>. The configuration includes specifying memory power nodes and their associated information. Each memory power node is specified using address ranges, supported memory power states. The memory power states will include both hardware controlled and software controlled memory power states. There can be multiple entries for a given memory power node to support non contiguous address ranges. MPST table also defines the communication mechanism between OSPM and platform runtime firmware for triggering software controlled memory powerstate transitions implemented in platform runtime firmware. </P>
<P CLASS="Body">
<A NAME="pgfId-1728042"></A><A HREF="ACPI_Software_Programming_Model.htm#74158" CLASS="XRef">See MPST ACPI Table Overview.</A> below provides structure organization overview of MPST table. <IMG SRC="ACPI_Software_Programming_Model-6.gif" ALIGN="BASELINE" ALT="">
<A NAME="OLE_LINK1"></A></P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1728048"></A><A NAME="74158"></A>MPST ACPI Table Overview</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728229"></A><A NAME="78460"></A>MPST Table Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728051"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728053"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728055"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728057"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728059"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728061"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728063"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728065"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728067"></A>     Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728069"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728071"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728073"></A>&#8216;MPST&#8217;. Signature for Memory Power State Table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728075"></A>     Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728077"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728079"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728081"></A>Length in bytes for entire MPST.  The length implies the number of Entry fields at the end of the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728083"></A>     Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728085"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728087"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728089"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728091"></A>     Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728093"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728095"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728097"></A>Entire table must sum to zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728099"></A>     OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728101"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728103"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728105"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728107"></A>     OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728109"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728111"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728113"></A>For the  memory power state table, the table ID is the manufacturer model ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728115"></A>     OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728117"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728119"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728121"></A>OEM revision of memory power state Table for supplied OEM Table ID </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728123"></A>     Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728125"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728127"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728129"></A>Vendor ID of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728131"></A>     Creator Revision </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728133"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728135"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728137"></A>Revision of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728139"></A>Memory PCC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728141"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728143"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728145"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728147"></A>MPST Platform Communication Channel Identifier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728149"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728151"></A>36 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728153"></A>Identifier of the MPST Platform Communication Channel. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728155"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728157"></A>3 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728159"></A>37 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728161"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728163"></A>Memory Power Node</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728165"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728167"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728169"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728171"></A>Memory Power Node Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728173"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728175"></A>40 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728177"></A>Number of Memory power Node structure entries</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728179"></A><EM CLASS="Italic">
Reserved</EM>
 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728181"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728183"></A>42 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728185"></A>Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728187"></A>Memory Power Node Structure[ Memory Power Node Count]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728189"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728191"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728193"></A>This field provides information on the memory power nodes present in the system. The information includes memory node id, power states supported &amp; associated latencies. Further details of this field are specified in  <A HREF="ACPI_Software_Programming_Model.htm#_Ref274729487" CLASS="XRef">See Memory Power Node.</A> </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728198"></A>Memory Power State Characteristics</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728200"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728202"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728204"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728206"></A>Memory Power State Characteristics Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728208"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728210"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728212"></A>Number of Memory power State Characteristics Structure entries</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728214"></A><EM CLASS="Italic">
Reserved</EM>
 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728216"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728218"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728220"></A>Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728222"></A>Memory Power State Characteristics Structure [m]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728224"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728226"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728228"></A>This field provides information of memory power states supported in the system. The information includes power consumed, transition latencies, relevant flags. </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728231"></A><A NAME="_Toc288145663"></A>MPST PCC Sub Channel</H6>
<P CLASS="Body">
<A NAME="pgfId-1728232"></A>The MPST PCC Sub Channel Identifier value provided by the platform in this field should be programmed to the Type field of PCC Communications Subspace Structure.  The MPST table references its PCC Subspace in a given platform by this identifier, as shown in <A HREF="ACPI_Software_Programming_Model.htm#78460" CLASS="XRef">See MPST Table Structure.</A>.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1728234"></A><A NAME="_Toc288145664"></A>Using PCC registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1744507"></A>OSPM will write PCC registers by filling in the register value in PCC sub channel space and issuing a PCC Execute command. See <A HREF="ACPI_Software_Programming_Model.htm#56075" CLASS="XRef">See PCC Command Codes used by MPST Platform Communication Channel .</A>, below. All other command values are reserved.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1744508"></A><A NAME="56075"></A>PCC Command Codes used by MPST Platform Communication Channel </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1744511"></A>Command</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1744513"></A> Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744515"></A>0x00-0x02</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744517"></A>All other values are reserved.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744519"></A>0x03</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744521"></A>Execute MPST Command.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744523"></A>0x04-0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1744525"></A>All other values are reserved.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728334"></A><A NAME="88935"></A>MPST Platform Communication Channel Shared Memory Region</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1740219"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1740221"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1740223"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1740225"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740227"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740229"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740231"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740233"></A>The PCC signature. The signature of a subspace is computed by a bitwise-or of the value 0x50434300 with the subspace ID. For example, subspace 3 has signature 0x50434303. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740235"></A>Command</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740237"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740239"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740241"></A>PCC command field, see<A HREF="Platform_Comm_Channel.htm#68313" CLASS="XRef">See Platform Communications Channel (PCC).</A> and <A HREF="ACPI_Software_Programming_Model.htm#56075" CLASS="XRef">See PCC Command Codes used by MPST Platform Communication Channel .</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740243"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740245"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740247"></A>6 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740249"></A>PCC status field, see <A HREF="Platform_Comm_Channel.htm#68313" CLASS="XRef">See Platform Communications Channel (PCC).</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableHeading">
<A NAME="pgfId-1740251"></A>Communication Space </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740259"></A> MEMORY_POWER_COMMAND_REGISTER</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740261"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740263"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740265"></A>Memory region for OSPM to write the requested memory power state. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1741070"></A>Write:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1741077"></A>1 to this field to GET the memory power state</P>
<P CLASS="TableBody">
<A NAME="pgfId-1741084"></A>2 to this field to set the memory power state</P>
<P CLASS="TableBody">
<A NAME="pgfId-1740266"></A>3 - GET AVERAGE POWER CONSUMED</P>
<P CLASS="TableBody">
<A NAME="pgfId-1740267"></A>4 - GET MEMORY ENERGY CONSUMED</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740269"></A>MEMORY_POWER_STATUS_REGISTER</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740271"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740273"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740275"></A>Bits [3:0]: Status (specific to MEMORY_POWER_COMMAND_REGISTER) </P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1740276"></A>0000b = Success</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1740277"></A>0001b = Not Valid</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1740278"></A>0010b = Not Supported</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1740279"></A>0011b = Busy</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1740280"></A>0100b = Failed</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1740281"></A>0101b = Aborted </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1744311"></A>0110b  = Invalid Data </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1744363"></A>Other values reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1744319"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744376"></A>Bit [4]: Background Activity specific to  the following MEMORY_POWER _COMMAND_REGISTER value:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744320"></A>3 - GET AVERAGE POWER CONSUMED </P>
<P CLASS="TableBody">
<A NAME="pgfId-1744321"></A>4 - GET MEMORY ENERGY CONSUMED</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744322"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744324"></A>0b = inactive</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744325"></A>1b = background memory activity is in progress</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744312"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1744313"></A>Bits [31:5]: Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740284"></A>POWER STATE ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740286"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740288"></A>16 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740290"></A>On completion of a GET operation, OSPM reads the current platform state ID from this field. Prior to a SET operation, OSPM populates this field with the power state value which needs to be triggered. Power State values will be based on the platform capability</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740292"></A>MEMORY_POWER_NODE_ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740294"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740296"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740298"></A>This field identifies Memory power node number for the command.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740300"></A>MEMORY_ENERGY_CONSUMED </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740302"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740304"></A>24 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740306"></A>This field returns the energy consumed by the memory that constitutes the MEMORY_POWER_NODE_ID specified in the previous field. A value of all 1s in this field indicates that platform does not implement this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740308"></A>EXPECTED_AVERAGE_POWER_CONSUMED </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740310"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740312"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1740314"></A>This field returns the expected average power consumption for the memory constituted by MEMORY_POWER_NODE_ID. A value of all 1s in this field indicates that platform does not implement this field.</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1728335"></A>OSPM should use the ratio of computed memory power consumed to expected average power consumed in determining the memory power management action. </LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728336"></A>Memory Power State </H6>
<P CLASS="Body">
<A NAME="pgfId-1728337"></A>Memory Power State represents the state of a memory power node (which maps to a memory address range) while the platform is in the G0 working state. Memory power node could be in active state named MPS0 or in one of the power manage states MPS1-MPSn. </P>
<P CLASS="Body">
<A NAME="pgfId-1728338"></A>It should be noted that active memory power state (MPS0) does not preclude memory power management in that state. It only indicates that any active state memory power management in MPS0 is transparent to the OSPM and more importantly does not require assist from OSPM in terms of restricting memory occupancy and activity.</P>
<P CLASS="Body">
<A NAME="pgfId-1728339"></A>MPS1-MPSn states are characterized by non-zero exit latency for exit from the state to MPS0. These states could require explicit OSPM-initiated entry and exit, explicit OSPM-initiated entry but autonomous exit or autonomous entry and exit. In all three cases, these states require explicit OSPM action to isolate and free the memory address range for the corresponding memory power node.</P>
<P CLASS="Body">
<A NAME="pgfId-1728340"></A>Transitions to more aggressive memory power states (for example, from MPS1 to MPS2) can be entered on progressive idling but require transition through MPS0 (i.e. MPS1&#61661;MPS0&#61661;MPS2). Power state transition diagram is shown in <A HREF="ACPI_Software_Programming_Model.htm#54706" CLASS="XRef">See Memory Power State Transitions.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1728344"></A>It is possible that after OSPM request a memory power state, a brief period of activity returns the memory power node to MPS0 state . If platform  is capable of returning to a memory power state on subsequent period of idle, the platform must treat the previously requested memory power state as a persistent hint. </P>
<P CLASS="Normal">
<A NAME="pgfId-1728348"></A>&nbsp;</P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-7.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1728350"></A><A NAME="54706"></A>Memory Power State Transitions</H6>
<P CLASS="Body">
<A NAME="pgfId-1728351"></A>The following table enumerates the power state values that a node can transition to.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728380"></A>Power state Values </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728356"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728358"></A>State Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728360"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728362"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728364"></A>MPS0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728366"></A>This state value maps to active state of memory node (Normal operation). OSPM can access memory during this state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728368"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728370"></A>MPS1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728372"></A>This state value can be mapped to any memory power state depending on the platform capability. The platform will inform the features of MPS1 state using the Memory Power State Structure. By convention, it is required that low value power state will have lower power savings and lower latencies than the higher valued power states. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728374"></A>2,3...n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728376"></A>MPS2, MPS3, ...</P>
<P CLASS="TableBody">
<A NAME="pgfId-1728377"></A>MPSn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728379"></A>Same description as MPS1. </P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1728381"></A>The following provides the list of command status:</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728431"></A>Command Status </H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728384"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728386"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728388"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728390"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728392"></A>Command Complete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728394"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728396"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728398"></A>If set, the platform has completed processing the last command.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728400"></A>SCI Doorbell</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728402"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728404"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728406"></A>If set, then this PCC Sub-Channel has signaled the SCI door bell.  In Response to this SCI, OSPM should probe the Command Complete  and the Platform Notification fields to determine the cause of SCI. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728408"></A>Error</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728410"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728412"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728414"></A>If set, an error occurred executing the last command.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728416"></A>Platform Notification </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728418"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728420"></A>3 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728422"></A>Indicates that the SCI doorbell was invoked by the platform. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728424"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728426"></A>12 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728428"></A>4 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728430"></A>Reserved.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728432"></A>Action Sequence </H6>
<P CLASS="Body">
<A NAME="pgfId-1728433"></A>SetMemoryPowerState: The following sequence needs to be done to set a memory power state</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1728434"></A>Write target POWER NODE ID value to MEMORY_POWER_NODE_ID register of PCC sub channel.</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728435"></A>Write desired POWER STATE ID value to POWER STATE ID register of PCC sub channel .</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728436"></A>Write SET (See <A HREF="ACPI_Software_Programming_Model.htm#88935" CLASS="XRef">See MPST Platform Communication Channel Shared Memory Region.</A>) to MEMORY_POWER_STATE register of PCC sub channel. </LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728437"></A>Write PCC EXECUTE (See <A HREF="ACPI_Software_Programming_Model.htm#56075" CLASS="XRef">See PCC Command Codes used by MPST Platform Communication Channel .</A>) to PCC Command register for the PCC sub channel.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728438"></A>OSPM rings the door bell by writing to Doorbell register.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728439"></A>Platform completes the request and will generate SCI to indicate that the command is complete.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728440"></A>OSPM reads the Status register for the PCC sub channel and confirms that the command was successfully completed. </LI>
</OL>
<P CLASS="Normal">
<A NAME="pgfId-1728441"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1728442"></A>GetMemoryPowerState: The following sequence needs to be done to get the current memory power state</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1728443"></A>Write target POWER NODE ID value to MEMORY_POWER_NODE_ID register of PCC sub channel.</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728444"></A>Write GET (See <A HREF="ACPI_Software_Programming_Model.htm#88935" CLASS="XRef">See MPST Platform Communication Channel Shared Memory Region.</A>) to MEMORY_POWER_STATE register of PCC sub channel. </LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728445"></A>Write PCC EXECUTE (See <A HREF="ACPI_Software_Programming_Model.htm#56075" CLASS="XRef">See PCC Command Codes used by MPST Platform Communication Channel .</A>) to PCC Command register for the PCC sub channel.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728446"></A>OSPM rings the door bell by writing to Doorbell register.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728447"></A>Platform completes the request and will generate SCI to indicate that command is complete.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728448"></A>OSPM reads Status register for the PCC sub channel and confirms that the command was successfully completed.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1728449"></A>OSPM reads POWER STATE from POWER_STATE_ID register of PCC sub channel.</LI>
</OL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728453"></A><A NAME="_Ref274729487"></A><A NAME="_Ref274729508"></A><A NAME="_Toc288145669"></A>Memory Power Node</H6>
<P CLASS="Body">
<A NAME="pgfId-1740788"></A>Memory Power Node is a representation of a logical memory region that needs to be transitioned in and out of a memory power state as a unit. This logical memory region is made up of one more system memory address range(s). A Memory Power Node is uniquely identified by Memory Power Node ID.</P>
<P CLASS="Body">
<A NAME="pgfId-1740792"></A>Note that memory power node structure defined in <A HREF="ACPI_Software_Programming_Model.htm#28380" CLASS="XRef">See Memory Power Node Structure definition.</A> can only represent a single address range. This address range should be 4K aligned. If a Memory Power Node contains more than one memory address range (i.e. non-contiguous range), firmware must construct a Memory power Node structure for each of the memory address ranges but specify the same Memory Power Node ID in all the structures. </P>
<P CLASS="Body">
<A NAME="pgfId-1728456"></A>Memory Power Nodes are not hierarchical. However, a given memory address range covered by a Memory power node could be fully covered by another memory power node if that nodes memory address range is inclusive of the other node&#8217;s range. For example, memory power node MPN0 may cover memory address range 1G-2G and memory power node MPN1 covers 1-4G. Here MPN1 memory address range also comprehends the range covered by MPN0. </P>
<P CLASS="Body">
<A NAME="pgfId-1728457"></A>OSPM is expected to identify the memory power node(s) that corresponds to the maximum memory address range that OSPM is able to power manage at a given time. For example, if MPN0 covers 1G-2G and MPN1 covers 1-4G and OSPM is able to power manage 1-4G, it should select MPN1. If MPN0 is in a non-active memory power state, OSPM must move MPN0 to MPS0 (Active state) before placing MPN1 in desired Memory Power State. Further, MPN1 can support more power states than MPN0. If MPN1 is in such a state , say MPS3 , that MPN0 does not support, software must not query MPN0. If queried, MPN0 will return &quot;not Valid&quot; until MPN1 returns to MPS0. </P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1728458"></A>[Implementation Note] In general, memory nodes corresponding to larger address space ranges correspond to higher memory aggregation (e.g. memory covered by a DIMM vs. memory covered by a memory channel) and hence typically present higher power saving opportunities.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1728460"></A><A NAME="_Toc288145670"></A>Memory Power Node Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1728461"></A>The following structure specifies the fields used for communicating memory power node information.  Each entry in the MPST table will be having corresponding memory power node structure defined. </P>
<P CLASS="Body">
<A NAME="pgfId-1728462"></A>This structure communicates address range, number of power states implemented, information about individual power states, number of distinct physical components that comprise this memory power node.</P>
<P CLASS="Body">
<A NAME="pgfId-1728463"></A>The physical component identifiers can be cross-referenced against the memory topology table entries.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728586"></A><A NAME="28380"></A>Memory Power Node Structure definition</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776451"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776453"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776455"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776457"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728474"></A> Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728476"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728478"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728480"></A>The flag describes type of memory node. Refer to <A HREF="ACPI_Software_Programming_Model.htm#92920" CLASS="XRef">See Flag format.</A> for details.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728482"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728484"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728486"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728488"></A>For future use</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728490"></A> Memory Power Node Id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728492"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728494"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728496"></A>This field provides memory power node number. This is a unique identification for Memory Power State Command and creation of freelists/cache lists in OSPM memory manager to bias allocation of non power managed nodes vs. power managed nodes. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728498"></A> Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728500"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728502"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728504"></A>Length in bytes for Memory Power Node Structure.  The length implies the number of Entry fields at the end of the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728506"></A>Base Address Low</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728508"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728510"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728512"></A>Low 32 bits of Base Address of the memory range. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728514"></A>Base Address High</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728516"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728518"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728520"></A>High 32 bits of Base Address of the memory range. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728522"></A>Length Low</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728524"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728526"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728528"></A>Low 32 bits of Length of the memory range. This field along with &#8220;Length High&#8221; field is used to derive the end physical address of this address range.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728530"></A>Length High</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728532"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728534"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728536"></A>High 32 bits of Length of the memory range. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728538"></A>Number of Power States (n)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728540"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728542"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728544"></A>This field indicates number of power states supported for this memory power node and in turn determines the number of entries in memory power state structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728546"></A>Number of Physical Components</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728548"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728550"></A>28 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728552"></A>This field indicates the number of distinct Physical Components that constitute this memory power node. This field is also used to identify the number of entries of Physical Component Identifier entries present at end of this table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728555"></A>Memory Power State Structure [n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728557"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728559"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728561"></A>This field provides information of various power states supported in the system for a given memory power node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728563"></A>Physical Component Identifier1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728565"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728567"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728569"></A>2 byte identifier of distinct physical component that makes up this memory power node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728571"></A>.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728573"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728575"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728577"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728579"></A>Physical Component Identifier m</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728581"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728583"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728585"></A>2 byte identifier of distinct physical component that makes up this memory power node</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728621"></A><A NAME="92920"></A>Flag format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741137"></A>Bit </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741139"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741141"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741105"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741107"></A>Enabled</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741109"></A>If clear, the OSPM ignores this Memory Power Node Structure. This allows system firmware to populate the MPST with a static number of structures but enable them as necessary.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741111"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741113"></A>Power Managed Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741115"></A>1 - Memory node is power managed</P>
<P CLASS="TableBody">
<A NAME="pgfId-1741116"></A>0 - Memory node is not power managed. For non power managed node, OSPM shall not attempt to transition node into low power state. System behavior is undefined if OSPM attempts this. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1741117"></A>NOTE: If the memory range corresponding to the memory node includes platform firmware reserved memory that cannot be power managed, the platform should indicate such memory as &#8220;not power managed&#8221; to OSPM. This allows OSPM to ignore such ranges from its power optimization.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741119"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741121"></A>Hot Pluggable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741123"></A>This flag indicates that the memory node supports the hot plug feature. Refer to <A HREF="ACPI_Software_Programming_Model.htm#90816" CLASS="XRef">See Interaction with Memory Hot Plug.</A> for interaction with memory hot plug.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741125"></A>3-7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741127"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741129"></A>Reserved for future use</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728622"></A>Memory Power State Structure</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728648"></A>Memory Power State Structure definition</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728625"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728627"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728629"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1728631"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728633"></A>Power State Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728635"></A>1 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728637"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728639"></A>This field provides value of power state. The specific value to be used is system dependent. However convention needs to be maintained where higher numbers indicates deeper power states with higher power savings and higher latencies. For example, a power state value of 2 will have higher power savings and higher latencies than a power state value of 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728641"></A>Power State Information Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728643"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728645"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728647"></A>This field provides unique index into the memory power state characteristics entries which will provide details about the power consumed, power state characteristics and transition latencies. The indexing mechanism is to avoid duplication (and hence reduce potential for mismatch errors) of memory power state characteristics entries across multiple memory nodes.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728649"></A> Memory Power State Characteristics structure </H6>
<P CLASS="Body">
<A NAME="pgfId-1728650"></A>The table below describes the power consumed, exit latency and the characteristics of the memory power state. This table is referenced by a memory power node.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1734160"></A>Memory Power State Characteristics Structure </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734384"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1734386"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734390"></A>Byte Offset</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734341"></A>Power State Structure ID</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734300"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734302"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734305"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734397"></A>Bit [5:0] = This field describes the format of table Structure</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734398"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734399"></A>Power State Structure ID Value = 1</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734400"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734401"></A>Bit [7:6] = Structure Revision</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734402"></A>Current revision is 1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734356"></A>Flag</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734309"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734311"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734315"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734417"></A>The flag describes the caveats associated with entering the specified power state. Refer to <A HREF="ACPI_Software_Programming_Model.htm#89557" CLASS="XRef">See Flag format of Memory Power State Characteristics Structure.</A> for details.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734371"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734321"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734324"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734432"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734449"></A>Average Power Consumed in MPS0 state (in  milli watts)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734328"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734330"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734332"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734442"></A>This field provides average power consumed for this memory power node in MPS0 state. This power is measured in milliWatts and signifies the total power consumed by this memory the given power state as measured in DC watts. Note that this value should be used as guideline only for estimating power savings and not as actual power consumed. Also memory power node can map to single or collection of RANKs/DIMMs. The actual power consumed is dependent on DIMM type, configuration and memory load.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734488"></A>Relative Power Saving to MPS0 state</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734477"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734479"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734533"></A>This is a percentage of power saved in MPSx state relative to MPS0 state and should be calculated as ((MPS0 power - MPSx power)/MPS0 Power)*100.  When this entry is describing MPS0 state itself, OSPM should ignore this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734503"></A>Exit Latency (in ns)  (MPSx&#61661; MPS0)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734467"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734469"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734471"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734548"></A>This field provides latency of exiting out of a power state (MPSx) to active state (MPS0). The unit of this field is nanoseconds.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734549"></A>When this entry is describing MPS0 state itself, OSPM should ignore this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734518"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734461"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734463"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734564"></A>Reserved for future use.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1734197"></A><A NAME="89557"></A>Flag format of Memory Power State Characteristics Structure </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1734164"></A>Bit </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1734166"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1734168"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734170"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734172"></A>Memory Content Preserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734174"></A>If Bit [0] is set, it indicates memory contents will be preserved in the specified power state</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734175"></A>If Bit [0] is clear, it indicates memory contents will be lost in the specified power state (e.g. for states like offline)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734177"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734179"></A>Autonomous Memory Power State Entry</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734181"></A>If Bit [1] is set, this field indicates that given memory power state entry transition needs to be triggered explicitly by OSPM by calling the Set Power State command.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734182"></A>If Bit [1] is clear, this field indicates that given memory power state entry transition is automatically implemented in hardware and does not require a OSPM trigger. The role of OSPM in this case is to ensure that the corresponding memory region is idled from a software standpoint to facilitate entry to the state.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734183"></A>Not meaningful for MPS0 - write it for this table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734185"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734187"></A>Autonomous Memory Power State Exit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734189"></A>If Bit [1] is set, this field indicates that given memory power state exit needs to be explicitly triggered by the OSPM before the memory can be accessed. System behavior is undefined if OSPM or other software agents attempt to access memory that is currently in a low power state.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1734190"></A>If Bit [1] is clear, this field indicates that given memory power state is exited automatically on access to the memory address range corresponding to the memory power node.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734192"></A>3-7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734194"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1734196"></A>Reserved for future use</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1728811"></A><A NAME="_Toc288145673"></A>Power Consumed</H6>
<P CLASS="Body">
<A NAME="pgfId-1728812"></A>Average Power Consumed in MPS0 state indicates the power in milli Watts for the MPS0 state. Relative power savings to MPS0 indicates the savings in the MPSx state as a percentage of savings relative to MPS0 state.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1728813"></A>Exit Latency</H6>
<P CLASS="Body">
<A NAME="pgfId-1728814"></A>Exit Latency provided in the Memory Power Characteristics structure for a specific power state is inclusive of the entry latency for that state.</P>
<P CLASS="Body">
<A NAME="pgfId-1728815"></A>Exit latency must always be provided for a memory power state regardless of whether the memory power state entry and/or exit are autonomous or requires explicit trigger from OSPM.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728816"></A>Autonomous Memory Power Management </H6>
<P CLASS="Body">
<A NAME="pgfId-1728817"></A>Not all memory power management states require OSPM to actively transition a memory power node in and out of the memory power state. Platforms may implement memory power states that are fully handled in hardware in terms of entry and exit transition. In such fully autonomous states, the decision to enter the state is made by hardware based on the utilization of the corresponding memory region and the decision to exit the memory power state is initiated in response to a memory access targeted to the corresponding memory region.</P>
<P CLASS="Body">
<A NAME="pgfId-1728818"></A>The role of OSPM software in handling such autonomous memory power states is to vacate the use of such memory regions when possible in order to allow hardware to effectively save power. No other OSPM initiated action is required for supporting these autonomously power managed regions. However, it is not an error for OSPM explicitly initiates a state transition to an autonomous entry memory power state through the MPST command interface. The platform may accept the command and enter the state immediately in which case it must return command completion with SUCCESS (00000b) status. If platform does not support explicit entry, it must return command completion with NOT SUPPORTED (00010b) status.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728819"></A>Handling BIOS Reserved Memory</H6>
<P CLASS="Body">
<A NAME="pgfId-1728820"></A>Platform firmware may have regions of memory reserved for its own use that are unavailable to OSPM for allocation. Memory nodes where all (or a portion) of the memory is reserved by platform firmware may pose a problem for OSPM because it does not know whether the platform firmware reserved memory is in use. </P>
<P CLASS="Body">
<A NAME="pgfId-1728821"></A>If the platform firmware  reserved memory impacts the ability of the memory power node to enter memory power state(s), the platform must indicate to OSPM (by clearing the Power Managed Flag - see <A HREF="ACPI_Software_Programming_Model.htm#92920" CLASS="XRef">See Flag format.</A> for details) that this memory power node cannot be power managed. This allows OSPM to ignore such ranges from its memory power optimization.<A NAME="_Toc288145677"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728823"></A>Interaction with NUMA processor and memory affinity tables</H6>
<P CLASS="Body">
<A NAME="pgfId-1728824"></A>The memory power state table describes address range for each of the memory power nodes specified. OSPM can use the address ranges information provided in MPST table and derive processor affinity of a given memory power node based on the SRAT entries created by the platform boot firmware. The association of memory power node to proximity domain can be used by OSPM to implement memory coalescing taking into account NUMA node topology for memory allocation/release and manipulation of different page lists in memory management code (implementation specific).  </P>
<P CLASS="Body">
<A NAME="pgfId-1728825"></A>An example of policy which can be implemented in OSPM for memory coalescing is:  OSPM can prefer allocating memory from local memory power nodes before going to remote memory power nodes. The later sections provide sample NUMA configurations and explain the policy for various memory power nodes. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728826"></A><A NAME="90816"></A>Interaction with Memory Hot Plug </H6>
<P CLASS="Body">
<A NAME="pgfId-1728827"></A>The hot pluggable memory regions are described using memory device objects (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#30870" CLASS="XRef">See Memory Devices.</A>). The memory address ranges of these memory device objects are defined using the _CRS method. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728828"></A>Scope (&#92;_SB) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728829"></A>      Device (MEM0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728830"></A>            Name (_HID, EISAID (&#8220;PNP0C80&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728831"></A>            Name (_CRS, ResourceTemplate () {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728832"></A>                  QwordMemory (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728833"></A>                        ResourceConsumer,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728834"></A>                        ,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728835"></A>                        MinFixed,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728836"></A>                        MaxFixed,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728837"></A>                        Cacheable,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728838"></A>                        ReadWrite,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728839"></A>                        0xFFFFFFF,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728840"></A>                        0x10000000,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728841"></A>                        0x30000000,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728842"></A>                        0, , ,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728843"></A>                  )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728844"></A>           })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728845"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1728846"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1728848"></A>The memory power state table (MPST) is a static structure created for all memory objects independent of hot plug status (online or offline) during initialization. The OSPM will populate the MPST table during the boot.  If hot-pluggable flag is set for a given memory power node in MPST table, OSPM will not use this node till physical presence of memory is communicated through ACPI notification mechanism.</P>
<P CLASS="Body">
<A NAME="pgfId-1728849"></A>The association between memory device object (e.g. MEM0) to the appropriate memory power node id in the MPST table is determined by comparing the address range specified using _CRS method and address ranges configured in the MPST table entries.  This association needs to be identified by OSPM as part of ACPI memory hot plug implementation. When memory device is hot added, as part of existing acpi driver for memory hot plug, OSPM will scan device object for  _CRS method and get the relevant address ranges for the given memory object, OSPM will determine the appropriate memory power node ids based on the address ranges from _CRS and enable it for power management and memory coalescing. </P>
<P CLASS="Body">
<A NAME="pgfId-1728851"></A>Similarly when memory is hot removed, the corresponding memory power nodes will be disabled.<A NAME="_Toc288145679"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728852"></A>OS Memory Allocation Considerations</H6>
<P CLASS="Body">
<A NAME="pgfId-1728853"></A>OSes (non-virtualized OS or a hypervisor/VMM) may need to allocate non-migratable memory. It is recommended that the OSes (if possible) allocate this memory from memory ranges corresponding to memory power nodes that indicate they are not power manageable. This allows OS to optimize the power manageable memory power nodes for optimal power savings.</P>
<P CLASS="Body">
<A NAME="pgfId-1728854"></A>OSes can assume that memory ranges that belong to memory power nodes that are power manageable (as indicated by the flag) are interleaved in a manner that does no impact the ability of that range to enter power managed states. For example, such memory is not cacheline interleaved.</P>
<P CLASS="Body">
<A NAME="pgfId-1728855"></A>Reference to memory in this document always refers to host physical memory. For virtualized environments, this requires hypervisors to be responsible for memory power management. Hypervisors also have the ability to create opportunities for memory power management by vacating appropriate host physical memory through remapping guest physical memory.</P>
<P CLASS="Body">
<A NAME="pgfId-1728856"></A>OSes can assume that the memory ranges included in MPST always refer to memory store - either volatile or non-volatile and never to MMIO or MMCFG ranges.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1728857"></A><A NAME="30717"></A>Memory Topology Table (PMTT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1728858"></A>This table describes the memory topology of the system to OSPM, where the memory topology can be logical or physical. The topology is provided to the last level physical component (e.g. DIMM).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1728967"></A>Platform Memory Topology Table</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739777"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739779"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739781"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739783"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728869"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728871"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728873"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728875"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728877"></A>     Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728879"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728881"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728883"></A>&#8216;PMTT&#8217;. Signature for Platform Memory Topology Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728885"></A>     Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728887"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728889"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728891"></A>Length in bytes of the entire PMTT.  The length implies the number of Memory Aggregator structures at the end of the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728893"></A>     Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728895"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728897"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728899"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728901"></A>     Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728903"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728905"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728907"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728909"></A>     OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728911"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728913"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728915"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728917"></A>     OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728919"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728921"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728923"></A>For the  PMTT, the table ID is the manufacturer model ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728925"></A>     OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728927"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728929"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728931"></A>OEM revision of the PMTT for supplied OEM Table ID. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728933"></A>     Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728935"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728937"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728939"></A>Vendor ID of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728941"></A>     Creator Revision </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728943"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728945"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728947"></A>Revision of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728949"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728951"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728953"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728955"></A>Reserved, must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728957"></A>Memory Aggregator Device Structure [n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728959"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728961"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728963"></A>A list of memory aggregator device structures for the platform. See <A HREF="ACPI_Software_Programming_Model.htm#60042" CLASS="XRef">See Common Memory Aggregator Device Structure.</A>.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1729048"></A><A NAME="60042"></A>Common Memory Aggregator Device Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1831677"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831679"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831681"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1831683"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728979"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728981"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728983"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728985"></A>The field describes type of the Memory Aggregator Device. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728986"></A>0 - Socket </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728987"></A>1 - Memory Controller </P>
<P CLASS="TableBody">
<A NAME="pgfId-1742578"></A>2 - DIMM </P>
<P CLASS="TableBody">
<A NAME="pgfId-1728989"></A>3 - 0xFF - Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728991"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728993"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728995"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728997"></A>Reserved, must be zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1728999"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729001"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729003"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729005"></A>Length in bytes for this Structure. This length implies the length of the Type Specific Data at the end of the structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729007"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729009"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729011"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729013"></A>Bit [0] - set to 1 to indicate that this is a top level aggregator device. This device must be counted in the number of top level aggregator devices in PMTT table and must be surfaces via PMTT.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1729014"></A>Bit [0] - 0 indicates that this is not a top level aggregator device. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729015"></A>Bit [1] - 1 indicates a physical element of the topology.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1729016"></A>0 indicates a logical element of topology </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729017"></A>Bit [2] and [3]  - </P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729018"></A>00 - Indicates that all components aggregated by this device implement volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729019"></A>01 - Indicates that components aggregated by this device implement both volatile and non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729020"></A>10 - Indicates that all   components aggregated by this device implement non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729021"></A>11 - Reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1729022"></A>Bits [15:4] Reserved, must be zero </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729024"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729026"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729028"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729030"></A>Reserved, must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729032"></A>Type Specific Data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729034"></A>__</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729036"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729038"></A>Type specific data. Interpretation of this data is specific to the type of the memory aggregator device. See <A HREF="ACPI_Software_Programming_Model.htm#48251" CLASS="XRef">See Socket Structure.</A>, <A HREF="ACPI_Software_Programming_Model.htm#40410" CLASS="XRef">See Memory Controller Structure.</A>, and <A HREF="ACPI_Software_Programming_Model.htm#21676" CLASS="XRef">See Physical Components Identifier Structure.</A>. </P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1729125"></A><A NAME="48251"></A>Socket Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741416"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741418"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741420"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741422"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741424"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741426"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741428"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741430"></A>0 - Socket </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741432"></A><EM CLASS="Italic">
Reserved</EM>
 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741434"></A>1 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741436"></A>1 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741438"></A>Reserved, must be zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741440"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741442"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741444"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741446"></A>Length in bytes for this Structure. The length implies the number of memory controller structures at the end of this structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741448"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741450"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741452"></A>4 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741454"></A>Bit [0] - 1 indicates that this is a top level aggregator device. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1741455"></A>Bit [1] - Set to 1 since socket is a physical element of the topology </P>
<P CLASS="TableBody">
<A NAME="pgfId-1741456"></A>Bit [2] and [3]  - </P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1741457"></A>00 - Indicates that all components aggregated by this device implement volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1741458"></A>01 - Indicates that components aggregated by this device implement both volatile and non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1741459"></A>10 - Indicates that all   components aggregated by this device implement non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1741460"></A>11 - Reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1741461"></A>Bit [4] - Bit [15] Reserved, must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741463"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741465"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741467"></A>6 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741469"></A>Reserved, must be zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741471"></A>Socket Identifier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741473"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741475"></A>8 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741477"></A>Uniquely identifies the socket in the system.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741479"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741481"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741483"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741485"></A>Reserved, must be zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741487"></A>Memory Controller Structure [n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741489"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741491"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741493"></A>A list of Memory Controller Structures.This list provides information on the memory controllers present in the socket. See <A HREF="ACPI_Software_Programming_Model.htm#40410" CLASS="XRef">See Memory Controller Structure.</A>.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1729267"></A><A NAME="40410"></A>Memory Controller Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729129"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729131"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729133"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729135"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729137"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729139"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729141"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729143"></A>1 - Memory Controller </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729145"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729147"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729149"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729151"></A>Reserved, must be zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729153"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729155"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729157"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729159"></A>Length in bytes for this Structure. The length implies the number of physical component identifier structures at the end of this structure. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729161"></A>Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729163"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729165"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729167"></A>Bit [0] - 1 indicates that this is a top level aggregator device. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729168"></A>Bit [1] - 1 indicates a physical element of the topology.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1729169"></A>0 indicates a logical element of the topology </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729170"></A>Bit [2] and [3]  - </P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729171"></A>00 - Indicates that all components aggregated by this device implement volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729172"></A>01 - Indicates that components aggregated by this device implement both volatile and non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729173"></A>10 - Indicates that all components aggregated by this device implement non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729174"></A>11 - Reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1729175"></A>Bit [4] - Bit [15] Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729177"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729179"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729181"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729183"></A>Reserved, must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729185"></A>Read Latency (typical)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729187"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729189"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729191"></A>In nanoseconds as seen at the controller for a cacheline access. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729193"></A>Write latency (typical)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729195"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729197"></A>12 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729199"></A>In nanoseconds as seen at the controller for a cacheline access.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729201"></A>Read Bandwidth (typical)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729203"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729205"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729207"></A>In MB/s</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729209"></A>Write Bandwidth (typical)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729211"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729213"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729215"></A>In MB/s</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729217"></A>Optimal access unit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729219"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729221"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729223"></A>In bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729225"></A>Optimal access alignment</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729227"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729229"></A>26</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729231"></A>In bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729233"></A><EM CLASS="Italic">
Reserved</EM>
 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729235"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729237"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729239"></A>Reserved , must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729241"></A>Number of Proximity Domains (m) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729243"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729245"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729247"></A>Number of Proximity Domains that immediately follow. A zero in this field indicates that proximity domain information is not provided by the platform and that no 4-byte domains follow</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729249"></A>Proximity Domain [m]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729251"></A>4*m</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729253"></A>32 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729255"></A>Proximity domains for memory address space(s) spawned by this memory controller. Each proximity domain is a 4-byte entity as defined in the System Resource Allocation Table (SRAT).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729257"></A>Physical Component Identifier Structure [n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729259"></A>__</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729261"></A>-</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729263"></A>A list of Physical Components structures for this memory controller. See <A HREF="ACPI_Software_Programming_Model.htm#21676" CLASS="XRef">See Physical Components Identifier Structure.</A>.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1729359"></A><A NAME="21676"></A>Physical Components Identifier Structure  </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729380"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729382"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729384"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1729386"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729279"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729281"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729283"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729285"></A>2- DIMM  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729287"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729289"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729291"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729293"></A>Reserved, must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729295"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729297"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729299"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729301"></A>Length in bytes for this Structure.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729303"></A>Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729305"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729307"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729309"></A>Bit [0] -  0 indicates that this is not a top level memory aggregator. DIMM is typically behind a memory controller or a socket device or both. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729310"></A>Bit [1] - 1 indicates a physical element of the topology.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1729311"></A>Set to 0 to indicate a logical element of the topology </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729312"></A>Bit [2] and [3]  - </P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729313"></A>00 - Indicates that all components aggregated by this device implement volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729314"></A>01 - Indicates that components aggregated by this device implement both volatile and non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729315"></A>10 - Indicates that all components aggregated by this device implement non-volatile memory </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1729316"></A>11 - Reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1729317"></A>Bit [4] - Bit [15] Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729319"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729321"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729323"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729325"></A>Reserved, must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729327"></A>Physical Component Identifier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729329"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729331"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729333"></A>Uniquely identifies the physical memory component in the system.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729335"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729337"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729339"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729341"></A>Reserved, must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729343"></A>Size of DIMM  </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729345"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729347"></A>12 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729349"></A>Size in MB of the DIMM device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729351"></A>SMBIOS Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729353"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729355"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1729357"></A>Refers to Type 17 table handle of corresponding SMBIOS record. The platform indicates that this field is not valid by setting a value of 0xFFFFFFFF. If the platform provides a valid handle, the upper 2 bytes must be 0 ( since SMBIOS handles are 2 bytes only). </P>
<P CLASS="TableBody">
<A NAME="pgfId-1729358"></A>NOTE: The use of this handle is for management software to be able to cross-reference the physical DIMM  described in SMBIOS against the topology described in this table. It is not expected that OSPM will utilize this field.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1713006"></A><A NAME="89334"></A>Boot Graphics Resource Table (BGRT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1713008"></A>The Boot Graphics Resource Table (BGRT) is an optional table that provides a mechanism to indicate that an image was drawn on the screen during boot, and some information about the image. </P>
<P CLASS="Body">
<A NAME="pgfId-1713009"></A>The table is written when the image is drawn on the screen. This should be done after it is expected that any firmware components that may write to the screen are done doing so and it is known that the image is the only thing on the screen. If the boot path is interrupted (e.g., by a key press), the valid bit within the status field should be changed to 0 to indicate to the OS that the current image is invalidated.</P>
<P CLASS="Body">
<A NAME="pgfId-1713266"></A>This table is only supported on UEFI systems.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1713408"></A><A NAME="29157"></A>Boot Graphics Resource Table Fields</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730384"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730386"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730388"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730390"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713277"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713279"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713281"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713283"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713285"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713287"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713289"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713291"></A>&#8220;BGRT&#8221; Signature for the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713293"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713295"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713297"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713299"></A>Length, in bytes, of the entire table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713301"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713303"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713305"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713307"></A>1  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713309"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713311"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713313"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713315"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713317"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713319"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713321"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713323"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713325"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713327"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713329"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713331"></A>The table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713333"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713335"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713337"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713339"></A>OEM revision for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713341"></A>   Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713343"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713345"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713347"></A>Vendor ID of utility that created the table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713349"></A>   Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713351"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713353"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713355"></A>Revision of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713357"></A> Version</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713359"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713361"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713363"></A>2-bytes (16 bit) version ID. This value must be 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713365"></A> Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713367"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713369"></A>38</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713371"></A>1-byte status field indicating current status of the image.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1745983"></A>Bits [7:3] = Reserved (must be zero)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1787615"></A>Bits [2:1] = <EM CLASS="Italic">
Orientation Offset</EM>
. These bits describe the clockwise degree offset from the image&#8217;s default orientation.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1787616"></A>    [00] = 0, no offset</P>
<P CLASS="TableBody">
<A NAME="pgfId-1787617"></A>    [01] = 90</P>
<P CLASS="TableBody">
<A NAME="pgfId-1787618"></A>    [10] = 180</P>
<P CLASS="TableBody">
<A NAME="pgfId-1713373"></A>    [11] = 270</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713375"></A>Image Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713377"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713379"></A>39</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713381"></A>1-byte enumerated type field indicating format of the image.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1713382"></A>0 = Bitmap</P>
<P CLASS="TableBody">
<A NAME="pgfId-1713383"></A>1 - 255  Reserved (for future use)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713385"></A> Image Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713387"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713389"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713391"></A>8-byte (64 bit) physical address pointing to the firmware&#8217;s in-memory copy of the image bitmap.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713393"></A> Image Offset X</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713395"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713397"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713399"></A>A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.   (X, Y) display offset of the top left corner of the boot image. The top left corner of the display is at offset (0, 0).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713401"></A>Image Offset Y</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713403"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713405"></A>52</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713407"></A>A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.   (X, Y) display offset of the top left corner of the boot image. The top left corner of the display is at offset (0, 0).</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1713157"></A>The BGRT is a dynamic ACPI table that enables boot firmware to provide OPSM with a pointer to the location in memory where the boot graphics image is stored. </P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1713158"></A>Version</H6>
<P CLASS="Body">
<A NAME="pgfId-1713159"></A>The version field identifies which revision of the BGRT table is implemented.  The version field should be set to 1.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1713160"></A>Status</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1713161"></A>Status Description Field</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1713165"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1713167"></A>Field Name</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713169"></A>Bit 0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713171"></A>Displayed</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1745421"></A>The status field contains information about the current status of the table.  The Valid bit is bit 0 of the lowest byte.  It should be set to 1 while the image resource is displayed on the screen, and set to 0 while it is not displayed.</P>
<P CLASS="Body">
<A NAME="pgfId-1713175"></A>All other bits are reserved.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1713177"></A> Image Type</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1713178"></A>Image Type Description Field</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1713181"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1713183"></A>Definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713185"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1713187"></A>Image Type is Bitmap</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1713191"></A>The Image type field contains information about the format of the image being returned.   If the value is 0, the Image Type is Bitmap. The format for a Bitmap is defined atthe reference located in &#8220;Links to ACPI-Related Documents&#8221; (<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading &quot;Types of Bitmaps&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId-1713192"></A>All other values not defined in the table are reserved for future use.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1713193"></A>Image Address</H6>
<P CLASS="Body">
<A NAME="pgfId-1744736"></A>The Image Address contains the location in memory where an in-memory copy of the boot image can be found. The image should be stored in EfiBootServicesData, allowing the system to reclaim the memory when the image is no longer needed.   </P>
<P CLASS="Body">
<A NAME="pgfId-1744737"></A>Implementations must present the image in a 24 bit bitmap with pixel format 0xRRGGBB, or a32-bit bitmap with the pixel format 0xrrRRGGBB, where &#8216;rr&#8217; is reserved.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1713196"></A>Image Offset</H6>
<P CLASS="Body">
<A NAME="pgfId-1713781"></A>The Image Offset contains 2 consecutive 4 byte unsigned longs describing the (X, Y) display offset of the top left corner of the boot image. The top left corner of the display is at offset (0, 0).</P>
<P CLASS="Body">
<A NAME="pgfId-1713785"></A>&nbsp;</P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-8.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1713523"></A>Image Offset</H6>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1713763"></A><A NAME="89858"></A>Firmware Performance Data Table (FPDT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1711594"></A>This section describes the format of the Firmware Performance Data Table (FPDT), which provides sufficient information to describe the platform initialization performance records.  This information represents the boot performance data relating to specific tasks within the firmware boot process.  The FPDT includes only those mileposts that are part of every platform boot process:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1711595"></A>End of reset sequence (Timer value noted at beginning of platform boot firmware initialization - typically at reset vector)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1711596"></A>Handoff to OS Loader</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1711597"></A>This information represents the firmware boot performance data set that would be used to track performance of each UEFI phase, and would be useful for tracking impacts resulting from changes due to hardware/software configuration.  </P>
<P CLASS="Body">
<A NAME="pgfId-1711598"></A>All timer values are express in 1 nanosecond increments.  For example, if a record indicates an event occurred at a timer value of 25678, this means that 25.678 microseconds have elapsed from the last reset of the timer measurement. All timer values will be required to have an accuracy of +/- 10%.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1719885"></A>Firmware Performance Data Table (FPDT) Format<A NAME="marker-1719882"></A><A NAME="marker-1719883"></A><A NAME="marker-1719884"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720010"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720012"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720014"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720016"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719896"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719898"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719900"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719902"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719904"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719906"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719908"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719910"></A>&#8216;FPDT&#8217; Signature for the Firmware Performance Data Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719912"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719914"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719916"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719918"></A>The length of the table, in bytes, of the entire FPDT.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719920"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719922"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719924"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719926"></A>The revision of the structure corresponding to the signature field for this table.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1719927"></A>For the Firmware Performance Data Table conforming to this revision of the specification, the revision is 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719929"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719931"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719933"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719935"></A>The entire table, including the checksum field, must add to zero to be considered valid.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719937"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719939"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719941"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719943"></A>An OEM-supplied string that identifies the OEM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719945"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719947"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719949"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719951"></A>An OEM-supplied string that the OEM uses to identify this particular data table.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719953"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719955"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719957"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719959"></A>An OEM-supplied revision number.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719961"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719963"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719965"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719967"></A>The Vendor ID of the utility that created this table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719969"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719971"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719973"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719975"></A>The revision of the utility that created this table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719977"></A>Performance Records</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719979"></A>--</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719981"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1719983"></A>The set of Performance Records.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1711630"></A>Performance Record Format</H6>
<P CLASS="Body">
<A NAME="pgfId-1711631"></A>A performance record is comprised of a sub-header including a record type and length, and a set of data, which may include a timer.  The format of the record layout is specific to the record type.  In this manner, records are only as large as needed to contain the specific type of data to be conveyed.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1711633"></A>Performance Record Structure <A NAME="marker-1711632"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739580"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739582"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739584"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739586"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711644"></A>Performance Record Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711646"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711648"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711650"></A>This value depicts the format and contents of the performance record.	</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711652"></A>Record Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711654"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711656"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711658"></A>This value depicts the length of the performance record, in bytes.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711660"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711662"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711664"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711666"></A>This value is updated if the format of the record type is extended.  Any changes to a performance record layout must be backwards-compatible in that all previously defined fields must be maintained if still applicable, but newly defined fields allow the length of the performance record to be increased. Previously defined record fields must not be redefined, but are permitted to be deprecated.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711668"></A>Data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711670"></A>--</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711672"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711674"></A>The content of this field is defined by the Performance Record Type definition.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1711679"></A>Performance Record Types</H6>
<P CLASS="Body">
<A NAME="pgfId-1712316"></A>The table below describes the various types of records contained within the FPDT, and their associated Performance Record Type.  Note that unless otherwise specified, multiple performance records are permitted in the FPDT for a given type, because some events can occur multiple times during the boot process.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1711681"></A>Performance Record Types</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1711684"></A>Record Type Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1711688"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1711692"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711696"></A>0x0000</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711700"></A>Firmware Basic Boot Performance Pointer Record</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711704"></A>Record containing a pointer to the Basic Boot Performance Data Record.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711708"></A>0x0001</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711712"></A>S3 Performance Table Pointer Record</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711716"></A>Record containing a pointer to an S3 Performance Table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711720"></A>0x0002 - 0x0FFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711724"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711728"></A>Reserved for ACPI specification usage.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711732"></A>0x1000 - 0x1FFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711736"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711740"></A>Reserved for Platform Vendor usage.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711744"></A>0x2000 - 0x2FFF  </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711748"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711752"></A>Reserved for Hardware Vendor usage. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711756"></A>0x3000 - 0x3FFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711760"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711764"></A>Reserved for platform firmware Vendor usage.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711768"></A>0x4000 - 0xFFFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711770"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1711774"></A>Reserved for future use</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Table-Head-th">
<A NAME="pgfId-1711778"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1711783"></A>Runtime Performance Record Types</H6>
<P CLASS="Body">
<A NAME="pgfId-1711784"></A>The table below describes the various types of runtime records and their associated Runtime Performance Record types. These Records are not contained within the FPDT; they are referenced by their respective pointer records in the FPDT.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1711785"></A>Runtime Performance Record Types</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730400"></A>Record Type Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730402"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730404"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711794"></A>0x0000</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711796"></A>Basic S3 Resume  Performance Record</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711798"></A>Performance record describing minimal firmware performance metrics for S3 resume operations</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711800"></A>0x0001</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711802"></A>Basic S3 Suspend Performance Record</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711804"></A>Performance record describing minimal firmware performance metrics for S3 suspend operations</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720038"></A>0x0002 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720040"></A>Firmware Basic Boot Performance Data Record	</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720042"></A>Performance record showing basic performance metrics for critical phases of the firmware boot process. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711806"></A>0x0003 - 0x0FFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711808"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711810"></A>Reserved for ACPI specification usage.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711812"></A>0x1000 - 0x1FFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711814"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711816"></A>Reserved for Platform Vendor usage.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711818"></A>0x2000 - 0x2FFF  </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711820"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711822"></A>Reserved for Hardware Vendor usage.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711824"></A>0x3000 - 0x3FFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711826"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711828"></A>Reserved for platform firmware Vendor usage.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711830"></A>0x4000 - 0xFFFF </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711832"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711834"></A>Reserved for future use</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1711928"></A>S3 Performance Table Pointer Record</H6>
<P CLASS="Body">
<A NAME="pgfId-1711929"></A>The S3 Performance Table Pointer Record contains a pointer to the S3 Performance Table.  The S3 Performance Table itself exists in a range of memory described as ACPI AddressRangeReserved  in the system memory map. The record pointer is a required entry in the FPDT for any system supporting the S3 state, and the pointer must point to a valid static physical address. Only one of these records will be produced.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1711931"></A>S3 Performance Table Pointer Record <A NAME="marker-1711930"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711934"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711936"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711938"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711940"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711942"></A>Performance Record Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711944"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711946"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711948"></A>1 - S3 Performance Table Record </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711950"></A>Record Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711952"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711954"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711956"></A>16 - This value depicts the length of the performance record, in bytes.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711958"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711960"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711962"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711964"></A>1 - Revision of this Performance Record</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711966"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711968"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711970"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711972"></A>Reserved  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711974"></A>S3PT Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711976"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711978"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711980"></A>64-bit processor-relative physical address of the S3 Performance Table </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1720130"></A>Firmware Basic Boot Performance Pointer Record</H6>
<P CLASS="Body">
<A NAME="pgfId-1720131"></A>The Firmware Basic Boot Performance Pointer Record contains a pointer to the Firmware Basic Boot Performance Data Record. The Firmware Basic Boot Performance Data Record itself exists in a range of memory described as ACPI AddressRangeReserved  in the system memory map. The record pointer is a required entry in the FPDT for any system and the pointer must point to a valid static physical address.  Only one of these records will be produced.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1720133"></A>S4 Performance Table Pointer Record <A NAME="marker-1720132"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720136"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720138"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720140"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720142"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720144"></A>Performance Record Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720146"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720148"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720150"></A>0 - Firmware Basic Boot Performance Pointer Record</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720152"></A>Record Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720154"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720156"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720158"></A>16 - This value depicts the length of the performance record, in bytes.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720160"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720162"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720164"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720166"></A>1 - Revision of this Performance Record</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720168"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720170"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720172"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720174"></A>Reserved  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720176"></A>FBPT Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720178"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720180"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720182"></A>64-bit processor-relative physical address of the Firmware Basic Boot Performance Table</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1720122"></A>S3 Performance Table </H6>
<P CLASS="Body">
<A NAME="pgfId-1711985"></A>The S3 Performance Table resides outside of the FPDT. It includes a header, defined in <A HREF="ACPI_Software_Programming_Model.htm#81445" CLASS="XRef">See Basic S3 Resume Performance Record.</A>, and one or more Performance Records. </P>
<P CLASS="Body">
<A NAME="pgfId-1711986"></A>All event entries must be initialized to zero during the initial boot sequence, and overwritten during the platform runtime firmware S3 resume sequence. The S3 Performance Table must include the Basic S3 Resume Performance Record. Other entries are optional. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1711988"></A>S3 Performance Table Header <A NAME="marker-1711987"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711991"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711993"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711995"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1711997"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1711999"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712001"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712003"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712005"></A>&#8216;S3PT&#8217; is the signature to use.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712007"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712009"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712011"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712013"></A>Length of the S3 Performance Table.  This includes the header and allocated size of the subsequent records.  This size would at minimum include the size of the header and the Basic S3 Resume Performance Record.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1712018"></A><A NAME="81445"></A>Basic S3 Resume Performance Record <A NAME="marker-1712017"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739793"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739795"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739797"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1739799"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712029"></A>Runtime</P>
<P CLASS="TableBody">
<A NAME="pgfId-1712030"></A>Performance Record Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712032"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712034"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712036"></A>0 - The Basic S3 Resume Performance Record Type.  Zero to one of these records will be produced.	</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712038"></A>Record Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712040"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712042"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712044"></A>24 - The value depicts the length of this performance record, in bytes.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712046"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712048"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712050"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712052"></A>1 - Revision of this Performance Record</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712054"></A>Resume Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712056"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712058"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712060"></A>A count of the number of S3 resume cycles since the last full boot sequence.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712062"></A>FullResume</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712064"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712066"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712068"></A>Timer recorded at the end of platform runtime firmware S3 resume, just prior to handoff to the OS waking vector. Only the most recent resume cycle&#8217;s time is retained. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712070"></A>AverageResume</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712072"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712074"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712076"></A>Average timer value of all resume cycles logged since the last full boot sequence, including the most recent resume.  Note that the entire log of timer values does not need to be retained in order to calculate this average.  AverageResumenew = (AverageResumeold * (ResumeCount -1) + FullResume) / ResumeCount</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1712087"></A>Basic S3 Suspend Performance Record <A NAME="marker-1712086"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1712329"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1712331"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1712333"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1712335"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712098"></A>Runtime</P>
<P CLASS="TableBody">
<A NAME="pgfId-1712099"></A>Performance Record Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712101"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712103"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712105"></A>1 - The Basic S3 Suspend Performance Record Type. Zero to one of these records will be produced.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712107"></A>Record Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712109"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712111"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712113"></A>20 - The value depicts the length of this performance record, in bytes.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712115"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712117"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712119"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712121"></A>1 - Revision of this Performance Record</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712123"></A>SuspendStart</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712125"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712127"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712129"></A>Timer value recorded at the OS write to SLP_TYP upon entry to S3. Only the most recent suspend cycle&#8217;s timer value is retained. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712131"></A>SuspendEnd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712133"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712135"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1712137"></A>Timer value recorded at the final firmware write to SLP_TYP (or other mechanism) used to trigger hardware entry to S3. Only the most recent suspend cycle&#8217;s timer value is retained.   </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1720251"></A>Firmware Basic Boot Performance Table </H6>
<P CLASS="Body">
<A NAME="pgfId-1720252"></A>The Firmware Basic Boot Performance Table resides outside of the FPDT. It includes a header, defined in <A HREF="ACPI_Software_Programming_Model.htm#77210" CLASS="XRef">See Firmware Basic Boot Performance Table Header.</A>, and one or more Performance Records. </P>
<P CLASS="Body">
<A NAME="pgfId-1720428"></A>All event entries will be overwritten during the platform runtime firmware S4 resume sequence. The Firmware Basic Boot Performance Table must include the Firmware Basic Boot Performance Table. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1720456"></A><A NAME="77210"></A>Firmware Basic Boot Performance Table Header <A NAME="marker-1720430"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720433"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720435"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720437"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1720439"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720441"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720443"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720445"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720447"></A>&#8216;FBPT&#8217; is the signature to use.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720449"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720451"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720453"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1720455"></A>Length of the Firmware Basic Boot Performance Table.  This includes the header and allocated size of the subsequent records.  This size would at minimum include the size of the header and the Firmware Basic Boot Performance Record.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1720457"></A>Firmware Basic Boot Performance Data Record</H6>
<P CLASS="Body">
<A NAME="pgfId-1720285"></A>A firmware basic boot performance data record which contains timer information associated with final OS loader activity as well as the data associated with starting and ending boot time information.  Only one of these records will be produced.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1731230"></A><A NAME="74443"></A>Firmware Basic Boot Performance Data Record Structure <A NAME="marker-1731146"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1731149"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1731151"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1731153"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1731155"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731157"></A>Performance Record Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731159"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731161"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731163"></A>2 - Firmware Basic Boot Performance Data Record </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731165"></A>Record Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731167"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731169"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731171"></A>48 - This value depicts the length of the performance record, in bytes.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731173"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731175"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731177"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731179"></A>2 - Revision of this Performance Record</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731181"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731183"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731185"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731187"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731189"></A>Reset End</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731191"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731193"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731195"></A>Timer value logged at the beginning of firmware image execution.  This may not always be zero or near zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731197"></A>OS Loader LoadImage Start</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731199"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731201"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731203"></A>Timer value logged just prior to loading the OS boot loader into memory.<BR>
For non-UEFI compatible boots, this field must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731205"></A>OS Loader StartImage Start</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731207"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731209"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731211"></A>Timer value logged just prior to launching the currently loaded OS boot loader image.<BR>
For non-UEFI compatible boots, the timer value logged will be just prior to the INT 19h handler invocation.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731213"></A>ExitBootServices Entry</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731215"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731217"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731219"></A>Timer value logged at the point when the OS loader calls the ExitBootServices function for UEFI compatible firmware.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1731220"></A>For non-UEFI compatible boots, this field must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731222"></A>ExitBootServices Exit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731224"></A>8 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731226"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1731228"></A>Timer value logged at the point just prior to the OS loader gaining control back from the ExitBootServices function for UEFI compatible firmware.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1731229"></A>For non-UEFI compatible boots, this field must be zero.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1741513"></A><A NAME="44426"></A>Generic Timer Description Table (GTDT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1759186"></A>This section describes t<A NAME="marker-1759184"></A><A NAME="marker-1759185"></A>he format of the Generic Timer Description Table (GTDT), which provides OSPM with information about a system&#8217;s Generic Timers configuration. The Generic Timer (GT) is a standard timer interface implemented on ARM processor-based systems. The GT hardware specification can be found at <EM CLASS="Italic">
Links to ACPI-Related Documents </EM>
(<EM CLASS="Hyperlink">
http://uefi.org/acpi</EM>
) under the heading <EM CLASS="Italic">
ARM Architecture</EM>
. The GTDT provides OSPM with information about a system's GT interrupt configurations, for both per-processor timers, and platform (memory-mapped) timers. </P>
<P CLASS="Body">
<A NAME="pgfId-1741543"></A>The GT specification defines the following per-processor timers: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1741558"></A>Secure EL1 timer, </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1741565"></A>Non-Secure EL1 timer, </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1741572"></A>EL2 timer, </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1741579"></A>Virtual EL1 timer,  </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1836631"></A>Virtual EL2 timer,</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1836991"></A>and defines the following memory-mapped Platform timers:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1752647"></A>GT Block,</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1752648"></A>Server Base System Architecture (SBSA) Generic Watchdog. </LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1742046"></A>GTDT Table Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741871"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741873"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741875"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1741877"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741879"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741881"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741883"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741885"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741887"></A>      Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741889"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741891"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741893"></A>&#8216;GTDT&#8217;. Signature for the Generic Timer Description Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741895"></A>      Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741897"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741899"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741901"></A>Length, in bytes, of the entire Generic Timer Description Table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741903"></A>      Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741905"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741907"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741909"></A>3</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741911"></A>      Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741913"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741915"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741917"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741919"></A>      OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741921"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741923"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741925"></A>OEM ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741927"></A>      OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741929"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741931"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741933"></A>The manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741935"></A>      OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741937"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741939"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741941"></A>OEM revision for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741943"></A>     Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741945"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741947"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741949"></A>Vendor ID of utility that created the table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741951"></A>     Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741953"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741955"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741957"></A>Revision of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741967"></A>CntControlBase Physical Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741969"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741971"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741973"></A>The 64-bit physical address at which the Counter Control block is located.This value is optional if the system implements EL3 (Security Extensions). If not provided, this field must be 0xFFFFFFFFFFFFFFFF.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741975"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741977"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741979"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741981"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741983"></A>Secure EL1 Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741985"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741987"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741989"></A>GSIV for the secure EL1 timer. This value is optional, as an operating system executing in the non-secure world (EL2 or EL1), will ignore the content of these fields. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741991"></A>Secure EL1 Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741993"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741995"></A>52</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741997"></A>Flags for the secure EL1  timer (defined below). This value is optional, as an operating system executing in the non-secure world (EL2 or EL1) will ignore the content of this field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1741999"></A>Non-Secure EL1 Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742001"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742003"></A>56</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742005"></A>GSIV for the non-secure  EL1 timer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742007"></A>Non-Secure EL1 Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742009"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742011"></A>60</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742013"></A>Flags for the non-secure EL1 timer (defined below).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742015"></A>Virtual EL1 Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742017"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742019"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742021"></A>GSIV for the virtual EL1 timer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742023"></A>Virtual EL1 Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742025"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742027"></A>68</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742029"></A>Flags for the virtual EL1 timer (defined below)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742031"></A>EL2 Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742033"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742035"></A>72</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742037"></A>GSIV for the EL2 timer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742039"></A>EL2 Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742041"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742043"></A>76</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1742045"></A>Flags for the EL2 timer(defined below).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752824"></A>CntReadBase Physical Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752826"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752828"></A>80</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1778392"></A>The 64-bit physical address at which the Counter Read block is located. This value is optional if the system implements EL3</P>
<P CLASS="TableBody">
<A NAME="pgfId-1778393"></A>(Security Extensions). If not provided, this field must be</P>
<P CLASS="TableBody">
<A NAME="pgfId-1752830"></A>0xFFFFFFFFFFFFFFFF.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752816"></A>Platform Timer Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752818"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752820"></A>88</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752822"></A>Number of entries in the Platform Timer Structure[] array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752808"></A>Platform Timer Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752810"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752812"></A>92</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752814"></A>Offset to the Platform Timer Structure[] array from the start of this table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836743"></A>Virtual EL2 Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836745"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836747"></A>96</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836749"></A>GSIV for the virtual EL2 timer. This field is mandatory for systems implementing ARMv8.1 VHE. For systems not implementing ARMv8.1 VHE, this field is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836751"></A>Virtual EL2 Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836753"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836755"></A>100</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1836757"></A>Flags for the virtual EL2 timer (defined below). This field is mandatory for systems implementing ARMv8.1 VHE. For systems not implementing ARMv8.1 VHE, this field is 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752800"></A>Platform Timer Structure[]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752802"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752804"></A>Platform Timer Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1752806"></A>Array of Platform Timer Type structures describing memory-mapped Timers available on this platform. These structures are described in the below sections.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1753007"></A>Flag Definitions: Secure EL1 Timer, Non-Secure EL1 Timer, EL2 Timer, Virtual EL1 Timer and Virtual EL2 Timer</H6>
<P CLASS="Body">
<A NAME="pgfId-1801859"></A>Secure EL1 Timer Flags, Non-Secure EL1 Timer Flags, EL2 Timer Flags, Virtual EL1 Timer Flags, and Virtual EL2 Timer Flags all have the same definition as follows.</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1753010"></A>Bit Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1753012"></A>Bit Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1753014"></A>Number of bits</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1753016"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753018"></A>Timer interrupt Mode </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753020"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753022"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753024"></A>This bit indicates the mode of the timer interrupt</P>
<P CLASS="TableBody">
<A NAME="pgfId-1753025"></A><BR>
1: Interrupt is Edge triggered</P>
<P CLASS="TableBody">
<A NAME="pgfId-1753026"></A>0: Interrupt is Level triggered</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753028"></A>Timer Interrupt polarity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753030"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753032"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753034"></A>This bit indicates the polarity of the timer interrupt</P>
<P CLASS="TableBody">
<A NAME="pgfId-1753035"></A><BR>
1: Interrupt is Active low</P>
<P CLASS="TableBody">
<A NAME="pgfId-1753036"></A>0: Interrupt is Active high</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753119"></A>Always-on Capability</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753121"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753123"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753143"></A>This bit indicates the always-on capability of the timer implementation.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1753144"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1760543"></A>1: This timer is guaranteed to assert its interrupt and wake a processor, regardless of the processor&#8217;s power state. All of the methods by which an ARM Generic Timer may generate an interrupt must be supported, and must be capable of waking the processor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1759324"></A>0: This timer may lose context or may not be guaranteed to assert interrupts when its associated processor enters a low-power state</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753038"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753040"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753042"></A>29</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1753044"></A>Reserved, must be zero. </P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1756295"></A>The GTDT Platform Timer Structure [] field is an array of Platform Timer Type structures, each of which describes the configuration of an available platform timer. These timers are in addition to the per-processor timers described above them in the GTDT.</P>
<P CLASS="Body">
<A NAME="pgfId-1836999"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1756325"></A>Platform Timer Type Structures</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756389"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756391"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756393"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756395"></A>GT Block</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756397"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756399"></A>SBSA Generic Watchdog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756401"></A>0x02-0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756403"></A>Reserved for future use</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1756407"></A><EM CLASS="SC-10-114693">
The first byte of each structure declares the type of that structure and the second and third bytes declare the length of that structure.</EM>
</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1756409"></A>GT Block Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1757539"></A><EM CLASS="SC-10-114693">
The GT Block is a standard timer block that is mapped into the system address space. Each GT Block implements up to 8 GTs (GT0 - GT7).</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1757540"></A><EM CLASS="SC-10-114693">
The format of the GT Block structure is shown in <A HREF="ACPI_Software_Programming_Model.htm#51567" CLASS="XRef">See GT Block Structure Format.</A>.</EM>
</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1757656"></A><A NAME="51567"></A>GT Block Structure Format</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1777083"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1777085"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1777089"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHeading">
<A NAME="pgfId-1777093"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760373"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760375"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760379"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760383"></A>0x0    GT Block</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760387"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760389"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760393"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760397"></A>20+n*40, where n is the number of timers implemented in the GT Block</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760401"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760405"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760409"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760413"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760415"></A>GT Block </P>
<P CLASS="TableBody">
<A NAME="pgfId-1760416"></A>Physical address (CntCtlBase)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760420"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760424"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760428"></A>The 64-bit physical address at which the GT CntCTLBase Block is located</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760430"></A>GT Block Timer Count </P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760432"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760436"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760440"></A>Number of Timers implemented in this GT Block ('n'). . Must be less than or equal to 8.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760444"></A>GT Block Timer Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760448"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760452"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760456"></A>Offset to the Platform Timer Structure array from the start of this structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1760458"></A>GT Block Timer Structure[]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760460"></A>n*40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760464"></A> GT Block Timer Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1760471"></A>Array of GT Block Timer Structures. See <A HREF="ACPI_Software_Programming_Model.htm#72283" CLASS="XRef">See GT Block Timer Structure Format.</A>.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1756547"></A><A NAME="72283"></A>GT Block Timer Structure Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757491"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757494"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757497"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757499"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757287"></A>GT Frame Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757289"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757291"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757293"></A>The frame number (0-7) for this timer (&#8216;x&#8217;)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757295"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757297"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757299"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757301"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757303"></A>GTx Physical Address (CntBaseX)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757305"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757307"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757309"></A>Physical Address at which the CntBase block for GTx is located</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757311"></A>GTx Physical Address (CntEL0BaseX)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757313"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757315"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757317"></A>Physical Address at which the CntEL0Base block for GTx is located. If this block is not implemented for GTx, must be 0xFFFFFFFFFFFFFFFF.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757319"></A>GTx Physical Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757321"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757323"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757325"></A>GSIV for the GTx physical timer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757327"></A>GTx Physical Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757329"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757331"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757333"></A>Flags for the GTx physical timer. See <A HREF="ACPI_Software_Programming_Model.htm#36950" CLASS="XRef">See Flag Definitions: GT Block Physical Timers and Virtual Timers.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757335"></A>GTx Virtual Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757337"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757339"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757341"></A>GSIV for the GTx virtual timer If the Virtual Timer is not implemented for GTx, this field must be 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757343"></A>GTx Virtual Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757345"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757347"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757349"></A>Flags for the GTx virtual timer, if implemented. See <A HREF="ACPI_Software_Programming_Model.htm#36950" CLASS="XRef">See Flag Definitions: GT Block Physical Timers and Virtual Timers.</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757351"></A>GTx Common Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757353"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757355"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757357"></A>See <A HREF="ACPI_Software_Programming_Model.htm#77479" CLASS="XRef">See Flag Definitions: Common Flags.</A>.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1756649"></A><A NAME="36950"></A>Flag Definitions: GT Block Physical Timers and Virtual Timers</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756652"></A>Bit Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756654"></A>Bit </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1756655"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756657"></A>Number </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1756658"></A>of bits</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756660"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756662"></A>Timer interrupt </P>
<P CLASS="TableBody">
<A NAME="pgfId-1756663"></A>Mode </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756665"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756667"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1815115"></A>This bit indicates the mode of the timer interrupt.</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1815116"></A>1: Interrupt is Edge triggered.</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1756672"></A>0: Interrupt is Level triggered.</LI>
</UL>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756674"></A>Timer Interrupt polarity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756676"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756678"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756680"></A>This bit indicates the polarity of the timer interrupt</P>
<P CLASS="TableBody">
<A NAME="pgfId-1756682"></A>1: Interrupt is Active low</P>
<P CLASS="TableBody">
<A NAME="pgfId-1756683"></A>0: Interrupt is Active high</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756685"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756687"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756689"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1756691"></A>Reserved, must be zero. </P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1757424"></A><A NAME="77479"></A>Flag Definitions: Common Flags</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757384"></A>Bit Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757386"></A>Bit </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1757387"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757389"></A>Number </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1757390"></A>of bits</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1757392"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757394"></A>Secure Timer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1757396"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1757398"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757400"></A>This bit indicates whether the timer is secure or non-secure</P>
<P CLASS="TableBody">
<A NAME="pgfId-1757402"></A>1: Timer is Secure</P>
<P CLASS="TableBody">
<A NAME="pgfId-1757403"></A>0: Timer is Non-secure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757405"></A>Always-on Capability</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1757407"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1757409"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757411"></A>This bit indicates the always-on capability of the Physical and Virtual Timers implementation.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1757412"></A>1: This timer is guaranteed to assert its interrupt and wake a processor, regardless of the processor&#8217;s power state. All of the methods by which an ARM Generic Timer may generate an interrupt must be supported, and must be capable of waking the processor. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1759817"></A>0: This timer may lose context or may not be guaranteed to assert interrupts when its associated processor enters a low-power state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757417"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1757419"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1757421"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1757423"></A>Reserved, must be zero. </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1757425"></A>SBSA Generic Watchdog Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1757426"></A><EM CLASS="SC-10-114693">
The SBSA Generic Watchdog is a Platform GT with built-in support for use as the Watchdog timer on Server Base System Architecture (SBSA)-compliant platforms. </EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1759442"></A><EM CLASS="SC-10-114693">
The format of the SBSA Generic Watchdog structure is shown in <A HREF="ACPI_Software_Programming_Model.htm#29947" CLASS="XRef">See SBSA Generic Watchdog Structure Format.</A>.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-1759443"></A>The link for SBSA is <EM CLASS="Hyperlink">
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0029/index.html.</EM>
</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1759513"></A><A NAME="29947"></A>SBSA Generic Watchdog Structure Format</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759447"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759449"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759451"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1759453"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759455"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759457"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759459"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759461"></A>0x1     Watchdog GT</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759463"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759465"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759467"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759469"></A>28</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759471"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759473"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759475"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759477"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759479"></A>RefreshFrame Physical Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759481"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759483"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759485"></A>Physical Address at which the  RefreshFrame block is located</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759487"></A>WatchdogControlFrame Physical Address</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759489"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759491"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759493"></A>Physical Address at which the  Watchdog Control Frame block is located</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759495"></A>Watchdog Timer GSIV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759497"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759499"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759501"></A>GSIV for the SBSA Generic Watchdog timer </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759503"></A>Watchdog Timer Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1759505"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1759507"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1759509"></A>Flags for the SBSA Generic Watchdog timer. See <A HREF="ACPI_Software_Programming_Model.htm#77377" CLASS="XRef">See Flag Definitions: SBSA Generic Watchdog Timer.</A></P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1756822"></A><A NAME="77377"></A>Flag Definitions: SBSA Generic Watchdog Timer</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756825"></A>Bit Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756827"></A>Bit </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1756828"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756830"></A>Number </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1756831"></A>of bits</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1756833"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756835"></A>Timer interrupt </P>
<P CLASS="Normal">
<A NAME="pgfId-1756836"></A>Mode </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756838"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756840"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756842"></A>This bit indicates the mode of the timer interrupt</P>
<P CLASS="Normal">
<A NAME="pgfId-1756843"></A></P>
<P CLASS="Normal">
<A NAME="pgfId-1756844"></A>1: Interrupt is Edge triggered</P>
<P CLASS="Normal">
<A NAME="pgfId-1756845"></A>0: Interrupt is Level triggered</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756847"></A>Timer Interrupt polarity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756849"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756851"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756853"></A>This bit indicates the polarity of the timer interrupt</P>
<P CLASS="Normal">
<A NAME="pgfId-1756854"></A></P>
<P CLASS="Normal">
<A NAME="pgfId-1756855"></A>1: Interrupt is Active low</P>
<P CLASS="Normal">
<A NAME="pgfId-1756856"></A>0: Interrupt is Active high</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756858"></A>Secure Timer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756860"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756862"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756864"></A>This bit indicates whether the timer is secure or non-secure</P>
<P CLASS="Normal">
<A NAME="pgfId-1756865"></A></P>
<P CLASS="Normal">
<A NAME="pgfId-1756866"></A>1: Timer is Secure</P>
<P CLASS="Normal">
<A NAME="pgfId-1756867"></A>0: Timer is Non-secure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756869"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756871"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756873"></A>29</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Normal">
<A NAME="pgfId-1756875"></A>Reserved, must be zero. </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1762632"></A><A NAME="24805"></A>NVDIMM Firmware Interface Table (NFIT)</H6>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1785478"></A><A NAME="11301"></A>NFIT Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1787406"></A>This optional table provides information that allows OSPM to enumerate NVDIMMs present in the platform and associate system physical address ranges created by the NVDIMMs. NVDIMMs are represented by zero or more NVDIMM devices under a single NVDIMM root device in ACPI namespace.</P>
<P CLASS="Body">
<A NAME="pgfId-1781028"></A>OSPM evaluates NFIT only during system initialization. Any changes to the NVDIMM state at runtime or information regarding hot added NVDIMMs are communicated using the _FIT method (See <A HREF="Device_Configuration.htm#31911" CLASS="XRef">See _FIT (Firmware Interface Table).</A>) of the NVDIMM root device. </P>
<P CLASS="Body">
<A NAME="pgfId-1762641"></A>The NFIT consists of the following structures:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1762642"></A>System Physical Address (SPA) Range Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#46965" CLASS="XRef">See System Physical Address (SPA) Range Structure.</A>) - Describes the SPA ranges occupied by NVDIMMs and the types of the SPA ranges.</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1762643"></A>NVDIMM Region Mapping Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#11197" CLASS="XRef">See NVDIMM Region Mapping Structure.</A>)  - Describes mappings of NVDIMM regions to SPA ranges and NVDIMM region properties.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1762645"></A>Interleave Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#12749" CLASS="XRef">See Interleave Structure .</A>)  - Describes the various interleave options used by NVDIMM regions.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1762647"></A>SMBIOS Management Information Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#97912" CLASS="XRef">See SMBIOS Management Information Structure .</A>) - Describes SMBIOS Table entries for hot added NVDIMMs.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1762649"></A>NVDIMM Control Region Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#42965" CLASS="XRef">See NVDIMM Control Region Structure.</A>) - Describes NVDIMM function interfaces, and if applicable, their Block Control Windows.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1762651"></A>NVDIMM Block Data Window Region Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#16432" CLASS="XRef">See NVDIMM Block Data Window Region Structure .</A>) - Describes Block Data Windows for a NVDIMM function interfaces that have Block Control Windows.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1762653"></A>Flush Hint Address Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#13012" CLASS="XRef">See Flush Hint Address Structure.</A>) - Describes special system physical addresses that when written help achieve durability for writes to NVDIMM regions.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1826612"></A>Platform Capabilities Structure (see <A HREF="ACPI_Software_Programming_Model.htm#58079" CLASS="XRef">See Platform Capabilities Structure.</A>) - Describes the Platform Capabilities to inform OSPM of platform-wide NVDIMM capabilities.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1762654"></A><A HREF="ACPI_Software_Programming_Model.htm#53065" CLASS="XRef">See NVDIMM Firmware Interface Table (NFIT) Overview.</A> illustrates the above structures and how they are associated with each other.</P>
<P CLASS="Body-Text">
<A NAME="pgfId-1762634"></A></P>
<P CLASS="Normal">
<A NAME="pgfId-1762638"></A></P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-9.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1762639"></A><A NAME="53065"></A>NVDIMM Firmware Interface Table (NFIT) Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1764238"></A>The following table defines the NFIT.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1762656"></A><A NAME="41258"></A>NVDIMM Firmware Interface Table (NFIT)</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1781324"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1781326"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1781328"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1781330"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableBody">
<A NAME="pgfId-1781332"></A>Header</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781340"></A>     Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781342"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781344"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781346"></A> &#8216;NFIT&#8217; is Signature for this table </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781348"></A>     Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781350"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781352"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781354"></A>Length in bytes for entire table.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781356"></A>     Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781358"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781360"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781362"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781364"></A>     Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781366"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781368"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781370"></A>Entire table must sum to zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781372"></A>     OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781374"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781376"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781378"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781380"></A>     OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781382"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781384"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781386"></A>The table ID is the manufacturer model ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781388"></A>     OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781390"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781392"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781394"></A>OEM revision of table for supplied OEM Table ID </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781396"></A>     Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781398"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781400"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781402"></A>Vendor ID of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781404"></A>     Creator Revision </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781406"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781408"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781410"></A>Revision of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781412"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781414"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781416"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781418"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781420"></A>NFIT Structure[n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781422"></A>_</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781424"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781426"></A>A list of NFIT structures for this implementation.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1762790"></A>Each NFIT Structure must start with a 2 byte Type field followed by a 2 byte length field. This allows OSPM to ignore unrecognized types. Supported NFIT Structure types are listed in <A HREF="ACPI_Software_Programming_Model.htm#_Ref396499543" CLASS="XRef">See NFIT Structure Types.</A>. </P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1762795"></A><A NAME="_Ref396499543"></A><A NAME="_Toc400770430"></A>NFIT Structure Types</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1762798"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1762800"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762802"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762804"></A>System Physical Address (SPA) Range Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762806"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762808"></A>NVDIMM Region Mapping Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762810"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762812"></A>Interleave Structure	</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762814"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762816"></A>SMBIOS Management Information Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762818"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762820"></A>NVDIMM Control Region Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762822"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762824"></A>NVDIMM Block Data Window Region Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762826"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762828"></A>Flush Hint Address Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1826565"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1826567"></A>Platform Capabilities Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762830"></A>8-0xFFFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762832"></A>Reserved </P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1762837"></A><A NAME="46965"></A>System Physical Address (SPA) Range Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1762838"></A>This structure describes the system physical address ranges occupied by NVDIMMs, and their corresponding Region Types.  </P>
<P CLASS="Body">
<A NAME="pgfId-1762839"></A>System physical address ranges described as Virtual CD or Virtual Disk shall be described as AddressRangeReserved in E820, and EFI Reserved Memory Type in the UEFI GetMemoryMap. </P>
<P CLASS="Body">
<A NAME="pgfId-1762843"></A>Platform is allowed to implement this structure just to describe system physical address ranges that describe Virtual CD and Virtual Disk. For Virtual CD Region and Virtual Disk Region (both volatile and persistent), the following fields - Proximity Domain, SPA Range Structure Index, Flags, and Address Range Memory Mapping Attribute, are not relevant and shall be set to 0.</P>
<P CLASS="Body">
<A NAME="pgfId-1762844"></A>The default mapping of the NVDIMM Control Region shall be UC memory attributes with AddressRangeReserved type in E820 and EfiMemoryMappedIO type in UEFI GetMemoryMap. The default mapping of the NVDIMM Block Data Window Region shall be WB memory attributes with AddressRangeReserved type in E820 and EfiMemoryMappedIO type in UEFI GetMemoryMap.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1762848"></A><A NAME="61049"></A>SPA Range Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1767915"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1767917"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1767919"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1767921"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762859"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762861"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762863"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762865"></A>0 - SPA Range Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762867"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762869"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762871"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762873"></A>Length in bytes for entire structure.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762883"></A>SPA Range Structure Index </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762885"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762887"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762889"></A>Used by NVDIMM Region Mapping Structure to uniquely refer to this structure. Value of 0 is Reserved and shall not be used as an index.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762891"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762893"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762895"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762897"></A>Bit [0] set to 1 indicates that Control region is strictly for management during hot add/online operation.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1762898"></A>Bit [1] set to 1 to indicate that data in Proximity Domain field is valid.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1762899"></A>Bits [15:2] : Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762901"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762903"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762905"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762907"></A>Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762909"></A>Proximity Domain</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762911"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762913"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762915"></A>Integer that represents the proximity domain to which the memory belongs. This number must match with corresponding entry in the SRAT table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762917"></A>Address Range  Type GUID </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762919"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762921"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762923"></A>GUID that defines the type of the Address Range Type. The GUID can be any of the values defined in this section, or a vendor defined GUID. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762925"></A>System Physical Address Range Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762927"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762929"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762931"></A>Start Address of the System Physical Address Range </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762933"></A>System Physical Address Range Length  </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762935"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762937"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762939"></A>Range Length of the region in bytes </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762941"></A>Address Range Memory Mapping Attribute</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762943"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762945"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1762947"></A>Memory mapping attributes for this address range: </P>
<P CLASS="TableBody">
<A NAME="pgfId-1837333"></A>EFI_MEMORY_UC =            0x00000001</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837334"></A>EFI_MEMORY_WC =            0x00000002</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837335"></A>EFI_MEMORY_WT =            0x00000004</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837336"></A>EFI_MEMORY_WB =            0x00000008</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837337"></A>EFI_MEMORY_UCE =           0x00000010</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837338"></A>EFI_MEMORY_WP =            0x00001000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837339"></A>EFI_MEMORY_RP =            0x00002000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837340"></A>EFI_MEMORY_XP =            0x00004000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837341"></A>EFI_MEMORY_NV =            0x00008000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837342"></A>EFI_MEMORY_MORE_RELIABLE = 0x00010000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837343"></A>EFI_MEMORY_RO =            0x00020000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837344"></A>EFI_MEMORY_SP =            0x00040000</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837345"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837346"></A>These types can be OR&#8217;d together as needed. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1837347"></A>Refer to UEFI Specification for memory attributes description</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1834996"></A>The following GUIDs are used to describe the NVDIMM Region Types. Additional GUIDs can be generated to describe additional Address Range Types.</P>
<P CLASS="Body">
<A NAME="pgfId-1762969"></A>Persistent Memory (PM) Region:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762970"></A>{ 0x66F0D379, 0xB4F3, 0x4074, 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }</P>
<P CLASS="Body">
<A NAME="pgfId-1762972"></A>NVDIMM Control Region:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762973"></A>{ 0x92F701F6, 0x13B4, 0x405D, 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }</P>
<P CLASS="Body">
<A NAME="pgfId-1762975"></A>NVDIMM Block Data Window Region:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762976"></A>{ 0x91AF0530, 0x5D86, 0x470E, 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }</P>
<P CLASS="Body">
<A NAME="pgfId-1762978"></A>RAM Disk supporting a Virtual Disk Region - Volatile (a volatile memory region that contains a raw disk format):</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762979"></A>{ 0x77AB535A,0x45FC,0x624B,0x55,0x60,0xF7,0xB2,0x81,0xD1,0xF9,0x6E }</P>
<P CLASS="Body">
<A NAME="pgfId-1762981"></A>RAM Disk supporting a Virtual CD Region - Volatile (a volatile memory region that contains an ISO image):</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762982"></A>{ 0x3D5ABD30,0x4175,0x87CE,0x6D,0x64,0xD2,0xAD,0xE5,0x23,0xC4,0xBB }</P>
<P CLASS="Body">
<A NAME="pgfId-1762984"></A>RAM Disk supporting a Virtual Disk Region - Persistent (a persistent memory region that contains a raw disk format):</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762985"></A>{ 0x5CEA02C9,0x4D07,0x69D3,0x26,0x9F,0x44,0x96,0xFB,0xE0,0x96,0xF9 }</P>
<P CLASS="Body">
<A NAME="pgfId-1762987"></A>RAM Disk supporting a Virtual CD Region - Persistent (a persistent memory region that contains an ISO image):</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1762988"></A>{ 0x08018188,0x42CD,0xBB48,0x10,0x0F,0x53,0x87,0xD5,0x3D,0xED,0x3D }</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1762990"></A>The Address Range Type GUID values used in the ACPI NFIT must match the corresponding values in the Disk Type GUID of the RAM Disk device path that describe the same RAM Disk Type. Refer to the UEFI specification for details.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1776204"></A><A NAME="11197"></A>NVDIMM Region Mapping Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1785552"></A>The NVDIMM Region Mapping structure describes an NVDIMM region and its mapping, if any, to a SPA range. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1785577"></A><A NAME="35502"></A>NVDIMM Region Mapping Structure </H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1768702"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1768704"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1768706"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1768708"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763004"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763006"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763008"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763010"></A>1  - NVDIMM Region Mapping Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763012"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763014"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763016"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763018"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763020"></A>NFIT Device Handle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763022"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763024"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763032"></A>The _ADR of the NVDIMM device (see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#79373" CLASS="XRef">See NVDIMM Device.</A>) containing the NVDIMM region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763034"></A>NVDIMM Physical ID </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763036"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763038"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763040"></A>Handle (i.e., instance number) for the SMBIOS*<EM CLASS="Superscript">
 </EM>
Memory Device (Type 17) structure describing the NVDIMM containing the NVDIMM region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763044"></A>NVDIMM Region ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763046"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763048"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781482"></A>Unique identifier for the NVDIMM region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781483"></A>This identifier shall be unique across all the NVDIMM regions in the NVDIMM.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781495"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763050"></A>There could be multiple regions within the device corresponding to different address types. Also, for a given address type, there could be multiple regions due to interleave discontinuity. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763052"></A>SPA Range Structure   Index </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763054"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763056"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781499"></A>The SPA range, if any, associated with the NVDIMM region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781501"></A>0x0000: The NVDIMM region does not map to a SPA range.  The following fields are not valid and should be ignored:</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1781502"></A>NVDIMM Region Size;</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1781503"></A>Region Offset;</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1781504"></A>NVDIMM Physical Address Region Base;</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1781505"></A>Interleave Structure Index; and</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1781506"></A>Interleave Ways.</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1781507"></A>Fields other than those (e.g., NFIT Device Handle, NVDIMM Physical ID, NVDIMM Region ID, and NVDIMM State Flags) are valid.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781509"></A>0x0001 to 0xFFFF: The index of the SPA Range Structure (see <A HREF="ACPI_Software_Programming_Model.htm#46965" CLASS="XRef">See System Physical Address (SPA) Range Structure.</A>) for the NVDIMM region.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763060"></A>NVDIMM Control Region Structure Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763062"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763064"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763066"></A>The index of the NVDIMM Control Region Structure (see <A HREF="ACPI_Software_Programming_Model.htm#42965" CLASS="XRef">See NVDIMM Control Region Structure.</A>) for the NVDIMM region.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763068"></A>NVDIMM Region Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763070"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763072"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1781567"></A>In bytes.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781568"></A>The size of the NVDIMM region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763074"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1763075"></A>If SPA Range Structure Index and Interleave Ways are both non-zero, this field shall match System Physical Address Range Length divided by Interleave Ways.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763076"></A>NOTE: the size in SPA Range occupied by the NVDIMM for this region will not be the same as the NVDIMM Region Size when Interleave Ways is greater than 1.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763078"></A>Region Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763080"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763082"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763084"></A>In bytes.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781594"></A>The Starting Offset for the NVDIMM region in the Interleave Set. This offset is with respect to System Physical Address Range Base in the SPA Range Structure.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1781595"></A>NOTE: The starting SPA of the NVDIMM region in the NVDIMM is provided by System Physical Address Range Base + Region Offset</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763088"></A>NVDIMM Physical Address Region Base</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763090"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763092"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763094"></A>In bytes. The base physical address within the NVDIMM of the NVDIMM region.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763096"></A>Interleave Structure Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763098"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763100"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763102"></A>The Interleave Structure (see <A HREF="ACPI_Software_Programming_Model.htm#12749" CLASS="XRef">See Interleave Structure .</A>), if any, for the NVDIMM region, as  defined in <A HREF="ACPI_Software_Programming_Model.htm#49849" CLASS="XRef">See Interleave Structure Index and Interleave Ways definition.</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763129"></A>Interleave Ways</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763131"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763133"></A>42</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763135"></A>Number of NVDIMMs in the interleave set, including the NVDIMM containing the NVDIMM region, as defined in <A HREF="ACPI_Software_Programming_Model.htm#49849" CLASS="XRef">See Interleave Structure Index and Interleave Ways definition.</A>. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763137"></A>NVDIMM State Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763139"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763141"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763143"></A>Bit [0] set to 1 indicates that the previous SAVE operation to the NVDIMM containing the NVDIMM region failed. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1781744"></A>Bit [0] set to 0 indicates that the previous SAVE succeeded, or there was no previous SAVE. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1763144"></A>Bit [1] set to 1 indicates that the last RESTORE operation from the NVDIMM containing the NVDIMM region failed. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1780693"></A>Bit [1] set to 0 indicates that the last RESTORE succeeded or there was no last RESTORE.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763145"></A>Bit [2] set to 1 indicates that the platform flush of data to the NVDIMM containing the NVDIMM region before the previous SAVE failed. As a result, the restored data content may be inconsistent even if Bit [0] and Bit [1] do not indicate failure. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1780690"></A>Bit [2] set to 0 indicates that the platform flush succeeded, or there was no platform flush.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763146"></A>Bit [3] set to 1 indicates that the NVDIMM containing the NVDIMM region is not able to accept persistent writes. For an energy-source backed NVDIMM device, Bit [3] is set if it is not armed or the previous ERASE operation did not complete. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1780716"></A>Bit [3] set to 0 indicates that the NVDIMM containing the NVDIMM region is armed. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1763147"></A>Bit [4] set to 1 indicates that the NVDIMM containing the NVDIMM region observed SMART and health events prior to OSPM handoff.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763148"></A>Bit [5] set to 1 indicates that platform firmware is enabled to notify OSPM of SMART and health events related to the NVDIMM containing the NVDIMM region using Notify codes as specified in <A HREF="ACPI_Software_Programming_Model.htm#28325" CLASS="XRef">See NVDIMM Device Notification Values.</A>.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1780734"></A>Bit [6] set to 1 indicates that the platform firmware did not map the NVDIMM containing the NVDIMM region into an SPA range. This could be due to various issues such as a device initialization error, device error, insufficient hardware resources to map the device, or a disabled device. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1780735"></A>Implementation Note: In case of device error, Bit [4] might be set along with Bit [6].</P>
<P CLASS="TableBody">
<A NAME="pgfId-1780736"></A>Bit [7] to Bit [15] are reserved.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1780737"></A>Implementation Note: Platform firmware might report several set bits. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763150"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763152"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763154"></A>46</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763156"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableBody">
<A NAME="pgfId-1781924"></A><EM CLASS="Superscript">
* </EM>
See <EM CLASS="Italic">
DSP0134 System Management BIOS (SMBIOS) Reference Specification</EM>
<A HREF="http://www.dmtf.org/standards/smbios" CLASS="URL">, Version 3.0.0 (2015-02-12) by the Distributed Management Task Force, Inc. (DMTF) at http://www.dmtf.org/standards/smbios.</A></P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1763160"></A><A NAME="49849"></A>Interleave Structure Index and Interleave Ways definition</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766386"></A>Interleave Structure Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766388"></A>Interleave Ways</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766390"></A>Interpretation </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766392"></A>0</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766394"></A>0</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766396"></A>Interleaving, if any, of the NVDIMM region is not reported</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766398"></A>0</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766400"></A>1</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766402"></A>The NVDIMM region is not interleaved with other NVDIMMs (i.e., it is one-way interleaved) </H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766404"></A>0</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766406"></A>&gt; 1</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766408"></A>The NVDIMM region is part of an interleave set with the number of NVDIMMs indicated in the Interleave Ways field, including the NVDIMM containing the NVDIMM region, but the Interleave Structure is not described.</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766410"></A>&gt; 0</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766412"></A>&gt; 1</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1781971"></A>The NVDIMM region is part of an interleave set with:</H6>
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1781972"></A>a) the number of NVDIMMs indicated in the Interleave Ways field, including the NVDIMM containing the NVDIMM region; and</H6>
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1781973"></A>b) the Interleave Structure (see <A HREF="ACPI_Software_Programming_Model.htm#12749" CLASS="XRef">See Interleave Structure .</A>) indicated by the Interleave Structure Index field. </H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="2">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766416"></A>All other combinations</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="HeadingRunIn">
<A NAME="pgfId-1766420"></A>Invalid case </H6>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1763127"></A>Interleave Structure Index=0, Interleave Ways !=1 is to allow a PM range which is interleaved but the actual interleave is not described but only provides the physical Memory Devices (as described by SMBIOS Type 17) that contribute to the PM region. Typically, only block region requires the interleave structure since software has to undo the effect of interleave.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1763163"></A><A NAME="12749"></A>Interleave Structure </H6>
<P CLASS="Body">
<A NAME="pgfId-1763164"></A>Memory from DIMMs/NVDIMMs could be interleaved across memory channels, memory controller and processor sockets. This structure describes the memory interleave for a given address range. Since interleave is a repeating pattern, this structure only describes the lines involved in the memory interleave before the pattern start to repeat.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1776018"></A>Interleave Structure<A NAME="43493"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765985"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765987"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765989"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765991"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763176"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763178"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763180"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763182"></A>2  - Interleave Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763184"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763186"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763188"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763190"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763192"></A>Interleave Structure Index </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763194"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763196"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763198"></A>Index Number uniquely identifies the interleave description - this allows reuse of interleave description across multiple NVDIMMs. Index must be non-zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763200"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763202"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763204"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763206"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763208"></A>Number of Lines Described (m)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763210"></A> 4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763212"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763214"></A>Only need to describe the number of lines needed before the interleave pattern repeats </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763216"></A>Line Size 	( in bytes ) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763218"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763220"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763222"></A>e.g. 64, 128, 256, 4096 </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763224"></A>Line 1 Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763226"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763228"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763230"></A>Line 1 Offset refers to the offset of the line, in multiples of Line Size, from the corresponding SPA Range Base for the NVDIMM region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763231"></A>Line 1 SPA = SPA Range Base + Region Offset + (Line 1 Offset*Line Size). Line SPA is naturally aligned to the Line size. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763233"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763235"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763237"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763239"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763241"></A>Line m Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763243"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763245"></A>16+((m-1)*4)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763247"></A>Line m Offset refers to the offset of the line, in multiples of Line Size, from the corresponding SPA Range Base for the NVDIMM region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763248"></A>Line m SPA = SPA Range Base + Region Offset + (Line m Offset*Line Size) where m is the last line number before the pattern repeats. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1763249"></A>Line SPA is naturally aligned to the Line size.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1763258"></A><A NAME="97912"></A>SMBIOS Management Information Structure </H6>
<P CLASS="Body">
<A NAME="pgfId-1763259"></A>This structure enables platform to communicate the additional SMBIOS entries beyond the entries provided by SMBIOS Table at boot to the OS (e.g. Type 17 entries corresponding to hot added NVDIMMs). </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1776041"></A>SMBIOS Management Information Structure<A NAME="_Toc400770434"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765993"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765995"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765997"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1765999"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763271"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763273"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763275"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763277"></A>3 - SMBIOS Management Information Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763279"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763281"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763283"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763285"></A>Length in bytes for entire structure.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763287"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763289"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763291"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763293"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763295"></A>Data </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763297"></A>_</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763299"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763301"></A>SMBIOS Table Entries</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1777996"></A><A NAME="42965"></A>NVDIMM Control Region Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1782107"></A>The system shall include an NVDIMM Control Region Structure for every Function Interface in the NVDIMM.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1763344"></A><A NAME="_Toc400770402"></A><A NAME="_Toc396827914"></A><A NAME="_Toc396819863"></A><A NAME="_Toc393976997"></A><A NAME="_Toc393968278"></A><A NAME="_Toc393968135"></A><A NAME="_Toc393965333"></A><A NAME="_Toc393290241"></A><A NAME="_Toc393270441"></A><A NAME="_Toc393177801"></A><A NAME="_Toc392608997"></A><A NAME="_Toc392084361"></A><A NAME="_Toc391912043"></A><A NAME="_Toc396827862"></A><A NAME="_Toc396819811"></A><A NAME="_Toc393976945"></A><A NAME="_Toc393968226"></A><A NAME="_Toc393968083"></A><A NAME="_Toc393965281"></A><A NAME="_Toc393290189"></A><A NAME="_Toc393270389"></A><A NAME="_Toc393177749"></A><A NAME="_Toc392608945"></A><A NAME="_Toc392084309"></A><A NAME="_Toc391911991"></A><A NAME="_Toc396827861"></A><A NAME="_Toc396819810"></A><A NAME="_Toc393976944"></A><A NAME="_Toc393968225"></A><A NAME="_Toc393968082"></A><A NAME="_Toc393965280"></A><A NAME="_Toc393290188"></A><A NAME="_Toc393270388"></A><A NAME="_Toc393177748"></A><A NAME="_Toc392608944"></A><A NAME="_Toc392084308"></A><A NAME="_Toc391911990"></A>NVDIMM Control Region Structure <A NAME="_Toc400770435"></A>Mark</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776141"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776143"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776145"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776147"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763356"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763358"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763360"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763362"></A>4 - NVDIMM Control Region Structure </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763364"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763366"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763368"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763370"></A>Length in bytes for entire structure.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1763371"></A>The length of this structure is either 32 bytes or 80 bytes. The length of the structure can be 32 bytes only if the Number of Block Control Windows field has a value of 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763373"></A>NVDIMM Control Region Structure Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763375"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763377"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763379"></A>Index Number uniquely identifies the NVDIMM Control Region Structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763381"></A>Vendor ID </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763383"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763385"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782123"></A>Identifier indicating the vendor of the NVDIMM. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1782124"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782125"></A>This field shall be set to the value of the NVDIMM SPD Module Manufacturer ID Code field <EM CLASS="Superscript">
a</EM>
 with byte 0 set to DDR4 SPD byte 320 and byte 1 set to DDR4 SPD byte 321. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763389"></A>Device ID </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763391"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763393"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782140"></A>Identifier for the NVDIMM, assigned by the module vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782141"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782142"></A>This field shall be set to the value of the NVDIMM SPD Module Product Identifier field <EM CLASS="Superscript">
b</EM>
 with byte 0 set to SPD byte 192 and byte 1 set to SPD byte 193.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763397"></A>Revision ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763399"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763401"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763405"></A>Revision of the NVDIMM, assigned by the module vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782183"></A>Byte 1 of this field is reserved.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782184"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782185"></A>Byte 0 of this field shall be set to the value of the NVDIMM SPD Module Revision Code field <EM CLASS="Superscript">
a</EM>
 (i.e., SPD byte 349).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763407"></A>Subsystem Vendor ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763409"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763411"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782221"></A>Vendor of the NVDIMM non-volatile memory subsystem controller <EM CLASS="Superscript">
c</EM>
.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782222"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782223"></A>This field shall be set to the value of the NVDIMM SPD Non-Volatile Memory Subsystem Controller Vendor ID field <EM CLASS="Superscript">
b</EM>
 with byte 0 set to SPD byte 194 and byte 1 set to SPD byte 195.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763415"></A>Subsystem Device ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763417"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763419"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782238"></A>Identifier for the NVDIMM non-volatile memory subsystem controller, assigned by the non-volatile memory subsystem controller vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782239"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782240"></A>This field shall be set to the value of the NVDIMM SPD Non-Volatile Memory Subsystem Controller Device ID field <EM CLASS="Superscript">
b</EM>
 with byte 0 set to SPD byte 196 and byte 1 set to SPD byte 197.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763425"></A>Subsystem Revision ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763427"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763429"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782255"></A>Revision of the NVDIMM non-volatile memory subsystem controller, assigned by the non-volatile memory subsystem controller vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782256"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782257"></A>Byte 1 of this field is reserved.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782258"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782259"></A>Byte 0 of this field shall be set to the value of the NVDIMM SPD Non-Volatile Memory Subsystem Controller Revision Code field <EM CLASS="Superscript">
b </EM>
(i.e., SPD byte 198).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763435"></A>Valid Fields</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763437"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763439"></A>18</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782560"></A>Valid bits for fields defined after the initial NFIT definition in ACPI 6.0 within the initially defined lengths of 32 and 80 bytes.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782561"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782562"></A>Bits [7-1]: Reserved</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782563"></A>Bit [0]: Manufacturing Location field and Manufacturing Date field </P>
<P CLASS="TableBody">
<A NAME="pgfId-1782564"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782565"></A>Bit [0] set to one indicates that the Manufacturing Location field and Manufacturing Date field are valid. Bit [0] set to zero indicates that the Manufacturing Location field and Manufacturing Date field are not valid and should be ignored. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1782566"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782567"></A>Systems compliant with this specification shall set Bit [0] to one. Systems that were compliant with ACPI 6.0 had Bit [0] set to zero, meaning they did not have Manufacturing Location and Manufacturing Date fields.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782498"></A>Manufacturing Location</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782500"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782502"></A>19</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782580"></A>Manufacturing location for the NVDIMM, assigned by the module vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782581"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782582"></A>This field shall be set to the value of the NVDIMM SPD Module Manufacturing Location field <EM CLASS="Superscript">
a</EM>
 (SPD byte 322).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782583"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782584"></A>Validity of this field is indicated in Valid Fields Bit [0].</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782490"></A>Manufacturing Date</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782492"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782494"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782597"></A>Date the NVDIMM was manufactured, assigned by the module vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782598"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782599"></A>This field shall be set to the value of the NVDIMM SPD Module Manufacturing Date field <EM CLASS="Superscript">
a</EM>
 with byte 0 set to SPD byte 323 and byte 1 set to SPD byte 324.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782600"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782601"></A>Validity of this field is indicated in Valid Fields Bit [0].</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782482"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782484"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782486"></A>22</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782488"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763443"></A>Serial Number</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763445"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763447"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782628"></A>Serial number of the NVDIMM, assigned by the module vendor.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782629"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782630"></A>This field shall be set to the value of the NVDIMM SPD Module Serial Number field<EM CLASS="Superscript">
 a</EM>
 with byte 0 set to SPD byte 325, byte 1 set to SPD byte 326, byte 2 set to SPD byte 327, and byte 3 set to SPD byte 328.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763451"></A>Region Format Interface Code </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763453"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763455"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1782645"></A>Identifier for the programming interface.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782646"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782647"></A>This field shall be set to the value of the NVDIMM SPD Function Interface descriptor <EM CLASS="Superscript">
b</EM>
 for the function interface represented by the NVDIMM Control Region structure, with:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782648"></A>a) byte 0 bits 7:5 set to 000b;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782649"></A>b) byte 0 bits 4:0 set to the Function Interface field (i.e., Function Interface descriptor bits 4:0);</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782650"></A>c) byte 1 bits 7:5 set to 000b; and</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782651"></A>d) byte 1 bits 4:0 set to the Function Class field (i.e., Function Interface descriptor bits 9:5).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782652"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782653"></A>EXAMPLE: A Function Interface Descriptor of 0x8021 means:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782654"></A>a) Function Interface Descriptor is implemented;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782655"></A>b) there is no Extended Function Parameter Block;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782656"></A>c) function class is byte-addressable energy backed (0x01); and</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782657"></A>d) function interface is byte addressable energy backed function interface 1 (0x01) <EM CLASS="Superscript">
d</EM>
,</P>
<P CLASS="TableBody">
<A NAME="pgfId-1786015"></A>and maps to a Region Format Interface Code of 0x0101.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786086"></A>Number of Block Control Windows</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786088"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786090"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786092"></A>Number of Block Control Windows must match the corresponding number of Block Data Windows. Fields that follow this field are valid only if the number of Block Control Windows is non-zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786094"></A>Size of Block Control Window</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786096"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786098"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786100"></A>In Bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786102"></A>Command Register Offset in Block Control Window</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786104"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786106"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786108"></A>In Bytes. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1786109"></A>Logical offset. Refer to Note. The start of the subsequent Block Control Windows is calculated by adding Size of Block Control Window. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786111"></A>Size of Command Register in Block Control Windows</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786113"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786115"></A>48</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786117"></A>In Bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786119"></A>Status Register Offset in Block Control Window</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786121"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786123"></A>56</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786125"></A>In Bytes. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1786126"></A>Logical offset. Refer to Note1. The start of the subsequent Block Control Window is calculated by adding Size of Block Control Window.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786128"></A>Size of Status Register in Block Control Windows</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786130"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786132"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786134"></A>In Bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786136"></A>NVDIMM Control Region Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786138"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786140"></A>72</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786142"></A>Bit [0] - set to 1 to indicate that the Block Data Windows implementation is buffered. The content of the data window is only valid when so indicated by Status Register.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763517"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763519"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763521"></A>74</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763523"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableBody">
<A NAME="pgfId-1782680"></A><EM CLASS="Superscript">
 a</EM>
 See JEDEC Standard No. 21-C<EM CLASS="Italic">
 JEDEC Configurations for Solid State Memories</EM>
, Annex L: Serial Presence Detect (SPD) for DDR4 SDRAM modules, DDR4 SPD Document Release 2.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782681"></A><EM CLASS="Superscript">
 b </EM>
See JEDEC Standard No. 21-C <EM CLASS="Italic">
JEDEC Configurations for Solid State Memories</EM>
, Annex L: Serial Presence Detect (SPD) for DDR4 SDRAM modules, DDR4 SPD Document Release 3 (forthcoming).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782682"></A> <EM CLASS="Superscript">
c</EM>
 In an NVDIMM, the module contains a non-volatile memory subsystem controller.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1782683"></A><EM CLASS="Superscript">
 d </EM>
See JEDEC Standard No. 2233-22 B<EM CLASS="Italic">
yte Addressable Energy Backed Interface,</EM>
 Version 1.0 (forthcoming).</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1763530"></A>Logical offset in structure above refers to offset from the start of NVDIMM Control Region. The logical offset is with respect to the device not with respect to system physical address space. Software should construct the device address space (accounting for interleave) before applying the block control start offset.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1763532"></A><A NAME="16432"></A>NVDIMM Block Data Window Region Structure </H6>
<P CLASS="Body">
<A NAME="pgfId-1763533"></A>This structure shall be provided only if the number of Block Data Windows is non-zero.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1776108"></A>NVDIMM Block Data Windows Region Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766009"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766011"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766013"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1766015"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763545"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763547"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763549"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763551"></A>5 - NVDIMM Block Data Window  Region  Structure  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763553"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763555"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763557"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763559"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763561"></A>NVDIMM Control Region Structure Index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763563"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763565"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763567"></A>Provides association for the corresponding NVDIMM Control Region. Shall be Non-zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763569"></A>Number of Block Data Windows</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763571"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763573"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763575"></A>Number of Block Data Windows shall match the corresponding number of Block Control Windows. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763577"></A>Block Data Window Start Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763579"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763581"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763583"></A>In Bytes. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1763584"></A>Logical offset. Refer to Note2. The start of the subsequent Block Data Window is calculated by adding Size of Block Data Window.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763586"></A>Size of Block Data Window</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763588"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763590"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763592"></A>In Bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763594"></A>Block Accessible Memory Capacity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763596"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763598"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763600"></A>In Bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763602"></A>Beginning address of first block in Block Accessible Memory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763604"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763606"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763608"></A>In Bytes. The address of the next block is obtained by adding the value of this field to Size of Block Data Window.</P>
</TD>
</TR>
</TABLE>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1763614"></A>Logical offset in table above refers to offset from the start of NVDIMM Data Window Region. The logical offset is with respect to the device not with respect to system physical address space. Software should construct the device address space (accounting for interleave) before applying the Block Data Window start offset.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1763616"></A><A NAME="13012"></A>Flush Hint Address Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1763617"></A>Software needs an assurance of durability (i.e. a guarantee that the writes have reached the target NVDIMM) after writing to a NVDIMM region. The Flush Hint feature is platform specific and if supported, the platform exposes this durability mechanism to OSPM by providing a Flush Hint Address Structure.</P>
<P CLASS="Body">
<A NAME="pgfId-1763618"></A>For a given NVDIMM (as indicated by the NFIT Device Handle in the Flush Hint Address Structure), software can write to any one of these Flush Hint Addresses to cause any preceding writes to the NVDIMM region to be flushed out of the intervening platform buffers<A HREF="#pgfId-1763621" CLASS="footnote">1</A> to the targeted NVDIMM (to achieve durability).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1776155"></A>Flush Hint Address Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776188"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776190"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776192"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1776194"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763633"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763635"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763637"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763639"></A>6 -  Flush Hint Address Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763641"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763643"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763645"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763647"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763649"></A>NFIT Device Handle </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763651"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763653"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763655"></A>Indicates the NVDIMM supported by the Flush Hint Addresses in this structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763657"></A>Number of Flush Hint Addresses in this structure (m)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763659"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763661"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763663"></A>Number of Flush Hint Addresses in this structure. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763665"></A>Reserved </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763667"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763669"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763671"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763673"></A>Flush Hint Address 1 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763675"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763677"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763679"></A>64-bit system physical address that needs to be written to cause durability flush. Software is allowed to write up to a cache line of data. The content of the data is not relevant to the functioning of the flush hint mechanism.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763681"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763683"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763685"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763687"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763689"></A>Flush Hint Address m </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763691"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763693"></A>16+ ((m-1)*8) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1763695"></A>64-bit system physical address that needs to be written to cause durability flush. Software is allowed to write up to a cache line of data. The content of the data is not relevant to the functioning of the flush hint mechanism.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1825155"></A><A NAME="58079"></A>Platform Capabilities Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1825188"></A>This structure informs OSPM of the NVDIMM platform capabilities. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1825492"></A>Platform Capabilities Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826271"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826273"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826275"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826277"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826209"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826211"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826213"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826215"></A>7 - Platform Capabilities Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826217"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826219"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826221"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826223"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826225"></A>Highest Valid Capability</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826227"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826229"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826231"></A>The bit index of the highest valid capability implemented by the platform. The subsequent bits shall not be considered to determine the capabilities supported by the platform.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826233"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826235"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826237"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826239"></A>Reserved (0)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826241"></A>Capabilities</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826243"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826245"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826423"></A>Bit[0] - CPU Cache Flush to NVDIMM Durability on Power Loss Capable. If set to 1, indicates that platform ensures the entire CPU store data path is flushed to persistent memory on system power loss.</P>
<P CLASS="TableHeading">
<A NAME="pgfId-1826424"></A>Bit[1] - Memory Controller Flush to NVDIMM Durability on Power Loss Capable. If set to 1, indicates that platform provides mechanisms to automatically flush outstanding write data from the memory controller to persistent memory in the event of platform power loss. Note: If bit 0 is set to 1 then this bit shall be set to 1 as well.</P>
<P CLASS="TableHeading">
<A NAME="pgfId-1826425"></A>Bit[2] - Byte Addressable Persistent Memory Hardware Mirroring Capable. If set to 1, indicates that platform supports mirroring multiple byte addressable persistent memory regions together. If this feature is supported and enabled, healthy hardware mirrored interleave sets will have the EFI_MEMORY_MORE_RELIABLE Address Range Memory Mapping Attribute set in the System Physical Address Range structure in the NFIT table. </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1826247"></A>Bits[31:3] - Reserved </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826249"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826251"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826253"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1826255"></A>Reserved (1)</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1782874"></A> NVDIMM Representation Format</H6>
<P CLASS="Body">
<A NAME="pgfId-1782875"></A>If software or an NVDIMM manufacturer displays, prints on a label, or otherwise makes available an identifier for an NVDIMM (e.g., to uniquely identify the NVDIMM), then the following hexadecimal format should be used:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1782876"></A> If the Manufacturing Location and Manufacturing Date fields are valid:</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="BulletPara">
<A NAME="pgfId-1782877"></A>C language format string: &quot;%02x%02x-%02x-%02x%02x-%02x%02x%02x%02x&quot;</H6>
<P CLASS="Body">
<A NAME="pgfId-1782878"></A>Format values:</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1782879"></A>Vendor ID byte 0 (including the parity bit)</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782880"></A>Vendor ID byte 1</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782881"></A>Manufacturing Location byte</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782882"></A>Manufacturing Date byte 0 (i.e., the year)</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782883"></A>Manufacturing Date byte 1 (i.e., the week)</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782884"></A>Serial Number byte 0</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782885"></A>Serial Number byte 1</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782886"></A>Serial Number byte 2</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782887"></A>Serial Number byte 3</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1782888"></A>If the Manufacturing Location and Manufacturing Date fields are not valid:</LI>
</OL>
</DIV>
<DIV>
<H6 CLASS="BulletPara">
<A NAME="pgfId-1782889"></A>C language format string: &quot;%02x%02x-%02x%02x%02x%02x&quot;</H6>
<P CLASS="Body">
<A NAME="pgfId-1782890"></A>Format values:</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1782891"></A>Vendor ID byte 0 (including the parity bit)</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782892"></A>Vendor ID byte 1</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782893"></A>Serial Number byte 0</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782894"></A>Serial Number byte 1</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782895"></A>Serial Number byte 2</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1782896"></A>Serial Number byte 3</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1782897"></A>This format matches the order of SPD bytes 320 to 328 from low to high (i.e., showing the lowest or first byte on the left).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1818481"></A><A NAME="82207"></A>Secure Devices (SDEV) ACPI Table</H6>
<P CLASS="Body">
<A NAME="pgfId-1822093"></A>The Secure DEVices (SDEV) table is a list of secure devices known to the system. The table is applicable to systems where a secure OS partition and a non-secure OS partition co-exist. A secure device is a device that is protected by the secure OS, preventing accesses from non-secure OS.</P>
<P CLASS="Body">
<A NAME="pgfId-1822094"></A>The table provides a hint as to which devices should be protected by the secure OS. The enforcement of the table is provided by the secure OS and any pre-boot environment preceding it. The table itself does not provide any security guarantees. It is the responsibility of the system manufacturer to ensure that the operating system is configured to enable security features that make use of the SDEV table.</P>
<P CLASS="Body">
<A NAME="pgfId-1822096"></A>There are three options for each device in the system:</P>
<P CLASS="Body">
<A NAME="pgfId-1822097"></A>1)	Device is listed in SDEV. &#8220;Allow handoff...&#8221; flag is clear.</P>
<P CLASS="Body">
<A NAME="pgfId-1822098"></A>This provides a hint that the device should be always protected within the secure OS. </P>
<P CLASS="Body">
<A NAME="pgfId-1822099"></A>For example, the secure OS may require that a device used for user authentication must be protected to guard against tampering by malicious software.</P>
<P CLASS="Body">
<A NAME="pgfId-1822100"></A>2)	Device is listed in SDEV. &#8220;Allow handoff...&#8221; flag is set.</P>
<P CLASS="Body">
<A NAME="pgfId-1822101"></A>This provides a hint that the device should be initially protected by the secure OS, but it is up to the discretion of the secure OS to allow the device to be handed off to the non-secure OS when requested. Any OS component that expected the device to be operating in secure mode would not correctly function after the handoff has been completed.</P>
<P CLASS="Body">
<A NAME="pgfId-1822102"></A>For example, a device may be used for variety of purposes, including user authentication. If the secure OS determines that the necessary components for driving the device are missing, it may release control of the device to the non-secure OS. In this case, the device cannot be used for secure authentication, but other operations can correctly function.</P>
<P CLASS="Body">
<A NAME="pgfId-1822103"></A>3)	Device not listed in SDEV</P>
<P CLASS="Body">
<A NAME="pgfId-1822104"></A>For example, the status quo is that no hints are provided. Any OS component that expected the device to be in secure mode would not correctly function.</P>
<P CLASS="Body">
<A NAME="pgfId-1822106"></A>The OS vendor provides guidance on which devices can be listed in the SDEV table; in other words, which devices are compatible with the secure OS, and which devices should have the &#8220;allow handoff&#8221; flag set.</P>
<P CLASS="Body">
<A NAME="pgfId-1822107"></A>See table below for the SDEV ACPI definition.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1818866"></A><A NAME="63879"></A>SDEV ACPI Table</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818537"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818539"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818541"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818543"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818545"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818547"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818549"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818551"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818553"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818555"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818557"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818559"></A>&#8216;SDEV&#8217;. Signature for the Table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818561"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818563"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818565"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818567"></A>Length, in bytes, of the entire Table. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818569"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818571"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818573"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818575"></A>1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818577"></A>Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818579"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818581"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818583"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818585"></A>OEM ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818587"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818589"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818591"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818593"></A>OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818595"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818597"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818599"></A>For the SDEV Table, the table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818601"></A>OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818603"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818605"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818607"></A>OEM revision of SDEV Table for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818609"></A>Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818611"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818613"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818615"></A>Vendor ID of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818617"></A>Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818619"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818621"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818623"></A>Revision of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818625"></A>Secure Device Structures []</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818627"></A>-</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818629"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818631"></A>A list of structures containing one or more Secure Device Structures as defined in next section.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1818635"></A>Secure Device Structures</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1818639"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1818641"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818643"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818645"></A>PCIe Endpoint Device based Secure Device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818647"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818649"></A>ACPI_NAMESPACE_DEVICE based Secure Device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818651"></A>All Other Values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818653"></A>Reserved for future use. For forward compatibility, software skips structures it does not comprehend by skipping the appropriate number of bytes indicated by the Length field.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1822485"></A>All new device structures must include the Type, Flags, and Length fields as the first 3 fields respectively.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1818658"></A>PCIe Endpoint Device Based Device Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1820136"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1820138"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1820140"></A>Byte Offset </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1820142"></A>Description </P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818670"></A>Type </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818672"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818674"></A>0 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818676"></A>0x01: PCIe Endpoint device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822511"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822513"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822515"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822536"></A>Bit 0: Allow handoff to non-secure OS.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1822517"></A>All other bits are reserved and must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818678"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818680"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818682"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818684"></A>Length of this Entry in Bytes. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818686"></A>PCI Segment Number </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818688"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818690"></A>4 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818692"></A>PCI segment number of the device .</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818694"></A>Start Bus Number </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818696"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818698"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818700"></A>This field describes the bus number (bus number of the first PCI Bus produced by the PCI Host Bridge) under which the secure device resides. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818702"></A>PCI Path Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818704"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818706"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818708"></A>Pointer to the PCI path* entry offset in the Secure PCI Device Structure data region.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1818709"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1818710"></A>A PCI Path describes the hierarchal path from the Host Bridge to the device. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1818711"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1818712"></A>For example, a device in an N-deep hierarchy is identified by N {PCI Device Number, PCI Function Number} pairs, where N is a positive integer. Even offsets contain the Device numbers, and odd offsets contain the Function numbers. The first {Device, Function} pair resides on the bus identified by the &#8216;Start Bus Number&#8217; field. Each subsequent pair resides on the bus directly behind the bus of the device identified by the previous pair. The identity (Bus, Device and Function) of the target device is obtained by recursively walking down these N {Device, Function} pairs.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818714"></A>PCI Path Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818716"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818718"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818720"></A>Length of the PCI path entry.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818722"></A>Vendor specific data Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818724"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818726"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818728"></A>Offset of the data specific to the device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818730"></A>Vendor specific data Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818732"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818734"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818736"></A>Length of the data specific to the device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822551"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822553"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822555"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822557"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1822567"></A>Example:</P>
<P CLASS="Body">
<A NAME="pgfId-1822560"></A>The following table is an example for implementing a PCIe Endpoint Device Based Device Structure for a PCIe device (Bus 1, Dev 2, Function 1), that is a child of a PCIe Root Port (Bus 0, Dev 18, Function 0).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1823623"></A>PCIe Endpoint Device Based Device Structure Example</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1822596"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1822598"></A>Byte </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1822599"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1822601"></A>Byte </P>
<P CLASS="TableHeading">
<A NAME="pgfId-1822602"></A>Offset </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1822604"></A>Value </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822606"></A>Type </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822608"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822610"></A>0 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822612"></A>0x01: PCIe Endpoint device.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822614"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822616"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822618"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822620"></A>0x01</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822622"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822624"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822626"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822628"></A>0x18</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822630"></A>PCI Segment Number </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822632"></A>2 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822634"></A>4 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822636"></A>0x0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822638"></A>Start Bus Number </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822640"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822642"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822644"></A>0x0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822646"></A>PCI Path Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822648"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822650"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822652"></A>0x10 (16 DEC)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822654"></A>PCI Path Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822656"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822658"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822660"></A>0x4</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822662"></A>Vendor specific data </P>
<P CLASS="TableBody">
<A NAME="pgfId-1822663"></A>Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822665"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822667"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822669"></A>0x14 (20 DEC)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822671"></A>Vendor specific data </P>
<P CLASS="TableBody">
<A NAME="pgfId-1822672"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822674"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822676"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822678"></A>0x4</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822680"></A>PCI Path </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822682"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822684"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822686"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822688"></A>PCI Device</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822690"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822692"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822694"></A>0x12 (18 DEC)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822696"></A>PCI Function</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822698"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822700"></A>17</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822702"></A>0x0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822704"></A>PCI Device</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822706"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822708"></A>18</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822710"></A>0x2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822712"></A>PCI Function</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822714"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822716"></A>19</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822718"></A>0x1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822720"></A>Vendor specific data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822722"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822724"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1822726"></A>0xDEADBEEF</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1818740"></A>ACPI_NAMESPACE_DEVICE based Secure Device Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832008"></A>Field </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832010"></A>Byte Length </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832012"></A>Byte Offset </P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832014"></A>Description </P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818752"></A>Type </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818754"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818756"></A>0 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818758"></A>0x00: ACPI integrated devices</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1824649"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1824651"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1824653"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1824671"></A>Bit 0: Allow handoff to non-secure OS.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1824655"></A>All other bits are reserved and must be zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818760"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818762"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818764"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818766"></A>Length of this entry in bytes. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818768"></A>Device Identifier Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818770"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818772"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818774"></A>Offset, in Secure ACPI Device structure of  null terminated ASCII string that contains a fully qualified reference to the ACPI name-space object that is this device. (For example, &#8220;&#92;&#92;_SB.I2C0&#8221; represents the ACPI object name for an embedded I2C Device in southbridge; Quotes are omitted in the data field). Refer to ACPI specification for fully qualified references for ACPI name-space objects.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818776"></A>Device Identifier Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818778"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818780"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818782"></A>Length of Device Identifier string in bytes, including the termination byte</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818784"></A>Vendor specific data Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818786"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818788"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818790"></A>Offset, in Secure ACPI Device Structure, of the data specific to the device supplied by the vendor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818792"></A>Vendor specific data Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818794"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818796"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1818798"></A>Length of the data specific to the device supplied by the vendor</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1809915"></A><A NAME="54307"></A>Heterogeneous Memory Attribute Table (HMAT)</H6>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1809942"></A>HMAT Overview</H6>
<P CLASS="Normal">
<A NAME="pgfId-1811507"></A>Heterogeneous Memory Attribute Table (HMAT) describes the memory attributes, such as memory side cache attributes and bandwidth and latency details, related to Memory Proximity Domains. The software is expected to use this information as hint for optimization. </P>
<P CLASS="Normal">
<A NAME="pgfId-1811508"></A>OSPM evaluates HMAT only during system initialization. Any changes to the HMAT state at runtime or information regarding HMAT for hot plug are communicated using the _HMA method (see <A HREF="Device_Configuration.htm#16303" CLASS="XRef">See _HMA(Heterogeneous Memory Attributes).</A>).<BR>
The HMAT consists of the following structures:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1811557"></A>Memory Proximity Domain Attributes Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#30657" CLASS="XRef">See Memory Proximity Domain Attributes Structure.</A>) - Describes attributes of memory proximity domains. </H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1811558"></A>System Locality Latency and Bandwidth Information Structure (s) (see <A HREF="ACPI_Software_Programming_Model.htm#76050" CLASS="XRef">See System Locality Latency and Bandwidth Information Structure.</A>) - Describes the memory access latency and bandwidth information from various memory access initiator proximity domains. </LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1811559"></A>Memory Side Cache Information Structure(s) (see <A HREF="ACPI_Software_Programming_Model.htm#15013" CLASS="XRef">See Memory Side Cache Information Structure.</A>) - Describes memory side cache information for memory proximity domains if the memory side cache is present and the physical device (SMBIOS handle) forms the memory side cache.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1809971"></A>These structures are illustrated by the following figure. </P>
<P CLASS="Body">
<A NAME="pgfId-1809973"></A>&nbsp;</P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-10.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1809975"></A>HMAT Representation</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1811705"></A>Heterogeneous Memory Attribute Table Header</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1811708"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1811710"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1811712"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1811714"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableBody">
<A NAME="pgfId-1811716"></A>Header</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811724"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811726"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811728"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811730"></A>&#8216;HMAT&#8217; is Signature for this table </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811732"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811734"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811736"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811738"></A>Length in bytes for entire table.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811740"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811742"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811744"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811746"></A>2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811748"></A>Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811750"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811752"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811754"></A>Entire table must sum to zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811756"></A>OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811758"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811760"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811762"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811764"></A>OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811766"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811768"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811770"></A>The table ID is the manufacturer model ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811772"></A>OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811774"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811776"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811778"></A>OEM revision of table for supplied OEM Table ID </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811780"></A>Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811782"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811784"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811786"></A>Vendor ID of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811788"></A>Creator Revision </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811790"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811792"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811794"></A>Revision of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811796"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811798"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811800"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811802"></A>To make the structures 8 byte aligned</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811804"></A>HMAT Table Structures[n]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811806"></A>_</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811808"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1811810"></A>A list of HMAT table structures for this implementation.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1812265"></A>HMAT Structure Types</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1817502"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1817504"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812327"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812329"></A>Memory Proximity Domain Attributes Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812331"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812333"></A>System Locality Latency and Bandwidth Information Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812335"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812337"></A>Memory Side Cache Information Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812339"></A>3-0xFFFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1812341"></A>Reserved</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1812269"></A>Memory Side Cache Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1813295"></A>Memory side cache allows to optimize the performance of memory subsystems. <A HREF="ACPI_Software_Programming_Model.htm#60158" CLASS="XRef">See Memory Side Cache Example.</A> shows an example of system physical address (SPA) range with memory side cache in front of actual memory that is seen by the software. When the software accesses an SPA, if it is present in the near memory (hit) it would be returned to the software, if it is not present in the near memory (miss) it would access the next level of memory and so on.</P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-11.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1813354"></A><A NAME="60158"></A>Memory Side Cache Example</H6>
<P CLASS="Body">
<A NAME="pgfId-1812273"></A>The term &#8220;far memory&#8221; is used to denote the last level memory (Level 0 Memory) in the memory hierarchy as shown in <A HREF="ACPI_Software_Programming_Model.htm#60158" CLASS="XRef">See Memory Side Cache Example.</A>. The Level n Memory acts as memory side cache to Level n-1 Memory and Level n-1 memory acts as memory side cache for Level n-2 memory and so on. If Non-Volatile memory is cached by memory side cache, then platform is responsible for persisting the modified contents of the memory side cache corresponding to the Non-Volatile memory area on power failure, system crash or other faults.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1812275"></A><A NAME="30657"></A>Memory Proximity Domain Attributes Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-998370"></A>This structure describes the system physical address (SPA) range occupied by the memory subsystem and its associativity with processor proximity domain as well as hint for memory usage.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-998374"></A>Memory Proximity Domain Attributes Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-998395"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-998408"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-998421"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-998434"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998447"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998449"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998451"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998453"></A>0  - Memory Proximity Domain Attributes Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998494"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998496"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998498"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998500"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998532"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998534"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998536"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998538"></A>40 - Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998580"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998582"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998584"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998672"></A>Bit [0]: set to 1 to indicate that data in the Proximity Domain for the Attached Initiator field is valid. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1844559"></A>Bit [1]: Reserved. Previously defined as Memory Proximity Domain field is valid. Deprecated since ACPI 6.3.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1844560"></A>Bit [2]: Reserved. Previously defined as Reservation Hint. Deprecated since ACPI 6.3.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1844555"></A>Bits [15:3] : Reserved.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998686"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998688"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998690"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998692"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998724"></A>Proximity Domain for the Attached Initiator</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998726"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998728"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1844603"></A>This field is valid only if the memory controller responsible for satisfying the access to memory belonging to the specified memory proximity domain is directly attached to an initiator that belongs to a proximity domain. In that case, this field contains the integer that represents the proximity domain to which the initiator (Generic Initiator or Processor) belongs. This number shall match the corresponding entry in the SRAT table&#8217;s processor affinity structure (e.g., Processor Local APIC/SAPIC Affinity Structure, Processor Local x2APIC Affinity Structure, GICC Affinity Structure) if the initiator is a processor, or the Generic Initiator Affinity Structure if the initator is a generic initiator.</P>
<P CLASS="TableBody">
<A NAME="pgfId-998783"></A>Note: this field provides additional information as to the initiator node that is closest (as in directly attached) to the memory address ranges within the specified memory proximity domain, and therefore should provide the best performance.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998793"></A>Proximity Domain for the Memory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998795"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998797"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998799"></A>Integer that represents the memory proximity domain to which this memory belongs. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998848"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998850"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998852"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998854"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998886"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998888"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998890"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998892"></A>Previously defined as the Start Address of the System Physical Address Range. Deprecated since ACPI Specification 6.3.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998934"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998936"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-998938"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1844760"></A>Previously defined as the Range Length of the region in bytes. Deprecated since ACPI Specification 6.3.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1813413"></A>Note: The Proximity Domain values must first be assigned and described in the SRAT table, the same values are then used in the SLIT, HMAT, MSCT, and NFIT tables when the associated characteristics need to be described for the matching Proximity Domains.  </P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1812277"></A><A NAME="76050"></A>System Locality Latency and Bandwidth Information Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1813593"></A>This optional structure provides a matrix that describes the normalized memory read/write latency, read/write bandwidth between Initiator Proximity Domains (Processor or I/O) and Target Proximity Domains (Memory).</P>
<P CLASS="Body">
<A NAME="pgfId-1844790"></A>The Entry Base Unit for latency is in picoseconds. The Entry Base Unit for bandwidth is in megabytes per second (MB/s). The Initiator to Target Proximity Domain matrix entry can have one of the following values.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1844791"></A>0:  the corresponding latency or bandwidth information is not provided.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1844792"></A>1-0xFFFE: the corresponding latency or bandwidth information expressed in multiples of Entry Base Unit.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1844793"></A>0xFFFF: the initiator and target domains are unreachable from each other.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1844796"></A>The represented latency or bandwidth value is determined as follows: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1844797"></A>Represented latency = (Initiator to Target Proximity Domain matrix entry value * Entry Base Unit) picoseconds.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1844798"></A>Represented bandwidth = (Initiator to Target Proximity Domain matrix entry value * Entry Base Unit) MB/s.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1844800"></A>The following examples show how to report latency and throughput values:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1844801"></A>If the &#8220;Entry Base Unit&#8221; is 1 for latency and the matrix entry has the value of 10, the latency is 10 picoseconds.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1844802"></A>If the &#8220;Entry Base Unit&#8221; is 1000 for latency and the matrix entry has the value of 100, the latency is 100 nanoseconds.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1844803"></A>If the &#8220;Entry Base Unit&#8221; is 1 for BW and the matrix entry has the value of 10, the BW is 10 MB/s.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1844805"></A>If the &#8220;Entry Base Unit&#8221; is 1024 for BW and the matrix entry has the value of 100, the BW is 100 GB/s.</LI>
<LI CLASS="Note">
<A NAME="pgfId-1813596"></A>The lowest latency number represents best performance and the highest bandwidth number represents best performance. The latency and bandwidth numbers represented in this structure correspond to specification rated latency and bandwidth for the platform. The represented latency is determined by aggregating the specification rated latencies of the memory device and the interconnects from initiator to target. The represented bandwidth is determined by the lowest bandwidth among the specification rated bandwidth of the memory device and the interconnects from the initiator to target.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1813599"></A><A NAME="83301"></A>System Locality Latency and Bandwidth Information Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814189"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814191"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814193"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814195"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813610"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813612"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813614"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813616"></A>1 - System Locality Latency and Bandwidth Information Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813618"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813620"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813622"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813624"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813626"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813628"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813630"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813632"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813634"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813636"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813638"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813640"></A>Bits [3:0] Memory Hierarchy:</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813641"></A>0 - Memory<BR>
If the memory side cache is not present, this structure represents the memory performance. If memory side cache is present, this structure represents the memory performance when no hits occur in any of the memory side caches associated with the memory  </LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1844906"></A>1 - 1st level memory side cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813645"></A>2 - 2nd level memory side cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813646"></A>3 - 3rd level memory side cache</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817854"></A>Other bits:</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813648"></A>Bits[7:4] Reserved</LI>
</UL>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813650"></A>Data Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813652"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813654"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813656"></A>Type of data represented by this structure instance.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1817875"></A> &nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813657"></A>If Memory Hierarchy = 0</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813658"></A>0 - Access Latency (if read and write latencies are same)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813659"></A>1 - Read Latency</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813660"></A>2 - Write Latency</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813661"></A>3 - Access Bandwidth (if read and write bandwidth are same)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813662"></A>4 - Read Bandwidth</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813663"></A>5 - Write Bandwidth</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817878"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813664"></A>If Memory Hierarchy = 1, 2, 3, or 4</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813665"></A>0 - Access Hit Latency (if read hit and write hit latencies are same)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813666"></A>1 - Read Hit Latency</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813667"></A>2 - Write Hit Latency</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813668"></A>3 - Access Hit Bandwidth (if read hit and write hit latency are same)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813669"></A>4 - Read Hit Bandwidth</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1813670"></A>5 - Write Hit Bandwidth</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817891"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813671"></A>Other values reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813673"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813675"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813677"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813679"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813681"></A>Number of Initiator Proximity Domains (s)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813683"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813685"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813687"></A>Indicates total number of Proximity Domains that can initiate memory access requests to other proximity domains.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813688"></A>This is typically the processor or I/O proximity domains.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813690"></A>Number of Target Proximity Domains (t)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813692"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813694"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813696"></A>Indicates total number of Proximity Domains that can act as target. This is typically the Memory Proximity Domains.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813698"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813700"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813702"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813704"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813706"></A>Entry Base Unit </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813708"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813710"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813712"></A>Base unit for Matrix Entry Values (latency or bandwidth).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813713"></A>Base unit for latency in picoseconds.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813714"></A>Base unit for bandwidth in megabytes per second (MB/s).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1813715"></A>This field shall be non-zero. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813717"></A>Initiator Proximity Domain List[0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813719"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813721"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813723"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813725"></A>Initiator Proximity Domain List[1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813727"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813729"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813731"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813733"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813735"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813737"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813739"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813741"></A>Initiator Proximity Domain List[s-1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813743"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813745"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813747"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813749"></A>Target Proximity Domain List[0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813751"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813753"></A>32 + 4 x s</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813755"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813757"></A>Target Proximity Domain List[1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813759"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813761"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813763"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813765"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813767"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813769"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813771"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813773"></A>Target Proximity Domain List[t-1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813775"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813777"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813779"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableBody">
<A NAME="pgfId-1813781"></A>The following list of entries provides latency/bandwidth values. Total Number Entry shall be equal to Number of Initiator Proximity Domains * Number of Target Proximity Domains</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813789"></A>Entry[0][0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813791"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813793"></A>32 + 4 x s + 4 x t</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813795"></A>Matrix entry (Initiator Proximity Domain List[0], Target Proximity Domain List[0])</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813797"></A>Entry[0][1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813799"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813801"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813803"></A>Matrix entry (Initiator Proximity Domain List[0], Target Proximity Domain List[1])</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813805"></A>... ...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813807"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813809"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813811"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813813"></A>Entry[0][Number of Target Proximity Domains -1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813815"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813817"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813819"></A>Matrix entry (Initiator Proximity Domain List[0], Target Proximity Domain List[t-1])</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813821"></A>Entry[1][ 0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813823"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813825"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813827"></A>Matrix entry (Initiator Proximity Domain List[1], Target Proximity Domain List[0])</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813829"></A>Entry[1][1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813831"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813833"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813835"></A>Matrix entry (Initiator Proximity Domain List[1], Target Proximity Domain List[1])</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813837"></A>... ...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813839"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813841"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813843"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813845"></A>Entry[1][ Number of Target Proximity Domains -1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813847"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813849"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813851"></A>Matrix entry (Initiator Proximity Domain List[1], Target Proximity Domain List[t-1])</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813853"></A>... ...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813855"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813857"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813859"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813861"></A>Entry[Number of Initiator Proximity Domains - 1][ Number of Target Proximity Domains -1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813863"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813865"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1813867"></A>Matrix entry (Initiator Proximity Domain List[s-1], Target Proximity Domain List[t-1])</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1813871"></A>Implementation Note: The Flag field in this table allows read latency, write latency, read bandwidth and write bandwidth as well as Memory Hierarchy levels. Hence this structure could be repeated up to 4 x number of Memory Hierarchy levels if memory attributes expressed for each memory level.</P>
<P CLASS="Body">
<A NAME="pgfId-1813585"></A>If both SLIT table and the HMAT table with the memory latency information are present, the OSPM should attempt to use the data in the HMAT rather than the data in the SLIT.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1813587"></A><A NAME="15013"></A>Memory Side Cache Information Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-1814745"></A>System memory hierarchy could be constructed to have a large size of low performance far memory and smaller size of high performance near memory. <A HREF="ACPI_Software_Programming_Model.htm#65308" CLASS="XRef">See Memory Side Cache Information Structure.</A> describes memory side cache information for a given memory domain. The software could use this information to effectively place the data in memory to maximize the performance of the system memory that use the memory side cache.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1814752"></A><A NAME="65308"></A>Memory Side Cache Information Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814891"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814893"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814895"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1814897"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814763"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814765"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814767"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814769"></A>2 - Memory Side Cache Information Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814771"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814773"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814775"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814777"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814779"></A>Length </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814781"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814783"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814785"></A>Length in bytes for entire structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814787"></A>Proximity Domain for the Memory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814789"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814791"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814793"></A>Integer that represents the memory proximity domain to which the memory side cache information applies. This number shall match the corresponding entry in the SRAT table&#8217;s Memory Affinity Structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814795"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814797"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814799"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814801"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814803"></A>Memory Side Cache Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814805"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814807"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814809"></A>Size of memory side cache in bytes for the above memory proximity domain.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814811"></A>Cache Attributes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814813"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814815"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814817"></A>Bits [3:0] - Total Cache Levels for this Memory Proximity Domain</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814818"></A>0 - None</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814819"></A>1 - One level cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814820"></A>2 - Two level cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814821"></A>3 - Three level cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814822"></A>Other values reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817894"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1814823"></A>Bits [7:4] : Cache Level described in this structure</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814824"></A>0 - None</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814825"></A>1 - One level cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814826"></A>2 - Two level cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814827"></A>3 - Three level cache</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814828"></A>Other values reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817897"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1814829"></A>Bits [11:8] - Cache Associativity</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814830"></A>0 - None</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814831"></A>1 - Direct Mapped</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814832"></A>2 - Complex Cache Indexing (implementation specific)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814833"></A>Other values reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817900"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1814834"></A>Bits [15:12] - Write Policy</P>
<UL>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814835"></A>0 - None</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814836"></A>1 - Write Back (WB)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814837"></A>2 - Write Through (WT)</LI>
<LI CLASS="TableBullet">
<A NAME="pgfId-1814838"></A>Other values reserved</LI>
</UL>
<P CLASS="TableBody">
<A NAME="pgfId-1817903"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1814839"></A>Bits [31:16] - Cache Line size in bytes</P>
<P CLASS="TableBody">
<A NAME="pgfId-1814840"></A>Number of bytes accessed from next cache level on cache miss.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814842"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814844"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814846"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814848"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814850"></A>Number of SMBIOS handles (n)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814852"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814854"></A>30</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814856"></A>Number of SMBIOS handles that contributes to the memory side cache physical devices.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814858"></A>SMBIOS Handles</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814860"></A>2xn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814862"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1814864"></A>Refers to corresponding SMBIOS Type-17 Handles Structure that contains Physical Memory Component related information</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1809967"></A>Implementation Note: A proximity domain should contain only one set of memory attributes. If memory attributes differ, represent them in different proximity domains. If the Memory Side Cache Information Structure is present, the System Locality Latency and Bandwidth Information Structure shall contain latency and bandwidth information for each memory side cache level.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1806142"></A><A NAME="16209"></A>Platform Debug Trigger Table (PDTT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1806596"></A>This section describes the format of the Platform Debug Trigger Table (PDTT) description table, which is an optional table that describes one or more PCC subspace identifiers that can be used to trigger/notify the platform specific debug facilities to capture non-architectural system state.  This is intended as a standard mechanism for the OSPM to notify the platform of a fatal crash (e.g. kernel panic or bug check).  </P>
<P CLASS="Body">
<A NAME="pgfId-1806597"></A>This table is intended for platforms that provide debug hardware facilities that can capture system info beyond the normal OS crash dump.  This trigger could be used to capture platform specific state information (e.g. firmware state, on-chip hardware facilities, auxiliary controllers, etc.).  This type of debug feature could be leveraged on mobile, client, and enterprise platforms. </P>
<P CLASS="Body">
<A NAME="pgfId-1806598"></A>Certain platforms may have multiple debug subsystems that must be triggered individually.  This table accommodates such systems by allowing multiple triggers to be listed.  </P>
<P CLASS="Body">
<A NAME="pgfId-1837030"></A>After triggering debug facilities, the CPU may continue to operate as expected so that the kernel may continue with crash processing/handling (e.g. possibly attempting to attach a debugger or proceed with a full crash dump prior to rebooting the system), depending on the value defined in Trigger order. Please refer to <A HREF="ACPI_Software_Programming_Model.htm#44319" CLASS="XRef">See PDTT PCC Trigger Order.</A> for more details.</P>
<P CLASS="Body">
<A NAME="pgfId-1806599"></A>After triggering debug facilities, the CPU must continue to operate as expected so that the kernel may continue with crash processing/handling (e.g. possibly attempting to attach a debugger or proceed with a full crash dump prior to rebooting the system).</P>
<P CLASS="Body">
<A NAME="pgfId-1806600"></A>On some platforms, the debug trigger may put some hardware components/peripherals into a frozen non-operational state, and so the debug trigger is not recommended to be used during normal run-time operation.</P>
<P CLASS="Body">
<A NAME="pgfId-1806601"></A>Other platforms may allow the debug trigger for capture system state to debug run-time behavioral issues (e.g. system performance and power issues), specified by the &quot;Run-time&quot; flag field in <BR>
<A HREF="ACPI_Software_Programming_Model.htm#35443" CLASS="XRef">See PDTT Platform Communication Channel Identifier Structure.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1837045"></A>When multiple triggers exist, the triggers within each of the two groups, defined by trigger order, will be executed in order. OSPM may need to wait for PCC completion before executing next trigger based on the &#8220;Wait for Completion&#8221; flag field in <A HREF="ACPI_Software_Programming_Model.htm#35443" CLASS="XRef">See PDTT Platform Communication Channel Identifier Structure.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1806603"></A>Note: The mechanism by which this system debug state information is retrieved by the user is platform and vendor specific.  This will most likely will require special tools and privileges in order to access and parse the platform debug information captured by this trigger.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1806610"></A>PDTT Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806613"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806615"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806617"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806619"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806621"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806623"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806625"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806627"></A>&#8216;PDTT&#8217;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806629"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806631"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806633"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806635"></A>Length in bytes of the entire Platform Debug Trigger Table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806637"></A>Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806639"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806641"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806643"></A>0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806645"></A>Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806647"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806649"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806651"></A>Entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806653"></A>OEM ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806655"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806657"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806659"></A>OEM ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806661"></A>OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806663"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806665"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806667"></A>The table ID is the manufacturer model ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806669"></A>OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806671"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806673"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806675"></A>OEM revision for supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806677"></A>Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806679"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806681"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806683"></A>Vendor ID of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806685"></A>Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806687"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806689"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806691"></A>Revision of utility that created the table.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806693"></A>Trigger Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806695"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806697"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806699"></A>Number of PDTT Platform Communication Channel Identifiers </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806701"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806703"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806705"></A>37</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806707"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806709"></A>Trigger Identifier Array Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806711"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806713"></A>40</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806715"></A>Offset to the &#8220;PDTT Platform Communication Channel Identifiers[]&#8221; Array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806717"></A>PDTT Platform Communication Channel Identifiers []</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806719"></A>---</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806721"></A>Trigger Identifier Array Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806723"></A>Array of PDTT Platform Communication Channel Identifiers to notify various platform debug facilities. This identifier selects the PCC subspace index that must be listed in the PCCT.  It also describes per trigger flags.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806724"></A>Each Identifier is 2 bytes. Must provide a minimum of one identifier</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806725"></A>Described in <A HREF="ACPI_Software_Programming_Model.htm#35443" CLASS="XRef">See PDTT Platform Communication Channel Identifier Structure.</A> below.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1806729"></A><A NAME="35443"></A>PDTT Platform Communication Channel Identifier Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806732"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806734"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806736"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806738"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806740"></A>PDTT PCC Sub Channel Identifier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806742"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806744"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806746"></A>PCC sub channel ID </P>
<P CLASS="TableBody">
<A NAME="pgfId-1806747"></A>Note: this must be an index listed in the PCCT</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806749"></A>Run-time</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806751"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806753"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806755"></A>0: Trigger must only be invoked in fatal crash scenarios.  This debug trigger may put some hardware components/peripherals into a frozen non-operational state</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806756"></A>1: Trigger may be invoked at run-time as well as in fatal crash scenarios</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806758"></A>Wait for Completion</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806760"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806762"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806764"></A>0: OSPM may initiate next trigger immediately</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806765"></A>1: OSPM must wait for PCC complete prior to initiating the next trigger in the list</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837068"></A>Trigger Order</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837070"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837072"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837100"></A>Used in fatal crash scenarios.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1837101"></A>0: OSPM must initiate trigger before kernel crash dump processing </P>
<P CLASS="TableBody">
<A NAME="pgfId-1837074"></A>1: OSPM must initiate trigger at the end of crash dump processing.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806767"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806769"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806771"></A>11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806773"></A>Must be zero</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1806777"></A>PDTT PCC Sub Channel</H6>
<P CLASS="Body">
<A NAME="pgfId-1806778"></A>The PDTT PCC Sub Channel Identifier value provided by the platform in this field should be programmed to the Type field of PCC Communications Subspace Structure. The PDTT references its PCC Subspace in a given platform by this identifier, as shown in <A HREF="ACPI_Software_Programming_Model.htm#35443" CLASS="XRef">See PDTT Platform Communication Channel Identifier Structure.</A>.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1806779"></A>Using PCC registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1806780"></A>OSPM will write PCC registers by filling in the register value in PCC sub channel space and issuing a PCC execute platform debug trigger command. See <A HREF="ACPI_Software_Programming_Model.htm#53425" CLASS="XRef">See PCC Commands Codes used by Platform Debug Trigger Table.</A>. All other command values are reserved.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1806781"></A><A NAME="53425"></A>PCC Commands Codes used by Platform Debug Trigger Table</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806784"></A>Command</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806786"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806788"></A>0x00</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806790"></A>Execute Platform Debug Trigger (doorbell only - no command/response)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806792"></A>0x01</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806794"></A>Execute Platform Debug Trigger (with vendor specific command in communication space)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806796"></A>0x01-0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806798"></A>All other values are reserved.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1806802"></A>PDTT Platform Communication Channel</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806805"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806807"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806809"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806811"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806813"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806815"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806817"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806819"></A>The PCC signature. The signature of a subspace is computed by a bitwise-or of the value 0x50434300 with the subspace ID. For example, subspace 3 has signature 0x50434303.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806821"></A>Command</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806823"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806825"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806827"></A>PCC command field, see Section 14 and Table YYY</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806829"></A>Status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806831"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806833"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806835"></A>PCC status field, see Section 14</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="4">
<P CLASS="TableBody">
<A NAME="pgfId-1806837"></A>Communication </P>
<P CLASS="TableBody">
<A NAME="pgfId-1837293"></A>Space</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806845"></A>Vendor Specific</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806847"></A>variable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806849"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806851"></A>Optional vendor specific command/response area written by OSPM - must be zero if not supported</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1837169"></A><A NAME="44319"></A>PDTT PCC Trigger Order </H6>
<P CLASS="Body">
<A NAME="pgfId-1837170"></A>The trigger order defines two categories for triggers </P>
<P CLASS="Body">
<A NAME="pgfId-1837171"></A>Trigger Order 0: Triggers are invoked by OSPM before executing its crash dump processing functions. </P>
<P CLASS="Body">
<A NAME="pgfId-1837172"></A>Trigger Order 1:  Triggers are invoked by OSPM at the end of crash dump processing functions, typically after the kernel has processed crash dumps. </P>
<P CLASS="Body">
<A NAME="pgfId-1837245"></A>Capturing platform specific debug information from certain IPs would require intrusive mechanism which may limit kernel operations after the operations. Trigger order allows the platform to define such operations that will be invoked at the end of kernel operations by OSPM.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1806855"></A>Example: OS Invoking Multiple Debug Triggers </H6>
<P CLASS="Body">
<A NAME="pgfId-1806856"></A>To illustrate how these debug triggers are intended to be used by the OS, consider this example of a system with 4 independent debug triggers as shown in <A HREF="ACPI_Software_Programming_Model.htm#78147" CLASS="XRef">See Example: Platform with 4 debug triggers.</A>. These triggers are described to the OS via the PDTT example in <A HREF="ACPI_Software_Programming_Model.htm#53951" CLASS="XRef">See Example: Platform with 4 debug triggers.</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1806857"></A>Note: This example assumes no vendor specific communication is required, so only PCC command 0x0 is used.</P>
<P CLASS="Body">
<A NAME="pgfId-1806858"></A>When the OS encounters a fatal crash, prior to collecting a crash dump and rebooting the system, the OS may choose to invoke the debug triggers in the order listed in the PDTT. The addresses of the doorbell register and the PCC general communication space (if needed) are retrieved from the PCCT, depending on the PCC subspace type (see <A HREF="Platform_Comm_Channel.htm#55497" CLASS="XRef">See PCC Subspace Structure type 0 (Generic Communications Subspace).</A>, <A HREF="Platform_Comm_Channel.htm#56025" CLASS="XRef">See PCC Subspace Structure type 1 (HW-Reduced Communications Subspace).</A>, or <A HREF="Platform_Comm_Channel.htm#66530" CLASS="XRef">See PCC Subspace Structure type 2 (HW-Reduced Communications Subspace).</A>). </P>
<P CLASS="Body">
<A NAME="pgfId-1817283"></A>&nbsp;</P>
<P CLASS="Normal">
<A NAME="pgfId-1806862"></A><IMG SRC="ACPI_Software_Programming_Model-12.gif" ALIGN="BASELINE" ALT="">
&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1806863"></A><A NAME="78147"></A>Example: Platform with 4 debug triggers</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1806864"></A><A NAME="53951"></A>Example: Platform with 4 debug triggers</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832115"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832117"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832119"></A>Notes</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806873"></A>Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806875"></A>&#8216;PDTT&#8217;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806877"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806879"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806881"></A>...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806883"></A>...</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806885"></A>Trigger Count</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806887"></A>4 </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806889"></A>Describing the 4 triggers illustrated in Figure XXX above</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806891"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806893"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806895"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806897"></A>Trigger Identifier Array Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806899"></A>44</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806901"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806903"></A>PDTT PCC Identifiers [0]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806905"></A>0x0004</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806907"></A>[Bits 0:7] - 4 (channel subspace ID  4)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806908"></A>[Bit 8] - 0 (Trigger may only be invoked in fatal crash scenarios)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806909"></A>[Bit 9] - 0 (OSPM may initiate next trigger immediately)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806911"></A>PDTT PCC Identifiers [1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806913"></A>0x0201</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806915"></A>[Bits 0:7] - 1 (channel ID  subspace 1)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806916"></A>[Bit 8] - 0 (Trigger may only be invoked in fatal crash scenarios)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806917"></A>[Bit 9] - 1 (OSPM must wait for PCC complete prior to initiating the next trigger in the list)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806919"></A>PDTT PCC Identifiers [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806921"></A>0x0002</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806923"></A>[Bits 0:7] - 2 (channel ID  subspace 2)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806924"></A>[Bit 8] - 0 (Trigger may only be invoked in fatal crash scenarios)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806925"></A>[Bit 9] - 0 (OSPM may initiate next trigger immediately)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806927"></A>PDTT PCC Identifiers [3]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806929"></A>0x0203</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1806931"></A>[Bits 0:7] - 3  (channel ID  subspace 3)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806932"></A>[Bit 8] - 0 (Trigger may only be invoked in fatal crash scenarios)</P>
<P CLASS="TableBody">
<A NAME="pgfId-1806933"></A>[Bit 9] - 1 (OSPM must wait for PCC complete prior to initiating the next trigger in the list)</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1806937"></A>Walking through the list of triggers in the PDTT, the OS may execute the following steps:</P>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1807427"></A>For Trigger 0, retrieves doorbell register address from PCCT per PCC subspace ID 4 and writes to it with appropriate write/preserve mask.  Since OS does not need to wait for completion, OS does not need to send a PCC command and should ignore the PCC subspace base address</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1807428"></A>For Trigger 1, retrieves doorbell register address and PCC subspace address from PCCT per PCC subspace ID 1. Since OS must wait for completion, OS must write PCC command (0x0) and write to the doorbell register per section 14 and poll for the completion bit.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1807429"></A>For Trigger 2, , retrieves doorbell register address from PCCT per PCC subspace ID 2 and writes to it with appropriate write/preserve mask.  Since OS does not need to wait for completion, OS does not need to send a PCC command and should ignore the PCC subspace base address</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1807430"></A>For Trigger 3, retrieves doorbell register address and PCC subspace address from PCCT per PCC subspace ID 3. Since OS must wait for completion, OS must write PCC command (0x0) and write to the doorbell register per section 14 and poll for the completion bit.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1806176"></A>Note: When wait for completion is necessary, the OS must poll bit zero (completion bit) of the status field of that PCC channel (see <A HREF="Platform_Comm_Channel.htm#66530" CLASS="XRef">See PCC Subspace Structure type 2 (HW-Reduced Communications Subspace).</A> and <A HREF="Platform_Comm_Channel.htm#_Ref272262201" CLASS="XRef">See Generic Communications Channel Shared Memory Region.</A>).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1817972"></A><A NAME="67872"></A>Processor Properties Topology Table (PPTT)</H6>
<P CLASS="Body">
<A NAME="pgfId-1807581"></A>This optional table is used to describe the topological structure of processors controlled by the OSPM, and their shared resources, such as caches. The table can also describe additional information such as which nodes in the processor topology constitute a physical package. The structure of PPTT is described in <A HREF="ACPI_Software_Programming_Model.htm#91448" CLASS="XRef">See Processor Properties Topology Table.</A>.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1807582"></A><A NAME="91448"></A>Processor Properties Topology Table</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1808196"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1808198"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1808200"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1808202"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807593"></A>Header</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807595"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807597"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807599"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807601"></A>    Signature</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807603"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807605"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807607"></A>&#8216;PPTT&#8217; Processor Properties Topology Table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807609"></A>    Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807611"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807613"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807615"></A>Length of entire PPTT table in bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807617"></A>    Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807619"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807621"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807623"></A>2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807625"></A>    Checksum</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807627"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807629"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807631"></A>The entire table must sum to zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807633"></A>    OEMID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807635"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807637"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807639"></A>OEM ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807641"></A>    OEM Table ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807643"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807645"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807647"></A>OEM revision of table for supplied OEM Table ID</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807649"></A>    OEM Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807651"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807653"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807655"></A>OEM revision of the PPTT for the supplied OEM Table ID.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807657"></A>    Creator ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807659"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807661"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807663"></A>Vendor ID of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807665"></A>    Creator Revision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807667"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807669"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807671"></A>Revision of utility that created the table</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807673"></A>Body</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807675"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807677"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807679"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807681"></A>Processor topology structure[N]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807683"></A>-</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807685"></A>36</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807687"></A>List of processor topology structures</P>
</TD>
</TR>
</TABLE>
<P CLASS="Normal">
<A NAME="pgfId-1834494"></A>&nbsp;</P>
<P CLASS="Normal">
<A NAME="pgfId-1807691"></A>Processor topology structures are described in the following sections.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1818175"></A><A NAME="64795"></A>Processor hierarchy node structure (Type 0)</H6>
<P CLASS="Body">
<A NAME="pgfId-1807693"></A>The processor hierarchy node structure is described in <A HREF="ACPI_Software_Programming_Model.htm#70115" CLASS="XRef">See Processor Hierarchy Node Structure.</A>. This structure can be used to describe a single processor or a group. To describe topological relationships, each processor hierarchy node structure can point to a parent processor hierarchy node structure. This allows representing tree like topology structures. Multiple trees may be described, covering for example multiple packages. For the root of a tree, the parent pointer should be 0.</P>
<P CLASS="Body">
<A NAME="pgfId-1834110"></A>If PPTT is present, one instance of this structure must be present for every individual processor presented through the MADT interrupt controller structures. In addition, an individual entry must be present for every instance of a group of processors that shares a common resource described in the PPTT. Resources are described in other PPTT structures such as Type 1 cache structures. Each physical package in the system must also be represented by a processor node structure. </P>
<P CLASS="Body">
<A NAME="pgfId-1807693"></A>Each processor node includes a list of resources that are private to that node. Resources are described in other PPTT structures such as Type 1 cache structures. The processor node&#8217;s private resource list includes a reference to each of the structures that represent private resources to a given processor node. For example, an SoC level processor node might contain two references, one pointing to a Level 3 cache resource and another pointing to an ID structure. For compactness, separate instances of an identical resource can be represented with a single structure that is listed as a resource of multiple processor nodes. </P>
<P CLASS="Body">
<A NAME="pgfId-1834171"></A>For example, is expected that in the common case all processors will have identical L1 caches. For these platforms a single L1 cache structure could be listed by all processors:</P>
<P CLASS="Body">
<A NAME="pgfId-1834408"></A>&nbsp;</P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-13.gif" ALT="">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-1834128"></A>Note: though less space efficient, it is also acceptable to declare a node for each instance of a resource. In the example above, it would be legal to declare an L1 for each processor.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1834106"></A><A NAME="70115"></A>Processor Hierarchy Node Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832225"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832227"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832229"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832231"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807705"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807707"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807709"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807711"></A>0 - processor structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807713"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807715"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807717"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807719"></A>Length of the local processor structure in bytes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807721"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807723"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807725"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807727"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807729"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807731"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807733"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807735"></A>See <A HREF="ACPI_Software_Programming_Model.htm#64610" CLASS="XRef">See Processor Structure Flags.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807737"></A>Parent</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807739"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807741"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807743"></A>Reference to parent processor hierarchy node structure. The reference is encoded as the difference between the start of the PPTT table and the start of the parent processor structure entry. A value of zero must be used where a node has no parent.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807745"></A>ACPI Processor ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807747"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807749"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807751"></A>If the processor structure represents an actual processor, this field must match the value of ACPI processor ID field in the processor&#8217;s entry in the MADT.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807752"></A>If the processor structure represents a group of associated processors, the structure might match a processor container in the name space. In that case this entry will match the value of the _UID method of the associated processor container. Where there is a match it must be represented.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1834479"></A>The flags field, described in <A HREF="ACPI_Software_Programming_Model.htm#64610" CLASS="XRef">See Processor Structure Flags.</A> includes a bit to describe whether the ACPI processor ID is valid.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807754"></A>Number of private resources</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807756"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807758"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807760"></A>Number of resource structure references in Private Resources (below)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807762"></A>Private resources[N]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807764"></A>N*4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807766"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807768"></A>Each resource is a reference to another PPTT structure. The structure referred to must not be a processor hierarchy node. Each resource structure pointed to represents resources that are private the processor hierarchy node. For example, for cache resources, the cache type structure represents caches that are private to the instance of processor topology represented by this processor hierarchy node structure. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1807769"></A>The references are encoded as the difference between the start of the PPTT table and the start of the resource structure entry.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1809424"></A>Processor Structure Flags are described in <A HREF="ACPI_Software_Programming_Model.htm#64610" CLASS="XRef">See Processor Structure Flags.</A>.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1807774"></A><A NAME="64610"></A>Processor Structure Flags</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832443"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832445"></A>Bit Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832447"></A>Bit Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832449"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807786"></A>Physical package</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807788"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807790"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807792"></A>Set to 1 if this node of the processor topology represents the boundary of a physical package, whether socketed or surface mounted.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807793"></A>Set to 0 if this instance of the processor topology does not represent the boundary of a physical package.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1834178"></A>Each valid processor must belong to exactly one package.  That is, the leaf must itself be a physical package or have an ancestor marked as a physical package.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807795"></A>ACPI Processor ID valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807797"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807799"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807801"></A>For non-leaf entries in the processor topology, the ACPI Processor ID entry can relate to a Processor container in the namespace. The processor container will have a matching ID value returned through the _UID method. As not every processor hierarchy node structure in PPTT may have a matching processor container, this flag indicates whether the ACPI processor ID points to valid entry. Where a valid entry is possible the ACPI Processor ID and _UID method are mandatory.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1834193"></A>For leaf entries in PPTT that represent processors listed in MADT, the ACPI Processor ID must always be provided and this flag must be set to 1. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834214"></A>Processor is a Thread</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834216"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834218"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834284"></A>For leaf entries: must be set to 1 if the processing element representing this processor shares functional units with sibling nodes.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1834220"></A>For non-leaf entries: must be set to 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834222"></A>Node is a Leaf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834224"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834226"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1834228"></A>Must be set to 1 if node is a leaf in the processor hierarchy.  Else must be set to 0.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842300"></A>Identical Implementation</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842302"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842304"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1842348"></A>A value of 1 indicates that all children processors share an identical implementation revision.  </P>
<P CLASS="TableBody">
<A NAME="pgfId-1842349"></A>This field should be ignored on leaf nodes by the OSPM.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1842306"></A>Note: this implies an identical processor version and identical implementation reversion, not just a matching architecture revision.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807803"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807805"></A>27</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807807"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807809"></A>Must be zero</P>
</TD>
</TR>
</TABLE>
<P CLASS="Normal">
<A NAME="pgfId-1807813"></A>Note: Threads sharing a core must be grouped under a unique Processor hierarchy node structure for each group of threads.</P>
<P CLASS="Normal">
<A NAME="pgfId-1807814"></A>Note: processors may be marked as disabled in the MADT. In this case, the corresponding processor hierarchy node structures in PPTT should be considered as disabled.  Additionally, all processor hierarchy node structures representing a group of processors with all child processors disabled should be considered as being disabled.  All resources attached to disabled processor hierarchy node structures in PPTT should also be considered disabled.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1818199"></A>Cache Type Structure - Type 1</H6>
<P CLASS="Body">
<A NAME="pgfId-1807817"></A>The cache type structure is described in <A HREF="ACPI_Software_Programming_Model.htm#58886" CLASS="XRef">See Cache Type Structure.</A>. The cache type structure can be used to represent a set of caches that are private to a particular processor hierarchy node structure, that is, to a particular node in the processor topology tree. The set of caches is described as a NULL, or zero, terminated linked list. Only the head of the list needs to be listed as a resource by a processor node (and counted toward Number of Private Resources), as the cache node itself contains a link to the next level of cache. </P>
<P CLASS="Body">
<A NAME="pgfId-1807818"></A>Cache type structures are optional, and can be used to complement or replace cache discovery mechanisms provided by the processor architecture. For example, some processor architectures describe individual cache properties, but do not provide ways of discovering which processors share a particular cache. When cache structures are provided, all processor caches must be described in a cache type structure. </P>
<P CLASS="Body">
<A NAME="pgfId-1834342"></A>Each cache type structure includes a reference to the cache type structure that represents the next level cache. The level in this context must relate to the CPU architecture&#8217;s definition of cache level. The list must include all caches that are private to a processor hierarchy node. It is not permissible to skip levels. That is, a cache node included in a given hierarchy processor node level must not point to a cache structure referred to by a processor node in a different level of the hierarcy. </P>
<P CLASS="Body">
<A NAME="pgfId-1834372"></A>For example, if a node represents a CPU that has a private L1 and private L2 cache, the list would contain both caches (L1-&gt;L2-&gt;0). If on the other hand the L2 cache was shared, the list would just include the L1 (L1-&gt;0), and a parent processor topology node, to all processors that share the L2, would contain the cache type structure that represents the shared L2. </P>
<P CLASS="Body">
<A NAME="pgfId-1846925"></A>Processors, or higher level nodes within the hierarchy, with separate instruction and data caches must describe the instruction and data caches with separate linked lists of cache type structures both listed as private resources of the relevant processor hierarchy node structure.  If the separate instruction are data caches are unified at a higher level of cache then the linked lists should converge.  </P>
<P CLASS="Body">
<A NAME="pgfId-1834459"></A>Consider the following example.</P>
<P CLASS="Body">
<A NAME="pgfId-1834343"></A> &nbsp;</P>
<DIV>
<IMG SRC="ACPI_Software_Programming_Model-14.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1834396"></A>Cache Type Structure - Type 1 Example</H6>
<P CLASS="Body">
<A NAME="pgfId-1834345"></A>In this example:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1834346"></A>Each processor has private L1 data, L1 intruction and L2 caches. The two processors are contained in a cluster which provides an L3 cache.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1834347"></A>Each processor&#8217;s hierarchy node has two separate cache type structures as private resources for L1I and L1D</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1834348"></A>Both the L1I and L1D cache structures point to the L2 cache structure as their next level of cache</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1834349"></A>L2 cache type structure terminates the linked list of the CPU&#8217;s caches. The resulting list denotes all private caches at the processor level</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1834350"></A>Both processor nodes have their parent pointer pointing to node that represents the cluster.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1834351"></A>The cluster node includes the L3 cache as it&#8217;s private resource. The L3 node in turn has no next level of cache.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1807820"></A>An entry in the list indicates primarily that a cache exists at this node in the hierarchy. Where possible, cache properties should be discovered using processor architectural mechanisms, but the cache type structure may also provide the properties of the cache. A flag is provided to indicate whether properties provided in the table are valid, in which case the table content should be used in preference to processor architected discovery. On Arm-based systems, all cache properties must be provided in the table.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1807821"></A><A NAME="58886"></A>Cache Type Structure</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1809226"></A>Field</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1809228"></A>Byte Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1809230"></A>Byte Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1809232"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807832"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807834"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807836"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807838"></A>1 - Cache type structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807840"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807842"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807844"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807846"></A>24</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807848"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807850"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807852"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807854"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807856"></A>Flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807858"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807860"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807862"></A>See <A HREF="ACPI_Software_Programming_Model.htm#44764" CLASS="XRef">See Cache Structure Flags.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807864"></A>Next Level of Cache</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807866"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807868"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807870"></A>Reference to next level of cache that is private to the processor topology instance. The reference is encoded as the difference between the start of the PPTT table and the start of the cache type structure entry. This value will be zero if this entry represents the last cache level appropriate to the the processor hierarchy node structures using this entry.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807872"></A>Size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807874"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807876"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807878"></A>Size of the cache in bytes. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807880"></A>Number of sets</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807882"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807884"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807886"></A>Number of sets in the cache</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807888"></A>Associativity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807890"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807892"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807894"></A>Integer number of ways. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807896"></A>Attributes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807898"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807900"></A>21</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807902"></A>Bits 1:0: Allocation type</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807903"></A>0x0 - Read allocate</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807904"></A>0x1 - Write allocate</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807905"></A>0x2 or 0x03 indicate Read and Write allocate</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807906"></A>Bits:3:2: Cache type: </P>
<P CLASS="TableBody">
<A NAME="pgfId-1807907"></A>0x0 Data</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807908"></A>0x1 Instruction</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807909"></A>0x2 or 0x3 Indicate a unified cache</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807910"></A>Bits   4: Write policy:</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807911"></A>0x0 Write back</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807912"></A>0x1 Write through</P>
<P CLASS="TableBody">
<A NAME="pgfId-1807913"></A>Bits:7:5 Reserved must be zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807915"></A>Line size</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807917"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807919"></A>22</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807921"></A>Line size in bytes</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1807925"></A>The cache type structure flags are described in <A HREF="ACPI_Software_Programming_Model.htm#44764" CLASS="XRef">See Cache Structure Flags.</A>. </P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1807926"></A><A NAME="44764"></A>Cache Structure Flags</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832542"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832544"></A>Bit Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832546"></A>Bit Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Body">
<A NAME="pgfId-1832548"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807938"></A>Size property valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807940"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807942"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807944"></A>Set to 1 if the size properties described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this property.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807946"></A>Number of sets valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807948"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807950"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807952"></A>Set to 1 if the number of sets property described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this property.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807954"></A>Associativity valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807956"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807958"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807960"></A>Set to 1 if the associativity property described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this property.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807962"></A>Allocation type valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807964"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807966"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807968"></A>Set to 1 if the allocation type attribute described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this attribute.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807970"></A>Cache type valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807972"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807974"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807976"></A>Set to 1 if the cache type attribute described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this attribute.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807978"></A>Write policy valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807980"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807982"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807984"></A>Set to 1 if the write policy attribute described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this attribute.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807986"></A>Line size valid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807988"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807990"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807992"></A>Set to 1 if the line size property described is valid. A value of 0 indicates that, where possible, processor architecture specific discovery mechanisms should be used to ascertain the value of this property.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807994"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807996"></A>25</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1807998"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808000"></A>Must be zero</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1808004"></A><A NAME="61595"></A>ID structure - Type 2</H6>
<P CLASS="Body">
<A NAME="pgfId-1808005"></A>The ID type structure is described in <A HREF="ACPI_Software_Programming_Model.htm#82197" CLASS="XRef">See ID Type Structure.</A>. The ID structure can be used to provide an ID (or vendor specific part number) for a particular processor hierarchy node structure. The ID structure is optional, and may be used by software to determine special features and/or errata workarounds for that processor hierarchy node. This ID structure can also be used to identify all underlying hierarchy nodes and components, which may include identifying proprietary hardware components that are not explicitly described in this table. </P>
<P CLASS="Body">
<A NAME="pgfId-1808006"></A>This ID structure would typically be used to describe an ID of a physical package node, but may be optionally used at any node level.</P>
<P CLASS="Body">
<A NAME="pgfId-1808007"></A>Example: In the case where this ID structure is used to uniquely describe a physical package node, it could represent a single system-on-chip (SoC) on a single die and all nodes and components within that node (e.g. processors, caches, system buses and DMA engines, interrupt controllers, on-chip peripherals, etc.). The silicon vendor of this SoC has a known erratum with a particular hardware component in that SoC that could impact behavior and/or correctness. An operating system vendor may query this ID structure to first determine the silicon vendor, then later acquire the remaining ID fields to determine part number, matching it against the part with a known erratum. The operating system may then remedy errata by either disabling relevant features or applying an appropriate software work around.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1808008"></A><A NAME="82197"></A>ID Type Structure</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832638"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832640"></A>Byte Length</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832642"></A>Byte Offset</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832644"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808019"></A>Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808021"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808023"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808025"></A>2 - ID structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808027"></A>Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808029"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808031"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808033"></A>30</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808035"></A>Reserved</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808037"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808039"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808041"></A>Must be zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808043"></A>VENDOR_ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808045"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808047"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808049"></A><A HREF="http://www.uefi.org/acpi_id_list" CLASS="URL">This identifies the node vendor using the vendor ACPI ID as described in the ACPI ID registry is available at  http://www.uefi.org/acpi_id_list</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808052"></A>LEVEL_1_ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808054"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808056"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808058"></A>Vendor specific value to identify first level unique node ID (e.g. chip family ID) </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808060"></A>LEVEL_2_ID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808062"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808064"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808066"></A>Vendor specific value to identify second level unique node ID (e.g. chip ID)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808068"></A>MAJOR_REV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808070"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808072"></A>24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808074"></A>Vendor specific value to identify major revision of the node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808076"></A>MINOR_REV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808078"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808080"></A>26</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808082"></A>Vendor specific value to identify minor revision of the node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808084"></A>SPIN_REV</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808086"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808088"></A>28</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1808090"></A>Vendor specific value to identify spin revision of the node</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1753048"></A>ACPI Namespace <A NAME="marker-1807417"></A><A NAME="marker-1807418"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1362518"></A>For all Definition Blocks, the system maintains a single hierarchical namespace that it uses to refer to objects. All Definition Blocks load into the same namespace. Although this allows one Definition Block to reference objects and data from another (thus enabling interaction), it also means that OEMs must take care to avoid any naming collisions<A HREF="#pgfId-1362521" CLASS="footnote">2</A>. A name collision in an attempt to load a Definition Block is considered fatal. The contents of the namespace changes only on a load operation.</P>
<P CLASS="Body">
<A NAME="pgfId-1362522"></A>The namespace is hierarchical in nature, with each name allowing a collection of names &#8220;below&#8221; it. The following naming conventions apply to all names:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1362523"></A>All names are a fixed 32 bits.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362524"></A>The first byte of a name is inclusive of: &#8216;A&#8217;-&#8216;Z&#8217;, &#8216;_&#8217;, (0x41-0x5A, 0x5F).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362525"></A>The remaining three bytes of a name are inclusive of: &#8216;A&#8217;-&#8216;Z&#8217;, &#8216;0&#8217;-&#8216;9&#8217;, &#8216;_&#8217;, (0x41-0x5A, 0x30-0x39, 0x5F).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362526"></A>By convention, when an ASL compiler pads a name shorter than 4 characters, it is done so with trailing underscores (&#8216;_&#8217;). See the language definition for AML NameSeg in the <A HREF="ACPI_Source_Language_Reference.htm#94069" CLASS="XRef">See ACPI Source Language (ASL) Reference.</A> chapter. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362527"></A>Names beginning with &#8216;_&#8217; are reserved by this specification. Definition Blocks can only use names beginning with &#8216;_&#8217; as defined by this specification.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362528"></A>A name proceeded with &#8216;&#92;&#8217; causes the name to refer to the root of the namespace (&#8216;&#92;&#8217; is not part of the 32-bit fixed-length name).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362529"></A>A name proceeded with &#8216;^&#8217; causes the name to refer to the parent of the current namespace (&#8216;^&#8217; is not part of the 32-bit fixed-length name).</LI>
</UL>
<DIV>
<H6 CLASS="Pb">
<A NAME="pgfId-1712343"></A>&nbsp;</H6>
<P CLASS="Body">
<A NAME="pgfId-1712344"></A>Except for names preceded with a &#8216;&#92;&#8217;, the current namespace determines where in the namespace hierarchy a name being created goes and where a name being referenced is found. A name is located by finding the matching name in the current namespace, and then in the parent namespace. If the parent namespace does not contain the name, the search continues recursively upwards until either the name is found or the namespace does not have a parent (the root of the namespace). This indicates that the name is not found<A HREF="#pgfId-1712347" CLASS="footnote">3</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1362542"></A>An attempt to access names in the parent of the root will result in the name not being found.</P>
<P CLASS="Body">
<A NAME="pgfId-1362543"></A>There are two types of namespace paths: an absolute namespace path (that is, one that starts with a &#8216;&#92;&#8217; prefix), and a relative namespace path (that is, one that is relative to the current namespace). The namespace search rules discussed above, only apply to single NameSeg paths, which is a relative namespace path. For those relative name paths that contain multiple NameSegs or Parent Prefixes, &#8216;^&#8217;, the search rules do not apply. If the search rules do not apply to a relative namespace path, the namespace object is looked up relative to the current namespace. For example:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362544"></A>ABCD			    //search rules apply</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362545"></A>^ABCD		       //search rules do not apply</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362546"></A>XYZ.ABCD		    //search rules do not apply</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362547"></A>&#92;XYZ.ABCD		   //search rules do not apply </P>
<P CLASS="Body">
<A NAME="pgfId-1362548"></A>All name references use a 32-bit fixed-length name or use a Name Extension prefix to concatenate multiple 32-bit fixed-length name components together. This is useful for referring to the name of an object, such as a control method, that is not in the scope of the current namespace.</P>
<P CLASS="Body">
<A NAME="pgfId-1835929"></A>Namepaths are used primarily for two purposes:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1835930"></A>To reference an existing object. In this case, all NameSegs within the Namepath must already exist.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1835954"></A>	To create a new object. For example:</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1835932"></A>Device (XYZ.ABCD) {...}<BR>
OperationRegion (&#92;XYZ.ABCD, SystemMemory, 0, 0x200)</P>
<P CLASS="Body">
<A NAME="pgfId-1835935"></A>Each of these declarations is intended to create a new object with the name ABCD according the following rules:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1835936"></A>Object XYZ must already exist for the ABCD object to be created</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1835937"></A>If XYZ does not exist, that will cause a fatal error</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1835921"></A>In general, it is only the final Nameseg that will be used as the name of the new object. If any other Nameseg along the Namepath does not exist, it is a fatal error. In this sense, the Namepath is similar to a file pathname in a filesystem consisting of some number of existing directories followed by a final filename.</P>
<P CLASS="Body">
<A NAME="pgfId-1362555"></A>The figure below shows a sample of the ACPI namespace after a Differentiated Definition Block has been loaded.</P>
</DIV>
<DIV>
<H6 CLASS="Art">
<A NAME="pgfId-1745568"></A><IMG SRC="ACPI_Software_Programming_Model-15.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H6>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1745569"></A>Example ACPI NameSpace</H6>
<P CLASS="Body">
<A NAME="pgfId-1362562"></A>Care must be taken when accessing namespace objects using a relative single segment name because of the namespace search rules. An attempt to access a relative object recurses toward the root until the object is found or the root is encountered. This can cause unintentional results. For example, using the namespace described in Figure 5.5, attempting to access a _CRS named object from within the &#92;_SB_.PCI0.IDE0 will have different results depending on if an absolute or relative path name is used. If an absolute pathname is specified (&#92;_SB_.PCI0.IDE0._CRS) an error will result since the object does not exist. Access using a single segment name (_CRS) will actually access the &#92;_SB_.PCI0._CRS object. Notice that the access will occur successfully with no errors.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362584"></A><A NAME="marker-1362581"></A><A NAME="99993"></A>Predefined Root Namespaces</H6>
<P CLASS="Body">
<A NAME="pgfId-1362585"></A>The following namespaces are defined under the namespace root.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362586"></A>Namespaces Defined Under the Namespace Root</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730410"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730412"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362594"></A><A NAME="RSVD_GPE"></A>&#92;_GPE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362596"></A>General events in GPE register block.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362599"></A><A NAME="RSVD_PR"></A>&#92;_PR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362601"></A>ACPI 1.0 Processor Namespace. ACPI 1.0 requires all Processor objects to be defined under this namespace. ACPI 2.0 and later allow Processor object definitions under the &#92;_SB namespace. Platforms may maintain the &#92;_PR namespace for compatibility with ACPI 1.0 operating systems, but it is otherwise deprecated. see the compatibility note in <A HREF="ACPI_Software_Programming_Model.htm#38264" CLASS="XRef">See Processor Local x2APIC Structure.</A>. An ACPI-compatible namespace may define Processor objects in either the &#92;_SB or &#92;_PR scope but not both.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1362602"></A>For more information about defining Processor objects, see <A HREF="Processor_Configuration_and_Control.htm#48288" CLASS="XRef">See Processor Configuration and Control.</A>, &#8220;Processor Configuration and Control.&#8221; </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362605"></A><A NAME="RSVD_SB"></A>&#92;_SB</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362607"></A>All Device/Bus Objects are defined under this namespace.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362610"></A><A NAME="RSVD_SI"></A>&#92;_SI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362612"></A>System indicator objects are defined under this namespace. For more information about defining system indicators, see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#_Toc489256134" CLASS="XRef">See &#92;_SI System Indicators.</A>, &#92;_SI System Indicators.&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362615"></A><A NAME="RSVD_TZ"></A>&#92;_TZ</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1362617"></A>ACPI 1.0 Thermal Zone namespace. ACPI 1.0 requires all Thermal Zone objects to be defined under this namespace. Thermal Zone object definitions may now be defined under the &#92;_SB namespace. ACPI-compatible systems may maintain the &#92;_TZ namespace for compatibility with ACPI 1.0 operating systems. An ACPI-compatible namespace may define Thermal Zone objects in either the &#92;_SB or &#92;_TZ scope but not both.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1362618"></A>For more information about defining Thermal Zone objects, see <A HREF="Thermal_management.htm#54593" CLASS="XRef">See Thermal Management.</A>, &#8220;Thermal Management.&#8221;</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362634"></A><A NAME="_Toc489256020"></A><A NAME="_Toc489267944"></A><A NAME="_Toc489272497"></A><A NAME="_Toc202340548"></A><A NAME="_Toc258262232"></A>Objects<A NAME="marker-1783694"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1362635"></A>All objects, except locals, have a global scope. Local data objects have a per-invocation scope and lifetime and are used to process the current invocation from beginning to end.</P>
<P CLASS="Body">
<A NAME="pgfId-1362636"></A>The contents of objects vary greatly. Nevertheless, most objects refer to data variables of any supported data type, a control method, or system software-provided functions.</P>
<P CLASS="Body">
<A NAME="pgfId-1362637"></A>Objects may contain a revision field. Successive ACPI specifications define object revisions so that they are backwards compatible with OSPM implementations that support previous specifications / object revisions. New object fields are added at the end of previous object definitions. OSPM interprets objects according to the revision number it supports including all earlier revisions. As such, OSPM expects that an object&#8217;s length can be greater than or equal to the length of the known object revision. When evaluating objects with revision numbers greater than that known by OSPM, OSPM ignores internal object fields values that are beyond the defined object field range for the known revision.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1370634"></A><A NAME="_Toc489256021"></A><A NAME="_Toc489267945"></A><A NAME="_Toc489272498"></A><A NAME="_Toc202340549"></A><A NAME="_Toc258262233"></A>Definition Block Encoding<A NAME="marker-1362650"></A><A NAME="marker-1362651"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1376406"></A>This section specifies the encoding used in a Definition Block to define names (load time only), objects, and packages. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1787720"></A>AML Encoding</H6>
<P CLASS="Body">
<A NAME="pgfId-1787718"></A>The Definition Block is encoded as a stream from beginning to end. The lead byte in the stream comes from the AML encoding tables shown in <A HREF="ACPI_Source_Language_Reference.htm#94069" CLASS="XRef">See ACPI Source Language (ASL) Reference.</A>, &#8220;ACPI Source Language (ASL) Reference,&#8221; and signifies how to interpret some number of following bytes, where each following byte can in turn signify how to interpret some number of following bytes. For a full specification of the AML encoding, see <A HREF="ACPI_Source_Language_Reference.htm#94069" CLASS="XRef">See ACPI Source Language (ASL) Reference.</A>, &#8220;ACPI Source Language (ASL) Reference.&#8221; <A NAME="marker-1376410"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1376411"></A>Within the stream there are two levels of data being defined. One is the packaging and object declarations (load time), and the other is an object reference (package contents/run-time).</P>
<P CLASS="Body">
<A NAME="pgfId-1362662"></A>All encodings are such that the lead byte of an encoding signifies the type of declaration or reference being made. The type either has an implicit or explicit length in the stream. All explicit length declarations take the form shown below, where PkgLength is the length of the inclusive length of the data for the operation.</P>
</DIV>
<DIV>
<H6 CLASS="Art">
<A NAME="pgfId-1362666"></A><IMG SRC="ACPI_Software_Programming_Model-16.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H6>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1362667"></A>AML Encoding</H6>
<P CLASS="Body">
<A NAME="pgfId-1362668"></A>Encodings of implicit length objects either have fixed length encodings or allow for nested encodings that, at some point, either result in an explicit or implicit fixed length.</P>
<P CLASS="Body">
<A NAME="pgfId-1362669"></A>The PkgLength is encoded as a series of 1 to 4 bytes in the stream with the most significant two bits of byte zero, indicating how many following bytes are in the PkgLength encoding. The next two bits are only used in one-byte encodings, which allows for one-byte encodings on a length up to 0x3F. Longer encodings, which do not use these two bits, have a maximum length of the following: two-byte encodings of 0x0FFF, three-byte encodings of 0x0FFFFF, and four-byte length encodings of 0x0FFFFFFFF.</P>
<P CLASS="Body">
<A NAME="pgfId-1362670"></A>It is fatal for a package length to not fall on a logical boundary. For example, if a package is contained in another package, then by definition its length must be contained within the outer package, and similarly for a datum of implicit length. </P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1787738"></A><A NAME="36467"></A>Definition Block Loading</H6>
<P CLASS="Body">
<A NAME="pgfId-1362671"></A>At some point, the system software decides to &#8220;load&#8221; a Definition Block. Loading is accomplished when the system makes a pass over the data and populates the ACPI namespace and initializes objects accordingly. The namespace for which population occurs is either from the current namespace location, as defined by all nested packages or from the root if the name is preceded with &#8216;&#92;&#8217;. </P>
<P CLASS="Body">
<A NAME="pgfId-1362672"></A>The first object present in a Definition Block must be a named control method. This is the Definition Block&#8217;s initialization control.</P>
<P CLASS="Body">
<A NAME="pgfId-1362673"></A>Packages are objects that contain an ordered reference to one or more objects. A package can also be considered a vertex of an array, and any object contained within a package can be another package. This permits multidimensional arrays of fixed or dynamic depths and vertices.</P>
<P CLASS="Body">
<A NAME="pgfId-1376394"></A>Unnamed objects are used to populate the contents of named objects. Unnamed objects cannot be created in the &#8220;root.&#8221; Unnamed objects can be used as arguments in control methods.<A NAME="marker-1376395"></A><A NAME="marker-1376396"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1743224"></A>Control method execution may generate errors when creating objects. This can occur if a Method that creates named objects blocks and is reentered while blocked. This will happen because all named objects have an absolute path. This is true even if the object name specified is relative. For example, the following ASL code segments are functionally identical.</P>
<P CLASS="Body">
<A NAME="pgfId-1743244"></A>(1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362681"></A>     Method (DEAD,) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362682"></A>         Scope (&#92;_SB_.FOO) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362683"></A>             Name (BAR,)  			// Run time definition</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362684"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362685"></A>     }</P>
<P CLASS="Body">
<A NAME="pgfId-1684753"></A>(2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362687"></A>     Scope (&#92;_SB_) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362688"></A>         Name (&#92;_SB_. FOO.BAR,)  	// Load time definition</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362689"></A>     }</P>
<P CLASS="Body">
<A NAME="pgfId-1362690"></A>Notice that in the above example the execution of the DEAD method will always fail because the object &#92;_SB_.FOO.BAR is created at load time. </P>
<P CLASS="Body">
<A NAME="pgfId-1787774"></A>The term of &quot;Definition Block level&quot; is used to refer to the AML byte streams that are not contained in any control method. Such AML byte streams can appear in the &quot;root&quot; scope or in the scopes created/opened by the &quot;Device, PowerResource, Processor, Scope and ThermalZone&quot; operators. Please refer to &quot;<A HREF="ACPI_Source_Language_Reference.htm#_Toc202341954" CLASS="XRef">See ASL Operator Reference.</A>, ASL Operator Reference&quot;for detailed descriptions.</P>
<P CLASS="Body">
<A NAME="pgfId-1787775"></A>Not only the named objects, but all term objects (mathematical, logical, and conditional expressions, etc., see &quot;<A HREF="ACPI_Machine_Language_Specification.htm#_Toc489267548" CLASS="XRef">See Term Objects Encoding.</A>, Term Object Encoding&quot;) are allowed at the Definition Block level. Allowing such executable AML opcodes at the Definition Block level allows BIOS writers to define dynamic object lists according to the system settings. For example:</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787776"></A>DefinitionBlock (&quot;DSDT.aml&quot;, &quot;DSDT&quot;, 2, &quot;OEM&quot;, &quot;FOOBOOK&quot;, 0x1000)</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787777"></A>{</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787778"></A>    ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787779"></A>    If (LEqual (CFG1 (), 1))</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787780"></A>    {</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787781"></A>        ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787782"></A>        Scope (_SB.PCI0.XHC.RHUB)</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787783"></A>        {</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787784"></A>            ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787785"></A>            If (LEqual (CFG2 (), 1))</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787786"></A>            {</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787787"></A>                ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787788"></A>                Device (HS11)</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787789"></A>                {</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787790"></A>                    ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787791"></A>                    If (LEqual (CFG3 (), 1))</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787792"></A>                    {</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787793"></A>                        ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787794"></A>                        Device (CAM0)</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787795"></A>                        {</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787796"></A>                            ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787797"></A>                        }</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787798"></A>                        ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787799"></A>                    }</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787800"></A>                    ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787801"></A>                }</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787802"></A>                ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787803"></A>            }</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787804"></A>            ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787805"></A>        }</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787806"></A>        ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787807"></A>    }</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787808"></A>    ...</P>
<P CLASS="CodeIBIExample">
<A NAME="pgfId-1787809"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1787810"></A>The interpretation of the definition block during the definition block loading is similar to the interpretation of the control method during the control method execution.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1362715"></A><A NAME="_Toc489256022"></A><A NAME="_Toc489267946"></A><A NAME="_Toc489272499"></A><A NAME="_Toc202340550"></A><A NAME="_Toc258262234"></A>Control Methods and the ACPI Source Language (ASL)</H2>
<P CLASS="Body">
<A NAME="pgfId-1362716"></A>OEMs and platform firmware vendors write definition blocks using the ACPI Source Language (ASL) and use a translator to produce the byte stream encoding described in <A HREF="ACPI_Software_Programming_Model.htm#_Toc489256021" CLASS="XRef">See Definition Block Encoding.</A>, &#8220;Definition Block Encoding&#8221;. For example, the ASL statements that produce the example byte stream shown in that earlier section are shown in the following ASL example. For a full specification of the ASL statements, see <A HREF="ACPI_Source_Language_Reference.htm#94069" CLASS="XRef">See ACPI Source Language (ASL) Reference.</A>, &#8220;ACPI Source Language (ASL) Reference.&#8221;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362717"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362718"></A>// ASL Example </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362719"></A>DefinitionBlock (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362720"></A>    &quot;forbook.aml&quot;,           // Output Filename</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362721"></A>    &quot;DSDT&quot;,                  // Signature</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362722"></A>    0x02,                    // DSDT Compliance Revision</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362723"></A>    &quot;OEM&quot;,                   // OEMID</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659893"></A>    &quot;forbook&quot;,               // TABLE ID</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659894"></A>    0x1000                   // OEM Revision</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659895"></A>)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362727"></A>{                            // start of definition block </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362728"></A>    OperationRegion(&#92;GIO, SystemIO, 0x125, 0x1)	</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659924"></A>    Field(&#92;GIO, ByteAcc, NoLock, Preserve)   {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659925"></A>        CT01,   1, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659926"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711341"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711342"></A>    Scope(&#92;_SB)                            // start of scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711343"></A>         Device(PCI0) {                    // start of device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362735"></A>             PowerResource(FET0, 0, 0) {   // start of pwr</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362736"></A>                 Method (_ON)   {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362737"></A>                     Store (Ones, CT01)    // assert power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362738"></A>                     Sleep (30)            // wait 30ms</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362739"></A>                 }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362740"></A>                 Method (_OFF) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362741"></A>                     Store (Zero, CT01)    // assert reset#</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362742"></A>                 }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362743"></A>                 Method (_STA) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362744"></A>                     Return (CT01)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362745"></A>                 }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659985"></A>             }                             // end of power</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659986"></A>         } // end of device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1659987"></A>    } // end of scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362749"></A>} // end of definition block</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711336"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362771"></A><A NAME="_Toc489256023"></A><A NAME="_Toc489267947"></A><A NAME="_Toc489272500"></A><A NAME="_Toc202340551"></A><A NAME="_Toc258262235"></A>ASL Statements<A NAME="marker-1362769"></A><A NAME="marker-1362770"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1362772"></A>ASL is principally a declarative language. ASL statements declare objects. Each object has three parts, two of which can be null:</P>
<DIV>
<H6 CLASS="spacing">
<A NAME="pgfId-1362773"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1362774"></A>     Object := ObjectType FixedList VariableList</P>
<P CLASS="Body">
<A NAME="pgfId-1362775"></A>FixedList refers to a list of known length that supplies data that all instances of a given ObjectType must have. It is written as (a, b, c,), where the number of arguments depends on the specific ObjectType, and some elements can be nested objects, that is (a, b, (q, r, s, t), d). Arguments to a FixedList can have default values, in which case they can be skipped. Some ObjectTypes can have a null FixedList.</P>
<P CLASS="Body">
<A NAME="pgfId-1362776"></A>VariableList refers to a list, not of predetermined length, of child objects that help define the parent. It is written as {x, y, z, aa, bb, cc}, where any argument can be a nested object. ObjectType determines what terms are legal elements of the VariableList. Some ObjectTypes can have a null variable list.</P>
<P CLASS="Body">
<A NAME="pgfId-1362777"></A>For a detailed specification of the ASL language, see <A HREF="ACPI_Source_Language_Reference.htm#94069" CLASS="XRef">See ACPI Source Language (ASL) Reference.</A>, &#8220;ACPI Source Language (ASL) Reference.&#8221; For a detailed specification of the ACPI Control Method Machine Language (AML), upon which the output of the ASL translator is based, see <A HREF="ACPI_Machine_Language_Specification.htm#35965" CLASS="XRef">See ACPI Machine Language (AML) Specification.</A>, &#8220;ACPI Machine Language (AML) Specification.&#8221;</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1362806"></A><A NAME="marker-1362803"></A><A NAME="75986"></A>Control Method Execution</H6>
<P CLASS="Body">
<A NAME="pgfId-1362809"></A><A NAME="_Ref360199223"></A><A NAME="_Ref360199698"></A>OSPM evaluates control method objects as necessary to either interrogate or adjust the system-level hardware state. This is called an invocation.<A NAME="marker-1362810"></A><A NAME="marker-1362811"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1362812"></A>A control method can use other internal, or well defined, control methods to accomplish the task at hand, which can include defined control methods provided by the operating software. Control Methods can reference any objects anywhere in the Namespace. Interpretation of a Control Method is not preemptive, but it can block. When a control method does block, OSPM can initiate or continue the execution of a different control method. A control method can only assume that access to global objects is exclusive for any period the control method does not block.</P>
<P CLASS="Body">
<A NAME="pgfId-1362818"></A>Global objects are those NameSpace objects created at table load time.<A NAME="_Toc374252787"></A><A NAME="_Toc374852686"></A><A NAME="_Toc375382477"></A><A NAME="_Toc375924709"></A><A NAME="_Toc423759921"></A></P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1362826"></A>Arguments</H6>
<P CLASS="Body">
<A NAME="pgfId-1362827"></A>Up to seven arguments can be passed to a control method. Each argument is an object that in turn could be a &#8220;package&#8221; style object that refers to other objects. Access to the argument objects is provided via the ASL ArgTerm (ArgX) language elements. The number of arguments passed to any control method is fixed and is defined when the control method package is created. </P>
<P CLASS="Body">
<A NAME="pgfId-1362828"></A>Method arguments can take one of the following forms:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1362829"></A>An ACPI name or namepath that refers to a named object. This includes the LocalX and ArgX names. In this case, the object associated with the name is passed as the argument.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362830"></A>An ACPI name or namepath that refers to another control method. In this case, the method is invoked and the return value of the method is passed as the argument. A fatal error occurs if no object is returned from the method. If the object is not used after the method invocation it is automatically deleted.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362831"></A>A valid ASL expression. In the case, the expression is evaluated and the object that results from this evaluation is passed as the argument. If this object is not used after the method invocation it is automatically deleted.<A NAME="marker-1362832"></A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1362838"></A>M<A NAME="_Ref46716116"></A>ethod Calling Convention</H6>
<P CLASS="Body">
<A NAME="pgfId-1362839"></A>The calling convention for control methods can best be described as call-by-reference-constant. In this convention, objects passed as arguments are passed by &#8220;reference&#8221;, meaning that they are not copied to new objects as they are passed to the called control method (A calling convention that copies objects or object wrappers during a call is known as call-by-value or call-by-copy). </P>
<P CLASS="Body">
<A NAME="pgfId-1362840"></A>This call-by-reference-constant convention allows internal objects to be shared across each method invocation, therefore reducing the number of object copies that must be performed as well as the number of buffers that must be copied. This calling convention is appropriate to the low-level nature of the ACPI subsystem within the kernel of the host operating system where non-paged dynamic memory is typically at a premium. The ASL programmer must be aware of the calling convention and the related side effects.</P>
<P CLASS="Body">
<A NAME="pgfId-1362841"></A>However, unlike a pure call-by-reference convention, the ability of the called control method to modify arguments is extremely limited. This reduces aliasing issues such as when a called method unexpectedly modifies a object or variable that has been passed as an argument by the caller. In effect, the arguments that are passed to control methods are passed as constants that cannot be modified except under specific controlled circumstances.</P>
<P CLASS="Body">
<A NAME="pgfId-1362842"></A>Generally, the objects passed to a control method via the ArgX terms cannot be directly written or modified by the called method. In other words, when an ArgX term is used as a target operand in an ASL statement, the existing ArgX object is not modified. Instead, the new object replaces the existing object and the ArgX term effectively becomes a LocalX term.</P>
<P CLASS="Body">
<A NAME="pgfId-1362843"></A>The only exception to the read-only argument rule is if an ArgX term contains an Object Reference created via the RefOf ASL operator. In this case, the use of the ArgX term as a target operand will cause any existing object stored at the ACPI name referred to by the RefOf operation to be overwritten. </P>
<P CLASS="Body">
<A NAME="pgfId-1362844"></A>In some limited cases, a new, writable object may be created that will allow a control method to change the value of an ArgX object. These cases are limited to Buffer and Package objects where the &#8220;value&#8221; of the object is represented indirectly. For Buffers, a writable Index or Field can be created that refers to the original buffer data and will allow the called method to read or modify the data. For Packages, a writable Index can be created to allow the called method to modify the contents of individual elements of the Package.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1730419"></A>Local Variables and Locally Created Data Objects</H6>
<P CLASS="Body">
<A NAME="pgfId-1362846"></A>Control methods can access up to eight local data objects. Access to the local data objects have shorthand encodings. On initial control method execution, the local data objects are NULL. Access to local objects is via the ASL LocalTerm language elements. </P>
<P CLASS="Body">
<A NAME="pgfId-1362847"></A>Upon control method execution completion, one object can be returned that can be used as the result of the execution of the method. The &#8220;caller&#8221; must either use the result or save it to a different object if it wants to preserve it. See the description of the Return ASL operator for additional details</P>
<P CLASS="Body">
<A NAME="pgfId-1362848"></A>NameSpace objects created within the scope of a method are dynamic. They exist only for the duration of the method execution. They are created when specified by the code and are destroyed on exit. A method may create dynamic objects outside of the current scope in the NameSpace using the scope operator or using full path names. These objects will still be destroyed on method exit. Objects created at load time outside of the scope of the method are static. For example:<A NAME="marker-1362849"></A><A NAME="marker-1362850"></A><A NAME="marker-1362851"></A><A NAME="marker-1362852"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362854"></A>Scope (&#92;XYZ) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362855"></A>     Name (BAR, 5)           // Creates &#92;XYZ.BAR</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362856"></A>     Method (FOO, 1) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362857"></A>         Store (BAR, CREG)   // same effect as Store (&#92;XYZ.BAR, CREG)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362858"></A>         Name (BAR, 7)       // Creates &#92;XYZ.FOO.BAR</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362859"></A>         Store (BAR, DREG)   // same effect as Store (&#92;XYZ.FOO.BAR, DREG</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362860"></A>         Name (&#92;XYZ.FOOB, 3) // Creates &#92;XYZ.FOOB</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362861"></A>     } // end method</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362862"></A>} // end scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1684870"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1362864"></A>The object &#92;XYZ.BAR is a static object created when the table that contains the above ASL is loaded. The object &#92;XYZ.FOO.BAR is a dynamic object that is created when the Name (BAR, 7) statement in the FOO method is executed. The object &#92;XYZ.FOOB is a dynamic object created by the &#92;XYZ.FOO method when the Name (&#92;XYZ.FOOB, 3) statement is executed. Notice that the &#92;XYZ.FOOB object is destroyed after the &#92;XYZ.FOO method exits. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1362865"></A><A NAME="42812"></A>   Access to Operation Regions</H6>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1787436"></A>Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1362866"></A>Control Methods read and write data to locations in address spaces (for example, System memory and System I/O) by using the Field operator (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">See Field (Declare Field Objects).</A> Field (Declare Field Objects)&#8221;) to declare a data element within an entity known as an &#8220;Operation Region&#8221; and then performing accesses using the data element name. An Operation Region is a specific region of operation within an address space that is declared as a subset of the entire address space using a starting address (offset) and a length (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">See OperationRegion (Declare Operation Region).</A> &#8220;OperationRegion (Declare Operation Region)&#8221;)<A NAME="marker-1362867"></A>. Control methods must have exclusive access to any address accessed via fields declared in Operation Regions. Control methods may not directly access any other hardware registers, including the ACPI-defined register blocks. Some of the ACPI registers, in the defined ACPI registers blocks, are maintained on behalf of control method execution. For example, the GPEx_BLK is not directly accessed by a control method but is used to provide an extensible interrupt handling model for control method invocation.<A NAME="marker-1362868"></A><A NAME="marker-1362869"></A><A NAME="marker-1362870"></A></P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1362871"></A>Accessing an OpRegion may block, even if the OpRegion is not protected by a mutex. For example, because of the slow nature of the embedded controller, an embedded controller OpRegion field access may block.<A NAME="_Toc374252788"></A><A NAME="_Toc374852687"></A><A NAME="_Toc375382478"></A><A NAME="_Toc375924710"></A><A NAME="_Toc423759922"></A></LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1362877"></A><A HREF="ACPI_Software_Programming_Model.htm#46346" CLASS="XRef">See Operation Region Address Space Identifiers.</A> defines Operation Region spaces.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1362878"></A><A NAME="46346"></A>Operation Region Address Space Identifiers</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1786935"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1786959"></A>Name (RegionSpace Keyword)</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1787026"></A>&nbsp;</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786937"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786961"></A>SystemMemory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787028"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786939"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786963"></A>SystemIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787030"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786941"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786965"></A>PCI_Config</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787032"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786943"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786967"></A>EmbeddedControl</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787034"></A><A HREF="ACPI_Embedded_Controller_Interface_Specification.htm#71995" CLASS="XRef">See ACPI Embedded Controller Interface Specification.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786945"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786969"></A>SMBus</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787036"></A><A HREF="ACPI_Sys_Mgmt_Bus_Interface_Specification.htm#78977" CLASS="XRef">See ACPI System Management Bus Interface Specification.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786947"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786971"></A>SystemCMOS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787038"></A><A HREF="ACPI_Software_Programming_Model.htm#22711" CLASS="XRef">See CMOS Protocols.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786949"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786973"></A>PciBarTarget</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787040"></A><A HREF="ACPI_Software_Programming_Model.htm#23750" CLASS="XRef">See PCI Device BAR Target Protocols.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786951"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786975"></A>IPMI</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787042"></A><A HREF="ACPI_Software_Programming_Model.htm#23886" CLASS="XRef">See Declaring IPMI Operation Regions.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786953"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786977"></A>GeneralPurposeIO</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787044"></A><A HREF="ACPI_Software_Programming_Model.htm#69535" CLASS="XRef">See Declaring GeneralPurposeIO Operation Regions.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786955"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786979"></A>GenericSerialBus</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787046"></A><A HREF="ACPI_Software_Programming_Model.htm#10758" CLASS="XRef">See Declaring GenericSerialBus Operation Regions.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837819"></A>0x0A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837821"></A>PCC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1837823"></A><A HREF="ACPI_Software_Programming_Model.htm#24517" CLASS="XRef">See Declaring PCC Operation Regions.</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786957"></A>0x0B-0x7F</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786981"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787048"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786994"></A>0x80 to 0xFF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1786996"></A>OEM defined</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1787050"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1362924"></A><A NAME="22711"></A>   CMOS Protocols</H6>
<P CLASS="Body">
<A NAME="pgfId-1362931"></A>This sect<A NAME="marker-1362927"></A><A NAME="marker-1362928"></A><A NAME="marker-1362929"></A><A NAME="marker-1362930"></A>ion describes how CMOS battery-backed non-volatile memory can be accessed from ASL. Most computers contain an RTC/CMOS device that can be represented as a linear array of bytes of non-volatile memory. There is a standard mechanism for accessing the first 64 bytes of non-volatile RAM in devices that are compatible with the Motorola RTC/CMOS device used in the original IBM PC/AT. Existing RTC/CMOS devices typically contain more than 64 bytes of non-volatile RAM, and no standard mechanism exists for access to this additional storage area. To provide access to all of the non-volatile memory in these devices from AML, PnP IDs exist for each type of extension. These are PNP0B00, PNP0B01, and PNP0B02. The specific devices that these PnP IDs support are described in <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#_Toc202341718" CLASS="XRef">See PC/AT RTC/CMOS Devices.</A>, &#8220;PC/AT RTC/CMOS Device&#8221;, along with field definition ASL example code. The drivers corresponding to these device handle operation region accesses to the SystemCMOS operation region for their respective device types.</P>
<P CLASS="Body">
<A NAME="pgfId-1362932"></A>All bytes of CMOS that are related to the current time, day, date, month, year and century are read-only.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1362933"></A><A NAME="23750"></A>   PCI Device BAR Target Protocols </H6>
<P CLASS="Body">
<A NAME="pgfId-1362941"></A>This section describes how<A NAME="marker-1362936"></A><A NAME="marker-1362937"></A><A NAME="marker-1362938"></A><A NAME="marker-1362939"></A><A NAME="marker-1362940"></A> PCI devices&#8217; control registers can be accessed from ASL. PCI devices each have an address space associated with them called the Configuration Space. At offset 0x10 through offset 0x27, there are as many as six Base Address Registers, (BARs). These BARs contain the base address of a series of control registers (in I/O or Memory space) for the PCI device. Since a Plug and Play OS may change the values of these BARs at any time, ASL cannot read and write from these deterministically using I/O or Memory operation regions. Furthermore, a Plug and Play OS will automatically assign ownership of the I/O and Memory regions associated with these BARs to a device driver associated with the PCI device. An ACPI OS (which must also be a Plug and Play operating system) will not allow ASL to read and write regions that are owned by native device drivers.</P>
<P CLASS="Body">
<A NAME="pgfId-1362942"></A>If a platform uses a PCI BAR Target operation region, an ACPI OS will not load a native device driver for the associated PCI function. For example, if any of the BARs in a PCI function are associated with a PCI BAR Target operation region, then the OS will assume that the PCI function is to be entirely under the control of the ACPI system firmware. No driver will be loaded. Thus, a PCI function can be used as a platform controller for some task (hot-plug PCI, and so on) that the ACPI system firmware performs.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1362943"></A>   Declaring a PCI BAR Target Operation Region</H6>
<P CLASS="Body">
<A NAME="pgfId-1362944"></A>PCI BARs contain the base address of an I/O or Memory region that a PCI device&#8217;s control registers lie within. Each BAR implements a protocol for determining whether those control registers are within I/O or Memory space and how much address space the PCI device decodes. (See the PCI Specification for more details.)</P>
<P CLASS="Body">
<A NAME="pgfId-1362945"></A>PCI BAR Target operation regions are declared by providing the offset of the BAR within the PCI device&#8217;s PCI configuration space. The BAR determines whether the actual access to the device occurs through an I/O or Memory cycle, not by the declaration of the operation region. The length of the region is similarly implied.</P>
<P CLASS="Body">
<A NAME="pgfId-1362946"></A>In the term OperationRegion(PBAR, PciBarTarget, 0x10, 0x4), the offset is the offset of the BAR within the configuration space of the device. This would be an example of an operation region that uses the first BAR in the device.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1362947"></A>   PCI Header Types and PCI BAR Target Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1362948"></A>PCI BAR Target operation regions may only be declared in the scope of PCI devices that have a PCI Header Type of 0. PCI devices with other header types are bridges. The control of PCI bridges is beyond the scope of ASL.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1362960"></A><A NAME="marker-1362957"></A><A NAME="23886"></A>Declaring IPMI Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1362961"></A>This section describes the Intelligent Platform Management Interface (IPMI) address space and the use of this address space to communicate with the Baseboard Management Controller (BMC) hardware from AML.</P>
<P CLASS="Body">
<A NAME="pgfId-1362962"></A>Similar to SMBus, IPMI operation regions are command based, where each offset within an IPMI address space represent an IPMI command and response pair. Given this uniqueness, IPMI operation regions include restrictions on their field definitions and require the use of an IPMI-specific data buffer for all transactions.<A NAME="marker-1362963"></A><A NAME="marker-1362964"></A><A NAME="marker-1362965"></A> The IPMI interface presented in this section is intended for use with any hardware implementation compatible with the IPMI specification, regardless of the system interface type. </P>
<P CLASS="Body">
<A NAME="pgfId-1362966"></A>Support of the IPMI generic address space by ACPI-compatible operating systems is optional, and is contingent on the existence of an ACPI IPMI device, i.e. a device with the &#8220;IPI0001&#8221; plug and play ID. If present, OSPM should load the necessary driver software based on the system interface type as specified by the _IFT (IPMI Interface Type) control method under the device, and register handlers for accesses into the IPMI operation region space.</P>
<P CLASS="Body">
<A NAME="pgfId-1362967"></A>For more information, refer to the IPMI specification.</P>
<P CLASS="Body">
<A NAME="pgfId-1362968"></A>Each IPMI operation region definition identifies a single IPMI network function. Operation regions are defined only for those IPMI network functions that need to be accessed from AML. As with other regions, IPMI operation regions are only accessible via the Field term (see <A HREF="ACPI_Software_Programming_Model.htm#80674" CLASS="XRef">See Declaring IPMI Fields.</A>, &#8220;Declaring IPMI Fields&#8221;).</P>
<P CLASS="Body">
<A NAME="pgfId-1362969"></A>This interface models each IPMI network function as having a 256-byte linear address range. Each byte offset within this range corresponds to a single command value (for example, byte offset 0xC1 equates to command value 0xC1), with a maximum of 256 command values. By doing this, IPMI address spaces appear linear and can be processed in a manner similar to the other address space types.</P>
<P CLASS="Body">
<A NAME="pgfId-1362970"></A>The syntax for the OperationRegion term (from <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">See OperationRegion (Declare Operation Region).</A>, &#8220;OperationRegion (Declare Operation Region]&#8221;) is described below.<A NAME="marker-1362971"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362973"></A>OperationRegion (<BR>
     RegionName,    // NameString<BR>
     RegionSpace,   // RegionSpaceKeyword<BR>
     Offset,        // TermArg=&gt;Integer<BR>
     Length         // TermArg=&gt;Integer<BR>
)</P>
<P CLASS="Body">
<A NAME="pgfId-1362974"></A>Where: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1362975"></A>RegionName specifies a name for this IPMI network function  (for example, &#8220;POWR&#8221;).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362976"></A>RegionSpace must be set to IPMI (operation region type value 0x07).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362977"></A>Offset is a word-sized value specifying the network function and initial command value offset for the target device. The network function address is stored in the high byte and the command value offset is stored in the low byte. For example, the value 0x3000 would be used for a device with the network function of 0x06, and an initial command value offset of zero (0).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1362978"></A>Length is set to the 0x100 (256), representing the maximum number of possible command values, for regions with an initial command value offset of zero (0). The difference of these two values is used for regions with non-zero offsets. For example, a region with an Offset value of 0x3010 would have a corresponding Length of 0xF0 (0x100 minus 0x10).</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1362979"></A>For example, a Baseboard Management Controller will support power metering capabilities at the network function 0x30, and IPMI commands to query the BMC device information at the network function 0x06.</P>
<P CLASS="Body">
<A NAME="pgfId-1362981"></A>The following ASL code shows the use of the OperationRegion term to describe these IPMI functions:<A NAME="marker-1362980"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362982"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362983"></A>Device (IPMI) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362984"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362985"></A>    Name(_HID, &quot;IPI0001&quot;)                        // IPMI device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362986"></A>    Name(_IFT, 0x1)                              // KCS system interface type</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362987"></A>    OperationRegion(DEVC, IPMI, 0x0600, 0x100)   // Device info network function</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362988"></A>    OperationRegion(POWR, IPMI, 0x3000, 0x100)   // Power network function</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362989"></A>    :</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1362990"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1362991"></A>Notice that these operation regions in this example are defined within the immediate context of the &#8216;owning&#8217; IPMI device. This ensures the correct operation region handler will be used, based on the value returned by the _IFT object. Each definition corresponds to a separate network function, and happens to use an initial command value offset of zero (0).</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1362993"></A><A NAME="80674"></A>Declaring IPMI Fields</H6>
<P CLASS="Body">
<A NAME="pgfId-1362998"></A>As with other regi<A NAME="marker-1362996"></A><A NAME="marker-1362997"></A>ons, IPMI operation regions are only accessible via the Field term. Each field element is assigned a unique command value and represents a virtual command for the targeted network function. </P>
<P CLASS="Body">
<A NAME="pgfId-1362999"></A>The syntax for the Field term (from  <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267428" CLASS="XRef">See Event (Declare Event Synchronization Object).</A>, &#8220;Event (Declare Event Synchronization Object]&#8221;) is described below. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363001"></A>Field(<BR>
    RegionName,     // NameString=&gt;OperationRegion<BR>
    AccessType,     // AccessTypeKeyword - BufferAcc<BR>
    LockRule,       // LockRuleKeyword<BR>
    UpdateRule      // UpdateRuleKeyword - ignored<BR>
) {FieldUnitList}</P>
<P CLASS="Body">
<A NAME="pgfId-1363002"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363003"></A>RegionName specifies the operation region name previously defined for the network function.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363004"></A>AccessType must be set to BufferAcc. This indicates that access to field elements will be done using a region-specific data buffer. For this access type, the field handler is not aware of the data buffer&#8217;s contents which may be of any size. When a field of this type is used as the source argument in an operation it simply evaluates to a buffer. When used as the destination, however, the buffer is passed bi-directionally to allow data to be returned from write operations. The modified buffer then becomes the response message of that command. This is slightly different than the normal case in which the execution result is the same as the value written to the destination. Note that the source is never changed, since it only represents a virtual register for a particular IPMI command.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363005"></A>LockRule indicates if access to this operation region requires acquisition of the Global Lock for synchronization. This field should be set to Lock on system with firmware that may access the BMC via IPMI, and NoLock otherwise.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363006"></A>UpdateRule is not applicable to IPMI operation regions since each virtual register is accessed in its entirety. This field is ignored for all IPMI field definitions.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363007"></A>IPMI operation regions require that all field elements be declared at command value granularity. This means that each virtual register cannot be broken down to its individual bits within the field definition. </P>
<P CLASS="Body">
<A NAME="pgfId-1363008"></A>Access to sub-portions of virtual registers can be done only outside of the field definition. This limitation is imposed both to simplify the IPMI interface and to maintain consistency with the physical model defined by the IPMI specification.</P>
<P CLASS="Body">
<A NAME="pgfId-1363009"></A>Since the system interface used for IPMI communication is determined by the _IFT object under the IPMI device, there is no need for using of the AccessAs term within the field definition. In fact its usage will be ignored by the operation handler.</P>
<P CLASS="Body">
<A NAME="pgfId-1363010"></A>For example, the register at command value 0xC1 for the power meter network function might represent the command to set a BMC enforced power limit, while the register at command value 0xC2 for the same network function might represent the current configured power limit. At the same time, the register at command value 0xC8 might represent the latest power meter measurement.</P>
<P CLASS="Body">
<A NAME="pgfId-1363012"></A>The following ASL code shows the use of the OperationRegion, Field, and Offset terms to represent these virtual registers:<A NAME="marker-1363013"></A><A NAME="marker-1363014"></A><A NAME="marker-1363015"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1684881"></A>OperationRegion(POWR, IPMI, 0x3000, 0x100)  // Power network function </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363018"></A>Field(POWR, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363019"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363020"></A>    Offset(0xC1),                           // Skip to command value 0xC1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363021"></A>    SPWL, 8,                                // Set power limit [command value 0xC1]</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363022"></A>    GPWL, 8,                                // Get power limit [command value 0xC2]</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363023"></A>    Offset(0xC8),                           // Skip to command value 0xC8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363024"></A>    GPMM, 8                                 // Get power meter measurement [command value 0xC8]</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363025"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363026"></A>Notice that command values are equivalent to the field element&#8217;s byte offset (for example, SPWL=0xC1, GPWL=0xC2, GPMM=0xC8).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1363027"></A>Declaring and Using IPMI Request and Response Buffer</H6>
<P CLASS="Body">
<A NAME="pgfId-1363033"></A>Since each virtual register in the IPMI operatio<A NAME="marker-1363030"></A><A NAME="marker-1363031"></A><A NAME="marker-1363032"></A>n region represents an individual IPMI command, and the operation relies on use of bi-directional buffer, a common buffer structure is required to represent the request and response messages. The use of a data buffer for IPMI transactions allows AML to receive status and data length values. </P>
<P CLASS="Body">
<A NAME="pgfId-1363034"></A>The IPMI data buffer is defined as a fixed-length 66-byte buffer that, if represented using a &#8216;C&#8217;-styled declaration, would be modeled as follows:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363035"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363036"></A>typedef struct</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363037"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363038"></A>    BYTE		Status;     // Byte 0 of the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363039"></A>    BYTE		Length;     // Byte 1 of the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363040"></A>    BYTE[64]		Data;    // Bytes 2 through 65 of the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363041"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363042"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363043"></A>Status (byte 0) indicates the status code of a given IPMI command. See <A HREF="ACPI_Software_Programming_Model.htm#30409" CLASS="XRef">See IPMI Status Code.</A>, &#8220;IPMI Status Code,&#8221; for more information. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363044"></A>Length (byte 1) specifies the number of bytes of valid data that exists in the data buffer. Valid Length values are 0 through 64. Before the operation is carried out, this value represents the length of the request data buffer. Afterwards, this value represents the length of the result response data buffer.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363045"></A>Data (bytes 65-2) represents a 64-byte buffer, and is the location where actual data is stored. Before the operation is carried out, this represents the actual request message payload. Afterwards, this represents the response message payload as returned by the IPMI command.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363046"></A>For example, the following ASL shows the use of the IPMI data buffer to carry out a command for a power function. This code is based on the example ASL presented in <A HREF="ACPI_Software_Programming_Model.htm#80674" CLASS="XRef">See Declaring IPMI Fields.</A>, &#8220;Declaring IPMI Fields,&#8221; which lists the operation region and field definitions for relevant IPMI power metering commands. <A NAME="marker-1363047"></A></P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="code-Ex-CODE-PRE-CITE">
<A NAME="pgfId-1363048"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1363049"></A>/* Create the IPMI data buffer */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363050"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363051"></A>Name(BUFF, Buffer(66){})                        // Create IPMI data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363052"></A>CreateByteField(BUFF, 0x00, STAT)               // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363053"></A>CreateByteField(BUFF, 0x01, LENG)               // LENG = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363054"></A>CreateByteField(BUFF, 0x02, MODE)               // MODE = Mode     (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363055"></A>CreateByteField(BUFF, 0x03, RESV)               // RESV = Reserved (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363056"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363057"></A>Store(0x2, LENG)                                 // Request message is 2 bytes long</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363058"></A>Store(0x1, MODE)                                 // Set Mode to 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363059"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363060"></A>Store(Store(BUFF, GPMM), BUFF)                   // Write the request into the GPMM command,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363061"></A>                                                 // then read the results</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363062"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363063"></A>CreateByteField(BUFF, 0x02, CMPC)                // CMPC = Completion code (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363064"></A>CreateWordField(BUFF, 0x03, APOW)                // APOW = Average power measurement (Word)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363065"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363066"></A>If(LAnd(LEqual(STAT, 0x0), LEqual(CMPC, 0x0)))   // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363067"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363068"></A>    Return(APOW)                                 // Return the average power measurement</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363069"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363070"></A>Else</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363071"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363072"></A>    Return(Ones)                                 // Return invalid</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363073"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363074"></A>Notice the use of the CreateField primitives to access the data buffer&#8217;s sub-elements (Status, Length, and Data), where Data (bytes 65-2) is &#8216;typecast&#8217; into different fields (including the result completion code).</P>
<P CLASS="Body">
<A NAME="pgfId-1363075"></A>The example above demonstrates the use of the Store() operator and the bi-directional data buffer to invoke the actual IPMI command represented by the virtual register. The inner Store() writes the request message data buffer to the IPMI operation region handler, and invokes the command. The outer Store() takes the result of that command and writes it back into the data buffer, this time representing the response message.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1363077"></A><A NAME="30409"></A>  IPMI Status Code </H6>
<P CLASS="Body">
<A NAME="pgfId-1363078"></A>Every IPMI command results in a status code returned as the first byte of the response message, contained in the bi-directional data buffer. This status code can indicate success, various errors, and possibly timeout from the IPMI operation handler. This is necessary because it is possible for certain IPMI commands to take up to 5 seconds to carry out, and since an AML Store() operation is synchronous by nature, it is essential to make sure the IPMI operation returns in a timely fashion so as not to block the AML interpreter in the OSPM.</P>
<UL>
<LI CLASS="Note">
<A NAME="pgfId-1363079"></A>This status code is different than the IPMI completion code, which is returned as the first byte of the response message in the data buffer payload. The completion code is described in the complete IPMI specification. </LI>
</UL>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1363080"></A><A NAME="92432"></A>IPMI Status Codes</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730493"></A>Status Code</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730495"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1730497"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363089"></A>00h</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363091"></A>IPMI OK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363093"></A>Indicates the command has been successfully completed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363095"></A>07h</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363097"></A>IPMI Unknown Failure</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363099"></A>Indicates failure because of an unknown IPMI error.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363101"></A>10h</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363103"></A>IPMI Command Operation Timeout</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363105"></A>Indicates the operation timed out.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1713870"></A><A NAME="69535"></A>Declaring GeneralPurposeIO Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1713871"></A>For GeneralPurposeIO Operation Regions, the syntax for the OperationRegion term (from section <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">See OperationRegion (Declare Operation Region).</A>, &#8220;OperationRegion (Declare Operation Region]&#8221;) is described below.</P>
<P CLASS="Body">
<A NAME="pgfId-1714044"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1713981"></A>OperationRegion (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714032"></A>    RegionName,       // NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1713998"></A>    RegionSpace,      // RegionSpaceKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714019"></A>    Offset,           // TermArg=&gt;Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714020"></A>    Length            // TermArg=&gt;Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714025"></A>)</P>
<P CLASS="Body">
<A NAME="pgfId-1713876"></A>Where: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1713877"></A><EM CLASS="ArgCharacter">
RegionName</EM>
 specifies a name for this GeneralPurposeIO region (for example, &#8220;GPI1&#8221;).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1713878"></A><EM CLASS="ArgCharacter">
RegionSpace</EM>
 must be set to GeneralPurposeIO (operation region type value 0x08).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1713879"></A><EM CLASS="ArgCharacter">
Offset</EM>
 is ignored for the GeneralPurposeIO RegionSpace.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1713880"></A><EM CLASS="ArgCharacter">
Length</EM>
 is the maximum number of GPIO IO pins to be included in the Operation Region, rounded up to the next byte.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1713882"></A>GeneralPurposeIO OpRegions must be declared within the scope of the GPIO controller device being accessed.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1713894"></A> <A NAME="_Ref460293121"></A><A NAME="_Toc465496091"></A><A NAME="_Toc486665596"></A> <A NAME="_Toc489267386"></A><A NAME="_Toc489267740"></A><A NAME="_Toc489272714"></A><A NAME="_Ref42578964"></A><A NAME="_Toc202341899"></A><A NAME="_Toc258262518"></A>Declaring GeneralPurposeIO Fields<A NAME="marker-1713892"></A><A NAME="marker-1713893"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1713895"></A>As with other regions, GeneralPurposeIO operation regions are only accessible via the Field term. Each field element represents a subset of the <EM CLASS="ArgCharacter">
length</EM>
 bits declared in the OpRegion declaration. The pins within the OpRegion that are accessed via a given field name are defined by a Connection descriptor. The total number of defined field bits following a connection descriptor must equal the number of pins listed in the descriptor.</P>
<P CLASS="Body">
<A NAME="pgfId-1734635"></A>The syntax for the Field term (from <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">See Field (Declare Field Objects).</A>) is described below. </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1713899"></A>Field(</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714117"></A>    RegionName,    // NameString=&gt;OperationRegion</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714124"></A>    AccessType,    // AccessTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714131"></A>    LockRule,      // LockRuleKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714138"></A>    UpdateRule     // UpdateRuleKeyword - ignored</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1714145"></A>) {FieldUnitList}</P>
<P CLASS="Body">
<A NAME="pgfId-1713900"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1713901"></A><EM CLASS="ArgCharacter">
RegionName</EM>
 specifies the operation region name previously declared.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1713902"></A><EM CLASS="ArgCharacter">
AccessType</EM>
 must be set to ByteAcc. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1713903"></A><EM CLASS="ArgCharacter">
LockRule</EM>
 indicates if access to this operation region requires acquisition of the Global Lock for synchronization. Note that, on HW-reduced ACPI platforms, this field must be set to NoLock.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1713904"></A><EM CLASS="ArgCharacter">
UpdateRule</EM>
 is not applicable to GeneralPurposeIO operation regions since Preserve is always required. This field is ignored for all GeneralPurposeIO field definitions.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1739831"></A>The following ASL code shows the use of the OperationRegion, Field, and Offset terms as they apply to GeneralPurposeIO space.<A NAME="marker-1739832"></A><A NAME="marker-1739833"></A><A NAME="marker-1739834"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743461"></A>Device(DEVA)  //An Arbitrary Device Scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743462"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743463"></A>  ...//Other required stuff for this device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743464"></A>  Name (GMOD, ResourceTemplate ()     //An existing GPIO Connection (to be used later)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743465"></A>  {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743466"></A>   //2 Outputs that define the Power mode of the device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743467"></A>   GpioIo (Exclusive, PullDown, , , , &quot;&#92;&#92;_SB.GPI2&quot;) {10, 12}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743468"></A>  })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743469"></A> } //End DEVA</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743470"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743471"></A> Device (GPI2)  //The OpRegion declaration, and the _REG method, must be in the controller&#8217;s namespace scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1744211"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1744212"></A>  ...//Other required stuff for the GPIO controller</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1744213"></A>  OperationRegion(GPO2, GeneralPurposeIO, 0, 1)   // Note: length of 1 means region is </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847091"></A>                                                 // less than 1 byte (8 pins) long</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847086"></A>(or </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743475"></A>  Method(_REG,2) {}                  // Track availability of GeneralPurposeIO space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743476"></A> }                                   //End GPI2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743477"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743478"></A> Device (DEVB)                       //Access some GPIO Pins from this device scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847193"></A>                                     //to change the device's power mode</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743479"></A> {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743480"></A>  ...//Other required stuff for this device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743481"></A>  Name(_DEP, Package() {&quot;&#92;&#92;_SB.GPI2&quot;})    //OpRegion Dependency hint for OSPM</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743482"></A>  Field(&#92;_SB.GPI2.GPO2, ByteAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743483"></A>  {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743484"></A>   Connection (GMOD),       // Re-Use an existing connection (defined elsewhere)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743485"></A>   MODE, 2,                 // Power Mode</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743486"></A>   Connection (GpioIo(Exclusive, PullUp, , , , &quot;&#92;&#92;_SB.GPI2&quot;) {7}),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743487"></A>   STAT, 1,      // e.g. Status signal from the device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743488"></A>   Connection (GpioIo (Exclusive, PullUp, , , , &quot;&#92;&#92;_SB.GPI2&quot;) {9}),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743489"></A>   RSET, 1       // e.g. Reset signal to the device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743490"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743491"></A>  Method(_PS3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743492"></A>  {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743493"></A>   If (1) // Make sure GeneralPurposeIO OpRegion is available</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743494"></A>   {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743495"></A>    Store(0x03, MODE)    //Set both MODE bits. Power Mode 3</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743496"></A>   }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743497"></A>  }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743498"></A> } //End DEVB</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1743454"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1721028"></A><A NAME="10758"></A>Declaring GenericSerialBus Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1721029"></A>For GenericSerialBus Operation Regions, the syntax for the OperationRegion term (from <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">See OperationRegion (Declare Operation Region).</A>, &#8220;OperationRegion (Declare Operation Region]&#8221;) is described below.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721031"></A>OperationRegion (</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721806"></A>     RegionName,      // NameString</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721813"></A>     RegionSpace,     // RegionSpaceKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721820"></A>     Offset,          // TermArg=&gt;Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721827"></A>     Length           	// TermArg=&gt;Integer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721834"></A>)</P>
<P CLASS="Body">
<A NAME="pgfId-1721032"></A>Where: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1721033"></A>RegionName specifies a name for this region (for example, TOP1).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721034"></A>RegionSpace must be set to GenericSerialBus (operation region type value 0x09).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721035"></A>Offset specifies the initial command value offset for the target device. For example, the value 0x00 refers to a command value offset of zero (0). Raw protocols ignore this value.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721036"></A>Length is set to the 0x100 (256), representing the maximum number of possible command values.</LI>
<LI CLASS="Note">
<A NAME="pgfId-1721852"></A>The Operation Region must be declared within the scope of the Serial Bus controller device. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1721044"></A>The following ASL code shows the use of the OperationRegion, Field, and Offset terms as they apply to SPB space.<A NAME="marker-1721041"></A><A NAME="marker-1721042"></A><A NAME="marker-1721043"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721045"></A>      &lt;...&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721046"></A>Scope(&#92;_SB.I2C){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721047"></A>     OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)  // GenericSerialBus device at command</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721870"></A>                                                           // offset 0x00</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721048"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721049"></A>Name (SDB0, ResourceTemplate() {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721050"></A>     I2CSerialBusV2(0x4a,,100000,,&#8221;&#92;_SB.I2C&#8221;,,,,,RawDataBuffer(){1,2,3,4,5,6})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721051"></A>})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721052"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721053"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721054"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721055"></A>    Connection(SDB0) 						// Use the Resource Descriptor defined above</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721056"></A>     AccessAs(BufferAcc, AttribWord)	         // Use the GenericSerialBus Read/Write Word protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721057"></A>     FLD0, 8,                                // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721058"></A>     FLD1, 8                                 // Virtual register at command value 1.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721059"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721060"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721061"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721062"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721063"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&#8221;&#92;_SB.I2C&#8221;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721064"></A>     AccessAs(BufferAcc, AttribBytes (16))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721065"></A>     FLD2, 8                                 // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721066"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721935"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721936"></A>// Create the GenericSerialBus data buffer		</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721937"></A>Name(BUFF, Buffer(34){})                      // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721070"></A>CreateByteField(BUFF, 0x00, STAT)             // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721071"></A>CreateWordField(BUFF, 0x02, DATA)             // DATA = Data (Word)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721072"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783095"></A>&lt;...&gt;</P>
<P CLASS="Body">
<A NAME="pgfId-1721074"></A>The Operation Region in this example is defined within the scope of the target controller device, I2C. </P>
<P CLASS="Body">
<A NAME="pgfId-1721075"></A>GenericSerialBus regions are only accessible via the Field term (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">See Field (Declare Field Objects).</A> &#8220;Field (Declare Field Objects)) GenericSerialBus protocols are assigned to field elements using the AccessAs term (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489256024" CLASS="XRef">See ASL Macros.</A> &#8220;ASL Macros&#8221;) within the field definition. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1721144"></A>Accsessor Type Values</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1721079"></A>Accessor Type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1721081"></A>Value</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1721083"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721085"></A>AttribQuick</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721087"></A>0x02</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721089"></A>Read/Write Quick Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721091"></A>AttribSendReceive</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721093"></A>0x04</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721095"></A>Send/Receive Byte Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721097"></A>AttribByte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721099"></A>0x06</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721101"></A>Read/Write Byte Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721103"></A>AttribWord</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721105"></A>0x08</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721107"></A>Read/Write Word Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721109"></A>AttribBlock</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721111"></A>0x0A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721113"></A>Read/Write Block Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721115"></A>AttribBytes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721117"></A>0x0B</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721119"></A>Read/Write N-Bytes Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721121"></A>AttribProcessCall</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721123"></A>0x0C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721125"></A>Process Call Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721127"></A>AttribBlockProcessCall</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721129"></A>0x0D</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721131"></A>Write Block-Read Block Process Call Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721133"></A>AttribRawBytes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721135"></A>0x0E</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721137"></A>Raw Read/Write N-Bytes Protocol</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721139"></A>AttribRawProcessBytes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721141"></A>0x0F</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1721143"></A>Raw Process Call Protocol</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1721155"></A>Declaring GenericSerialBus Fields<A NAME="marker-1721153"></A><A NAME="marker-1721154"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1734680"></A>As with other regions, GenericSerialBus operation regions are only accessible via the Field term. Each field element is assigned a unique command value and represents a virtual register on the targeted GenericSerialBus device. </P>
<P CLASS="Body">
<A NAME="pgfId-1734684"></A>The syntax for the Field term (see <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">See Field (Declare Field Objects).</A> &#8220;Field (Declare Field Objects)) is described below. </P>
</DIV>
<DIV>
<H6 CLASS="code-Ex-CODE-PRE-CITE">
<A NAME="pgfId-1721158"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1721159"></A>Field(<BR>
     RegionName,     // NameString=&gt;OperationRegion<BR>
     AccessType,     // AccessTypeKeyword<BR>
     LockRule,       // LockRuleKeyword - ignored for Hardware-reduced ACPI platforms<BR>
     UpdateRule      // UpdateRuleKeyword - ignored<BR>
) {FieldUnitList}</P>
<P CLASS="Body">
<A NAME="pgfId-1721160"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1721161"></A>RegionName specifies the operation region name previously defined for the device.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721162"></A>AccessType must be set to BufferAcc. This indicates that access to field elements will be done using a region-specific data buffer. For this access type, the field handler is not aware of the data buffer&#8217;s contents which may be of any size. When a field of this type is used as the source argument in an operation it simply evaluates to a buffer. When used as the destination, however, the buffer is passed bi-directionally to allow data to be returned from write operations. The modified buffer then becomes the execution result of that operation. This is slightly different than the normal case in which the execution result is the same as the value written to the destination. Note that the source is never changed, since it could be a read only object (see <A HREF="ACPI_Software_Programming_Model.htm#_Toc258262519" CLASS="XRef">See Declaring and Using a GenericSerialBus Data Buffer.</A>, &#8220;Declaring an GenericSerialBus Data Buffer&#8221; and <A HREF="ACPI_Source_Language_Reference.htm#_Toc202341942" CLASS="XRef">See ASL Opcode Terms.</A>, &#8220;Opcode Terms&#8221;).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721163"></A>LockRule indicates if access to this operation region requires acquisition of the Global Lock for synchronization. This field should be set to Lock on system with firmware that may access the GenericSerialBus, and NoLock otherwise. On Hardware-reduced ACPI platforms, there is not a global lock so this parameter is ignored.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721164"></A>UpdateRule is not applicable to GenericSerialBus operation regions since each virtual register is accessed in its entirety. This field is ignored for all GenericSerialBus field definitions.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1721165"></A>GenericSerialBus operation regions require that all field elements be declared at command value granularity. This means that each virtual register cannot be broken down to its individual bits within the field definition. </P>
<P CLASS="Body">
<A NAME="pgfId-1721166"></A>Access to sub-portions of virtual registers can be done only outside of the field definition. This limitation is imposed to simplify the GenericSerialBus interface.</P>
<P CLASS="Body">
<A NAME="pgfId-1721167"></A>GenericSerialBus protocols are assigned to field elements using the AccessAs term within the field definition. The syntax for this term (from <A HREF="ACPI_Source_Language_Reference.htm#_Toc489272735" CLASS="XRef">See ASL Root and Secondary Terms.</A>, &#8220;ASL Root and SecondaryTerms&#8221;) is described below.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721169"></A>AccessAs(</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721956"></A>     AccessType,       //AccessTypeKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721957"></A>     AccessAttribute   //Nothing | ByteConst | AccessAttribKeyword</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721958"></A>)</P>
<P CLASS="Body">
<A NAME="pgfId-1721173"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1721174"></A>AccessType must be set to BufferAcc.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721175"></A>AccessAttribute indicates the GenericSerialBus protocol to assign to command values that follow this term. See<A HREF="ACPI_Software_Programming_Model.htm#66685" CLASS="XRef">See Using the GenericSerialBus Protocols.</A>, &#8220;Using the GenericSerialBus Protocols,&#8221; for a listing of the GenericSerialBus protocols.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1721176"></A>An AccessAs term must appear in a field definition to set the initial GenericSerialBus protocol for the field elements that follow. A maximum of one GenericSerialBus protocol may be defined for each field element. Devices supporting multiple protocols for a single command value can be modeled by specifying multiple field elements with the same offset (command value), where each field element is preceded by an AccessAs term specifying an alternate protocol.<A NAME="marker-1721177"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1721178"></A>For GenericSerialBus operation regions, connection attributes must be defined for each set of field elements. GenericSerialBus resources are assigned to field elements using the Connection term within the field definition. The syntax for this term (from <A HREF="ACPI_Source_Language_Reference.htm#29686" CLASS="XRef">See Connection (Declare Field Connection Attributes).</A> &#8220;Connection (Declare Field Connection Attributes)&#8221;) is described below.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721180"></A><EM CLASS="Style-Syntax-Element-Bold-Char-Char">
Connection</EM>
 (<EM CLASS="Style-Syntax-Element-Italic-Char-Char">
ConnectionResourceObj</EM>
)</P>
<P CLASS="Body">
<A NAME="pgfId-1721182"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1721183"></A>ConnectionResourceObj points to a Serial Bus Resource Connection Descriptor (see <A HREF="Device_Configuration.htm#98626" CLASS="XRef">See GenericSerialBus Connection Descriptors.</A>, &#8220;Serial Bus Connection Resource Descriptors&#8221; for valid types), or a named object that specifies a buffer field containing the connection resource information.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1721185"></A>Each Field definition references the initial command offset specified in the operation region definition. The offset is iterated for each subsequent field element defined in that respective Field. If a new connection is described in the same Field definition, the offset will not be returned to its initial value and a new Field must be defined to inherit the initial command value offset from the operation region definition. The following example illustrates this point.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721186"></A>&lt;...&gt;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783147"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)   //Initial offset is 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721187"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721188"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721189"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721190"></A>    Connection(I2CSerialBusV2(0x5a,,100000,, &quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721191"></A>         Offset(0x0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721192"></A>        AccessAs(BufferAcc, AttribBytes (4)),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721193"></A>        TFK1, 8,                                   //TFK1 at command value offset 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721194"></A>        TFK2, 8                                    //TFK2 at command value offset 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721195"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721196"></A>    Connection(I2CSerialBusV2(0x5c,,100000,, &quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){3,1}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721197"></A>         Offset(0x0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721198"></A>        AccessAs(BufferAcc, AttribBytes (12)),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721199"></A>        TS1, 8			                                     //TS1 at command value offset 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721200"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721201"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721202"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721203"></A>     {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721204"></A>     Connection(I2CSerialBusV2(0x5b,,100000,, &quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){2,9}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721205"></A>         AccessAs(BufferAcc, AttribByte),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721206"></A>         TM1, 8                                    //TM1 at command value offset 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721207"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783158"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783156"></A>&lt;...&gt;</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1721221"></A><A NAME="_Toc258262519"></A><A NAME="_Toc202341900"></A><A NAME="_Ref42579074"></A><A NAME="_Toc489272715"></A><A NAME="_Toc489267741"></A><A NAME="_Toc489267387"></A>Declaring and Using a GenericSerialBus Data Buffer<A NAME="marker-1721218"></A><A NAME="marker-1721219"></A><A NAME="marker-1721220"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1721222"></A>The use of a data buffer for GenericSerialBus transactions allows AML to receive status and data length values, as well as making it possible to implement the Process Call protocol. The BufferAcc access type is used to indicate to the field handler that a region-specific data buffer will be used. </P>
<P CLASS="Normal">
<A NAME="pgfId-1721225"></A><A NAME="marker-1721223"></A><A NAME="marker-1721224"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1721226"></A>For GenericSerialBus operation regions, this data buffer is defined as an arbitrary length buffer that, if represented using a &#8216;C&#8217;-styled declaration, would be modeled as follows:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721228"></A>typedef struct</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721229"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722013"></A>     BYTE		Status;    // Byte 0 of the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722014"></A>     BYTE		Length;    // Byte 1 of the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1734737"></A>     BYTE[x-1]	Data; // Bytes 2-x of the arbitrary length data buffer, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1734745"></A>  }                 // where x is the last index of the overall buffer</P>
<P CLASS="Body">
<A NAME="pgfId-1734729"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1721235"></A>Status (byte 0) indicates the status code of a given GenericSerialBus transaction. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721236"></A>Length (byte 1) specifies the number of bytes of valid data that exists in the data buffer. Use of this field is only defined for the Read/Write Block protocol. For other protocols--where the data length is implied by the protocol--this field is reserved. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1721237"></A>Data (bytes 2-x) represents an arbitrary length buffer, and is the location where actual data is stored.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1721238"></A>For example, the following ASL shows the use of the GenericSerialBus data buffer for performing transactions to a Smart Battery device. <A NAME="marker-1721239"></A><A NAME="marker-1721240"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721241"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721242"></A>/* Create the GenericSerialBus data buffer */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721243"></A>Name(BUFF, Buffer(34){})            // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721244"></A>CreateByteField(BUFF, 0x00, STAT)   // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721245"></A>CreateByteField(BUFF, 0x01, LEN)    // LEN = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721246"></A>CreateWordField(BUFF, 0x02, DATW)   // DATW = Data (Word - Bytes 2 &amp; 3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721247"></A>CreateField(BUFF, 0x10, 256, DBUF)  // DBUF = Data (Block - Bytes 2-33)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721248"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721249"></A>/* Read the battery temperature */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721250"></A>Store(BTMP, BUFF)                   // Invoke Read Word transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721251"></A>If(LEqual(STAT, 0x00))              // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721252"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721253"></A>                                    // DATW = Battery temperature in 1/10th degrees </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847389"></A>                                    // Kelvin</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721254"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721255"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721256"></A>/* Read the battery manufacturer name */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721257"></A>Store(MFGN, BUFF)                   // Invoke Read Blocktransaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721258"></A>If(LEqual(STAT, 0x00))              // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721259"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721260"></A>   // LEN = Length of the manufacturer name</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721261"></A>   // DBUF = Manufacturer name (as a counted string)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721262"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721263"></A>Notice the use of the CreateField primitives to access the data buffer&#8217;s sub-elements (Status, Length, and Data), where Data (bytes 2-33) is &#8216;typecast&#8217; as both word (DATW) and block (DBUF) data.</P>
<P CLASS="Body">
<A NAME="pgfId-1721264"></A>The example above demonstrates the use of the Store() operator to invoke a Read Block transaction to obtain the name of the battery manufacturer. Evaluation of the source operand (MFGN) results in a 34-byte buffer that gets copied by Store() to the destination buffer (BUFF).</P>
<P CLASS="Body">
<A NAME="pgfId-1721265"></A>Capturing the results of a write operation, for example to check the status code, requires an additional Store() operator, as shown below.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721266"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721267"></A>Store(Store(BUFF, MFGN), BUFF)    // Invoke Write Block transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721268"></A>If(LEqual(STAT, 0x00)) {...}        // Transaction successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721269"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-1721270"></A>Note that the outer Store() copies the results of the Write Block transaction back into BUFF. This is the nature of BufferAcc&#8217;s bi-directionality. It should be noted that storing (or parsing) the result of a GenericSerialBus Write transaction is not required although useful for ascertaining the outcome of a transaction.</P>
<P CLASS="Body">
<A NAME="pgfId-1721271"></A>GenericSerialBus Process Call protocols require similar semantics due to the fact that only destination operands are passed bi-directionally. These transactions require the use of the double-Store() semantics to prope<A NAME="_Toc465496095"></A><A NAME="_Toc486665600"></A>rly capture the return results.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1721274"></A><A NAME="66685"></A>Using the GenericSerialBus Protocols</H6>
<P CLASS="Body">
<A NAME="pgfId-1721275"></A>This section provides information and examples on how each of the GenericSerialBus protocols can be used to access GenericSerialBus devices from AML.<A NAME="marker-1721276"></A></P>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1730527"></A><A NAME="_Toc465496094"></A><A NAME="_Toc486665599"></A><A NAME="_Toc258262521"></A><A NAME="_Toc202341902"></A><A NAME="_Toc489272717"></A><A NAME="_Toc489267743"></A><A NAME="_Toc489267389"></A>Read/Write Quick (AttribQuick)<A NAME="marker-1721284"></A><A NAME="marker-1721285"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1721287"></A>The GenericSerialBus Read/Write Quick protocol (AttribQuick) is typically used to control simple devices using a device-specific binary command (for example, ON and OFF). Command values are not used by this protocol and thus only a single element (at offset 0) can be specified in the field definition. This protocol transfers no data.</P>
<P CLASS="Body">
<A NAME="pgfId-1721289"></A>The following ASL code illustrates how a device supporting the Read/Write Quick protocol should be accessed:<A NAME="marker-1783198"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721291"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)  // GenericSerialBus device at command value offset 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721292"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721293"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721294"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721295"></A>    AccessAs(BufferAcc, AttribQuick)  // Use the GenericSerialBus Read/Write Quick protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721296"></A>    FLD0, 8                           // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721297"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721298"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721299"></A>/* Create the GenericSerialBus data buffer */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721300"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721301"></A>Name(BUFF, Buffer(2){})               // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721302"></A>CreateByteField(BUFF, 0x00, STAT)     // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721303"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721304"></A>/* Signal device (e.g. OFF) */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721305"></A>Store(FLD0, BUFF)                     // Invoke Read Quick transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721306"></A>If(LEqual(STAT, 0x00)) {...}            // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721307"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721308"></A>/* Signal device (e.g. ON) */</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721309"></A>Store(BUFF, FLD0)                     // Invoke Write Quick transaction</P>
<P CLASS="Body">
<A NAME="pgfId-1721310"></A>In this example, a single field element (FLD0) at offset 0 is defined to represent the protocol&#8217;s read/write bit. Access to FLD0 will cause a GenericSerialBus transaction to occur to the device. Reading the field results in a Read Quick, and writing to the field results in a Write Quick. In either case data is not transferred--access to the register is simply used as a mechanism to invoke the transaction.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1730554"></A><A NAME="_Toc465496096"></A><A NAME="_Toc486665601"></A><A NAME="_Toc258262523"></A><A NAME="_Toc202341904"></A><A NAME="_Toc489272719"></A><A NAME="_Toc489267745"></A><A NAME="_Toc489267391"></A><A NAME="_Toc258262522"></A><A NAME="_Toc202341903"></A><A NAME="_Toc489272718"></A><A NAME="_Toc489267744"></A><A NAME="_Toc489267390"></A>Send/Receive Byte (AttribSendReceive)<A NAME="marker-1721323"></A><A NAME="marker-1721324"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1721326"></A>The GenericSerialBus Send/Receive Byte protocol (AttribSendReceive) transfers a single byte of data. Like Read/Write Quick, command values are not used by this protocol and thus only a single element (at offset 0) can be specified in the field definition.</P>
<P CLASS="Body">
<A NAME="pgfId-1721328"></A>The following ASL code illustrates how a device supporting the Send/Receive Byte protocol should be accessed:<A NAME="marker-1721327"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1739878"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783237"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)  // GenericSerialBus device at command value offset 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721331"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721332"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721333"></A>     Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721334"></A>     AccessAs(BufferAcc, AttribSendReceive) // Use the GenericSerialBus Send/Receive </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847434"></A>                                            // Byte protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721335"></A>     FLD0, 8                                // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721336"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721337"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721338"></A>// Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722594"></A>Name(BUFF, Buffer(3){})            // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722595"></A>CreateByteField(BUFF, 0x00, STAT)  // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722596"></A>CreateByteField(BUFF, 0x02, DATA)  // DATA = Data (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721344"></A>                                   // Receive a byte of data from the device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721345"></A>Store(FLD0, BUFF)                  // Invoke a Receive Byte transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721346"></A>If(LEqual(STAT, 0x00))             // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721347"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721348"></A>     // DATA = Received byte...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721349"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721350"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721351"></A>// Send the byte &#8216;0x16&#8217; to the device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721352"></A>Store(0x16, DATA)                  // Save 0x16 into the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721353"></A>Store(BUFF, FLD0)                  // Invoke a Send Byte transaction</P>
<P CLASS="Body">
<A NAME="pgfId-1730585"></A>In this example, a single field element (FLD0) at offset 0 is defined to represent the protocol&#8217;s data byte. Access to FLD0 will cause a GenericSerialBus transaction to occur to the device. Reading the field results in a Receive Byte, and writing to the field results in a Send Byte.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1730590"></A><A NAME="_Toc465496097"></A><A NAME="_Toc486665602"></A>Read/Write Byte (AttribByte)<A NAME="marker-1730588"></A><A NAME="marker-1730589"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1730591"></A>The GenericSerialBus Read/Write Byte protocol (AttribByte) also transfers a single byte of data. But unlike Send/Receive Byte, this protocol uses a command value to reference up to 256 byte-sized virtual registers.</P>
<P CLASS="Body">
<A NAME="pgfId-1721362"></A>The following ASL code illustrates how a device supporting the Read/Write Byte protocol should be accessed:<A NAME="marker-1721361"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722529"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)  // GenericSerialBus device at command value offset</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721365"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721366"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721367"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721368"></A>    AccessAs(BufferAcc, AttribByte)   // Use the GenericSerialBus Read/Write Byte protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721369"></A>    FLD0, 8,                          // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721370"></A>    FLD1, 8,                          // Virtual register at command value 1.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721371"></A>    FLD2, 8                           // Virtual register at command value 2.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721372"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721373"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721374"></A>// Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721375"></A>Name(BUFF, Buffer(3){})       </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722523"></A>// Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721376"></A>CreateByteField(BUFF, 0x00, STAT)     // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721377"></A>CreateByteField(BUFF, 0x02, DATA)     // DATA = Data (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721378"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721379"></A>// Read a byte of data from the device using command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721380"></A>Store(FLD1, BUFF)                     // Invoke a Read Byte transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721381"></A>If(LEqual(STAT, 0x00))                // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721382"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721383"></A>                                      // DATA = Byte read from FLD1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721384"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721385"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721386"></A>// Write the byte &#8216;0x16&#8217; to the device using command value 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721387"></A>Store(0x16, DATA)                     // Save 0x16 into the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721388"></A>Store(BUFF, FLD2)                     // Invoke a Write Byte transaction</P>
<P CLASS="Body">
<A NAME="pgfId-1721390"></A>In this example, three field elements (FLD0, FLD1, and FLD2) are defined to represent the virtual registers for command values 0, 1, and 2. Access to any of the field elements will cause a GenericSerialBus transaction to occur to the device. Reading FLD1 results in a Read Byte with a command value of 1, and writing to FLD2 results in a Write Byte with command value 2.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1730604"></A><A NAME="_Toc258262524"></A><A NAME="_Toc202341905"></A><A NAME="_Toc489272720"></A><A NAME="_Toc489267746"></A><A NAME="_Toc489267392"></A>Read/Write Word (AttribWord)<A NAME="marker-1721396"></A><A NAME="marker-1721397"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1721399"></A>The GenericSerialBus Read/Write Word protocol (AttribWord) transfers 2 bytes of data. This protocol also uses a command value to reference up to 256 word-sized virtual device registers. </P>
<P CLASS="Body">
<A NAME="pgfId-1721401"></A>The following ASL code illustrates how a device supporting the Read/Write Word protocol should be accessed:<A NAME="marker-1721400"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783310"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100) // GenericSerialBus device at command value offset 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721404"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721405"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721406"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721407"></A>    AccessAs(BufferAcc, AttribWord)// Use the GenericSerialBus Read/Write Word protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721408"></A>    FLD0, 8,                       // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721409"></A>    FLD1, 8,                       // Virtual register at command value 1.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721410"></A>    FLD2, 8                        // Virtual register at command value 2.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721411"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721412"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721413"></A>// Create the GenericSerialBus data buffer		</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721414"></A>Name(BUFF, Buffer(6){})					            // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721415"></A>CreateByteField(BUFF, 0x00, STAT)  // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721416"></A>CreateWordField(BUFF, 0x02, DATA)  // DATA = Data (Word)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721417"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721418"></A>// Read two bytes of data from the device using command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721419"></A>Store(FLD1, BUFF)                  // Invoke a Read Word transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721420"></A>If(LEqual(STAT, 0x00))             // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721421"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721422"></A>     // DATA = Word read from FLD1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721423"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721424"></A>// Write the word &#8216;0x5416&#8217; to the device using command value 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721425"></A>Store(0x5416, DATA)               // Save 0x5416 into the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721426"></A>Store(BUFF, FLD2)                 // Invoke a Write Word transaction</P>
<P CLASS="Body">
<A NAME="pgfId-1721427"></A>In this example, three field elements (FLD0, FLD1, and FLD2) are defined to represent the virtual registers for command values 0, 1, and 2. Access to any of the field elements will cause a GenericSerialBus transaction to occur to the device. Reading FLD1 results in a Read Word with a command value of 1, and writing to FLD2 results in a Write Word with command value 2.</P>
<P CLASS="Body">
<A NAME="pgfId-1721428"></A>Notice that although accessing each field element transmits a word (16 bits) of data, the fields are listed as 8 bits each. The actual data size is determined by the protocol. Every field element is declared with a length of 8 bits so that command values and byte offsets are equivalent.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1721430"></A>Read/Write Block (AttribBlock)</H6>
<P CLASS="Body">
<A NAME="pgfId-1721431"></A>The GenericSerialBus Read/Write Block protocol (AttribBlock) transfers variable-sized data. This protocol uses a command value to reference up to 256 block-sized virtual registers. </P>
<P CLASS="Body">
<A NAME="pgfId-1721433"></A>The following ASL code illustrates how a device supporting the Read/Write Block protocol should be accessed:<A NAME="marker-1721432"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721436"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721437"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721438"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721439"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721440"></A>    Offset(0x0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721441"></A>    AccessAs(BufferAcc, AttribBlock),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721442"></A>    TFK1, 8,</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721443"></A>    TFK2, 8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721444"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721445"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721446"></A>// Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721447"></A>Name(BUFF, Buffer(34){})            // Create SerialBus buf as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721448"></A>CreateByteField(BUFF, 0x00, STAT)   // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721449"></A>CreateBytefield(BUFF, 0x01, LEN)	    // LEN = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721450"></A>CreateWordField(BUFF, 0x03, DATW)   // DATW = Data (Word - Bytes 2 &amp; 3, or 16 bits)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721451"></A>CreateField(BUFF, 16, 256, DBUF)    // DBUF = Data (Bytes 2-33)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721452"></A>CreateField(BUFF, 16, 32,  DATD)    // DATD = Data (DWord)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721453"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721454"></A>// Read block of data from the device using command value 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721455"></A>Store(TFK1, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721456"></A>If(LNotEqual(STAT, 0x00)) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721457"></A>    Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721458"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721459"></A>// Read block of data from the device using command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721460"></A>Store(TFK2, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721461"></A>If(LNotEqual(STAT, 0x00)) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721462"></A>    Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721463"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783352"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783350"></A>&lt;...&gt;</P>
<P CLASS="Body">
<A NAME="pgfId-1721464"></A>In this example, two field elements (TFK1, and TFK2) are defined to represent the virtual registers for command values 0 and 1. Access to any of the field elements will cause a GenericSerialBus transaction to occur to the device. </P>
<P CLASS="Body">
<A NAME="pgfId-1721465"></A>Writing blocks of data requires similar semantics, such as in the following example.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721466"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722413"></A>Store(16, LEN) // In bits, so 4 bytes<BR>
Store(Store(BUFF, TFK1), BUFF)     // Invoke Write Block transaction<BR>
If(LEqual(STAT, 0x00)) {...}         // Transaction successful?</P>
<P CLASS="Body">
<A NAME="pgfId-1721467"></A>This accessor is not viable for some SPBs because the bus may not support the appropriate functionality. In cases that variable length buffers are desired but the bus does not support block accessors, refer to the SerialBytes protocol.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1721479"></A>Word Process Call (AttribProcessCall)<A NAME="marker-1721477"></A><A NAME="marker-1721478"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1721480"></A>The GenericSerialBus Process Call protocol (AttribProcessCall) transfers 2 bytes of data bi-directionally (performs a Write Word followed by a Read Word as an atomic transaction). This protocol uses a command value to reference up to 256 word-sized virtual registers. </P>
<P CLASS="Body">
<A NAME="pgfId-1721482"></A>The following ASL code illustrates how a device supporting the Process Call protocol should be accessed:<A NAME="marker-1721481"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783382"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100) // GenericSerialBus device at slave address 0x42</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721485"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721486"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721487"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721488"></A>    AccessAs(BufferAcc, AttribProcessCall)      // Use the GenericSerialBus Process Call protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721489"></A>    FLD0, 8,                      // Virtual register at command value 0.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721490"></A>    FLD1, 8,                      // Virtual register at command value 1.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721491"></A>    FLD2, 8                       // Virtual register at command value 2.</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721492"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721493"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721494"></A>// Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721495"></A>Name(BUFF, Buffer(6){})          // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721496"></A>CreateByteField(BUFF, 0x00, STAT) // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721497"></A>CreateWordField(BUFF, 0x02, DATA) // DATA = Data (Word)</P>
<P CLASS="Body">
<A NAME="pgfId-1721498"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721499"></A>// Process Call with input value &#8216;0x5416&#8217; to the device using command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721500"></A>Store(0x5416, DATA)              // Save 0x5416 into the data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721501"></A>Store(Store(BUFF, FLD1), BUFF)   // Invoke a Process Call transaction</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721502"></A>If(LEqual(STAT, 0x00))           // Successful?</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721503"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721504"></A>                                 // DATA = Word returned from FLD1...</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721505"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721506"></A>In this example, three field elements (FLD0, FLD1, and FLD2) are defined to represent the virtual registers for command values 0, 1, and 2. Access to any of the field elements will cause a GenericSerialBus transaction to occur to the device. Reading or writing FLD1 results in a Process Call with a command value of 1. Notice that unlike other protocols, Process Call involves both a write and read operation in a single atomic transaction. This means that the Data element of the GenericSerialBus data buffer is set with an input value before the transaction is invoked, and holds the output value following the successful completion of the transaction.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1721514"></A>Block Process Call (AttribBlockProcessCall)<A NAME="marker-1721512"></A><A NAME="marker-1721513"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1721515"></A>The GenericSerialBus Block Write-Read Block Process Call protocol (AttribBlockProcessCall) transfers a block of data bi-directionally (performs a Write Block followed by a Read Block as an atomic transaction). This protocol uses a command value to reference up to 256 block-sized virtual registers. </P>
<P CLASS="Body">
<A NAME="pgfId-1721517"></A>The following ASL code illustrates how a device supporting the Process Call protocol should be accessed:<A NAME="marker-1721516"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721519"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)  // GenericSerialBus device at </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847552"></A>                                                      // slave address 0x42</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721520"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721521"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721522"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))        </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721523"></A>         AccessAs(BufferAcc, AttribBlockProcessCall) // Use the Block Process Call </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847612"></A>                                                     // protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721524"></A>         FLD0, 8,                                   // Virtual register representing </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847686"></A>                                                    // a command value of 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721525"></A>         FLD1, 8                                     // Virtual register representing </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1847825"></A>                                                    // a command value of 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721526"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721527"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721528"></A>// Create the GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721529"></A>Name(BUFF, Buffer(35)())                    // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721530"></A>CreateByteField(BUFF, 0x00, STAT)           // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721531"></A>CreateByteField(BUFF, 0x01, LEN)            // LEN = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721532"></A>CreateField(BUFF, 0x10, 256, DATA)          // Data (Block)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721533"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721534"></A>// Process Call with input value &quot;ACPI&quot; to the device using command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721535"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721536"></A>Store(&quot;ACPI&quot;, DATA)                         // Fill in outgoing data</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721537"></A>Store(8, LEN)                               // Length of the valid data</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721538"></A>Store(Store(BUFF, FLD1), BUFF)              // Execute the PC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721539"></A>if (LEqual(STAT, 0x00))                     // Test the status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721540"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721541"></A>	// BUFF now contains information returned from PC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721542"></A>	// LEN now equals size of data returned</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721545"></A>}<A NAME="marker-1721543"></A><A NAME="marker-1721544"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1721547"></A><A NAME="78317"></A>Read/Write N Bytes (AttribBytes)</H6>
<P CLASS="Body">
<A NAME="pgfId-1721548"></A>The GenericSerialBus Read/Write N Bytes protocol (AttribBytes) transfers variable-sized data. The actual number of bytes to read or write is specified as part of the AccessAs attribute. </P>
<P CLASS="Body">
<A NAME="pgfId-1721550"></A>The following ASL code illustrates how a device supporting the Read/Write N Bytes protocol should be accessed:<A NAME="marker-1721549"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1783467"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721554"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721555"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721556"></A>    Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))        </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721557"></A>        Offset(0x0),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721558"></A>        AccessAs(BufferAcc, AttribBytes (4)),</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721559"></A>        TFK1, 8,                    //TFK1 at command value 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721560"></A>        TFK2, 8,                    //TFK2 at command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721561"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721562"></A>    Connection(I2CSerialBus(0x5b,,100000,,&quot;&#92;_SB.I2C&quot;,,,,RawDataBuffer(){2,9}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721563"></A>     // same connection attribute, but different vendor data passed to driver</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721564"></A>         AccessAs(BufferAcc, AttribByte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721565"></A>         TM1, 8                      //TM1 at command value 2</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721566"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721567"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721568"></A>// Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721569"></A>Name(BUFF, Buffer(34){})            // Create SerialBus buf as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721570"></A>CreateByteField(BUFF, 0x00, STAT)   // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721571"></A>CreateBytefield(BUFF, 0x01, LEN)    // LEN = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721572"></A>CreateWordField(BUFF, 0x02, DATW)   // DATW = Data (Word - Bytes 2 &amp; 3, or 16 bits)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721573"></A>CreateField(BUFF, 16, 256, DBUF)    // DBUF = Data (Bytes 2-34)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721574"></A>CreateField(BUFF, 16, 32,  DATD)    // DATD = Data (DWord)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721575"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721576"></A>// Read block of data from the device using command value 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721577"></A>Store(TFK1, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721578"></A>If(LNotEqual(STAT, 0x00)) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721579"></A>     Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721580"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721581"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721582"></A>// Write block of data to the device using command value 1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721583"></A>Store(Store(BUFF,TFK2), BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721584"></A>If(LNotEqual(STAT, 0x00)) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721585"></A>     Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721586"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721587"></A>In this example, two field elements (TFK1, and TFK2) are defined to represent the virtual registers for command values 0 and 1. Access to any of the field elements will cause a GenericSerialBus transaction to occur to the device of the length specified in the AccessAttributes. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1721589"></A><A NAME="40392"></A>Raw Read/Write N Bytes (AttribRawBytes)</H6>
<P CLASS="Body">
<A NAME="pgfId-1721590"></A>The GenericSerialBus Raw Read/Write N Bytes protocol (AttribRawBytes) transfers variable-sized data. The actual number of bytes to read or write is specified as part of the AccessAs attribute. The initial command value specified in the operation region definition is ignored by Raw accesses.</P>
<P CLASS="Body">
<A NAME="pgfId-1721592"></A>The following ASL code illustrates how a device supporting the Read/Write N Bytes protocol should be accessed:<A NAME="marker-1721591"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721595"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721596"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721597"></A>    {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721598"></A>     Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))    </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722337"></A>        AccessAs(BufferAcc, AttribRawBytes (4))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722338"></A>        TFK1, 8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722339"></A>    }</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="code-Ex-CODE-PRE-CITE">
<A NAME="pgfId-1721602"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1721603"></A>// Create the GenericSerialBus data buffer</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721604"></A>Name(BUFF, Buffer(34){})             // Create SerialBus buf as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721605"></A>CreateByteField(BUFF, 0x00, STAT)    // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721606"></A>CreateByteField(BUFF, 0x01, LEN)     // LEN = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721607"></A>CreateWordField(BUFF, 0x02, DATW)    // DATW = Data (Word - Bytes 2 &amp; 3, or 16 bits)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721608"></A>CreateField(BUFF, 16, 256, DBUF)     // DBUF = Data (Bytes 2-34)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721609"></A>CreateField(BUFF, 16, 32,  DATD)     // DATD = Data (DWord)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721610"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721611"></A>Store(0x0B,DATW)                     //Store appropriate reference data for driver to interpret</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721612"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721613"></A>//Read from TFK1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721614"></A>Store(TFK1, BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721615"></A>If(LNotEqual(STAT, 0x00)) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721616"></A>     Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721617"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721618"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721619"></A>//Write to TFK1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721620"></A>Store(Store(BUFF,TFK1), BUFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721621"></A>If(LNotEqual(STAT, 0x00)) { </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721622"></A>     Return(0) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721623"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721624"></A>Access to any field elements will cause a GenericSerialBus transaction to occur to the device of the length specified in the AccessAttributes. </P>
<P CLASS="Body">
<A NAME="pgfId-1721625"></A>Raw accesses assume that the writer has knowledge of the bus that the access is made over and the device that is being accessed. The protocol may only ensure that the buffer is transmitted to the appropriate driver, but the driver must be able to interpret the buffer to communicate to a register.</P>
<DIV>
<H6 CLASS="Heading-7">
<A NAME="pgfId-1721627"></A>Raw Block Process Call (AttribRawProcessBytes)</H6>
<P CLASS="Body">
<A NAME="pgfId-1721628"></A>The GenericSerialBus Raw Write-Read Block Process Call protocol (AttribRawProcessBytes) transfers a block of data bi-directionally (performs a Write Block followed by a Read Block as an atomic transaction). The initial command value specified in the operation region definition is ignored by Raw accesses.</P>
<P CLASS="Body">
<A NAME="pgfId-1721630"></A>The following ASL code illustrates how a device supporting the Process Call protocol should be accessed:<A NAME="marker-1721629"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721632"></A>OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)  // GenericSerialBus device at slave address 0x42</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721633"></A>Field(TOP1, BufferAcc, NoLock, Preserve)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722342"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722343"></A>     Connection(I2CSerialBusV2(0x5a,,100000,,&quot;&#92;_SB.I2C&quot;,,,,,RawDataBuffer(){1,6}))        </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1722344"></A>         AccessAs(BufferAcc, AttribRawProcessBytes)   // Use the Raw Bytes Process Call protocol</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721637"></A>         FLD0, 8</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721638"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1721639"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721640"></A>// Create the GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721641"></A>Name(BUFF, Buffer(34)())           // Create GenericSerialBus data buffer as BUFF</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721642"></A>CreateByteField(BUFF, 0x00, STAT)  // STAT = Status (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721643"></A>CreateByteField(BUFF, 0x01, LEN)   // LEN = Length (Byte)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721644"></A>CreateWordField(BUFF,0x02, DATW)  // Data (Bytes 2 and 3)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721645"></A>CreateField(BUFF, 0x10, 256, DATA) // Data (Block)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721646"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721647"></A>Store(0x0B,DATW)                   //Store appropriate reference data for driver to interpret</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721648"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721649"></A>// Process Call with input value &quot;ACPI&quot; to the device</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721650"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721651"></A>Store(&quot;ACPI&quot;, DATA)               // Fill in outgoing data</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721652"></A>Store(8, LEN)                     // Length of the valid data</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721653"></A>Store(Store(BUFF, FLD0), BUFF)    // Execute the PC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721654"></A>if (LEqual(STAT, 0x00))           // Test the status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721655"></A>{</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721656"></A>     // BUFF now contains information returned from PC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721657"></A>     // LEN now equals size of data returned</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1721660"></A>}<A NAME="marker-1721658"></A><A NAME="marker-1721659"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1721006"></A>Raw accesses assume that the writer has knowledge of the bus that the access is made over and the device that is being accessed. The protocol may only ensure that the buffer is transmitted to the appropriate driver, but the driver must be able to interpret the buffer to communicate to a register.</P>
<P CLASS="Body">
<A NAME="pgfId-1837889"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1837920"></A><A NAME="24517"></A>Declaring PCC Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1837922"></A><A NAME="_Ref265757165"></A>The Platform Communication Channel (PCC) is described in Chapter 14. The PCC table, described in <A HREF="Platform_Comm_Channel.htm#59683" CLASS="XRef">See Platform Communications Channel Table.</A>, contains information about PCC subspaces implemented in a given platform, where each subspace is a unique channel.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1837923"></A>Overview</H6>
<P CLASS="Body">
<A NAME="pgfId-1837924"></A>The PCC Operation Region works in conjunction with the PCC Table (<A HREF="Platform_Comm_Channel.htm#59683" CLASS="XRef">See Platform Communications Channel Table.</A>). The PCC Operation Region is associated with the region of the shared memory that follows the PCC signature. PCC Operation Region must not be used for extended subspaces of Type 4 (Slave subspaces). PCC subspaces that are earmarked for use as PCC Operation Regions must not be used as PCC subspaces for standard ACPI features such as CPPC, RASF, PDTT and MPST. These standard features must always use the PCC Table instead.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1837925"></A>Declaring a PCC OperationRegion</H6>
<P CLASS="Body">
<A NAME="pgfId-1837926"></A>The syntax for the <EM CLASS="CodeCharacter">
OperationRegion</EM>
 term (<A HREF="ACPI_Source_Language_Reference.htm#_Toc489267440" CLASS="XRef">See OperationRegion (Declare Operation Region).</A>) is described below:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837927"></A>OperationRegion (</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837928"></A>  RegionName,	      // NameString</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837929"></A>  RegionSpace,	     // RegionSpaceKeyword</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837930"></A>  Offset,	         // TermArg=&gt;Integer</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837931"></A>  Length           // TermArg=&gt;Integer</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837932"></A>)</P>
<P CLASS="Body">
<A NAME="pgfId-1837933"></A>The PCC Operation Region term in ACPI namespace will be defined thus:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837934"></A>OperationRegion ([subspace-name], PCC, [subspace-id], Length)</P>
<P CLASS="Body">
<A NAME="pgfId-1837935"></A>Where:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1837936"></A>RegionName is set to <EM CLASS="CodeCharacter">
[subspace-name]</EM>
, which is a unique name for this PCC subspace.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1837937"></A>RegionSpace must be set to <EM CLASS="CodeCharacter">
PCC</EM>
, operation region type 0x0A</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1837938"></A>Offset must be set to <EM CLASS="CodeCharacter">
[subspace-id]</EM>
, the subspace ID of this channel, as defined in the PCC table (PCCT).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1837939"></A>Length is the total size of the operation region, and is equal to the total size of the fields that succeed the PCC signature in the shared memory. </LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1837940"></A><A NAME="23133"></A>Declaring message fields within a PCC OperationRegion</H6>
<P CLASS="Body">
<A NAME="pgfId-1837941"></A>For all PCC subspace types, the PCC Operation Region pertains to the region of PCC subspace that succeeds the PCC signature. The layout of the Shared Memory Regions is specific to the PCC subspace. The Operation Region handler must therefore obtain the subspace type first before it can comprehend and access individual fields within the subspace.</P>
<P CLASS="Body">
<A NAME="pgfId-1837942"></A>Fields within an Operation region are accessed using the <EM CLASS="CodeCharacter">
Field</EM>
 keyword, and correspond to the fields that succeed the PCC signature in the subspace shared memory. The syntax for the <EM CLASS="CodeCharacter">
Field</EM>
 term (from <A HREF="ACPI_Source_Language_Reference.htm#_Toc489267429" CLASS="XRef">See Field (Declare Field Objects).</A>) is as follows:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837943"></A>Field (</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837944"></A>  RegionName,</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837945"></A>  AccessType,</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837946"></A>  LockRule,</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837947"></A>  UpdateRule</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837948"></A>) {FieldUnitList}</P>
<P CLASS="Body">
<A NAME="pgfId-1837949"></A>For PCC Operation Regions:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1837950"></A>RegionName specifies the name of the operation region, declared above the field term.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1837951"></A>AccessType must be set to <EM CLASS="CodeCharacter">
ByteAcc</EM>
.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1837952"></A>LockRule indicates if access to this operation region requires acquisition of the Global lock for synchronization. This field must be set to <EM CLASS="CodeCharacter">
NoLock</EM>
.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1837953"></A>UpdateRule is not applicable to PCC operation regions, since each command region is accessed in its entirety.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1837954"></A>The <EM CLASS="CodeCharacter">
FieldUnitList</EM>
 specifies individual fields within the Shared Memory Region of the subspace, which depends on the type of subspace. The declaration of the fields must match the layout of the subspace. Accordingly, for the Generic Communications subspaces (Types 0-2), the <EM CLASS="CodeCharacter">
FieldUnitList</EM>
 may be declared as follows: </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837955"></A>Field(NAME, ByteAcc, NoLock, Preserve)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837956"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837957"></A>  CMD, 16,       // Command field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837959"></A>  STAT, 16,      // Status field, to be read on completion of the command</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837960"></A>  DATA, [Size]	   // Communication space of size [Size] bits</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837961"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1837962"></A>Likewise, for the Extended Communication subspaces (Type 3), the <EM CLASS="CodeCharacter">
FieldUnitList</EM>
 may be declared as follows:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837963"></A>Field(NAME, ByteAcc, NoLock, Preserve)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837964"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837965"></A>  FLGS, 32,      // Command Flags field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837967"></A>  LEN, 32, 	      // Length field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837968"></A>  CMD, 32,       	// Command field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837969"></A>  DATA, [Size]	   // Communication space of size [Size] bits</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837970"></A>}</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1837971"></A><A NAME="37561"></A>An Example of PCC Operation Region Declaration</H6>
<P CLASS="Body">
<A NAME="pgfId-1837972"></A>As an example, if a platform feature uses PCC subspace with subspace ID of 0x02 of subspace Type 3 (Extended PCC communication channel), then the caller may declare the operation region as follows:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837973"></A>OperationRegion(PFRM, PCC, 0x02, 0x10C)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837974"></A>Field(PFRM, ByteAcc, NoLock, Preserve)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837975"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837976"></A>  Offset (4),	      // Flags start at offset 4 from beginning of shared memory </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837977"></A>  FLGS, 32,        // Command Flags field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837978"></A>  LGTH, 32,        // Length field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837979"></A>  COMD, 32, 	       // Command field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837980"></A>  COSP, 0x800      // Communication space of size 256 bytes</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837981"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1837982"></A>In this example, PFRM is the name of the subspace dedicated to the platform feature, and the size of the shared memory region is 0x10C bytes (256 bytes of communication space and 16 bytes of fields excluding the PCC Signature).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1837983"></A>Using a PCC OperationRegion</H6>
<P CLASS="Body">
<A NAME="pgfId-1837984"></A>The PCC Operation Region handler begins transmission of the message on the channel when it detects a write to the <EM CLASS="CodeCharacter">
CMD</EM>
 field. The caller must therefore update all other fields relevant to the operation region first, and then in the final step, write the command itself. As explained in <A HREF="ACPI_Software_Programming_Model.htm#23133" CLASS="XRef">See Declaring message fields within a PCC OperationRegion.</A>,  the fields to be updated are specific to the subspace type.</P>
<P CLASS="Body">
<A NAME="pgfId-1837985"></A>For the Generic Communication subspace type (Types 0, 1 and 2), the order of Operation Region writes would be as follows:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1837986"></A>Write the command payload into the <EM CLASS="CodeCharacter">
DATA</EM>
 field.</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1837987"></A>Write the command into the <EM CLASS="CodeCharacter">
CMD</EM>
 field.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1837989"></A>For the Extended Communication subspace type (Type 3), the order of Operation Region writes would be as follows:</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1837990"></A>Write the command payload, length and flags into the <EM CLASS="CodeCharacter">
CMD</EM>
 , <EM CLASS="CodeCharacter">
LEN</EM>
 and <EM CLASS="CodeCharacter">
FLGS</EM>
 fields, respectively, in any order of preference.</H6>
<OL>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1837991"></A>Write the command into the <EM CLASS="CodeCharacter">
CMD</EM>
 field.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-1837993"></A>In the above steps, the fields are as described in<A HREF="ACPI_Software_Programming_Model.htm#37561" CLASS="XRef">See An Example of PCC Operation Region Declaration.</A>. When the platform completes processing the command, it uses the same subspace Shared Memory Region to return the response data. The caller can thus read the Operation Region to retrieve the response data.</P>
<P CLASS="Body">
<A NAME="pgfId-1837994"></A>If channel errors are encountered during transmission of the command or its response, the channel reports an error status in the Channel Status register. The caller must therefore first check the Channel Status register before processing the return data. For the Generic PCC Communication Subspaces, the Channel Status register is located in the Shared Memory Region itself, as described in <A HREF="Platform_Comm_Channel.htm#35261" CLASS="XRef">See Generic Communications Channel Status Field.</A>. The caller must thus check the <EM CLASS="CodeCharacter">
STAT</EM>
 field in the Operation Region for the purpose. For the Extended PCC Communication Subspaces, the Channel Status register is located anywhere in system memory or IO, and pointed to by the Error Status register field within the Type 3 PCC Subspace structure, as described in <A HREF="Platform_Comm_Channel.htm#56438" CLASS="XRef">See Extended PCC subspaces (types 3 and 4).</A>.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1837995"></A>Using the _REG Method for PCC Operation Regions</H6>
<P CLASS="Body">
<A NAME="pgfId-1837996"></A>It is possible for the OS to include PCC operation region handlers that only comprehend and support a subset of the possible subspaces defined in this specification. The OS can provide supplementary information in the _REG method in order to indicate which exact subspaces(s) are supported. To accomplish this, the Arg0 parameter passed to the _REG method must include both the Address Space ID (PCC) and a qualifying Address Space sub-type in Byte 1, as follows:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837997"></A>Arg0, Byte 0 = PCC = 0x0A</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837998"></A>Arg0, Byte 1 = subspace type as defined in Section 14.1.2.</P>
<P CLASS="Body">
<A NAME="pgfId-1838000"></A>The OS may now indicate support for handling PCC operation region subspace Type 3 by invoking the _REG method with Arg0=0x030A and Arg1 = 0x01.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1838001"></A>Example Use of a PCC OperationRegion</H6>
<P CLASS="Body">
<A NAME="pgfId-1838002"></A>The following sample ACPI Power Meter (<A HREF="Power_Source_and_Power_Meter_Devices.htm#_Toc258262426" CLASS="XRef">See Power Meters.</A>) implementation describes how a PCC Operation Region can be used to read a platform power sensor that is exposed through a platform services channel. In this sample system, the platform services channel is implemented as an Extended PCC Communication Channel (Type 3), and assigned a PCC subspace ID of 0x07 in the PCCT. The sample platform implements three sensors - two power sensors, associated with CPU cluster 0 and cluster 1 respectively, and a SoC-level thermal sensor. The power sensors are read using command 0x15 (READ_POWER_SENSOR), while the thermal sensor is read using command 0x16 (READ_THERMAL_SENSOR), both on the platform services channel. The READ_POWER_SENSOR command take two input parameters called <EM CLASS="CodeCharacter">
SensorInstance</EM>
 and <EM CLASS="CodeCharacter">
MeasurementFormat</EM>
, which are appended together to the command as the payload. <EM CLASS="CodeCharacter">
SensorInstance</EM>
 specifies which power sensor is being referenced. <EM CLASS="CodeCharacter">
MeasurementFormat</EM>
 specifies the measurement unit (watts or milliwatts) in which the power consumption is expressed. The command payload is thus formatted as follows:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838003"></A>typedef struct</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838004"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838005"></A>  BYTE   SensorInstance;    	// Which instance of the sensor is being read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838006"></A>  BYTE   MeasurementFormat; 	// 0 = mW, 1 = W</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838007"></A>} COMMAND_PAYLOAD;</P>
<P CLASS="Body">
<A NAME="pgfId-1838008"></A>The power sensor for CPU cluster 0 is read by setting SensorInstance to 0x01, while the power sensor for CPU cluster 1 is read by setting SensorInstance to 0x02.</P>
<P CLASS="Body">
<A NAME="pgfId-1838009"></A>The response to the command from the platform is of the form:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838010"></A>typedef struct</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838011"></A>{</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838012"></A>  DWORD   Reading;	          // The sensor value read</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838013"></A>  DWORD   Status;	           // Status of the operation - 0: success, non-zero: error</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838014"></A>} SENSOR_RESPONSE;</P>
<P CLASS="Body">
<A NAME="pgfId-1838015"></A>Here, the field <EM CLASS="CodeCharacter">
Status</EM>
 pertains to the success or failure of the requested service. Channel errors can occur independent of the service, during transmission of the request. A generic placeholder register, <EM CLASS="CodeCharacter">
CHANNEL_STATUS_REG</EM>
 , and an associated error status field, <EM CLASS="CodeCharacter">
ERROR_STATUS_BIT</EM>
, is used as an illustration of how the channel status register may be read to detect channel errors during transit.</P>
<P CLASS="Body">
<A NAME="pgfId-1838016"></A>The ACPI Power Meter object may now be implemented for this example platform as follows:</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838017"></A>Device (PMT0)               // ACPI Power Meter object for CPU Cluster 0 Power Sensor</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838018"></A>{ </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838019"></A>   Name (_HID, &quot;ACPI000D&quot;)  // ACPI Power Meter device</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838020"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838021"></A>   // The Operation Region declaration based on section 5.5.2.4.7.4</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838022"></A>   OperationRegion (PFRM, PCC, 0x07, 0x8C)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838023"></A>   Field(PFRM, ByteAcc, NoLock, Preserve)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838024"></A>   {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838026"></A>     FLGS, 32,              	// Command Flags field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838027"></A>     LEN, 32,               	// Length field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838028"></A>     CMD, 32,               	// Command field</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838029"></A>     DATA, 0x400	            // Communication space of size 128 bytes</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838030"></A>   }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838031"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838032"></A>   Method (_REG, 2)         // Check if OS Op region handler is available</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838033"></A>   {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838034"></A>       // Check if Arg0.Byte0 = 0xA, PCC Operation Region Supported?</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838035"></A>       // Check if Arg0.Byte1 = 0x3, subchannel type 3 as defined in Table 14-357</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838036"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838037"></A>       // Disallow further processing until support for Type 3 becomes available</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838038"></A>   }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838039"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838040"></A>   Method (_PMM, 0, Serialized)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838041"></A>   {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838042"></A>      // Read a Power sensor</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838043"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838044"></A>      // Create the command buffer</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838045"></A>      Name(BUFF, Buffer(0x80){})		           // Create PCC data buffer as BUFF</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838046"></A>      Name(PAYL, Buffer(2) {0x02, 0x01})   	// Instance = CPU cluster 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838047"></A>					       // Read power in units of Watts</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838048"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838049"></A>      Store (PAYL, DATA)	                   // Only first two bytes written</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838050"></A>                        	                   // the rest default to 0</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838051"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838052"></A>      // Update the length and status fields</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838053"></A>      Store (0x06, LEN)	                    // 4B (command) + 2B (payload)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838054"></A>      Store (0x01, FLGS)	                   // Set Notify on Completion</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838055"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838056"></A>      // All done. Now write to the command field to begin transmission of</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838057"></A>      // the message over the PCC subspace. On receipt, the platform will </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838058"></A>      // read power sensor of CPU cluster 0 and return the power consumption</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838059"></A>      // reading in the Operation Region itself</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838060"></A>      //</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838061"></A>      Store (0x15, CMD)		                   // READ_POWER_SENSOR command = 0x15</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838062"></A>&nbsp;</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838063"></A>      If(LEqual( LAnd (CHANNEL_STATUS_REG, ERROR_STATUS_BIT), 0x01)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838064"></A>      {</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838065"></A>         Return (Ones).                    // Return invalid, so that the caller can take remedial steps</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838067"></A>      }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838068"></A>      </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838069"></A>      Store (DATA, BUFF)</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838070"></A>      CreateDWordField(BUFF, 0x00, PCL1)  // Power consumed by CPU cluster 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838071"></A>      CreateDWordField(BUFF, 0x01, STAT)  // Return status</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838072"></A>      If(LEqual(STAT, 0x0))               // Successful?</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838073"></A>      { </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838074"></A>         Return(PCL1)                     // Return the power measurement for CPU cluster 1</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838075"></A>      }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838076"></A>      Else</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838077"></A>      { </P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838078"></A>        Return(Ones)                      // Return invalid</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838079"></A>      }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1838080"></A>   }</P>
<P CLASS="CodeParagraph">
<A NAME="pgfId-1837891"></A>}</P>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1363130"></A><A NAME="_Toc489256027"></A><A NAME="_Toc489267951"></A><A NAME="_Toc489272504"></A><A NAME="_Toc202340553"></A><A NAME="_Toc258262237"></A>ACPI Event Programming Model<A NAME="marker-1363128"></A><A NAME="marker-1363129"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1714331"></A>The ACPI event programming model is based on the SCI interrupt and General-Purpose Event (GPE) register. ACPI provides an extensible method to raise and handle the SCI interrupt, as described in this section.</P>
<P CLASS="Body">
<A NAME="pgfId-1714332"></A>Hardware-reduced ACPI platforms (<A HREF="ACPI Hardware Specification.htm#95525" CLASS="XRef">See Hardware-Reduced ACPI.</A>) use GPIO Interrupt Connections to signal ACPI Events, described in <A HREF="ACPI_Software_Programming_Model.htm#19454" CLASS="XRef">See GPIO-signaled ACPI Events.</A>, or Interrupt-signaled ACPI Events, described in <A HREF="ACPI_Software_Programming_Model.htm#36453" CLASS="XRef">See Interrupt-signaled ACPI events.</A>. Note that any ACPI platform may utilize GPIO-signaled and/or Interrupts-signaled ACPI events (i.e. they are not limited to Hardware-reduced ACPI platforms).</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1714338"></A><A NAME="_Toc489256028"></A><A NAME="_Toc489267952"></A><A NAME="_Toc489272505"></A><A NAME="_Toc202340554"></A><A NAME="_Toc258262238"></A> ACPI Event Programming Model Components</H6>
<P CLASS="Body">
<A NAME="pgfId-1363157"></A>The components of the ACPI event programming model are the following:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363158"></A>OSPM</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363159"></A>FADT</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363160"></A>PM1a_STS, PM1b_STS and PM1a_EN, PM1b_EN fixed register blocks</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363161"></A>GPE0_BLK and GPE1_BLK register blocks</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363162"></A>GPE register blocks defined in GPE block devices</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363163"></A>SCI interrupt</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363164"></A>ACPI AML code general-purpose event model</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363165"></A>ACPI device-specific model events</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363166"></A>ACPI Embedded Controller event model</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363167"></A>The role of each component in the ACPI event programming model is described in the following table.</P>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1363168"></A><A NAME="46820"></A>ACPI Event Programming Model Components</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685562"></A>Component</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1685564"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363175"></A>OSPM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363177"></A>Receives all SCI interrupts raised (receives all SCI events). Either handles the event or masks the event off and later invokes an OEM-provided control method to handle the event. Events handled directly by OSPM are fixed ACPI events; interrupts handled by control methods are general-purpose events.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363179"></A>FADT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363181"></A>Specifies the base address for the following fixed register blocks on an ACPI-compatible platform: PM1x_STS and PM1x_EN fixed registers and the GPEx_STS and GPEx_EN fixed registers.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363183"></A>PM1x_STS and PM1x_EN fixed registers </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363185"></A>PM1x_STS bits raise fixed ACPI events. While a PM1x_STS bit is set, if the matching PM1x_EN bit is set, the ACPI SCI event is raised.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363187"></A>GPEx_STS and GPEx_EN fixed registers</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363189"></A>GPEx_STS bits that raise general-purpose events. For every event bit implemented in GPEx_STS, there must be a comparable bit in GPEx_EN. Up to 256 GPEx_STS bits and matching GPEx_EN bits can be implemented. While a GPEx_STS bit is set, if the matching GPEx_EN bit is set, then the general-purpose SCI event is raised.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363191"></A>SCI interrupt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363193"></A>A level-sensitive, shareable interrupt mapped to a declared interrupt vector. The SCI interrupt vector can be shared with other low-priority interrupts that have a low frequency of occurrence.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363195"></A>ACPI AML code general-purpose event model</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363197"></A>A model that allows OEM AML code to use GPEx_STS events. This includes using GPEx_STS events as &#8220;wake&#8221; sources as well as other general service events defined by the OEM (&#8220;button pressed,&#8221; &#8220;thermal event,&#8221; &#8220;device present/not present changed,&#8221; and so on).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363199"></A>ACPI device-specific model events</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363201"></A>Devices in the ACPI namespace that have ACPI-specific device IDs can provide additional event model functionality. In particular, the ACPI embedded controller device provides a generic event model.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363203"></A>ACPI Embedded Controller event model</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363205"></A>A model that allows OEM AML code to use the response from the Embedded Controller Query command to provide general-service event defined by the OEM.</P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363230"></A>Types of ACPI Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1363231"></A>At the ACPI hardware level, two types of events can be signaled by an SCI interrupt:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363232"></A>Fixed ACPI events</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363233"></A>General-purpose events</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363234"></A>In turn, the general-purpose events can be used to provide further levels of events to the system. And, as in the case of the embedded controller, a well-defined second-level event dispatching is defined to make a third type of typical ACPI event. For the flexibility common in today&#8217;s designs, two first-level general-purpose event blocks are defined, and the embedded controller construct allows a large number of embedded controller second-level event-dispatching tables to be supported. Then if needed, the OEM can also build additional levels of event dispatching by using AML code on a general-purpose event to sub-dispatch in an OEM defined manner.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363250"></A><A NAME="_Toc202340556"></A><A NAME="_Toc258262240"></A>Fixed Event Handling<A NAME="marker-1363248"></A><A NAME="marker-1363249"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1363251"></A>When OSPM receives a fixed ACPI event, it directly reads and handles the event registers itself. The following table lists the fixed ACPI events. For a detailed specification of each event, see <A HREF="ACPI Hardware Specification.htm#44941" CLASS="XRef">See ACPI Hardware Specification.</A>, &#8220;ACPI Hardware Specification.&#8221; </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1363252"></A><A NAME="21557"></A>Fixed ACPI Events</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832767"></A>Event</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832769"></A>Comment</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1832771"></A>&nbsp;</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363261"></A>Power management timer carry bit set.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1363263"></A>For more information, see the description of the TMR_STS and TMR_EN bits of the PM1x fixed register block in <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping,&#8221; as well as the TMR_VAL register in the PM_TMR_BLK in <A HREF="ACPI Hardware Specification.htm#54017" CLASS="XRef">See Power Management Timer (PM_TMR).</A>, &#8220;Power Management Timer.&#8221;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363267"></A>Power button signal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1363269"></A>A power button can be supplied in two ways. One way is to simply use the fixed status bit, and the other uses the declaration of an ACPI power device and AML code to determine the event. For more information about the alternate-device based power button, see <A HREF="ACPI Hardware Specification.htm#77029" CLASS="XRef">See Control Method Power Button.</A>, Control Method Power Button.&#8221; </P>
<P CLASS="TableBody">
<A NAME="pgfId-1363270"></A>Notice that during the S0 state, both the power and sleep buttons merely notify OSPM that they were pressed.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1363271"></A>If the system does not have a sleep button, it is recommended that OSPM use the power button to initiate sleep operations as requested by the user.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363275"></A>Sleep button signal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1363277"></A>A sleep button can be supplied in one of two ways. One way is to simply use the fixed status button. The other way requires the declaration of an ACPI sleep button device and AML code to determine the event.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363281"></A>RTC alarm</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1363283"></A>ACPI-defines an RTC wake alarm function with a minimum of one-month granularity. The ACPI status bit for the device is optional. If the ACPI status bit is not present, the RTC status can be used to determine when an alarm has occurred. For more information, see the description of the RTC_STS and RTC_EN bits of the PM1x fixed register block in <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping.&#8221; </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363287"></A>Wake status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableBody">
<A NAME="pgfId-1363289"></A>The wake status bit is used to determine when the sleeping state has been completed. For more information, see the description of the WAK_STS and WAK_EN bits of the PM1x fixed register block in <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping.&#8221; </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363293"></A>System bus master request</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363295"></A>The bus-master status bit provides feedback from the hardware as to when a bus master cycle has occurred. This is necessary for supporting the processor C3 power savings state. For more information, see the description of the BM_STS bit of the PM1x fixed register block in <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping.&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="Table">
<A NAME="pgfId-1363297"></A>&nbsp;</H6>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363299"></A>Global release status</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1363301"></A>This status is raised as a result of the Global Lock protocol, and is handled by OSPM as part of Global Lock synchronization. For more information, see the description of the GBL_STS bit of the PM1x fixed register block in <A HREF="ACPI Hardware Specification.htm#47410" CLASS="XRef">See PM1 Event Grouping.</A>, &#8220;PM1 Event Grouping.&#8221; For more information on Global Lock, see <A HREF="ACPI_Software_Programming_Model.htm#18034" CLASS="XRef">See Global Lock.</A>, &#8220;Global Lock.&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="Table">
<A NAME="pgfId-1363303"></A>&nbsp;</H6>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1363316"></A><A NAME="marker-1363315"></A><A NAME="44234"></A>General-Purpose Event Handling</H6>
<P CLASS="Body">
<A NAME="pgfId-1363317"></A>When OSPM receives a general-purpose event, it either passes control to an ACPI-aware driver, or uses an OEM-supplied control method to handle the event. An OEM can implement up to 128 general-purpose event inputs in hardware per GPE block, each as either a level or edge event. It is also possible to implement a single 256-pin block as long as it&#8217;s the only block defined in the system. </P>
<P CLASS="Body">
<A NAME="pgfId-1363318"></A>An example of a general-purpose event is specified in <A HREF="ACPI Hardware Specification.htm#44941" CLASS="XRef">See ACPI Hardware Specification.</A>, &#8220;ACPI Hardware Specification,&#8221; where EC_STS and EC_EN bits are defined to enable OSPM to communicate with an ACPI-aware embedded controller device driver. The EC_STS bit is set when either an interface in the embedded controller space has generated an interrupt or the embedded controller interface needs servicing. Notice that if a platform uses an embedded controller in the ACPI environment, then the embedded controller&#8217;s SCI output must be directly and exclusively tied to a single GPE input bit.</P>
<P CLASS="Body">
<A NAME="pgfId-1363319"></A>Hardware can cascade other general-purpose events from a bit in the GPEx_BLK through status and enable bits in Operational Regions (I/O space, memory space, PCI configuration space, or embedded controller space). For more information, see the specification of the General-Purpose Event Blocks (GPEx_BLK) in <A HREF="ACPI Hardware Specification.htm#58185" CLASS="XRef">See General-Purpose Event Register Blocks.</A>, &#8220;General-Purpose Event Register Blocks.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1363320"></A>OSPM manages the bits in the GPEx blocks directly, although the source to those events is not directly known and is connected into the system by control methods. When OSPM receives a general-purpose event (the event is from either a GPEx_BLK STS bit, a GPIO pin, or an Interrupt), OSPM does the following:</P>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1363321"></A>Disables the interrupt source </H6>
<UL>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1779455"></A>(GPEx_BLK EN bit).</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1779471"></A>GPIO interrupt for GPIO-signaled events</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1779472"></A>Interrupt for Interrupt-signaled events</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1363322"></A>If an edge event, clears the status bit.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1363323"></A>Performs one of the following:</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363324"></A>Dispatches to an ACPI-aware device driver.</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363325"></A>Queues the matching control method for execution.</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363326"></A>Manages a wake event using device _PRW objects.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1363327"></A>If a level event, waits for the control method handler to complete and clears the status bit.</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1363328"></A>Enables the interrupt source.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363329"></A>For OSPM to manage the bits in the GPEx_BLK blocks directly:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363330"></A>Enable bits must be read/write.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363331"></A>Status bits must be latching.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363332"></A>Status bits must be read/clear, and cleared by writing a &#8220;1&#8221; to the status bit.</LI>
</UL>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1363337"></A>_<A NAME="RSVD_Exx"></A>Exx, _Lxx, and _Qxx Methods for GPE Processing <A NAME="marker-1363336"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1363338"></A>The OEM AML code can perform OEM-specific functions custom to each event the particular platform might generate by executing a control method that matches the event. For GPE events, OSPM will execute the control method of the name &#92;_GPE._TXX where XX is the hex value format of the event that needs to be handled and T indicates the event handling type (T must be either &#8216;E&#8217; for an edge event or &#8216;L&#8217; for a level event). The event values for status bits in GPE0_BLK start at zero (_T00) and end at the (GPE0_BLK_LEN / 2) - 1. The event values for status bits in GPE1_BLK start at GPE1_BASE and end at GPE1_BASE + (GPE1_BLK_LEN / 2) - 1. GPE0_BLK_LEN, GPE1_BASE, and GPE1_BLK_LEN are all defined in the FADT.</P>
<P CLASS="Body">
<A NAME="pgfId-1363339"></A>The _Qxx methods are used for the Embedded Controller and SMBus (below.)</P>
<DIV>
<H6 CLASS="Pb">
<A NAME="pgfId-1363345"></A>&nbsp;</H6>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1363346"></A><A NAME="45352"></A>Queuing the Matching Control Method for Execution</H6>
<P CLASS="Body">
<A NAME="pgfId-1363347"></A>When a general-purpose event is raised, OSPM uses a naming convention to determine which control method to queue for execution and how the GPE EOI is to be handled. The GPEx_STS bits in the GPEx_BLK are indexed with a number from 0 through FF. The name of the control method to queue for an event raised from an enable status bit is always of the form &#92;_GPE._Txx where xx is the event value and T indicates the event EOI protocol to use (either &#8216;E&#8217; for edge triggered, or &#8216;L&#8217; for level triggered). The event values for status bits in GPE0_BLK start at zero (_T00), end at the (GPE0_BLK_LEN / 2) - 1, and correspond to each status bit index within GPE0_BLK. The event values for status bits in GPE1_BLK are offset by GPE_BASE and therefore start at GPE1_BASE and end at GPE1_BASE + (GPE1_BLK_LEN / 2) - 1.</P>
<P CLASS="Body">
<A NAME="pgfId-1363348"></A>For example, suppose an OEM supplies a wake event for a communications port and uses bit 4 of the GPE0_STS bits to raise the wake event status. In an OEM-provided Definition Block, there must be a Method declaration that uses the name &#92;_GPE._L04 or &#92;GPE._E04 to handle the event. An example of a control method declaration using such a name is the following:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363350"></A>Method (&#92;_GPE._L04) {    // GPE 4 level wake handler</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363351"></A>    Notify (&#92;_SB.PCIO.COM0, 2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363352"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363353"></A>The control method performs whatever action is appropriate for the event it handles. For example, if the event means that a device has appeared in a slot, the control method might acknowledge the event to some other hardware register and signal a change notify request of the appropriate device object. Or, the cause of the general-purpose event can result from more then one source, in which case the control method for that event determines the source and takes the appropriate action.</P>
<P CLASS="Body">
<A NAME="pgfId-1685478"></A>When a general-purpose event is raised from the GPE bit tied to an embedded controller, the embedded controller driver uses another naming convention defined by ACPI for the embedded controller driver to determine which control method to queue for execution. The queries that the embedded controller driver exchanges with the embedded controller are numbered from 0 through FF, yielding event codes 01 through FF. (A query response of 0 from the embedded controller is reserved for &#8220;no outstanding events.&#8221;) The name of the control method to queue is always of the form _Qxx where xx is the number of the query acknowledged by the embedded controller. An example declaration for a control method that handles an embedded controller query is the following:<A NAME="marker-1685479"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1685480"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1685481"></A>Method(_Q34) {     // embedded controller event for thermal</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363358"></A>    Notify (&#92;_SB.TZ0.THM1, 0x80)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363359"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1363360"></A>When an SMBus alarm is handled by the SMBus driver, the SMBus driver uses a similar naming convention defined by ACPI for the driver to determine the control method to queue for execution. When an alarm is received by the SMBus host controller, it generally receives the SMBus address of the device issuing the alarm and one word of data. On implementations that use SMBALERT# for notifications, only the device address will be received. The name of the control method to queue is always of the form _Qxx where xx is the SMBus address of the device that issued the alarm. The SMBus address is 7 bits long corresponding to hex values 0 through 7F, although some addresses are reserved and will not be used. The control method will always be queued with one argument that contains the word of data received with the alarm. An exception is the case of an SMBus using SMBALERT# for notifications, in this case the argument will be 0. An example declaration for a control method that handles a SMBus alarm follows:<A NAME="marker-1363361"></A></P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363362"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1363363"></A>Method(_Q18, 1) {     // Thermal sensor device at address 001 1000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711351"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711352"></A>         // Arg0 contains notification value (if any)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711353"></A>         // Arg0 = 0 if device supports only SMBALERT# </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1711348"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1739924"></A>    Notify (&#92;_SB.TZ0.THM1, 0x80)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1739925"></A>}</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1739926"></A>Dispatching to an ACPI-Aware Device Driver</H6>
<P CLASS="Body">
<A NAME="pgfId-1363371"></A>Certain device support, such as an embedded controller, requires a dedicated GPE to service the device. Such GPEs are dispatched to native OS code to be handled and not to the corresponding GPE-specific control method.<A NAME="marker-1363372"></A><A NAME="marker-1363373"></A><A NAME="marker-1363374"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1363375"></A>In the case of the embedded controller, an OS-native, ACPI-aware driver is given the GPE event for its device. This driver services the embedded controller device and determines when events are to be reported by the embedded controller by using the Query command. When an embedded controller event occurs, the ACPI-aware driver dispatches the requests to other ACPI-aware drivers that have registered to handle the embedded controller queries or queues control methods to handle each event. If there is no device driver to handle specific queries, OEM AML code can perform OEM-specific functions that are customized to each event on the particular platform by including specific control methods in the namespace to handle these events. For an embedded controller event, OSPM will queue the control method of the name _QXX, where XX is the hex format of the query code. Notice that each embedded controller device can have query event control methods.</P>
<P CLASS="Body">
<A NAME="pgfId-1363376"></A>Similarly, for an SMBus driver, if no driver registers for SMBus alarms, the SMBus driver will queue control methods to handle these. Methods must be placed under the SMBus device with the name _QXX where XX is the hex format of the SMBus address of the device sending the alarm.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1363377"></A>GPE Wake Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1363381"></A>An important <A NAME="marker-1363380"></A>use of the general-purpose events is to implement device wake events. The components of the ACPI event programming model interact in the following way:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1363382"></A>When a device asserts its wake signal, the general-purpose status event bit used to track that device is set.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363383"></A>While the corresponding general-purpose enable bit is enabled, the SCI interrupt is asserted.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363384"></A>If the system is sleeping, this will cause the hardware, if possible, to transition the system into the S0 state.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363385"></A>Once the system is running, OSPM will dispatch the corresponding GPE handler.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363386"></A>The handler needs to determine which device object has signaled wake and performs a wake Notify</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363387"></A> command on the corresponding device object(s) that have asserted wake.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1363388"></A>In turn OSPM will notify OSPM native driver(s) for each device that will wake its device to service it.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363389"></A>Events that wake may not be intermixed with non-wake (runtime) events on the same GPE input. The only exception to this rule is made for the special devices below. Only the following devices are allowed to utilize a single GPE for both wake and runtime events:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="StepNumList-1">
<A NAME="pgfId-1363390"></A>Button Devices</H6>
<UL>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363391"></A>PNP0C0C -- Power Button Device</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363392"></A>PNP0C0D -- Lid Device</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363393"></A>PNP0C0E -- Sleep Button Device</LI>
<LI CLASS="StepNumList-N">
<A NAME="pgfId-1363394"></A>PCI Bus Wakeup Event Reporting (PME)</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1363395"></A>PNP0A03 -- PCI Host Bridge</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1363396"></A>All wake events that are not exclusively tied to a GPE input (for example, one input is shared for multiple wake events) must have individual enable and status bits in order to properly handle the semantics used by the system.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1363409"></A><A NAME="marker-1363405"></A>Managing a Wake Event Using Device _PRW Objects</H6>
<P CLASS="Body">
<A NAME="pgfId-1371141"></A>A device&#8217;s _PRW object provides the zero-based bit index into the general-purpose status register block to indicate which general-purpose status bit from either GPE0_BLK or GPE1_BLK is used as the specific device&#8217;s wake mask. Although the hardware must maintain individual device wake enable bits, the system can have multiple devices using the same general-purpose event bit by using OEM-specific hardware to provide second-level status and enable bits. In this case, the OEM AML code is responsible for the second-level enable and status bits.</P>
<P CLASS="Body">
<A NAME="pgfId-1363410"></A>OSPM enables or disables the device wake function by enabling or disabling its corresponding GPE and by executing its _PSW control method (which is used to take care of the second-level enables). When the GPE is asserted, OSPM still executes the corresponding GPE control method that determines which device wakes are asserted and notifies the corresponding device objects. The native OS driver is then notified that its device has asserted wake, for which the driver powers on its device to service it.</P>
<P CLASS="Body">
<A NAME="pgfId-1363411"></A>If the system is in a sleeping state when the enabled GPE bit is asserted the hardware will transition the system into the S0 state, if possible.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1363414"></A>D<A NAME="RSVD_Wxx"></A>etermining the System Wake Source Using _Wxx Control Methods</H6>
<P CLASS="Body">
<A NAME="pgfId-1363415"></A>After a transition to the S0 state, OSPM may evaluate the _SWS object in the &#92;_GPE scope to determine the index of the GPE that was the source of the transition event. When a single GPE is shared among multiple devices, the platform provides a _Wxx control method, where xx is GPE index as described in <A HREF="ACPI_Software_Programming_Model.htm#RSVD_Wxx" CLASS="XRef">See Determining the System Wake Source Using _Wxx Control Methods.</A>, that allows the source device of the transition to be determined. If implemented, the _Wxx control method must exist in the &#92;_GPE scope or in the scope of a GPE block device.</P>
<P CLASS="Body">
<A NAME="pgfId-1363416"></A>If _Wxx is implemented, either hardware or firmware must detect and save the source device as described in <A HREF="Power_and_Performance_Mgmt.htm#_Toc202341592" CLASS="XRef">See </A></P>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
1.</SPAN>
<A NAME="pgfId-1763621"></A> Note that the platform buffers do not include processor cache(s)! Processors typically include ISA to flush data out of processor caches.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
2.</SPAN>
<A NAME="pgfId-1362521"></A> For the most part, since the name space is hierarchical, typically the bulk of a dynamic definition file will load into a different part of the hierarchy. The root of the name space and certain locations where interaction is being designed  are the areas in which extra care must be taken.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
3.</SPAN>
<A NAME="pgfId-1712347"></A> Unless the operation being performed is explicitly prepared for failure in name resolution, this is considered an error and may cause the system to stop working. </P>
</DIV>
</DIV>
</BODY>
</HTML>
