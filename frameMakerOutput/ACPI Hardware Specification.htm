<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2016/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="ACPI Hardware Specification.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 4 ACPI Hardware Specification</TITLE></HEAD>
<BODY>
<DIV>
<H1 CLASS="Heading-1">
<A NAME="pgfId-1354804"></A><A NAME="44941"></A>ACPI Hardware Specification<DIV>
<IMG SRC="ACPI Hardware Specification-1.gif" ALT="">
</DIV>
</H1>
<P CLASS="Body">
<A NAME="pgfId-1354807"></A><A NAME="OLE_LINK7"></A><A NAME="OLE_LINK8"></A>ACPI defines standard interface mechanisms that allow an ACPI-compatible OS to control and communicate with an ACPI-compatible hardware platform. These interface mechanisms are optional (See &quot;Hardware-Reduced ACPI&quot;, below).However, if the ACPI Hardware Specification is implemented, platforms must comply with the requirements in this section.</P>
<P CLASS="Body">
<A NAME="pgfId-1423760"></A>This section describes the hardware aspects of ACPI.</P>
<P CLASS="Body">
<A NAME="pgfId-1354808"></A>ACPI defines &#8220;hardware&#8221; as a programming model and its behavior. ACPI strives to keep much of the existing legacy programming model the same; however, to meet certain feature goals, designated features conform to a specific addressing and programming scheme. Hardware that falls within this category is referred to as &#8220;fixed.&#8221;</P>
<P CLASS="Body">
<A NAME="pgfId-1354809"></A>Although ACPI strives to minimize these changes, hardware engineers should read this section carefully to understand the changes needed to convert a legacy-only hardware model to an ACPI/Legacy hardware model or an ACPI-only hardware model.</P>
<P CLASS="Body">
<A NAME="pgfId-1354810"></A>ACPI classifies hardware into two categories: Fixed or Generic. Hardware that falls within the fixed category meets the programming and behavior specifications of ACPI. Hardware that falls within the generic category has a wide degree of flexibility in its implementation.<A NAME="marker-1354811"></A><A NAME="marker-1354812"></A></P>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1423775"></A><A NAME="95525"></A>Hardware-Reduced ACPI</H2>
<P CLASS="Body">
<A NAME="pgfId-1423777"></A>For certain classes of systems the ACPI Hardware Specification may not be adequate. Examples include legacy-free, UEFI-based platforms with recent processors, and those implementing mobile platform architectures. For such platforms, a Hardware-reduced ACPI mode is defined. Under this definition, the ACPI Fixed Hardware interface is not implemented, and software alternatives for many of the features it supports are used instead. Note, though, that Hardware-reduced ACPI is not intended to support every possible ACPI system that can be built today. Rather, it is intended to introduce new systems that are designed to be HW-reduced from the start.  The ACPI HW Specification should be used if the platform cannot be designed to work without it. Specifically, the following features are not supported under the HW-reduced definition:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1423778"></A>The Global Lock, SMI_CMD, ACPI Enable and ACPI Disable. Hardware-reduced ACPI systems always boot in ACPI mode, and do not support hardware resource sharing between OSPM and other asynchronous operating environments, such as UEFI Runtime Services or System Management Mode.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1423779"></A>Bus Master Reload and Arbiter Disable. Systems that depend on OS use of these bits to maintain cache coherency across processor sleep states are not supported.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1424631"></A>GPE block devices are not supported.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1423780"></A>Platforms that require the above features must implement the ACPI Hardware Specification.</P>
<P CLASS="Body">
<A NAME="pgfId-1423781"></A>Platforms that are designed for the Hardware-reduced ACPI definition must implement Revision 5 or greater of the Fixed ACPI Descriptor Table, and must set the HW_REDUCED_ACPI flag in the Flags field.</P>
<DIV>
<H6 CLASS="Note">
<A NAME="pgfId-1424544"></A>FFH is permitted and applicable to both full and HW-reduced ACPI implementations.</H6>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1423782"></A>Hardware-Reduced Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1423783"></A>HW-reduced ACPI platforms require alternatives to some of the features supported in the ACPI HW Specification, where none already exists. There are two areas that require such alternatives: The ACPI Platform Event Model, and System and Device Wakeup.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1423784"></A><A NAME="11302"></A>GPIO-Signaled Events or Interrupt Signaled Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1423785"></A>General Purpose Input/Output (GPIO) hardware can be used for signaling platform events. GPIO HW is a generalization of the GPE model, and is a shared hardware resource used for many applications. ACPI support for GPIO is described in section <A HREF="ACPI_Concepts.htm#39141" CLASS="XRef">See Connection Resources.</A>, &quot;Connection Resources&quot;. ACPI 6.1introduces the capability to signal events via interrupts. See <A HREF="ACPI_Software_Programming_Model.htm#36453" CLASS="XRef">See Interrupt-signaled ACPI events.</A> for further details.</P>
<P CLASS="Body">
<A NAME="pgfId-1423786"></A>GPIO based event signaling is provided through GPIO interrupt connections, which describe the connection to a GPIO controller and pin, and which are mapped to the ACPI Event Handling mechanism via the ACPI Event Information namespace object (_AEI). OSPM treats GPIO Interrupt Connections listed in _AEI exactly as it does SCI interrupts: it executes the Event Method associated with the specific event. The name of the method to run is determined by the pin information contained in the GPIO Interrupt Connection resource. See <A HREF="ACPI_Software_Programming_Model.htm#19454" CLASS="XRef">See GPIO-signaled ACPI Events.</A> for further details.</P>
<P CLASS="Body">
<A NAME="pgfId-1423787"></A>GPIO-signaled events can also be wake events, just as GPE events can on traditional ACPI platforms. Designating which events are wake events is done through attributes of the GPIO Interrupt Connection resource used.Devices may use _PRW to manage wake events as described in <A HREF="Power_and_Performance_Mgmt.htm#71464" CLASS="XRef">See _PRW (Power Resources for Wake).</A>. </P>
<P CLASS="Body">
<A NAME="pgfId-1425668"></A>Interrupt based event signaling follows a similar methodology, a generic event device (GED) is declared which in turn describes all interrupts associated with event generation. The interrupts are listed in a _CRS object. When an interrupt is asserted the OSPM will execute the event method (_EVT) declared in the GED object specifying the interrupt identifier as a parameter. In this way the interrupt can be associated with specific platform events.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1423788"></A><A NAME="69050"></A>Interrupt-based Wake Events</H6>
<P CLASS="Body">
<A NAME="pgfId-1423789"></A>Wake events on HW-reduced ACPI platforms are always caused by an interrupt reaching the processor. Therefore, there are two requirements for waking the system from a sleep or low-power idle state, or a device from a low-power state. First, the interrupt line must be Wake-Capable. Wake-capable interrupts are designed to be able to be delivered to the processor from low-power states. This implies that it must also cause the processor and any required platform hardware to power-up so that an Interrupt Service Routine can run. Secondly, an OS driver must enable the interrupt before entering a low-power state, or before OSPM puts the system into a sleep or low-power idle state. </P>
<P CLASS="Body">
<A NAME="pgfId-1423790"></A>Wake-capable interrupts are designated as such in their Extended Interrupt or GPIO Interrupt Connection resource descriptor. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1354832"></A><A NAME="_Toc489255985"></A><A NAME="_Toc489267909"></A><A NAME="_Toc489272462"></A><A NAME="_Toc202340510"></A><A NAME="_Toc258262191"></A>Fixed Hardware Programming Model<A NAME="marker-1354829"></A><A NAME="marker-1354830"></A><A NAME="marker-1354831"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1354833"></A>Because of the changes needed for migrating legacy hardware to the fixed category, ACPI limits the features specified by fixed hardware. Fixed hardware features are defined by the following criteria:<A NAME="marker-1354834"></A><A NAME="marker-1354835"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1354836"></A>Performance sensitive features</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354837"></A>Features that drivers require during wake</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354838"></A>Features that enable catastrophic OS software failure recovery</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1354839"></A>ACPI defines register-based interfaces to fixed hardware. CPU clock control and the power management timer are defined as fixed hardware to reduce the performance impact of accessing this hardware, which will result in more quickly reducing a thermal condition or extending battery life. If this logic were allowed to reside in PCI configuration space, for example, several layers of drivers would be called to access this address space. This takes a long time and will either adversely affect the power of the system (when trying to enter a low-power state) or the accuracy of the event (when trying to get a time stamp value).<A NAME="marker-1354840"></A><A NAME="marker-1354841"></A><A NAME="marker-1354842"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354843"></A>Access to fixed hardware by OSPM allows OSPM to control the wake process without having to load the entire OS. For example, if PCI configuration space access is needed, the bus enumerator is loaded with all drivers used by the enumerator. Defining these interfaces in fixed hardware at addresses with which OSPM can communicate without any other driver&#8217;s assistance, allows OSPM to gather information prior to making a decision as to whether it continues loading the entire OS or puts it back to sleep.</P>
<P CLASS="Body">
<A NAME="pgfId-1354844"></A>If elements of the OS fail, it may be possible for OSPM to access address spaces that need no driver support. In such a situation, OSPM will attempt to honor fixed power button requests to transition the system to the G2 state. In the case where OSPM event handler is no longer able to respond to power button events, the power button override feature provides a back-up mechanism to unconditionally transition the system to the soft-off state.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1354912"></A><A NAME="marker-1354862"></A><A NAME="63934"></A><A NAME="marker-1354910"></A>Generic Hardware Programming Model</H2>
<P CLASS="Body">
<A NAME="pgfId-1354913"></A>Although the fixed hardware programming model requires hardware registers to be defined at specific address locations, the generic hardware programming model allows hardware registers to reside in most address spaces and provides system OEMs with a wide degree of flexibility in the implementation of specific functions in hardware. OSPM directly accesses the fixed hardware registers, but relies on OEM-provided ACPI Machine Language (AML) code to access generic hardware registers.<A NAME="marker-1354914"></A><A NAME="marker-1354915"></A><A NAME="marker-1354916"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354917"></A>AML code allows the OEM to provide the means for OSPM to control a generic hardware feature&#8217;s control and event logic. </P>
<P CLASS="Body">
<A NAME="pgfId-1354918"></A>The section entitled &#8220;ACPI Source Language Reference&#8221; describes the ACPI Source Language (ASL)--a programming language that OEMs use to create AML. The ASL language provides many of the operators found in common object-oriented programming languages, but it has been optimized to enable the description of platform power management and configuration hardware. An ASL compiler converts ASL source code to AML, which is a very compact machine language that the ACPI AML code interpreter executes.<A NAME="marker-1354919"></A><A NAME="marker-1354920"></A><A NAME="marker-1354921"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354923"></A>AML does two things:<A NAME="marker-1354922"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1354924"></A>Abstracts the hardware from OSPM</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354925"></A>Buffers OEM code from the different OS implementations</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1354926"></A>One goal of ACPI is to allow the OEM &#8220;value added&#8221; hardware to remain basically unchanged in an ACPI configuration. One attribute of value-added hardware is that it is all implemented differently. To enable OSPM to execute properly on different types of value added hardware, ACPI defines higher level &#8220;control methods&#8221; that it calls to perform an action. The OEM provides AML code, which is associated with control methods, to be executed by OSPM. By providing AML code, generic hardware can take on almost any form.<A NAME="marker-1354927"></A><A NAME="marker-1354928"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354929"></A>Another important goal of ACPI is to provide OS independence. To do this, the OEM AML code has to execute the same under any ACPI-compatible OS. ACPI allows for this by making the AML code interpreter part of OSPM. This allows OSPM to take care of synchronizing and blocking issues specific to each particular OS.<A NAME="marker-1354930"></A><A NAME="marker-1354931"></A><A NAME="marker-1354932"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354933"></A>The generic feature model is represented in the following block diagram. In this model the generic feature is described to OSPM through AML code. This description takes the form of an object that sits in the ACPI Namespace associated with the hardware to which it is adding value.</P>
<DIV>
<H6 CLASS="spacing">
<A NAME="pgfId-1354934"></A>&nbsp;</H6>
<DIV>
<IMG SRC="ACPI Hardware Specification-2.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1354940"></A><A NAME="_Ref362170839"></A>Generic Hardware Feature Model</H6>
<P CLASS="Body">
<A NAME="pgfId-1354948"></A>As an example of a generic hardware control feature, a platform might be designed such that the IDE HDD&#8217;s D3 state has value-added hardware to remove power from the drive. The IDE drive would then have a reference to the AML PowerResource object (which controls the value added power plane) in its namespace, and associated with that object would be control methods that OSPM invokes to control the D3 state of the drive:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1354949"></A>_PS0: A control method to sequence the IDE drive to the D0 state.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354950"></A>_PS3: A control method to sequence the IDE drive to the D3 state.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354951"></A>_PSC: A control method that returns the status of the IDE drive (on or off).</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1354952"></A>The control methods under this object provide an abstraction layer between OSPM and the hardware. OSPM understands how to control power planes (turn them on or off or to get their status) through its defined PowerResource object, while the hardware has platform-specific AML code (contained in the appropriate control methods) to perform the desired function. In this example, the platform would describe its hardware to the ACPI OS by writing and placing the AML code to turn the hardware off within the _PS3 control method. This enables the following sequence:<A NAME="marker-1354953"></A><A NAME="marker-1354954"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354955"></A>When OSPM decides to place the IDE drive in the D3 state, it calls the IDE driver and tells it to place the drive into the D3 state (at which point the driver saves the device&#8217;s context).</P>
<P CLASS="Body">
<A NAME="pgfId-1354956"></A>When the IDE driver returns control, OSPM places the drive in the D3 state.</P>
<P CLASS="Body">
<A NAME="pgfId-1354957"></A>OSPM finds the object associated with the HDD and then finds within that object any AML code associated with the D3 state.</P>
<P CLASS="Body">
<A NAME="pgfId-1354958"></A>OSPM executes the appropriate _PS3 control method to control the value-added &#8220;generic&#8221; hardware to place the HDD into an even lower power state.</P>
<P CLASS="Body">
<A NAME="pgfId-1354959"></A>As an example of a generic event feature, a platform might have a docking capability. In this case, it will want to generate an event. Notice that all ACPI events generate an SCI, which can be mapped to any shareable system interrupt. In the case of docking, the event is generated when a docking has been detected or when the user requests to undock the system. This enables the following sequence:<A NAME="marker-1354960"></A><A NAME="marker-1354961"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1354962"></A>OSPM responds to the SCI and calls the AML code event handler associated with that generic event. The ACPI table associates the hardware event with the AML code event handler.</P>
<P CLASS="Body">
<A NAME="pgfId-1354963"></A>The AML-code event handler collects the appropriate information and then executes an AML Notify command to indicate to OSPM that a particular bus needs re-enumeration.</P>
<P CLASS="Body">
<A NAME="pgfId-1354964"></A>The following sections describe the fixed and generic hardware feature set of ACPI. These sections enable a reader to understand the following:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1354965"></A>Which hardware registers are required or optional when an ACPI feature, concept or interface is required by a design guide for a platform class</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354966"></A>How to design fixed hardware features</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354967"></A>How to design generic hardware features</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1354968"></A>The ACPI Event Model</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1355002"></A><A NAME="marker-1355000"></A>Diagram Legends</H2>
<P CLASS="Body">
<A NAME="pgfId-1355004"></A><A NAME="_Ref362661726"></A>The hardware section uses simplified logic diagrams to represent how certain aspects of the hardware are implemented. The following symbols are used in the logic diagrams to represent programming bits.</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355008"></A><IMG SRC="ACPI Hardware Specification-3.gif" ALIGN="BASELINE" ALT="">
		Write-only control bit</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355012"></A><IMG SRC="ACPI Hardware Specification-4.gif" ALIGN="BASELINE" ALT="">
		Enable, control or status bit</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355016"></A><IMG SRC="ACPI Hardware Specification-5.gif" ALIGN="BASELINE" ALT="">
		Sticky status bit</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355020"></A><IMG SRC="ACPI Hardware Specification-6.gif" ALIGN="BASELINE" ALT="">
		Query value</P>
<P CLASS="Body">
<A NAME="pgfId-1355021"></A>The half round symbol with an inverted &#8220;V&#8221; represents a write-only control bit. This bit has the behavior that it generates its control function when it is set. Reads to write-only bits are treated as ignore by software (the bit position is masked off and ignored).<A NAME="marker-1355022"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355023"></A>The round symbol with an &#8220;X&#8221; represents a programming bit. As an enable or control bit, software setting or clearing this bit will result in the bit being read as set or clear (unless otherwise noted). As a status bit it directly represents the value of the signal.<A NAME="marker-1355024"></A><A NAME="marker-1355025"></A><A NAME="marker-1355026"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355027"></A>The square symbol represents a sticky status bit. A sticky status bit is set by the level (not edge) of a hardware signal (active high or active low). The bit is only cleared by software writing a &#8220;1&#8221; to its bit position.<A NAME="marker-1355028"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355029"></A>The rectangular symbol represents a query value from the embedded controller. This is the value the embedded controller returns to the system software upon a query command in response to an SCI event. The query value is associated with the event control method that is scheduled to execute upon an embedded controller event. <A NAME="marker-1355030"></A></P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1355050"></A><A NAME="_Toc489255989"></A><A NAME="_Toc489267913"></A><A NAME="_Toc489272466"></A><A NAME="_Toc202340514"></A><A NAME="_Toc258262195"></A>Register Bit Notation<A NAME="marker-1355047"></A><A NAME="marker-1355048"></A><A NAME="marker-1355049"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1424137"></A>Throughout this section there are logic diagrams that reference bits within registers. These diagrams use a notation that easily references the register name and bit position. The notation is as follows:</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1424138"></A>Registername.Bit</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355053"></A>Registername contains the name of the register as it appears in this specification</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355054"></A>Bit contains a zero-based decimal value of the bit position.</P>
<P CLASS="Body">
<A NAME="pgfId-1355055"></A>For example, the SLP_EN bit resides in the PM1x_CNT register bit 13 and would be represented in diagram notation as:</P>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1355056"></A>SLP_EN<BR>
PM1x_CNT.13</P>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1355075"></A><A NAME="_Toc489255990"></A><A NAME="_Toc489267914"></A><A NAME="_Toc489272467"></A><A NAME="_Toc202340515"></A><A NAME="_Toc258262196"></A>The ACPI Hardware Model <A NAME="marker-1355073"></A><A NAME="marker-1355074"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1355077"></A><A NAME="_Ref360365117"></A>The ACPI hardware model is defined to allow OSPM to sequence the platform between the various global system states (G0-G3) as illustrated in the following figure by manipulating the defined interfaces. When first powered on, the platform finds itself in the global system state G3 or &#8220;Mechanical Off.&#8221; This state is defined as one where power consumption is very close to zero--the power plug has been removed; however, the real-time clock device still runs off a battery. The G3 state is entered by any power failure, defined as accidental or user-initiated power loss. <A NAME="marker-1355078"></A><A NAME="marker-1355079"></A><A NAME="marker-1355080"></A><A NAME="marker-1355081"></A><A NAME="marker-1355082"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355083"></A>The G3 state transitions into either the G0 working state or the Legacy state depending on what the platform supports. If the platform is an ACPI-only platform, then it allows a direct boot into the G0 working state by always returning the status bit SCI_EN set (1) (for more information, see  <A HREF="ACPI Hardware Specification.htm#48713" CLASS="XRef">See Legacy/ACPI Select and the SCI Interrupt.</A>, &#8220;Legacy/ACPI Select and the SCI Interrupt&#8221;). If the platform supports both legacy and ACPI operations (which is necessary for supporting a non-ACPI OS), then it would always boot into the Legacy state (illustrated by returning the SCI_EN clear (0)). In either case, a transition out of the G3 state requires a total boot of OSPM.<A NAME="marker-1355084"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355085"></A>The Legacy system state is the global state where a non-ACPI OS executes. This state can be entered from either the G3 &#8220;Mechanical Off,&#8221; the G2 &#8220;Soft Off,&#8221; or the G0 &#8220;Working&#8221; states only if the hardware supports both Legacy and ACPI modes. In the Legacy state, the ACPI event model is disabled (no SCIs are generated) and the hardware uses legacy power management and configuration mechanisms. While in the Legacy state, an ACPI-compliant OS can request a transition into the G0 working state by performing an ACPI mode request. OSPM performs this transition by writing the ACPI_ENABLE value to the SMI_CMD, which generates an event to the hardware to transition the platform into ACPI mode. When hardware has finished the transition, it sets the SCI_EN bit and returns control back to OSPM. While in the G0 &#8220;working state,&#8221; OSPM can request a transition to Legacy mode by writing the ACPI_DISABLE value to the SMI_CMD register, which results in the hardware going into legacy mode and resetting the SCI_EN bit LOW (for more information, see <A HREF="ACPI Hardware Specification.htm#48713" CLASS="XRef">See Legacy/ACPI Select and the SCI Interrupt.</A>, &#8220;Legacy/ACPI Select and the SCI Interrupt&#8221;).<A NAME="marker-1355086"></A><A NAME="marker-1355087"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355088"></A>The G0 &#8220;Working&#8221; state is the normal operating environment of an ACPI system. In this state different devices are dynamically transitioning between their respective power states (D0, D1, D2, D3hot, or D3) and processors are dynamically transitioning between their respective power states (C0, C1, C2 or C3). In this state, OSPM can make a policy decision to place the platform into the system G1 &#8220;sleeping&#8221; state. The platform can only enter a single sleeping state at a time (referred to as the global G1 state); however, the hardware can provide up to four system sleeping states that have different power and exit latencies represented by the S1, S2, S3, or S4 states. When OSPM decides to enter a sleeping state it picks the most appropriate sleeping state supported by the hardware (OS policy examines what devices have enabled wake events and what sleeping states these support). OSPM initiates the sleeping transition by enabling the appropriate wake events and then programming the SLP_TYPx field with the desired sleeping state and then setting the SLP_ENx bit. The system will then enter a sleeping state; when one of the enabled wake events occurs, it will transition the system back to the working state (for more information, see <A HREF="Waking_and_Sleeping.htm#91854" CLASS="XRef">See Waking and Sleeping.</A>, &#8220;Waking and Sleeping&#8221;).<A NAME="marker-1355089"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355090"></A>Another global state transition option while in the G0 &#8220;working&#8221; state is to enter the G2 &#8220;soft off&#8221; or the G3 &#8220;mechanical off&#8221; state. These transitions represent a controlled transition that allows OSPM to bring the system down in an orderly fashion (unloading applications, closing files, and so on). The policy for these types of transitions can be associated with the ACPI power button, which when pressed generates an event to the power button driver. When OSPM is finished preparing the operating environment for a power loss, it will either generate a pop-up message to indicate to the user to remove power, in order to enter the G3 &#8220;Mechanical Off&#8221; state, or it will initiate a G2 &#8220;soft-off&#8221; transition by writing the value of the S5 &#8220;soft off&#8221; system state to the SLP_TYPx register and setting the SLP_EN bit.<A NAME="marker-1355091"></A><A NAME="marker-1355092"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355093"></A>The G1 sleeping state is represented by four possible sleeping states that the hardware can support. Each sleeping state has different power and wake latency characteristics. The sleeping state differs from the working state in that the user&#8217;s operating environment is frozen in a low-power state until awakened by an enabled wake event. No work is performed in this state, that is, the processors are not executing instructions. Each system sleeping state has requirements about who is responsible for system context and wake sequences (for more information, see <A HREF="Waking_and_Sleeping.htm#91854" CLASS="XRef">See Waking and Sleeping.</A>, Waking and Sleeping&#8221;).</P>
<P CLASS="Body">
<A NAME="pgfId-1355094"></A>The G2 &#8220;soft off&#8221; state is an OS initiated system shutdown. This state is initiated similar to the sleeping state transition (SLP_TYPx is set to the S5 value and setting the SLP_EN bit initiates the sequence). Exiting the G2 soft-off state requires rebooting the system. In this case, an ACPI-only system will re-enter the G0 state directly (hardware returns the SCI_EN bit set), while an ACPI/Legacy system transitions to the Legacy state (SCI_EN bit is clear).</P>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1373886"></A>&nbsp;</H5>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1373891"></A>&nbsp;</H5>
<DIV>
<IMG SRC="ACPI Hardware Specification-7.gif" ALT="">
</DIV>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1373893"></A>Global States and Their Transitions<A NAME="marker-1425293"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355102"></A>The ACPI architecture defines mechanisms for hardware to generate events and control logic to implement this behavior model. Events are used to notify OSPM that some action is needed, and control logic is used by OSPM to cause some state transition. ACPI-defined events are &#8220;hardware&#8221; or &#8220;interrupt&#8221; events. A hardware event is one that causes the hardware to unconditionally perform some operation. For example, any wake event will sequence the system from a sleeping state (S1, S2, S3, and S4 in the global G1 state) to the G0 working state (see <A HREF="Waking_and_Sleeping.htm#46934" CLASS="XRef">See Example Sleeping States.</A>).<A NAME="marker-1355103"></A><A NAME="marker-1355104"></A><A NAME="marker-1355105"></A><A NAME="marker-1355106"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355107"></A>An interrupt event causes the execution of an event handler (AML code or an ACPI-aware driver), which allows the software to make a policy decision based on the event. For ACPI fixed-feature events, OSPM or an ACPI-aware driver acts as the event handler. For generic logic events OSPM will schedule the execution of an OEM-supplied AML control method associated with the event. </P>
<P CLASS="Body">
<A NAME="pgfId-1355108"></A>For legacy systems, an event normally generates an OS-transparent interrupt, such as a System Management Interrupt, or SMI. For ACPI systems the interrupt events need to generate an OS-visible interrupt that is shareable; edge-style interrupts will not work. Hardware platforms that want to support both legacy operating systems and ACPI systems support a way of re-mapping the interrupt events between SMIs and SCIs when switching between ACPI and legacy models. This is illustrated in the following block diagram.<A NAME="marker-1355109"></A><A NAME="marker-1355110"></A></P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1355117"></A><A NAME="_Ref360423442"></A><A NAME="_Ref360423454"></A><A NAME="_Ref369606651"></A><IMG SRC="ACPI Hardware Specification-8.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1355119"></A>Example Event Structure for a Legacy/ACPI Compatible Event Model</H6>
<P CLASS="Body">
<A NAME="pgfId-1355120"></A>This example logic illustrates the event model for a sample platform that supports both legacy and ACPI event models. This example platform supports a number of external events that are power-related (power button, LID open/close, thermal, ring indicate) or Plug and Play-related (dock, status change). The logic represents the three different types of events:</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="GlossTerm">
<A NAME="pgfId-1355121"></A>OS Transparent Events</H3>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1358200"></A>These events represent OEM-specific functions that have no OS support and use software that can be operated in an OS-transparent fashion (that is, SMIs).<A NAME="marker-1355122"></A></P>
</DIV>
<DIV>
<H3 CLASS="GlossTerm">
<A NAME="pgfId-1355126"></A><A NAME="marker-1355123"></A><A NAME="marker-1355124"></A>Interrupt Events</H3>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1358211"></A>These events represent features supported by ACPI-compatible operating systems, but are not supported by legacy operating systems. When a legacy OS is loaded, these events are mapped to the transparent interrupt (SMI# in this example), and when in ACPI mode they are mapped to an OS-visible shareable interrupt (SCI#). This logic is represented by routing the event logic through the decoder that routes the events to the SMI# arbiter when the SCI_EN bit is cleared, or to the SCI# arbiter when the SCI_EN bit is set.</P>
</DIV>
<DIV>
<H3 CLASS="GlossTerm">
<A NAME="pgfId-1355127"></A>Hardware events</H3>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1358218"></A>These events are used to trigger the hardware to initiate some hardware sequence such as waking, resetting, or putting the system to sleep unconditionally.</P>
<P CLASS="Body">
<A NAME="pgfId-1355128"></A>In this example, the legacy power management event logic is used to determine device/system activity or idleness based on device idle timers, device traps, and the global standby timer. Legacy power management models use the idle timers to determine when a device should be placed in a low-power state because it is idle--that is, the device has not been accessed for the programmed amount of time. The device traps are used to indicate when a device in a low-power state is being accessed by OSPM. The global standby timer is used to determine when the system should be allowed to go into a sleeping state because it is idle--that is, the user interface has not been used for the programmed amount of time.<A NAME="marker-1355129"></A><A NAME="marker-1355130"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355131"></A>These legacy idle timers, trap monitors, and global standby timer are not used by OSPM in the ACPI mode. This work is handled by different software structures in an ACPI-compatible OS. For example, the driver model of an ACPI-compatible OS is responsible for placing its device into a low-power state (D1, D2, D3hot, or D3) and transitioning it back to the On state (D0) when needed. And OSPM is responsible for determining when the system is idle by profiling the system (using the PM Timer) and other knowledge it gains through its operating structure environment (which will vary from OS to OS). When the system is placed into the ACPI mode, these events no longer generate SMIs, as OSPM handles this function. These events are disabled through some OEM-proprietary method.<A NAME="marker-1355132"></A><A NAME="marker-1355133"></A><A NAME="marker-1355134"></A><A NAME="marker-1355135"></A><A NAME="marker-1355136"></A><A NAME="marker-1355137"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355138"></A>On the other hand, many of the hardware events are shared between the ACPI and legacy models (docking, the power button, and so on) and this type of interrupt event changes to an SCI event when enabled for ACPI. The ACPI OS will generate a request to the platform runtime firmware to enter into the ACPI mode. The firmware sets the SCI_EN bit to indicate that the system has successfully entered into the ACPI mode, so this is a convenient mechanism to map the desired interrupt (SMI or SCI) for these events (as shown in Figure 4-3).<A NAME="marker-1355139"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355140"></A>The ACPI architecture specifies some dedicated hardware not found in the legacy hardware model: the power management timer (PM Timer). This is a free running timer that the ACPI OS uses to profile system activity. The frequency of this timer is explicitly defined in this specification and must be implemented as described.<A NAME="marker-1355141"></A><A NAME="marker-1355142"></A><A NAME="marker-1355143"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355144"></A>Although the ACPI architecture reuses most legacy hardware as is, it does place restrictions on where and how the programming model is generated. If used, all fixed hardware features are implemented as described in this specification so that OSPM can directly access the fixed hardware feature registers.<A NAME="marker-1355145"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355146"></A>Generic hardware features are manipulated by ACPI control methods residing in the ACPI Namespace. These interfaces can be very flexible; however, their use is limited by the defined ACPI control methods (for more information, see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#91076" CLASS="XRef">See ACPI-Defined Devices and Device-Specific Objects.</A>, &#8220;ACPI Devices and Device Specific Objects&#8221;). Generic hardware usually controls power planes, buffer isolation, and device reset resources. Additionally, &#8220;child&#8221; interrupt status bits can be accessed via generic hardware interfaces; however, they have a &#8220;parent&#8221; interrupt status bit in the GP_STS register. ACPI defines eight address spaces that may be accessed by generic hardware implementations. These include: <A NAME="marker-1355147"></A><A NAME="marker-1355148"></A><A NAME="marker-1355149"></A><A NAME="marker-1355150"></A><A NAME="marker-1355151"></A><A NAME="marker-1355152"></A><A NAME="marker-1355153"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355154"></A>System I/O space</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355156"></A>System memory space</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355158"></A>PCI configuration space</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355160"></A>Embedded controller space</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355162"></A>System Management Bus (SMBus) space </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355163"></A>CMOS</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355164"></A>PCI BAR Target</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355166"></A>IPMI space</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1442034"></A>Platform Communication Channel</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355167"></A>Generic hardware power management features can be implemented accessing spare I/O ports residing in any of these address spaces. The ACPI specification defines an optional embedded controller and SMBus interfaces needed to communicate with these associated address spaces.</P>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1355187"></A><A NAME="_Toc489255991"></A><A NAME="_Toc489267915"></A><A NAME="_Toc489272468"></A><A NAME="_Toc202340516"></A><A NAME="_Toc258262197"></A>Hardware Reserved Bits<A NAME="marker-1355184"></A><A NAME="marker-1355185"></A><A NAME="marker-1355186"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355188"></A>ACPI hardware registers are designed such that reserved bits always return zero, and data writes to them have no side affects. OSPM implementations must write zeros to reserved bits in enable and status registers and preserve bits in control registers, and they will treat these bits as ignored. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1355208"></A><A NAME="_Toc489255992"></A><A NAME="_Toc489267916"></A><A NAME="_Toc489272469"></A><A NAME="_Toc202340517"></A><A NAME="_Toc258262198"></A>Hardware Ignored Bits<A NAME="marker-1355205"></A><A NAME="marker-1355206"></A><A NAME="marker-1355207"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355209"></A>ACPI hardware registers are designed such that ignored bits are undefined and are ignored by software. Hardware-ignored bits can return zero or one. When software reads a register with ignored bits, it masks off ignored bits prior to operating on the result. When software writes to a register with ignored bit fields, it preserves the ignored bit fields. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1355228"></A><A NAME="_Toc489255993"></A><A NAME="_Toc489267917"></A><A NAME="_Toc489272470"></A><A NAME="_Toc202340518"></A><A NAME="_Toc258262199"></A>Hardware Write-Only Bits<A NAME="marker-1355226"></A><A NAME="marker-1355227"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355229"></A>ACPI hardware defines a number of write-only control bits. These bits are activated by software writing a 1 to their bit position. Reads to write-only bit positions generate undefined results. Upon reads to registers with write-only bits, software masks out all write-only bits.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1355247"></A><A NAME="_Toc489255994"></A><A NAME="_Toc489267918"></A><A NAME="_Toc489272471"></A><A NAME="_Toc202340519"></A><A NAME="_Toc258262200"></A>Cross Device Dependencies<A NAME="marker-1355246"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355248"></A>Cross Device Dependency is a condition in which an operation to a device interferes with the operation of other unrelated devices, or allows other unrelated devices to interfere with its behavior. This condition is not supportable and can cause platform failures. ACPI provides no support for cross device dependencies and suggests that devices be designed to not exhibit this behavior. The following two examples describe cross device dependencies:<A NAME="marker-1355249"></A><A NAME="marker-1355250"></A><A NAME="marker-1355251"></A></P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355260"></A>Example 1: Related Device Interferenc<A NAME="marker-1355259"></A>e<A NAME="marker-1355261"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355263"></A>This example illustrates a cross device dependency where a device interferes with the proper operation of other unrelated devices. Device A has a dependency that when it is being configured it blocks all accesses that would normally be targeted for Device B. Thus, the device driver for Device B cannot access Device B while Device A is being configured; therefore, it would need to synchronize access with the driver for Device A. High performance, multithreaded operating systems cannot perform this kind of synchronization without seriously impacting performance. </P>
<P CLASS="Body">
<A NAME="pgfId-1355264"></A>To further illustrate the point, assume that Device A is a serial port and Device B is a hard drive controller. If these devices demonstrate this behavior, then when a software driver configures the serial port, accesses to the hard drive need to block. This can only be done if the hard disk driver synchronizes access to the disk controller with the serial driver. Without this synchronization, hard drive data will be lost when the serial port is being configured. </P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355273"></A>Example 2: Unrelated Device Interferenc<A NAME="marker-1355272"></A>e</H6>
<P CLASS="Body">
<A NAME="pgfId-1355275"></A>This example illustrates a cross-device dependency where a device demonstrates a behavior that allows other unrelated devices to interfere with its proper operation. Device A exhibits a programming behavior that requires atomic back-to-back write accesses to successfully write to its registers; if any other platform access is able to break between the back-to-back accesses, then the write to Device A is unsuccessful. If the Device A driver is unable to generate atomic back-to-back accesses to its device, then it relies on software to synchronize accesses to its device with every other driver in the system; then a device cross dependency is created and the platform is prone to Device A failure.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1355295"></A><A NAME="_Toc489255995"></A><A NAME="_Toc489267919"></A><A NAME="_Toc489272472"></A><A NAME="_Toc202340520"></A><A NAME="_Toc258262201"></A>ACPI Hardware Features<A NAME="marker-1355294"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1355296"></A>This section describes the different hardware features defined by the ACPI interface. These features are categorized as the following:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355297"></A>Fixed Hardware Features</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355298"></A>Generic Hardware Features</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355299"></A>Fixed hardware features reside in a number of the ACPI-defined address spaces at the locations described by the ACPI programming model. Generic hardware features reside in one of four address spaces (system I/O, system memory, PCI configuration, embedded controller, or serial device I/O space) and are described by the ACPI Namespace through the declaration of AML control methods.</P>
<P CLASS="Body">
<A NAME="pgfId-1355300"></A>Fixed hardware features have exact definitions for their implementation. Although many fixed hardware features are optional, if implemented they must be implemented as described since OSPM manipulates the registers of fixed hardware devices and expects the defined behavior. Functional fixed hardware provides functional equivalents of the fixed hardware feature interfaces as described in <A HREF="ACPI Hardware Specification.htm#63934" CLASS="XRef">See Generic Hardware Programming Model.</A>, &#8220;Functional Fixed Hardware.&#8221;<A NAME="marker-1355301"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355302"></A>Generic hardware feature implementation is flexible. This logic is controlled by OEM-supplied AML code (for more information, see <A HREF="ACPI_Software_Programming_Model.htm#20338" CLASS="XRef">See ACPI Software Programming Model.</A>, &#8220;ACPI Software Programming Model&#8221;), which can be written to support a wide variety of hardware. Also, ACPI provides specialized control methods that provide capabilities for specialized devices. For example, the Notify command can be used to notify OSPM from a generic hardware event handler (control method) that a docking or thermal event has taken place. A good understanding of this section and <A HREF="ACPI_Software_Programming_Model.htm#20338" CLASS="XRef">See ACPI Software Programming Model.</A> of this specification will give designers a good understanding of how to design hardware to take full advantage of an ACPI-compatible OS.<A NAME="marker-1355303"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355304"></A>Notice that the generic features are listed for illustration only, the ACPI specification can support many types of hardware not listed.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355306"></A>Feature/Programming Model Summary<A NAME="marker-1355305"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1417958"></A>Feature Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1417960"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1417962"></A>Programming Model</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355315"></A>Power Management Timer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355317"></A>24-bit or 32-bit free running timer.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355319"></A>Fixed Hardware Feature Control Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355321"></A>Power Button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355323"></A>User pushes button to switch the system between the working and sleeping/soft-off states.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355325"></A>Fixed Hardware Event and Control Logic or Generic Hardware Event and Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355327"></A>Sleep Button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355329"></A>User pushes button to switch the system between the working and sleeping/soft-off states.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355331"></A>Fixed Hardware Event and Control Logic or Generic Hardware Event and Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355333"></A>Power Button Override</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355335"></A>User sequence (press the power button for 4 seconds) to turn off a hung system.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355337"></A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355339"></A>Real Time Clock Alarm</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355341"></A>Programmed time to wake the system.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355346"></A>Optional Fixed Hardware Event<A HREF="#pgfId-1355345" CLASS="footnote">1</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355348"></A>Sleep/Wake Control Logic</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355350"></A>Logic used to transition the system between the sleeping and working states.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355352"></A>Fixed Hardware Control and Event Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355354"></A>Embedded Controller Interface </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355356"></A>ACPI Embedded Controller protocol and interface, as described in <A HREF="ACPI_Embedded_Controller_Interface_Specification.htm#71995" CLASS="XRef">See ACPI Embedded Controller Interface Specification.</A>, &#8220;ACPI Embedded Controller Interface Specification.&#8221;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355358"></A>Generic Hardware Event Logic, must reside in the general-purpose register block</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355360"></A>Legacy/ACPI Select</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355362"></A>Status bit that indicates the system is using the legacy or ACPI power management model (SCI_EN).</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355364"></A>Fixed Hardware Control Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355366"></A>Lid switch</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355368"></A>Button used to indicate whether the system&#8217;s lid is open or closed (mobile systems only).</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355370"></A>Generic Hardware Event Feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355372"></A>C1 Power State</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355374"></A>Processor instruction to place the processor into a low-power state.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355376"></A>Processor ISA</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355378"></A>C2 Power Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355380"></A>Logic to place the processor into a C2 power state.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355382"></A>Fixed Hardware Control Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355384"></A>C3 Power Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355386"></A>Logic to place the processor into a C3 power state.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355388"></A>Fixed Hardware Control Logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355390"></A>Thermal Control</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355392"></A>Logic to generate thermal events at specified trip points.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355394"></A>Generic Hardware Event and Control Logic (See description of thermal logic in <A HREF="ACPI_Concepts.htm#65135" CLASS="XRef">See Thermal Management.</A>, &#8220;Thermal Management.&#8221;)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355396"></A>Device Power Management</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355398"></A>Control logic for switching between different device power states.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355400"></A>Generic Hardware control logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355402"></A>AC Adapter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355404"></A>Logic to detect the insertion and removal of the AC adapter.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355406"></A>Generic Hardware event logic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355408"></A>Docking/device insertion and removal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355410"></A>Logic to detect device insertion and removal events.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355412"></A>Generic Hardware event logic</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-2">
<A NAME="pgfId-1355428"></A><A NAME="_Toc489255996"></A><A NAME="_Toc489267920"></A><A NAME="_Toc489272473"></A><A NAME="_Toc202340521"></A><A NAME="_Toc258262202"></A>ACPI Register Model<A NAME="marker-1355427"></A></H2>
<P CLASS="Body">
<A NAME="pgfId-1355429"></A>ACPI hardware resides in one of six address spaces:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355430"></A>System I/O</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355431"></A>System memory </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355432"></A>PCI configuration </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355433"></A>SMBus </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355434"></A>Embedded controller </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355435"></A>Functional Fixed Hardware</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355436"></A>Different implementations will result in different address spaces being used for different functions. The ACPI specification consists of fixed hardware registers and generic hardware registers. Fixed hardware registers are required to implement ACPI-defined interfaces. The generic hardware registers are needed for any events generated by value-added hardware.<A NAME="marker-1355437"></A><A NAME="marker-1355438"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355439"></A>ACPI defines register blocks. An ACPI-compatible system provides an ACPI table (the FADT, built in memory at boot-up) that contains a list of pointers to the different fixed hardware register blocks used by OSPM. The bits within these registers have attributes defined for the given register block. The types of registers that ACPI defines are:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355440"></A>Status/Enable Registers (for events)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355442"></A>Control Registers</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355446"></A>If a regist<A NAME="marker-1355444"></A><A NAME="marker-1355445"></A>er block is of the status/enable type, then it will contain a register with status bits, and a corresponding register with enable bits. The status and enable bits have an exact implementation definition that needs to be followed (unless otherwise noted), which is illustrated by the following diagra<A NAME="marker-1355447"></A><A NAME="marker-1355448"></A>m:</P>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1355452"></A><IMG SRC="ACPI Hardware Specification-9.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1355453"></A>Block Diagram of a Status/Enable Cell</H6>
<P CLASS="Body">
<A NAME="pgfId-1355454"></A>Notice that the status bit, which hardware sets by the Event Input being set in this example, can only be cleared by software writing a 1 to its bit position. Also, the enable bit has no effect on the setting or resetting of the status bit; it only determines if the SET status bit will generate an &#8220;Event Output,&#8221; which generates an SCI when set if its enable bit is set.</P>
<P CLASS="Body">
<A NAME="pgfId-1355455"></A>ACPI also defines register groupings. A register grouping consists of two register blocks, with two pointers to two different blocks of registers, where each bit location within a register grouping is fixed and cannot be changed. The bits within a register grouping, which have fixed bit positions, can be split between the two register blocks. This allows the bits within a register grouping to reside in either or both register blocks, facilitating the ability to map bits within several different chips to the same register thus providing the programming model with a single register grouping bit structure. <A NAME="marker-1355456"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355457"></A>OSPM treats a register grouping as a single register; but located in multiple places. To read a register grouping, OSPM will read the &#8220;A&#8221; register block, followed by the &#8220;B&#8221; register block, and then will logically &#8220;OR&#8221; the two results together (the SLP_TYP field is an exception to this rule). Reserved bits, or unused bits within a register block always return zero for reads and have no side effects for writes (which is a requirement).</P>
<P CLASS="Body">
<A NAME="pgfId-1355458"></A>The SLP_TYPx field can be different for each register grouping. The respective sleeping object &#92;_Sx contains a SLP_TYPa and a SLP_TYPb field. That is, the object returns a package with two integer values of 0-7 in it. OSPM will always write the SLP_TYPa value to the &#8220;A&#8221; register block followed by the SLP_TYPb value within the field to the &#8220;B&#8221; register block. All other bit locations will be written with the same value. Also, OSPM does not read the SLP_TYPx value but throws it away.<A NAME="marker-1355459"></A></P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1355463"></A><IMG SRC="ACPI Hardware Specification-10.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1355464"></A>Example Fixed Hardware Feature Register Grouping</H6>
<P CLASS="Body">
<A NAME="pgfId-1355465"></A>As an example, the above diagram represents a register grouping consisting of register block A and register block b. Bits &#8220;a&#8221; and &#8220;d&#8221; are implemented in register block B and register block A returns a zero for these bit positions. Bits &#8220;b&#8221;, &#8220;c&#8221; and &#8220;e&#8221; are implemented in register block A and register block B returns a zero for these bit positions. All reserved or ignored bits return their defined ACPI values.</P>
<P CLASS="Body">
<A NAME="pgfId-1355466"></A>When accessing this register grouping, OSPM must read register block a, followed by reading register block b. OSPM then does a logical OR of the two registers and then operates on the results.</P>
<P CLASS="Body">
<A NAME="pgfId-1355467"></A>When writing to this register grouping, OSPM will write the desired value to register group A followed by writing the same value to register group B.</P>
<P CLASS="Body">
<A NAME="pgfId-1362247"></A>ACPI defines the following fixed hardware register blocks. Each register block gets a separate pointer from the FADT. These addresses are set by the OEM as static resources, so they are never changed--OSPM cannot re-map ACPI resources. The following register blocks are defined:<A NAME="marker-1362248"></A><A NAME="marker-1362249"></A><A NAME="marker-1362250"></A></P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1362254"></A><IMG SRC="ACPI Hardware Specification-11.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1362256"></A>Register Blocks versus Register Groupings<A NAME="marker-1362255"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1355478"></A>The PM1 EVT grouping consists of the PM1a_EVT and PM1b_EVT register blocks, which contain the fixed hardware feature event bits. Each event register block (if implemented) contains two registers: a status register and an enable register. Each register grouping has a defined bit position that cannot be changed; however, the bit can be implemented in either register block (A or B). The A and B register blocks for the events allow chipsets to vary the partitioning of events into two or more chips. For read operations, OSPM will generate a read to the associated A and B registers, OR the two values together, and then operate on this result. For write operations, OSPM will write the value to the associated register in both register blocks. Therefore, there are two rules to follow when implementing event registers:<A NAME="marker-1355479"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355480"></A>Reserved or unimplemented bits always return zero (control or enable).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355481"></A>Writes to reserved or unimplemented bits have no affect.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355482"></A>The PM1 CNT grouping contains the fixed hardware feature control bits and consists of the PM1a_CNT_BLK and PM1b_CNT_BLK register blocks. Each register block is associated with a single control register. Each register grouping has a defined bit position that cannot be changed; however, the bit can be implemented in either register block (A or B). There are two rules to follow when implementing CNT registers:<A NAME="marker-1355483"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355484"></A>Reserved or unimplemented bits always return zero (control or enable).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355485"></A>Writes to reserved or unimplemented bits have no affect.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355486"></A>The PM2_CNT_BLK register block currently contains a single bit for the arbiter disable function. The general-purpose event register contains the event programming model for generic features. All generic events, just as fixed events, generate SCIs. Generic event status bits can reside anywhere; however, the top-level generic event resides in one of the general-purpose register blocks. Any generic feature event status not in the general-purpose register space is considered a child or sibling status bit, whose parent status bit is in the general-purpose event register space. Notice that it is possible to have N levels of general-purpose events prior to hitting the GPE event status.<A NAME="marker-1355487"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355488"></A>General-purpose event registers are described by two register blocks: The GPE0_BLK or the GPE1_BLK. Each register block is pointed to separately from within the FADT. Each register block is further broken into two registers: GPEx_STS and GPEx_EN. The status and enable registers in the general-purpose event registers follow the event model for the fixed hardware event registers.<A NAME="marker-1355489"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1355506"></A><A NAME="_Toc489255997"></A><A NAME="_Toc489267921"></A><A NAME="_Toc489272474"></A><A NAME="_Toc202340522"></A><A NAME="_Toc258262203"></A>ACPI Register Summary</H6>
<P CLASS="Body">
<A NAME="pgfId-1355508"></A>The following tables summarize the ACPI registers:<A NAME="marker-1355507"></A></P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355510"></A>PM1 Event Registers<A NAME="marker-1355509"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355513"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355515"></A>Size (Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355517"></A>Address (relative to register block)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355519"></A>PM1a_STS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355521"></A>PM1_EVT_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355523"></A>&lt;PM1a_EVT_BLK &gt;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355525"></A>PM1a_EN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355527"></A>PM1_EVT_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355529"></A>&lt;PM1a_EVT_BLK &gt;+PM1_EVT_LEN/2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355531"></A>PM1b_STS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355533"></A>PM1_EVT_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355535"></A>&lt;PM1b_EVT_BLK &gt;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355537"></A>PM1b_EN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355539"></A>PM1_EVT_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355541"></A>&lt;PM1b_EVT_BLK &gt;+PM1_EVT_LEN/2</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355546"></A>PM1 Control Registers<A NAME="marker-1355545"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355549"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355551"></A>Size (Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355553"></A>Address (relative to register block)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355555"></A>PM1_CNTa</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355557"></A>PM1_CNT_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355559"></A>&lt;PM1a_CNT_BLK &gt;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355561"></A>PM1_CNTb</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355563"></A>PM1_CNT_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355565"></A>&lt;PM1b_CNT_BLK &gt;</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355570"></A>PM2 Control Register<A NAME="marker-1355569"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355573"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355575"></A>Size (Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355577"></A>Address (relative to register block)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355579"></A>PM2_CNT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355581"></A>PM2_CNT_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355583"></A>&lt;PM2_CNT_BLK &gt;</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355589"></A>PM Timer Register<A NAME="marker-1355587"></A><A NAME="marker-1355588"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355592"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355594"></A>Size (Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355596"></A>Address (relative to register block)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355598"></A>PM_TMR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355600"></A>PM_TMR_LEN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355602"></A>&lt;PM_TMR_BLK &gt;</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355607"></A>Processor Control Registers<A NAME="marker-1355606"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355610"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355612"></A>Size (Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355614"></A>Address (relative to register block)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355616"></A>P_CNT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355618"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355620"></A>Either &lt;P_BLK&gt; or specified by the PTC object (See <A HREF="Processor_Configuration_and_Control.htm#_Toc489256115" CLASS="XRef">See _PTC (Processor Throttling Control).</A>, &#8220;PTC [Processor Throttling Control].&#8221;)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355622"></A>P_LVL2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355624"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355626"></A>&lt;P_BLK&gt;+4h</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355628"></A>P_LVL3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355630"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355632"></A>&lt;P_BLK&gt;+5h</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355643"></A>General-Purpose Event Registers<A NAME="marker-1355642"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355646"></A>Register</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355648"></A>Size (Bytes)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355650"></A>Address (relative to register block)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355652"></A>GPE0_STS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355654"></A>GPE0_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355656"></A>&lt;GPE0_BLK&gt;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355658"></A>GPE0_EN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355660"></A>GPE0_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355662"></A>&lt;GPE0_BLK&gt;+GPE0_LEN/2</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355664"></A>GPE1_STS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355666"></A>GPE1_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355668"></A>&lt;GPE1_BLK&gt;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355670"></A>GPE1_EN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355672"></A>GPE1_LEN/2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355674"></A>&lt;GPE1_BLK&gt;+GPE1_LEN/2</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355686"></A>PM1 Event Registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1355689"></A>The PM1 event reg<A NAME="marker-1355688"></A>ister grouping contains two register blocks: the PM1a_EVT_BLK is a required register block when the following ACPI interface categories are required by a class specific platform design guide:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355690"></A>Power management timer control/status</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355691"></A>Processor power state control/status</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355692"></A>Global Lock related interfaces</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355693"></A>Power or Sleep button (fixed register interfaces)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355694"></A>System power state controls (sleeping/wake control)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355695"></A>The PM1b_EVT_BLK is an optional register block. Each register block has a unique 32-bit pointer in the Fixed ACPI Table (FADT) to allow the PM1 event bits to be partitioned between two chips. If the PM1b_EVT_BLK is not supported, its pointer contains a value of zero in the FADT.</P>
<P CLASS="Body">
<A NAME="pgfId-1355696"></A>Each register block in the PM1 event grouping contains two registers that are required to be the same size: the PM1x_STS and PM1x_EN (where x can be &#8220;a&#8221; or &#8220;b&#8221;). The length of the registers is variable and is described by the PM1_EVT_LEN field in the FADT, which indicates the total length of the register block in bytes. Hence if a length of &#8220;4&#8221; is given, this indicates that each register contains two bytes of I/O space. The PM1 event register block has a minimum size of 4 bytes.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355705"></A>PM1 Control Registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1355708"></A>The PM1 control reg<A NAME="marker-1355707"></A>ister grouping contains two register blocks: the PM1a_CNT_BLK is a required register block when the following ACPI interface categories are required by a class specific platform design guide:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355709"></A>SCI/SMI routing control/status for power management and general-purpose events</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355710"></A>Processor power state control/status</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355711"></A>Global Lock related interfaces</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355712"></A>System power state controls (sleeping/wake control)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355713"></A>The PM1b_CNT_BLK is an optional register block. Each register block has a unique 32-bit pointer in the Fixed ACPI Table (FADT) to allow the PM1 event bits to be partitioned between two chips. If the PM1b_CNT_BLK is not supported, its pointer contains a value of zero in the FADT.</P>
<P CLASS="Body">
<A NAME="pgfId-1355714"></A>Each register block in the PM1 control grouping contains a single register: the PM1x_CNT. The length of the register is variable and is described by the PM1_CNT_LEN field in the FADT, which indicates the total length of the register block in bytes. The PM1 control register block must have a minimum size of 2 bytes.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355723"></A>PM2 Control Register</H6>
<P CLASS="Body">
<A NAME="pgfId-1355726"></A>The PM2 control re<A NAME="marker-1355725"></A>gister is contained in the PM2_CNT_BLK register block. The FADT contains a length variable for this register block (PM2_CNT_LEN) that is equal to the size in bytes of the PM2_CNT register (the only register in this register block). This register block is optional, if not supported its block pointer and length contain a value of zero.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355735"></A>PM Timer Register</H6>
<P CLASS="Body">
<A NAME="pgfId-1355739"></A>The PM timer r<A NAME="marker-1355737"></A><A NAME="marker-1355738"></A>egister is contained in the PM_TMR_BLK register block. It is an optional register block that must be implemented when the power management timer control/status ACPI interface category is required by a class specific platform design guide.</P>
<P CLASS="Body">
<A NAME="pgfId-1355740"></A>If defined, this register block contains the register that returns the running value of the power management timer. The FADT also contains a length variable for this register block (PM_TMR_LEN) that is equal to the size in bytes of the PM_TMR register (the only register in this register block).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355750"></A>Processor Control Block (P_BLK<A NAME="marker-1355749"></A>)</H6>
<P CLASS="Body">
<A NAME="pgfId-1355752"></A>There is an optional processor control register block for each processor in the system. As this is a homogeneous feature, all processors must have the same level of support. The ACPI OS will revert to the lowest common denominator of processor control block support. The processor control block contains the processor control register (P_CNT-a 32-bit performance control configuration register), and the P_LVL2 and P_LVL3 CPU sleep state control registers. The 32-bit P_CNT register controls the behavior of the processor clock logic for that processor, the P_LVL2 register is used to place the CPU into the C2 state, and the P_LVL3 register is used to place the processor into the C3 state.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355761"></A>General-Purpose Event Registers</H6>
<P CLASS="Body">
<A NAME="pgfId-1355764"></A>The general-purpose event reg<A NAME="marker-1355763"></A>isters contain the root level events for all generic features. To facilitate the flexibility of partitioning the root events, ACPI provides for two different general-purpose event blocks: GPE0_BLK and GPE1_BLK. These are separate register blocks and are not a register grouping, because there is no need to maintain an orthogonal bit arrangement. Also, each register block contains its own length variable in the FADT, where GPE0_LEN and GPE1_LEN represent the length in bytes of each register block.</P>
<P CLASS="Body">
<A NAME="pgfId-1355765"></A>Each register block contains two registers of equal length: GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN. The length of the GPE1_STS and GPE1_EN registers is equal to half the GPE1_LEN. If a generic register block is not supported then its respective block pointer and block length values in the FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need to be the same size.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1355782"></A><A NAME="_Toc489255998"></A><A NAME="_Toc489267922"></A><A NAME="_Toc489272475"></A><A NAME="_Toc202340523"></A><A NAME="_Toc258262204"></A>Fixed Hardware Features</H6>
<P CLASS="Body">
<A NAME="pgfId-1355783"></A>This section describes the fixed hardware features defined by ACPI.</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355797"></A>Power Management Timer</H6>
<P CLASS="Body">
<A NAME="pgfId-1355802"></A>The ACPI specifica<A NAME="marker-1355799"></A><A NAME="marker-1355800"></A><A NAME="marker-1355801"></A>tion defines an optional power management timer that provides an accurate time value that can be used by system software to measure and profile system idleness (along with other tasks). The power management timer provides an accurate time function while the system is in the working (G0) state. To allow software to extend the number of bits in the timer, the power management timer generates an interrupt when the last bit of the timer changes (from 0 to 1 or 1 to 0). ACPI supports either a 24-bit or 32-bit power management timer. The PM Timer is accessed directly by OSPM, and its programming model is contained in fixed register space. The programming model can be partitioned in up to three different register blocks. The event bits are contained in the PM1_EVT register grouping, which has two register blocks, and the timer value can be accessed through the PM_TMR_BLK register block. A block diagram of the power management timer is illustrated in the following figure:</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1355806"></A><IMG SRC="ACPI Hardware Specification-12.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1355807"></A>Power Management Timer</H6>
<P CLASS="Body">
<A NAME="pgfId-1355808"></A>The power management timer is a 24-bit or 32-bit fixed rate free running count-up timer that runs off a 3.579545 MHz clock. The ACPI OS checks the FADT to determine whether the PM Timer is a 32-bit or 24-bit timer. The programming model for the PM Timer consists of event logic, and a read port to the counter value. The event logic consists of an event status and enable bit. The status bit is set any time the last bit of the timer (bit 23 or bit 31) goes from set to clear or clear to set. If the TMR_EN bit is set, then the setting of the TMR_STS will generate an ACPI event in the PM1_EVT register grouping (referred to as PMTMR_PME in the diagram). The event logic is only used to emulate a larger timer.</P>
<P CLASS="Body">
<A NAME="pgfId-1355809"></A>OSPM uses the read-only TMR_VAL field (in the PM TMR register grouping) to read the current value of the timer. OSPM never assumes an initial value of the TMR_VAL field; instead, it reads an initial TMR_VAL upon loading OSPM and assumes that the timer is counting. It is allowable to stop the Timer when the system transitions out of the working (G0/S0) state. The only timer reset requirement is that the timer functions while in the working state.<A NAME="marker-1355810"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355811"></A>The PM Timer&#8217;s programming model is implemented as a fixed hardware feature to increase the accuracy of reading the timer.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1355828"></A><A NAME="77822"></A>Console Buttons</H6>
<P CLASS="Body">
<A NAME="pgfId-1355829"></A>ACPI defines user-initiated events to request OSPM to transition the platform between the G0 working state and the G1 sleeping, G2 soft off and G3 mechanical off states. ACPI also defines a recommended mechanism to unconditionally transition the platform from a hung G0 working state to the G2 soft-off state. <A NAME="marker-1355830"></A><A NAME="marker-1355831"></A><A NAME="marker-1355832"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355833"></A>ACPI operating systems use power button events to determine when the user is present. As such, these ACPI events are associated with buttons in the ACPI specification. </P>
<P CLASS="Body">
<A NAME="pgfId-1355834"></A>The ACPI specification supports two button models:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355835"></A>A single-button model that generates an event for both sleeping and entering the soft-off state. The function of the button can be configured using OSPM UI.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355837"></A>A dual-button model where the power button generates a soft-off transition request and a sleep button generates a sleep transition request. The type of button implies the function of the button.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1355839"></A>Control of these button events is either through the fixed hardware programming model or the generic hardware programming model (control method based). The fixed hardware programming model has th<A NAME="marker-1355840"></A>e advantage that OSPM can access the button at any time, including when the system is crashed. In a crashed system with a fixed hardware power button, OSPM can make a &#8220;best&#8221; effort to determine whether the power button has been pressed to transition to the system to the soft-off state, because it doesn&#8217;t require the AML interpreter to access the event bits<A NAME="marker-1355841"></A><A NAME="marker-1355842"></A><A NAME="marker-1355843"></A>.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1355847"></A><A NAME="77498"></A>Power Button</H6>
<P CLASS="Body">
<A NAME="pgfId-1355851"></A>The power<A NAME="marker-1355849"></A><A NAME="marker-1355850"></A> button logic can be used in one of two models: single button or dual button. In the single-button model, the user button acts as both a power button for transitioning the system between the G0 and G2 states and a sleep button for transitioning the system between the G0 and G1 states. The action of the user pressing the button is determined by software policy or user settings. In the dual-button model, there are separate buttons for sleeping and power control. Although the buttons still generate events that cause software to take an action, the function of the button is now dedicated: the sleep button generates a sleep request to OSPM and the power button generates a wake request. </P>
<P CLASS="Body">
<A NAME="pgfId-1355852"></A>Support for a power button is indicated by a combination of the PWR_BUTTON flag and the power button device object, as shown in the following:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355853"></A>Power Button Support</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355856"></A>Indicated Support</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355858"></A>PWR_BUTTON Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355860"></A>Power Button Device Object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355862"></A>Fixed hardware power button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355864"></A>Clear</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355866"></A>Absent</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355868"></A>Control method power button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355870"></A>Set</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355872"></A>Present</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-1355875"></A>The power button can also have an additional capability to unconditionally transition the system from a hung working state to the G2 soft-off state. In the case where OSPM event handler is no longer able to respond to power button events, the power button override feature provides a back-up mechanism to unconditionally transition the system to the soft-off state. This feature can be used when the platform doesn&#8217;t have a mechanical off button, which can also provide this function. ACPI defines that holding the power button active for four seconds or longer will generate a power button override event.<A NAME="marker-1355876"></A><A NAME="marker-1355877"></A><A NAME="marker-1355878"></A><A NAME="marker-1355879"></A><A NAME="marker-1355880"></A><A NAME="marker-1355881"></A><A NAME="marker-1355882"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1355886"></A> Fixed Power Button</H6>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Normal">
<A NAME="pgfId-1355889"></A><A NAME="marker-1355887"></A><A NAME="marker-1355888"></A>&nbsp;</H4>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1355893"></A><IMG SRC="ACPI Hardware Specification-13.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1355894"></A>Fixed Power Button Logic</H6>
<P CLASS="Body">
<A NAME="pgfId-1355895"></A>The fixed hardware power button has its event programming model in the PM1x_EVT_BLK. This logic consists of a single enable bit and sticky status bit. When the user presses the power button, the power button status bit (PWRBTN_STS) is unconditionally set. If the power button enable bit (PWRBTN_EN) is set and the power button status bit is set (PWRBTN_STS) due to a button press while the system is in the G0 state, then an SCI is generated. OSPM responds to the event by clearing the PWRBTN_STS bit. The power button logic provides debounce logic that sets the PWRBTN_STS bit on the button press &#8220;edge.&#8221;  <A NAME="marker-1355896"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1355897"></A>While the system is in the G1 or G2 global states (S1, S2, S3, S4 or S5 states), any further power button press after the button press that transitioned the system into the sleeping state unconditionally sets the power button status bit and wakes the system, regardless of the value of the power button enable bit. OSPM responds by clearing the power button status bit and waking the system.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1355902"></A><A NAME="77029"></A> Control Method Power Button</H6>
<P CLASS="Body">
<A NAME="pgfId-1355907"></A>The power button progra<A NAME="marker-1355904"></A><A NAME="marker-1355905"></A><A NAME="marker-1355906"></A>mming model can also use the generic hardware programming model. This allows the power button to reside in any of the generic hardware address spaces (for example, the embedded controller) instead of fixed space. If the power button is implemented using generic hardware, then the OEM needs to define the power button as a device with an _HID object value of &#8220;PNP0C0C,&#8221; which then identifies this device as the power button to OSPM. The AML event handler then generates a Notify command to notify OSPM that a power button event was generated. While the system is in the working state, a power button press is a user request to transition the system into either the sleeping (G1) or soft-off state (G2). In these cases, the power button event handler issues the Notify command with the device specific code of 0x80. This indicates to OSPM to pass control to the power button driver (PNP0C0C) with the knowledge that a transition out of the G0 state is being requested. Upon waking from a G1 sleeping state, the AML event handler generates a notify command with the code of 0x2 to indicate it was responsible for waking the syste<A NAME="marker-1355908"></A><A NAME="marker-1355909"></A>m. </P>
<P CLASS="Body">
<A NAME="pgfId-1355910"></A>The power button device needs to be declared as a device within the ACPI Namespace for the platform and only requires an _HID. An example definition follows.</P>
<P CLASS="Body">
<A NAME="pgfId-1355921"></A><A NAME="marker-1355919"></A>This example ASL code performs the following:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1355922"></A>Creates a device named &#8220;PWRB&#8221; and associates the Plug and Play identifier (through the _HID object) of &#8220;PNP0C0C.&#8221;  </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355923"></A>The Plug and Play identifier associates this device object with the power button driver.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355924"></A>Creates an operational region for the control method power button&#8217;s programming model: System I/O space at 0x200.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355925"></A>Fields that are not accessed are written as zeros. These status bits clear upon writing a 1 to their bit position, therefore preserved would fail in this case.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355926"></A>Creates a field within the operational region for the power button status bit (called PBP). In this case the power button status bit is a child of the general-purpose event status bit 0. When this bit is set, it is the responsibility of the ASL-code to clear it (OSPM clears the general-purpose status bits). The address of the status bit is 0x200.0 (bit 0 at address 0x200).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355927"></A>Creates an additional status bit called PBW for the power button wake event. This is the next bit and its physical address would be 0x200.1 (bit 1 at address 0x200).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355928"></A>Generates an event handler for the power button that is connected to bit 0 of the general-purpose event status register 0. The event handler does the following:</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355929"></A>Clears the power button status bit in hardware (writes a one to it).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1355930"></A>Notifies OSPM of the event by calling the Notify command passing the power button object and the device specific event indicator 0x80.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="code-Ex-CODE-PRE-CITE">
<A NAME="pgfId-1355931"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1355932"></A>// Define a control method power button</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355933"></A>Device(&#92;_SB.PWRB){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355934"></A>     Name(_HID, EISAID(&#8220;PNP0C0C&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355935"></A>     Name(_PRW, Package(){0, 0x4})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355936"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355937"></A>     OperationRegion(&#92;PHO, SystemIO, 0x200, 0x1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417333"></A>     Field(&#92;PHO, ByteAcc, NoLock, WriteAsZeros){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417334"></A>         PBP, 1,                     // sleep/off request</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1423730"></A>         PBW, 1                      // wakeup request</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1423731"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1423732"></A>} // end of power button device object</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355943"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355944"></A>Scope(&#92;_GPE){                         // Root level event handlers</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355945"></A>    Method(_L00){                     // uses bit 0 of GP0_STS register</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355946"></A>         If(&#92;PBP){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355947"></A>              Store(One, &#92;PBP)        // clear power button status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355948"></A>              Notify(&#92;_SB.PWRB, 0x80) // Notify OS of event</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355949"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355950"></A>         If(&#92;PBW){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355951"></A>              Store(One, &#92;PBW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417408"></A>              Notify(&#92;_SB.PWRB, 0x2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417490"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417491"></A>    } // end of _L00 handler</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417492"></A>} // end of &#92;_GPE scope</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1355958"></A><A NAME="_Toc460009584"></A><A NAME="_Toc469218872"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1355960"></A><A NAME="62307"></A> Power Button Overrid<A NAME="marker-1355959"></A>e</H6>
<P CLASS="Body">
<A NAME="pgfId-1355963"></A><A NAME="marker-1355961"></A>The ACPI specification also allows that if the user presses the power button for more than four seconds while the system is in the working state, a hardware event is generated and the system will transition to the soft-off state. This hardware event is called a power button override. In reaction to the power button override event, the hardware clears the power button status bit (PWRBTN_STS).<A NAME="marker-1355964"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1355976"></A><A NAME="marker-1355974"></A>Sleep Button</H6>
<P CLASS="Body">
<A NAME="pgfId-1355977"></A>When using the two button model, ACPI supports a second button that when pressed will request OSPM to transition the platform between the G0 working and G1 sleeping states. Support for a sleep button is indicated by a combination of the SLEEP_BUTTON flag and the sleep button device object:</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1355978"></A>Sleep Button Support</H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355981"></A>Indicated Support</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355983"></A>SLEEP_BUTTON Flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1355985"></A>Sleep Button Device Object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355987"></A>No sleep button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355989"></A>Set</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355991"></A>Absent</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355993"></A>Fixed hardware sleep button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355995"></A>Clear</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355997"></A>Absent</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1355999"></A>Control method sleep button</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356001"></A>Set</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356003"></A>Present</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1356009"></A> Fixed Hardware Sleep Button</H6>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Normal">
<A NAME="pgfId-1356012"></A><A NAME="marker-1356010"></A><A NAME="marker-1356011"></A>&nbsp;</H4>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1356016"></A><IMG SRC="ACPI Hardware Specification-14.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1356018"></A>Fixed Hardware Sleep Button Logic<A NAME="marker-1356017"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1356019"></A>The fixed hardware sleep button has its event programming model in the PM1x_EVT_BLK. This logic consists of a single enable bit and sticky status bit. When the user presses the sleep button, the sleep button status bit (SLPBTN_STS) is unconditionally set. Additionally, if the sleep button enable bit (SLPBTN_EN) is set, and the sleep button status bit is set (SLPBTN_STS, due to a button press) while the system is in the G0 state, then an SCI is generated. OSPM responds to the event by clearing the SLPBTN_STS bit. The sleep button logic provides debounce logic that sets the SLPBTN_STS bit on the button press &#8220;edge.&#8221;  </P>
<P CLASS="Body">
<A NAME="pgfId-1356020"></A>While the system is sleeping (in either the S0, S1, S2, S3 or S4 states), any further sleep button press (after the button press that caused the system transition into the sleeping state) sets the sleep button status bit (SLPBTN_STS) and wakes the system if the SLP_EN bit is set. OSPM responds by clearing the sleep button status bit and waking the system.<A NAME="marker-1356021"></A></P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1356025"></A> Control Method Sleep Button</H6>
<P CLASS="Body">
<A NAME="pgfId-1356030"></A>The sleep button programmi<A NAME="marker-1356027"></A><A NAME="marker-1356028"></A><A NAME="marker-1356029"></A>ng model can also use the generic hardware programming model. This allows the sleep button to reside in any of the generic hardware address spaces (for example, the embedded controller) instead of fixed space. If the sleep button is implemented via generic hardware, then the OEM needs to define the sleep button as a device with an _HID object value of &#8220;PNP0C0E&#8221;, which then identifies this device as the sleep button to OSPM. The AML event handler then generates a Notify command to notify OSPM that a sleep button event was generated. While in the working state, a sleep button press is a user request to transition the system into the sleeping (G1) state. In these cases the sleep button event handler issues the Notify command with the device specific code of 0x80. This will indicate to OSPM to pass control to the sleep button driver (PNP0C0E) with the knowledge that the user is requesting a transition out of the G0 state. Upon waking-up from a G1 sleeping state, the AML event handler generates a Notify command with the code of 0x2 to indicate it was responsible for waking the system. </P>
<P CLASS="Body">
<A NAME="pgfId-1356037"></A>The sleep button device needs to be declared as a device within the ACPI Namespace for the platform and only requires an _HID. An example definition is shown below.</P>
<P CLASS="Body">
<A NAME="pgfId-1356040"></A>The AML code below does the following:<A NAME="marker-1356038"></A><A NAME="marker-1356039"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1356041"></A>Creates a device named &#8220;SLPB&#8221; and associates the Plug and Play identifier (through the _HID object) of &#8220;PNP0C0E.&#8221; </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356042"></A>The Plug and Play identifier associates this device object with the sleep button driver.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356043"></A>Creates an operational region for the control method sleep button&#8217;s programming model: System I/O space at 0x201.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356044"></A>Fields that are not accessed are written as &#8220;1s&#8221; (these status bits clear upon writing a &#8220;1&#8221; to their bit position, hence preserved would fail in this case).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356045"></A>Creates a field within the operational region for the sleep button status bit (called PBP). In this case the sleep button status bit is a child of the general-purpose status bit 0. When this bit is set it is the responsibility of the AML code to clear it (OSPM clears the general-purpose status bits). The address of the status bit is 0x201.0 (bit 0 at address 0x201).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356046"></A>Creates an additional status bit called PBW for the sleep button wake event. This is the next bit and its physical address would be 0x201.1 (bit 1 at address 0x201).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356047"></A>Generates an event handler for the sleep button that is connected to bit 0 of the general-purpose status register 0. The event handler does the following:</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356048"></A>Clears the sleep button status bit in hardware (writes a &#8220;1&#8221; to it).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356049"></A>Notifies OSPM of the event by calling the Notify command passing the sleep button object and the device specific event indicator 0x80.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="code-Ex-CODE-PRE-CITE">
<A NAME="pgfId-1356050"></A>&nbsp;</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1356051"></A>// Define a control method sleep button</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356052"></A>Device(&#92;_SB.SLPB){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356053"></A>     Name(_HID, EISAID(&#8220;PNP0C0E&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356054"></A>     Name(_PRW, Package(){0x01, 0x04})</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356055"></A>     OperationRegion(&#92;Boo, SystemIO, 0x201, 0x1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356056"></A>     Field(&#92;Boo, ByteAcc, NoLock, WriteAsZeros){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356057"></A>         SBP, 1,                            // sleep request</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356058"></A>         SBW, 1                             // wakeup request</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356059"></A>    }                                       // end of field definition</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356060"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356061"></A>Scope(&#92;_GPE){                               // Root level event handlers</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356062"></A>     Method(_L01){                          // uses bit 1 of GP0_STS register</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356063"></A>         If(&#92;SBP){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356064"></A>              Store(One, &#92;SBP)				              // clear sleep button status</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356065"></A>              Notify(&#92;_SB.SLPB, 0x80)       // Notify OS of event</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356066"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356067"></A>         If(&#92;SBW){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356068"></A>              Store(One, &#92;SBW)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356069"></A>              Notify(&#92;_SB.SLPB, 0x2)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356070"></A>         }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356071"></A>     } // end of _L01 handler</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356072"></A>} // end of &#92;_GPE scope</P>
<P CLASS="Body">
<A NAME="pgfId-1424143"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1358754"></A><A NAME="marker-1356092"></A><A NAME="16727"></A>Sleeping/Wake Control<A NAME="marker-1358753"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1356095"></A><A NAME="marker-1358755"></A><A NAME="marker-1358756"></A>The sleeping/wake logic consists of logic that will sequence the system into the defined low-power hardware sleeping state (S1-S4) or soft-off state (S5) and will wake the system back to the working state upon a wake event. Notice that the S4BIOS state is entered in a different manner (for more information, see <A HREF="Waking_and_Sleeping.htm#17584" CLASS="XRef">See The S4BIOS Transition.</A>, &#8220;The S4BIOS Transition&#8221;).</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1356099"></A><IMG SRC="ACPI Hardware Specification-15.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1356100"></A>Sleeping/Wake Logic</H6>
<P CLASS="Body">
<A NAME="pgfId-1356103"></A><A NAME="_Toc356222067"></A><A NAME="_Ref362661518"></A>The logic is controlled via two bit fields: Sleep Enable (SLP_EN) and Sleep Type (SLP_TYPx). The type of sleep or soft-off state desired is programmed into the SLP_TYPx field and upon assertion of the SLP_EN the hardware will sequence the system into the defined sleeping state. OSPM gets values for the SLP_TYPx field from the &#92;_Sx objects defined in the static definition block. If the object is missing OSPM assumes the hardware does not support that sleeping state. Prior to entering the desired sleeping state, OSPM will read the designated &#92;_Sx object and place this value in the SLP_TYP field.<A NAME="marker-1356104"></A><A NAME="marker-1356105"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356106"></A>Additionally ACPI defines a fail-safe Off protocol called the &#8220;power button override,&#8221; which allows the user to initiate an Off sequence in the case where the system software is no longer able to recover the system (the system has hung). ACPI defines that this sequence be initiated by the user pressing the power button for over 4 seconds, at which point the hardware unconditionally sequences the system to the Off state. This logic is represented by the PWRBTN_OR signal coming into the sleep logic.<A NAME="marker-1356107"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356108"></A>While in any of the sleeping states (G1), an enabled &#8220;Wake&#8221; event will cause the hardware to sequence the system back to the working state (G0). The &#8220;Wake Status&#8221; bit (WAK_STS) is provided for OSPM to &#8220;spin-on&#8221; after setting the SLP_EN/SLP_TYP bit fields. When waking from the S1 sleeping state, execution control is passed backed to OSPM immediately, whereas when waking from the S2-S4 states execution control is passed to the platform boot firmware (execution begins at the CPU&#8217;s reset vector). The WAK_STS bit provides a mechanism to separate OSPM&#8217;s sleeping and waking code during an S1 sequence. When the hardware has sequenced the system into the sleeping state (defined here as the processor is no longer able to execute instructions), any enabled wake event is allowed to set the WAK_STS bit and sequence the system back on (to the G0 state). If the system does not support the S1 sleeping state, the WAK_STS bit can always return zero.<A NAME="marker-1356109"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356110"></A>-If more than a single sleeping state is supported, then the sleeping/wake logic is required to be able to dynamically sequence between the different sleeping states. This is accomplished by waking the system; OSPM programs the new sleep state into the SLP_TYP field, and then sets the SLP_EN bit-placing the system again in the sleeping state.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356131"></A><A NAME="marker-1356129"></A><A NAME="36703"></A>Real Time Clock Alarm</H6>
<P CLASS="Body">
<A NAME="pgfId-1356132"></A>If implemented, the Real Time Clock (RTC) alarm must generate a hardware wake event when in the sleeping state. The RTC can be programmed to generate an alarm. An enabled RTC alarm can be used to generate a wake event when the system is in a sleeping state. ACPI provides for additional hardware to support OSPM in determining that the RTC was the source of the wake event: the RTC_STS and RTC_EN bits. Although these bits are optional, if supported they must be implemented as described here. <A NAME="marker-1356133"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356134"></A>If the RTC_STS and RTC_EN bits are not supported, OSPM will attempt to identify the RTC as a possible wake source; however, it might miss certain wake events. If implemented, the RTC wake feature is required to work in the following sleeping states: S1-S3. S4 wake is optional and supported through the RTC_S4 flag within the FADT (if set, then the platform supports RTC wake in the S4 state)<A HREF="#pgfId-1356137" CLASS="footnote">2</A>.<A NAME="marker-1356138"></A><A NAME="marker-1356139"></A><A NAME="marker-1356140"></A><A NAME="marker-1356141"></A><A NAME="marker-1356142"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356143"></A>When the RTC generates a wake event the RTC_STS bit will be set. If the RTC_EN bit is set, an RTC hardware power management event will be generated (which will wake the system from a sleeping state, provided the battery low signal is not asserted).<A NAME="marker-1356144"></A><A NAME="marker-1356145"></A></P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1356149"></A><IMG SRC="ACPI Hardware Specification-16.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1356150"></A>RTC Alarm</H6>
<P CLASS="Body">
<A NAME="pgfId-1356152"></A><A NAME="_Ref362191225"></A>The RTC wake event status and enable bits are an optional fixed hardware feature and a flag within the FADT (FIX_RTC) indicates if the register bits are to be used by OSPM. If the RTC wake event status and enable bits are implemented in fixed hardware, OSPM can determine if the RTC was the source of the wake event without loading the entire OS. This also gives the platform the capability of indicating an RTC wake source without consuming a GPE bit, as would be required if RTC wake was not implemented using the fixed hardware RTC feature. If the fixed hardware feature event bits are not supported, then OSPM will attempt to determine this by reading the RTC&#8217;s status field. If the platform implements the RTC fixed hardware feature, and this hardware consumes resources, the _FIX method can be used to correlate these resources with the fixed hardware. See <A HREF="Device_Configuration.htm#_Toc489256052" CLASS="XRef">See _DSD (Device Specific Data).</A>, &#8220;_FIX (Fixed Register Resource Provide&#8221;, for details.<A NAME="marker-1356153"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356154"></A>OSPM supports enhancements over the existing RTC device (which only supports a 99 year date and 24-hour alarm). Optional extensions are provided for the following features:</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="GlossTerm">
<A NAME="pgfId-1356155"></A>Day Alarm. </H3>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1358824"></A>The DAY_ALRM field points to an optional CMOS RAM location that selects the day within the month to generate an RTC alarm. <A NAME="marker-1356156"></A></P>
</DIV>
<DIV>
<H3 CLASS="GlossTerm">
<A NAME="pgfId-1356158"></A>Month Alarm. </H3>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1358831"></A>The MON_ALRM field points to an optional CMOS RAM location that selects the month within the year to generate an RTC alarm.<A NAME="marker-1356159"></A></P>
</DIV>
<DIV>
<H3 CLASS="GlossTerm">
<A NAME="pgfId-1356161"></A>Centenary Value. </H3>
<P CLASS="ArgDefinitionRH">
<A NAME="pgfId-1358869"></A>The CENT field points to an optional CMOS RAM location that represents the centenary value of the date (thousands and hundreds of years).<A NAME="marker-1358870"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1358877"></A>The RTC_STS bit may be set through the RTC interrupt (IRQ8 in IA-PC architecture systems). OSPM will insure that the periodic and update interrupt sources are disabled prior to sleeping. This allows the RTC&#8217;s interrupt pin to serve as the source for the RTC_STS bit generation. Note however that if the RTC interrupt pin is used for RTC_STS generation, the RTC_STS bit value may not be accurate when waking from S4. If this value is accurate when waking from S4, the platform should set the S4_RTC_STS_VALID flag, so that OSPM can utilize the RTC_STS information.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356174"></A>Alarm Field Decodings within the FADT<A NAME="marker-1356171"></A><A NAME="marker-1356172"></A><A NAME="marker-1356173"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423655"></A>Field</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423657"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423659"></A>Address (Location) in RTC CMOS RAM (Must be Bank 0)</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423662"></A>DAY_ALRM<A NAME="marker-1423661"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1423663"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1425376"></A>Eight bit value that can represent 0x01-0x31 days in BCD or 0x01-0x1F days in binary. Bits 6 and 7 of this field are treated as Ignored by software. The RTC is initialized such that this field contains a &#8220;don&#8217;t care&#8221; value when the platform firmware switches from legacy to ACPI mode. A don&#8217;t care value can be any unused value (not 0x1-0x31 BCD or 0x01-0x1F hex) that the RTC reverts back to a 24 hour alarm.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423667"></A>The DAY_ALRM field in the FADT will contain a non-zero value that represents an offset into the RTC&#8217;s CMOS RAM area that contains the day alarm value. A value of zero in the DAY_ALRM field indicates that the day alarm feature is not supported.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423670"></A>MON_ALRM<A NAME="marker-1423669"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1423671"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423673"></A>Eight bit value that can represent 01-12 months in BCD or 0x01-0xC months in binary. The RTC is initialized such that this field contains a don&#8217;t care value when the platform firmware switches from legacy to ACPI mode. A &#8220;don&#8217;t care&#8221; value can be any unused value (not 1-12 BCD or x01-xC hex) that the RTC reverts back to a 24 hour alarm and/or 31 day alarm).</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423675"></A>The MON_ALRM field in the FADT will contain a non-zero value that represents an offset into the RTC&#8217;s CMOS RAM area that contains the month alarm value. A value of zero in the MON_ALRM field indicates that the month alarm feature is not supported. If the month alarm is supported, the day alarm function must also be supported.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423678"></A>CENTURY<A NAME="marker-1423677"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1423679"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423681"></A>8-bit BCD or binary value. This value indicates the thousand year and hundred year (Centenary) variables of the date in BCD (19 for this century, 20 for the next) or binary (x13 for this century, x14 for the next).</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423683"></A>The CENTURY field in the FADT will contain a non-zero value that represents an offset into the RTC&#8217;s CMOS RAM area that contains the Centenary value for the date. A value of zero in the CENTURY field indicates that the Centenary value is not supported by this RTC.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356229"></A><A NAME="48713"></A> Legacy/ACPI Select and the SCI Interrupt</H6>
<P CLASS="Body">
<A NAME="pgfId-1362704"></A>As mentioned previously, power management events are generated to initiate an interrupt or hardware sequence. ACPI operating systems use the SCI interrupt handler to respond to events, while legacy systems use some type of transparent interrupt handler to respond to these events (that is, an SMI interrupt handler). ACPI-compatible hardware can choose to support both legacy and ACPI modes or just an ACPI mode. Legacy hardware is needed to support these features for non-ACPI-compatible operating systems. When the ACPI OS loads, it scans the platform firmware tables to determine that the hardware supports ACPI, and then if the it finds the SCI_EN bit reset (indicating that ACPI is not enabled), issues an ACPI activate command to the SMI handler through the SMI command port. The platform firmware acknowledges the switching to the ACPI model of power management by setting the SCI_EN bit (this bit can also be used to switch over the event mechanism as illustrated below):</P>
<P CLASS="Body">
<A NAME="pgfId-1362717"></A><A NAME="marker-1362705"></A><A NAME="marker-1362706"></A><A NAME="marker-1362707"></A><A NAME="marker-1362708"></A>&nbsp;</P>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1362712"></A><IMG SRC="ACPI Hardware Specification-17.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1356239"></A>Power Management Events to SMI/SCI Control Logic</H6>
<P CLASS="Body">
<A NAME="pgfId-1356240"></A>The interrupt events (those that generate SMIs in legacy mode and SCIs in ACPI mode) are sent through a decoder controlled by the SCI_EN bit. For legacy mode this bit is reset, which routes the interrupt events to the SMI interrupt logic. For ACPI mode this bit is set, which routes interrupt events to the SCI interrupt logic. This bit always returns set for ACPI-compatible hardware that does not support a legacy power management mode (in other words, the bit is wired to read as &#8220;1&#8221; and ignore writes).<A NAME="marker-1356241"></A><A NAME="marker-1356242"></A><A NAME="marker-1356243"></A><A NAME="marker-1356244"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356245"></A>The SCI interrupt is defined to be a shareable interrupt and is connected to an OS visible interrupt that uses a shareable protocol. The FADT has an entry that indicates what interrupt the SCI interrupt is mapped to (see <A HREF="ACPI_Software_Programming_Model.htm#92684" CLASS="XRef">See System Description Table Header.</A>, &#8220;System Description Table Header&#8221;). <A NAME="marker-1356246"></A><A NAME="marker-1356247"></A><A NAME="marker-1356248"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356249"></A>If the ACPI platform supports both legacy and ACPI modes, it has a register that generates a hardware event (for example, SMI for IA-PC processors). OSPM uses this register to make the hardware switch in and out of ACPI mode. Within the FADT are three values that signify the address (SMI_CMD) of this port and the data value written to enable the ACPI state (ACPI_ENABLE), and to disable the ACPI state (ACPI_DISABLE).</P>
<P CLASS="Body">
<A NAME="pgfId-1356252"></A>To transition an ACPI/Legacy platform from the Legacy mode to the ACPI mode the following would occur:<A NAME="marker-1356250"></A><A NAME="marker-1356251"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1356253"></A>ACPI driver checks that the SCI_EN bit is zero, and that it is in the Legacy mode.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356254"></A>OSPM does an OUT to the SMI_CMD port with the data in the ACPI_ENABLE field of the FADT.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356255"></A>OSPM polls the SCI_EN bit until it is sampled as SET.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1356257"></A>To transition an ACPI/Legacy platform from the ACPI mode to the Legacy mode the following would occur:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1356258"></A>ACPI driver checks that the SCI_EN bit is one, and that it is in the ACPI mode.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356259"></A>OSPM does an OUT to the SMI_CMD port with the data in the ACPI_DISABLE field of the FADT.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1356260"></A>OSPM polls the SCI_EN bit until it is sampled as RESET.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1356261"></A>Platforms that only support ACPI always return a 1 for the SCI_EN bit. In this case OSPM skips the Legacy to ACPI transition stated above.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356271"></A>Processor Control</H6>
<P CLASS="Body">
<A NAME="pgfId-1356272"></A>The ACPI specification defines several processor controls including power state control, throttling control, and performance state control. See <A HREF="Processor_Configuration_and_Control.htm#48288" CLASS="XRef">See Processor Configuration and Control.</A>, &#8220;Processor Configuration and Control,&#8221; for a complete description of the processor controls.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1356291"></A><A NAME="_Toc489255999"></A><A NAME="_Toc489267923"></A><A NAME="_Toc489272476"></A><A NAME="_Toc202340524"></A><A NAME="_Toc258262205"></A>Fixed Hardware Registers<A NAME="marker-1356289"></A><A NAME="marker-1356290"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1356295"></A><A NAME="_Toc356222096"></A><A NAME="_Ref362662024"></A><A NAME="_Ref362662071"></A>The fixed hardware registers are manipulated directly by OSPM. The following sections describe fixed hardware features under the programming model. OSPM owns all the fixed hardware resource registers; these registers cannot be manipulated by AML code. Registers are accessed with any width up to its register width (byte granular). <A NAME="marker-1356296"></A></P>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356306"></A><A NAME="47410"></A>PM1 Event Grouping</H6>
<P CLASS="Body">
<A NAME="pgfId-1356310"></A><A NAME="_Ref368038974"></A>The PM1 Event G<A NAME="marker-1356309"></A>rouping has a set of bits that can be distributed between two different register blocks. This allows these registers to be partitioned between two chips, or all placed in a single chip. Although the bits can be split between the two register blocks (each register block has a unique pointer within the FADT), the bit positions are maintained. The register block with unimplemented bits (that is, those implemented in the other register block) always returns zeros, and writes have no side effects.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1356315"></A>PM1 Status Registers</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1417678"></A>Register Locati<A NAME="marker-1417677"></A>on: &lt;PM1a_EVT_BLK / PM1b_EVT_BLK&gt;  System I/O or Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417679"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356321"></A>Attribute:         Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356322"></A>Size:              PM1_EVT_LEN / 2</P>
<P CLASS="Body">
<A NAME="pgfId-1356323"></A>The PM1 status registers contain the fixed hardware feature status bits. The bits can be split between two registers: PM1a_STS or PM1b_STS. Each register grouping can be at a different 32-bit aligned address and is pointed to by the PM1a_EVT_BLK or PM1b_EVT_BLK. The values for these pointers to the register space are found in the FADT. Accesses to the PM1 status registers are done through byte or word accesses.<A NAME="marker-1356324"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356325"></A>For ACPI/legacy systems, when transitioning from the legacy to the G0 working state this register is cleared by platform firmware prior to setting the SCI_EN bit (and thus passing control to OSPM). For ACPI only platforms (where SCI_EN is always set), when transitioning from either the mechanical off (G3) or soft-off state to the G0 working state this register is cleared prior to entering the G0 working state.<A NAME="marker-1356326"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356327"></A>This register contains optional features enabled or disabled within the FADT. If the FADT indicates that the feature is not supported as a fixed hardware feature, then software treats these bits as ignored.<A NAME="marker-1356328"></A></P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356330"></A><A NAME="12599"></A>PM1 Status Registers Fixed Hardware Feature Status Bits<A NAME="marker-1356329"></A><A NAME="marker-1356461"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1418023"></A>Bit</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1418025"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1418027"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356340"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356343"></A>TMR_STS<A NAME="marker-1356342"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356345"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356347"></A>This is the timer carry status bit. This bit gets set any time the most significant bit of a 24/32-bit counter changes from clear to set or set to clear. While TMR_EN and TMR_STS are set, an interrupt event is raised.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356349"></A>1-3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356351"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356353"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356355"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356358"></A>BM_STS<A NAME="marker-1356357"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356360"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356362"></A>This is the bus master status bit. This bit is set any time a system bus master requests the system bus, and can only be cleared by writing a &#8220;1&#8221; to this bit position. Notice that this bit reflects bus master activity, not CPU activity (this bit monitors any bus master that can cause an incoherent cache for a processor in the C3 state when the bus master performs a memory transaction).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356364"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356367"></A>GBL_STS<A NAME="marker-1356366"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356369"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356371"></A>This bit is set when an SCI is generated due to the platform runtime firmware wanting the attention of the SCI handler. Platform runtime firmware will have a control bit (somewhere within its address space) that will raise an SCI and set this bit. This bit is set in response to the platform runtime firmware releasing control of the Global Lock and having seen the pending bit set.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356373"></A>6-7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356376"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="marker-1356375"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356380"></A>Reserved. These bits always return a value of zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356382"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356385"></A>PWRBTN_STS<A NAME="marker-1356384"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356387"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356389"></A>This optional bit is set when the Power Button is pressed. In the system working state, while PWRBTN_EN and PWRBTN_STS are both set, an interrupt event is raised. In the sleep or soft-off state, a wake event is generated when the power button is pressed (regardless of the PWRBTN_EN bit setting). This bit is only set by hardware and can only be reset by software writing a &#8220;1&#8221; to this bit position. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1356390"></A>ACPI defines an optional mechanism for unconditional transitioning a system that has stopped working from the G0 working state into the G2 soft-off state called the power button override. If the Power Button is held active for more than four seconds, this bit is cleared by hardware and the system transitions into the G2/S5 Soft Off state (unconditionally).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356391"></A>Support for the power button is indicated by the PWR_BUTTON flag in the FADT being reset (zero). If the PWR_BUTTON flag is set or a power button device object is present in the ACPI Namespace, then this bit field is ignored by OSPM.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356392"></A>If the power button was the cause of the wake (from an S1-S4 state), then this bit is set prior to returning control to OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356394"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356397"></A>SLPBTN_STS<A NAME="marker-1356396"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356399"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356401"></A>This optional bit is set when the sleep button is pressed. In the system working state, while SLPBTN_EN and SLPBTN_STS are both set, an interrupt event is raised. In the sleep or soft-off states a wake event is generated when the sleeping button is pressed and the SLPBTN_EN bit is set. This bit is only set by hardware and can only be reset by software writing a &#8220;1&#8221; to this bit position. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1356402"></A>Support for the sleep button is indicated by the SLP_BUTTON flag in the FADT being reset (zero). If the SLP_BUTTON flag is set or a sleep button device object is present in the ACPI Namespace, then this bit field is ignored by OSPM.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356403"></A>If the sleep button was the cause of the wake (from an S1-S4 state), then this bit is set prior to returning control to OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356405"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356408"></A>RTC_STS<A NAME="marker-1356407"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356410"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356412"></A>This optional bit is set when the RTC generates an alarm (asserts the RTC IRQ signal). Additionally, if the RTC_EN bit is set then the setting of the RTC_STS bit will generate a power management event (an SCI, SMI, or resume event). This bit is only set by hardware and can only be reset by software writing a &#8220;1&#8221; to this bit position.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356413"></A>If the RTC was the cause of the wake (from an S1-S3 state), then this bit is set prior to returning control to OSPM. If the RTC_S4 flag within the FADT is set, and the RTC was the cause of the wake from the S4 state), then this bit is set prior to returning control to OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356415"></A>11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356418"></A>Ignore<A NAME="marker-1356417"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356420"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356422"></A>This bit field is ignored by software.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356424"></A>12-13</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356427"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="marker-1356426"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356431"></A>Reserved. These bits always return a value of zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356433"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356435"></A>PCIEXP_WAKE_STS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356437"></A>This bit is optional for chipsets that implement PCI Express. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1426449"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1426443"></A>This bit is set by hardware to indicate that the system woke due to a PCI Express wakeup event. A PCI Express wakeup event is defined as the PCI Express WAKE# pin being active , one or more of the PCI Express ports being in the beacon state, or receipt of a PCI Express PME message at a root port. This bit should only be set when one of these events causes the system to transition from a non-S0 system power state to the S0 system power state. This bit is set independent of the state of the PCIEXP_WAKE_DIS bit. </P>
<P CLASS="TableBody">
<A NAME="pgfId-1356438"></A>Software writes a 1 to clear this bit. If the WAKE# pin is still active during the write, one or more PCI Express ports is in the beacon state or the PME message received indication has not been cleared in the root port, then the bit will remain active (i.e. all inputs to this bit are level-sensitive).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1426446"></A>&nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356439"></A>Note: This bit does not itself cause a wake event or prevent entry to a sleeping state. Thus if the bit is 1 and the system is put into a sleeping state, the system will not automatically wake.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356441"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356444"></A>WAK_STS<A NAME="marker-1356443"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356446"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356448"></A>This bit is set when the system is in the sleeping state and an enabled wake event occurs. Upon setting this bit system will transition to the working state. This bit is set by hardware and can only be cleared by software writing a &#8220;1&#8221; to this bit position. </P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1356463"></A>PM1Enable Registers</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1417163"></A>Register Location: &lt;PM1a_EVT_BLK / PM1b_EVT_BLK&gt; + PM1_EVT_LEN / 2    System I/O or Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417165"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356467"></A>Attribute:         Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356468"></A>Size:              PM1_EVT_LEN / 2</P>
<P CLASS="Body">
<A NAME="pgfId-1356469"></A>The PM1 enable registers contain the fixed hardware feature enable bits. The bits can be split between two registers: PM1a_EN or PM1b_EN. Each register grouping can be at a different 32-bit aligned address and is pointed to by the PM1a_EVT_BLK or PM1b_EVT_BLK. The values for these pointers to the register space are found in the FADT. Accesses to the PM1 Enable registers are done through byte or word accesses.<A NAME="marker-1356470"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356471"></A>For ACPI/legacy systems, when transitioning from the legacy to the G0 working state the enables are cleared by platform firmware prior to setting the SCI_EN bit (and thus passing control to OSPM). For ACPI-only platforms (where SCI_EN is always set), when transitioning from either the mechanical off (G3) or soft-off state to the G0 working state this register is cleared prior to entering the G0 working state.</P>
<P CLASS="Body">
<A NAME="pgfId-1356472"></A>This register contains optional features enabled or disabled within the FADT. If the FADT indicates that the feature is not supported as a fixed hardware feature, then software treats the enable bits as write as zero.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356576"></A><A NAME="marker-1356479"></A><A NAME="49045"></A>PM1 Enable Registers Fixed Hardware Feature Enable Bits</H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1418036"></A><A NAME="_Toc356222097"></A>Bit</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1418038"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1418040"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356490"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356493"></A>TMR_EN<A NAME="marker-1356492"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356495"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356497"></A>This is the timer carry interrupt enable bit. When this bit is set then an SCI event is generated anytime the TMR_STS bit is set. When this bit is reset then no interrupt is generated when the TMR_STS bit is set.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356499"></A>4:1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356502"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="marker-1356501"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356506"></A>Reserved. These bits always return a value of zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356508"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356511"></A>GBL_EN<A NAME="marker-1356510"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356513"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356515"></A>The global enable bit. When both the GBL_EN bit and the GBL_STS bit are set, an SCI is raised.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356517"></A>7:6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356519"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356521"></A>Reserved</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356523"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356526"></A>PWRBTN_EN<A NAME="marker-1356525"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356528"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356530"></A>This optional bit is used to enable the setting of the PWRBTN_STS bit to generate a power management event (SCI or wake). The PWRBTN_STS bit is set anytime the power button is asserted. The enable bit does not have to be set to enable the setting of the PWRBTN_STS bit by the assertion of the power button (see description of the power button hardware). </P>
<P CLASS="TableBody">
<A NAME="pgfId-1356531"></A>Support for the power button is indicated by the PWR_BUTTON flag in the FADT being reset (zero). If the PWR_BUTTON flag is set or a power button device object is present in the ACPI Namespace, then this bit field is ignored by OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356533"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356536"></A>SLPBTN_EN<A NAME="marker-1356535"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356538"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356540"></A>This optional bit is used to enable the setting of the SLPBTN_STS bit to generate a power management event (SCI or wake). The SLPBTN_STS bit is set anytime the sleep button is asserted. The enable bit does not have to be set to enable the setting of the SLPBTN_STS bit by the active assertion of the sleep button (see description of the sleep button hardware).</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356541"></A>Support for the sleep button is indicated by the SLP_BUTTON flag in the FADT being reset (zero). If the SLP_BUTTON flag is set or a sleep button device object is present in the ACPI Namespace, then this bit field is ignored by OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356543"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356546"></A>RTC_EN<A NAME="marker-1356545"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356548"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356550"></A>This optional bit is used to enable the setting of the RTC_STS bit to generate a wake event. The RTC_STS bit is set any time the RTC generates an alarm.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356552"></A>13:11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356555"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="marker-1356554"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356559"></A>Reserved. These bits always return a value of zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356562"></A><A NAME="_Hlk66072117"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356564"></A>PCIEXP_WAKE_DIS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356566"></A>This bit is optional for chipsets that implement PCI Express.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1426502"></A> &nbsp;</P>
<P CLASS="TableBody">
<A NAME="pgfId-1426487"></A>This bit disables the inputs to the PCIEXP_WAKE_STS bit in the PM1 Status register from waking the system. Modification of this bit has no impact on the value of the PCIEXP_WAKE_STS bit. PCIEXP_WAKE_DIS bit. Software writes a 1 to clear this bit. If the WAKE# pin is still active during the write, one or more PCI Express ports is in the beacon state or the PME message received indication has not been cleared in the root port, then the bit will remain active (i.e. all inputs to this bit are level-sensitive). Note: This bit does not itself cause a wake event or prevent entry to a sleeping state. Thus if the bit is 1 and the system is put into a sleeping state, the system will not automatically wake.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356568"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356571"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="marker-1356570"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356575"></A>Reserved. These bits always return a value of zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356589"></A><A NAME="79611"></A>PM1 Control Grouping</H6>
<P CLASS="Body">
<A NAME="pgfId-1356592"></A>The PM1 Control Gr<A NAME="marker-1356591"></A>ouping has a set of bits that can be distributed between two different registers. This allows these registers to be partitioned between two chips, or all placed in a single chip. Although the bits can be split between the two register blocks (each register block has a unique pointer within the FADT), the bit positions specified here are maintained. The register block with unimplemented bits (that is, those implemented in the other register block) returns zeros, and writes have no side effects.<A NAME="marker-1356602"></A></P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1356604"></A>PM1 Control Registers</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1356606"></A>Register Location: &lt;PM1a_CNT_BLK / PM1b_CNT_BLK&gt; System I/O or Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356607"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356608"></A>Attribute:         Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356609"></A>Size:              PM1_CNT_LEN</P>
<P CLASS="Body">
<A NAME="pgfId-1356610"></A>The PM1 control registers contain the fixed hardware feature control bits. These bits can be split between two registers: PM1a_CNT or PM1b_CNT. Each register grouping can be at a different 32-bit aligned address and is pointed to by the PM1a_CNT_BLK or PM1b_CNT_BLK. The values for these pointers to the register space are found in the FADT. Accesses to PM1 control registers are accessed through byte and word accesses.<A NAME="marker-1356611"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356612"></A>This register contains optional features enabled or disabled within the FADT. If the FADT indicates that the feature is not supported as a fixed hardware feature, then software treats these bits as ignored.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356614"></A>PM1 Control Registers Fixed Hardware Feature Control Bits<A NAME="marker-1356613"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1424160"></A>Bit</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1424162"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1424164"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356623"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356626"></A>SCI_EN <A NAME="marker-1356625"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356628"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356630"></A>Selects the power management event to be either an SCI or SMI interrupt for the following events. When this bit is set, then power management events will generate an SCI interrupt. When this bit is reset power management events will generate an SMI interrupt. It is the responsibility of the hardware to set or reset this bit. OSPM always preserves this bit position.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356632"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356635"></A>BM_RLD<A NAME="marker-1356634"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356637"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356639"></A>When set, this bit allows the generation of a bus master request to cause any processor in the C3 state to transition to the C0 state. When this bit is reset, the generation of a bus master request does not affect any processor in the C3 state.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356641"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356644"></A>GBL_RLS<A NAME="marker-1356643"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356646"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356648"></A>This write-only bit is used by the ACPI software to raise an event to the platform runtime firmware, that is, generates an SMI to pass execution control to the platform runtime firmware for IA-PC platforms. Platform runtime firmware software has a corresponding enable and status bit to control its ability to receive ACPI events (for example, BIOS_EN and BIOS_STS). The GBL_RLS bit is set by OSPM to indicate a release of the Global Lock and the setting of the pending bit in the FACS memory structure.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356650"></A>8:3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356653"></A><EM CLASS="Italic">
Reserved</EM>
<A NAME="marker-1356652"></A></P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356657"></A>Reserved. These bits are reserved by OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356659"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356661"></A>Ignore</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356663"></A>Software ignores this bit field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356665"></A>12:10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356668"></A>SLP_TYPx<A NAME="marker-1356667"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356670"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356672"></A>Defines the type of sleeping or soft-off state the system enters when the SLP_EN bit is set to one. This 3-bit field defines the type of hardware sleep state the system enters when the SLP_EN bit is set. The &#92;_Sx object contains 3-bit binary values associated with the respective sleeping state (as described by the object). OSPM takes the two values from the &#92;_Sx object and programs each value into the respective SLP_TYPx field. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356674"></A>13</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356677"></A>SLP_EN<A NAME="marker-1356676"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356679"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356681"></A>This is a write-only bit and reads to it always return a zero. Setting this bit causes the system to sequence into the sleeping state associated with the SLP_TYPx fields programmed with the values from the &#92;_Sx object.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356683"></A>15:14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356685"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356687"></A>Reserved. This field always returns zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356710"></A><A NAME="marker-1356709"></A><A NAME="54017"></A>Power Management Timer (PM_TMR) </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1417623"></A>Register Location: &lt;PM_TMR_BLK&gt;   System I/O or Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417624"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417625"></A>Attribute:         Read-Only</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356715"></A>Size:              32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1356716"></A>This optional read-only register returns the current value of the power management timer (PM timer) if it is implemented on the platform. The FADT has a flag called TMR_VAL_EXT that an OEM sets to indicate a 32-bit PM timer or reset to indicate a 24-bit PM timer. When the last bit of the timer toggles the TMR_STS bit is set. This register is accessed as 32 bits.</P>
<P CLASS="Body">
<A NAME="pgfId-1356717"></A>This register contains optional features enabled or disabled within the FADT. If the FADT indicates that the feature is not supported as a fixed hardware feature, then software treats these bits as ignored.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356719"></A>PM Timer Bits<A NAME="marker-1356718"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356722"></A>Bit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356724"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356726"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356728"></A>23:0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356731"></A>TMR_VAL<A NAME="marker-1356730"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356733"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356735"></A>This read-only field returns the running count of the power management timer. This is a 24-bit counter that runs off a 3.579545-MHz clock and counts while in the S0 working system state. The starting value of the timer is undefined, thus allowing the timer to be reset (or not) by any transition to the S0 state from any other state. The timer is reset (to any initial value), and then continues counting until the system&#8217;s 14.31818 MHz clock is stopped upon entering its Sx state. If the clock is restarted without a reset, then the counter will continue counting from where it stopped.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356737"></A>31:24</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356740"></A>E_TMR_VAL<A NAME="marker-1356739"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356742"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356744"></A>This read-only field returns the upper eight bits of a 32-bit power management timer. If the hardware supports a 32-bit timer, then this field will return the upper eight bits; if the hardware supports a 24-bit timer then this field returns all zeros.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1417713"></A><A NAME="89118"></A> PM2 Control (PM2_CNT)</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1417715"></A>Register Locatio<A NAME="marker-1417714"></A>n: &lt;PM2_CNT_BLK&gt;  System I/O, System Memory, or Functional </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417716"></A>                   Fixed Hardware Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356762"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356763"></A>Attribute:         Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356764"></A>Size:              PM2_CNT_LEN</P>
<P CLASS="Body">
<A NAME="pgfId-1356765"></A>This register block is naturally aligned and accessed based on its length. For ACPI 1.0 this register is byte aligned and accessed as a byte.</P>
<P CLASS="Body">
<A NAME="pgfId-1356766"></A>This register contains optional features enabled or disabled within the FADT. If the FADT indicates that the feature is not supported as a fixed hardware feature, then software treats these bits as ignored.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356768"></A>PM2 Control Register Bits <A NAME="marker-1356767"></A></H6>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1424172"></A>Bit</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1424174"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1424176"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356777"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356780"></A>ARB_DIS<A NAME="marker-1356779"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356782"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356784"></A>This bit is used to enable and disable the system arbiter. When this bit is CLEAR the system arbiter is enabled and the arbiter can grant the bus to other bus masters. When this bit is SET the system arbiter is disabled and the default CPU has ownership of the system.</P>
<P CLASS="TableBody">
<A NAME="pgfId-1356785"></A>OSPM clears this bit when using the C0, C1 and C2 power states. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356787"></A>&gt;0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356789"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356791"></A>Reserved</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356813"></A><A NAME="marker-1356812"></A>Processor Register Block (P_BLK)</H6>
<P CLASS="Body">
<A NAME="pgfId-1356814"></A>This optional register block is used to control each processor in the system. There is one unique processor register block per processor in the system. For more information about controlling processors and control methods that can be used to control processors, see <A HREF="Processor_Configuration_and_Control.htm#48288" CLASS="XRef">See Processor Configuration and Control.</A>, &#8220;Processor Configuration and Control.&#8221; This register block is DWORD aligned and the context of this register block is not maintained across S3 or S4 sleeping states, or the S5 soft-off state.<A NAME="marker-1356815"></A></P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1356821"></A> Processor Control (P_CNT): 32<A NAME="marker-1356820"></A> </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1417728"></A>Register Location: Either &lt;P_BLK&gt;:              System I/O Space </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417742"></A>                   or specified by _PTC Object: System I/O, System Memory, or 						</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417743"></A>                                                Functional Fixed Hardware Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417744"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356828"></A>Attribute:         Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356829"></A>Size:              32 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1356830"></A>This register is accessed as a DWORD. The CLK_VAL field is where the duty setting of the throttling hardware is programmed as described by the DUTY_WIDTH and DUTY_OFFSET values in the FADT. Software treats all other CLK_VAL bits as ignored (those not used by the duty setting value).</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356832"></A>Processor Control Register Bits<A NAME="marker-1356831"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356835"></A>Bit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356837"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356839"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356841"></A>3:0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356844"></A>CLK_VAL<A NAME="marker-1356843"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356846"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356848"></A>Possible locations for the clock throttling value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356850"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356853"></A>THT_EN<A NAME="marker-1356852"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356855"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356857"></A>This bit enables clock throttling of the clock as set in the CLK_VAL field. THT_EN bit must be reset LOW when changing the CLK_VAL field (changing the duty setting).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356859"></A>31:5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356861"></A>CLK_VAL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356863"></A>Possible locations for the clock throttling value.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1356871"></A>Processor LVL2 Register (P_LVL2): 8<A NAME="marker-1356870"></A> </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1356874"></A>Register Location: Either &lt;P_BLK&gt; + 4:            System I/O Space </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417749"></A>                   or specified by _CST Object:   System I/O, System Memory, or </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356876"></A>                                                  Functional Fixed Hardware Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356877"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356878"></A>Attribute:         Read-Only</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356879"></A>Size:              8 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1356880"></A>This register is accessed as a byte.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356882"></A>Processor LVL2 Register Bits<A NAME="marker-1356881"></A><A NAME="marker-1356911"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356885"></A>Bit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356887"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356889"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356891"></A>7:0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356894"></A>P_LVL2<A NAME="marker-1356893"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356896"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356898"></A>Reads to this register return all zeros; writes to this register have no effect. Reads to this register also generate an &#8220;enter a C2 power state&#8221; to the clock control logic.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1356913"></A>Processor LVL3 Register (P_LVL3): 8 </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1356914"></A>Register Location: Either &lt;P_BLK&gt; + 5:           System I/O Space </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417758"></A>                   or specified by _CST Object:  System I/O, System Memory, or </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356916"></A>                                                 Functional Fixed Hardware Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356917"></A>Default Value:     00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356918"></A>Attribute:         Read-Only</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1356919"></A>Size:              8 bits</P>
<P CLASS="Body">
<A NAME="pgfId-1356920"></A>This register is accessed as a byte.</P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1356922"></A>Processor LVL3 Register Bits<A NAME="marker-1356921"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356934"></A><A NAME="_Toc356222071"></A><A NAME="_Ref362662220"></A><A NAME="_Ref368037198"></A><A NAME="_Ref368037254"></A><A NAME="_Ref369312360"></A>Bit</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356936"></A>Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1356938"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356940"></A>7:0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356943"></A>P_LVL3<A NAME="marker-1356942"></A></P>
<P CLASS="TableBody">
<A NAME="pgfId-1356945"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1356947"></A>Reads to this register return all zeros; writes to this register have no effect. Reads to this register also generate an &#8220;enter a C3 power state&#8221; to the clock control logic.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1356960"></A><A NAME="61654"></A>Reset Register</H6>
<P CLASS="Body">
<A NAME="pgfId-1356965"></A>The option<A NAME="marker-1356962"></A><A NAME="marker-1356963"></A><A NAME="marker-1356964"></A>al ACPI reset mechanism specifies a standard mechanism that provides a complete system reset. When implemented, this mechanism must reset the entire system. This includes processors, core logic, all buses, and all peripherals. From an OSPM perspective, asserting the reset mechanism is the logical equivalent to power cycling the system. Upon gaining control after a reset, OSPM will perform actions in like manner to a cold boot.</P>
<P CLASS="Body">
<A NAME="pgfId-1356966"></A>The reset mechanism is implemented via an 8-bit register described by RESET_REG in the FADT (always accessed via the natural alignment and size described in RESET_REG). To reset the system, software will write a value (indicated in RESET_VALUE in FADT) to the reset register. The RESET_REG field in the FADT indicates the location of the reset register. <A NAME="marker-1356967"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356968"></A>The reset register may exist only in I/O space, Memory space, or in PCI Configuration space on a function in bus 0. Therefore, the Address_Space_ID value in RESET_REG must be set to System I/O space, System Memory space, or PCI Configuration space (with a bus number of 0). As the register is only 8 bits, Register_Bit_Width must be 8 and Register_Bit_Offset must be 0.<A NAME="marker-1356969"></A><A NAME="marker-1356970"></A><A NAME="marker-1356971"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356972"></A>The system must reset immediately following the write to this register. OSPM assumes that the processor will not execute beyond the write instruction. OSPM should execute spin loops on the CPUs in the system following a write to this register.</P>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1423902"></A><A NAME="78810"></A>Sleep Control and Status Registers<A NAME="marker-1423899"></A><A NAME="marker-1423900"></A><A NAME="marker-1423901"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1423903"></A>The optional ACPI sleep registers (SLEEP_CONTROL_REG and SLEEP_STATUS_REG) specify a standard mechanism for system sleep state entry on HW-Reduced ACPI systems.  When implemented, the Sleep registers are a replacement for the SLP_TYP, SLP_EN and WAK_STS registers in the PM1_BLK. Use of these registers is at the discretion of OSPM. OSPM can decide whether to enter sleep states on the platform based on the LOW_POWER_S0_IDLE_CAPABLE flag. Even when implemented, OSPM may use other provided options for hibernate and shutdown (e.g. UEFI ResetSystem()).</P>
<P CLASS="Body">
<A NAME="pgfId-1423904"></A>The HW-reduced Sleep mechanism is implemented via two 8-bit registers described by SLEEP_CONTROL_REG and SLEEP_STATUS_REG in the FADT (always accessed via the natural alignment and size described in SLEEP_*_REG). To put the system into a sleep state, software will write the HW-reduced Sleep Type value (obtained from the &#92;_Sx object in the DSDT) and the SLP_EN bit to the sleep control register. The OSPM then polls the WAK_STS bit of the SLEEP_STATUS_REG waiting for it to be one (1), indicating that the system has been transitioned back to the Working state.<A NAME="marker-1423905"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1423906"></A>The Sleep registers may exist only in I/O space, Memory space, or in PCI Configuration space on a function in bus 0. Therefore, the Address_Space_ID value must be set to System I/O space,  SystemMemory space, or PCI Configuration space (with a bus number of 0). As the registers are only 8 bits, Register_Bit_Width must be 8 and Register_Bit_Offset must be 0.<A NAME="marker-1423907"></A><A NAME="marker-1423908"></A><A NAME="marker-1423909"></A></P>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1423913"></A>Sleep Control Register <A NAME="marker-1423911"></A><A NAME="marker-1423912"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423916"></A>Field Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423918"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423920"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423922"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423924"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423926"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423928"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423930"></A>Reserved. This bit is reserved by OSPM.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423932"></A>Ignore</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423934"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423936"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423938"></A>Software ignores this bit field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423940"></A>SLP_TYPx</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423942"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423944"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423946"></A>Defines the type of sleeping state the system enters when the SLP_EN bit is set to one. This 3-bit field defines the type of hardware sleep state the system enters when the SLP_EN bit is set. The &#92;_Sx object contains 3-bit binary values associated with the respective sleeping state (as described by the object). OSPM takes the HW-reduced Sleep Type value from the _SX object and programs it into the SLP_TYPx field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423949"></A>SLP_EN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423951"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423953"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423955"></A>This is a write-only bit and reads to it always return a zero. Setting this bit causes the system to sequence into the sleeping state associated with the SLP_TYPx fields programmed with the values from the &#92;_Sx object.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423957"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423959"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423961"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423963"></A>Reserved. This field always returns zero.</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="TableTitle">
<A NAME="pgfId-1423968"></A>Sleep Status Register <A NAME="marker-1423966"></A><A NAME="marker-1423967"></A></H6>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423971"></A>Field Name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423973"></A>Bit Length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423975"></A>Bit Offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHeading">
<A NAME="pgfId-1423977"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423979"></A>Ignore</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423981"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423983"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423985"></A>Software ignores this bit field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423987"></A><EM CLASS="Italic">
Reserved</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423989"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423991"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423993"></A>Reserved. These bits always return a value of zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423995"></A>Ignore</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423997"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1423999"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1424001"></A>Software ignores this bit field.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1424003"></A>WAK_STS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1424005"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1424007"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableBody">
<A NAME="pgfId-1424009"></A>This bit is set when the system is in the sleeping state and an enabled wake event occurs. Upon setting this bit system will transition to the working state. This bit is set by hardware and can only be cleared by software writing a &#8220;1&#8221; to this bit position.</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-3">
<A NAME="pgfId-1356983"></A><A NAME="_Toc489256000"></A><A NAME="_Toc489267924"></A><A NAME="_Toc489272477"></A><A NAME="_Toc202340525"></A><A NAME="_Toc258262206"></A>Generic Hardware Registers<A NAME="marker-1356982"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1356984"></A>ACPI provides a mechanism that allows a unique piece of &#8220;value added&#8221; hardware to be described to OSPM in the ACPI Namespace. There are a number of rules to be followed when designing ACPI-compatible hardware.<A NAME="marker-1356985"></A><A NAME="marker-1356986"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356987"></A>Programming bits can reside in any of the defined generic hardware address spaces (system I/O, system memory, PCI configuration, embedded controller, or SMBus), but the top-level event bits are contained in the general-purpose event registers. The general-purpose event registers are pointed to by the GPE0_BLK and GPE1_BLK register blocks, and the generic hardware registers can be in any of the defined ACPI address spaces. A device&#8217;s generic hardware programming model is described through an associated object in the ACPI Namespace, which specifies the bit&#8217;s function, location, address space, and address location. <A NAME="marker-1356988"></A><A NAME="marker-1356989"></A><A NAME="marker-1356990"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1356991"></A>The programming model for devices is normally broken into status and control functions. Status bits are used to generate an event that allows OSPM to call a control method associated with the pending status bit. The called control method can then control the hardware by manipulating the hardware control bits or by investigating child status bits and calling their respective control methods. ACPI requires that the top level &#8220;parent&#8221; event status and enable bits reside in either the GPE0_STS or GPE1_STS registers, and &#8220;child&#8221; event status bits can reside in generic address space.<A NAME="marker-1356992"></A><A NAME="marker-1356993"></A><A NAME="marker-1356994"></A><A NAME="marker-1356995"></A><A NAME="marker-1356996"></A><A NAME="marker-1356997"></A><A NAME="marker-1356998"></A><A NAME="marker-1356999"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357010"></A><A NAME="marker-1357008"></A>The example below illustrates some of these concepts. The top diagram shows how the logic is partitioned into two chips: a chipset and an embedded controller.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357011"></A>The chipset contains the interrupt logic, performs the power button (which is part of the fixed register space, and is not discussed here), the lid switch (used in portables to indicate when the clam shell lid is open or closed), and the RI# function (which can be used to wake a sleeping system).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357012"></A>The embedded controller chip is used to perform the AC power detect and dock/undock event logic. Additionally, the embedded controller supports some system management functions using an OS-transparent interrupt in the embedded controller (represented by the EXTSMI# signal).</LI>
</UL>
<DIV>
<H6 CLASS="spacing">
<A NAME="pgfId-1357013"></A>&nbsp;</H6>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1357017"></A><IMG SRC="ACPI Hardware Specification-18.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1357019"></A>Example of General-Purpose vs. Generic Hardware Events<A NAME="marker-1357018"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1357021"></A>At the top level, the generic events in the GPEx_STS register are the:<A NAME="marker-1357020"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357022"></A>Embedded controller interrupt, which contains two query events: one for AC detection and one for docking (the docking query event has a child interrupt status bit in the docking chip).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357023"></A>Ring indicate status (used for waking the system).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357024"></A>Lid status. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1357027"></A>The embedded controller event status bit (EC_STS) is used to indicate that one of two query events is active. <A NAME="marker-1357025"></A><A NAME="marker-1357026"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357028"></A>A query event is generated when the AC# signal is asserted. The embedded controller returns a query value of 34 (any byte number can be used) upon a query command in response to this event; OSPM will then schedule for execution the control method associated with query value 34. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1357029"></A>Another query event is for the docking chip that generates a docking event. In this case, the embedded controller will return a query value of 35 upon a query command from system software responding to an SCI from the embedded controller. OSPM will then schedule the control method associated with the query value of 35 to be executed, which services the docking event.<A NAME="marker-1357030"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357031"></A>For each of the status bits in the GPEx_STS register, there is a corresponding enable bit in the GPEx_EN register. Notice that the child status bits do not necessarily need enable bits (see the DOCK_STS bit). <A NAME="marker-1357032"></A><A NAME="marker-1357033"></A><A NAME="marker-1357034"></A><A NAME="marker-1357035"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357036"></A>The lid logic contains a control bit to determine if its status bit is set when the LID is open (LID_POL is set and LID is set) or closed (LID_POL is clear and LID is clear). This control bit resides in generic I/O space (in this case, bit 2 of system I/O space 33h) and would be manipulated with a control method associated with the lid object.</P>
<P CLASS="Body">
<A NAME="pgfId-1357037"></A>As with fixed hardware events, OSPM will clear the status bits in the GPEx register blocks. However, AML code clears all sibling status bits in the generic hardware.</P>
<P CLASS="Body">
<A NAME="pgfId-1357038"></A>Generic hardware features are controlled by OEM supplied control methods, encoded in AML. ACPI provides both an event and control model for development of these features. The ACPI specification also provides specific control methods for notifying OSPM of certain power management and Plug and Play events. <A HREF="ACPI_Software_Programming_Model.htm#20338" CLASS="XRef">See ACPI Software Programming Model.</A>, &#8220;ACPI Software Programming Model,&#8221; provides information on the types of hardware functionality that support the different types of subsystems. The following is a list of features supported by ACPI. The list is not intended to be complete or comprehensive.<A NAME="marker-1357039"></A><A NAME="marker-1357040"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357041"></A>Device insertion/ejection (for example, docking, device bay, A/C adapter)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357045"></A>Batteries<A HREF="#pgfId-1357044" CLASS="footnote">3</A></LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357046"></A>Platform thermal subsystem</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357047"></A>Turning on/off power resources</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357048"></A>Mobile lid Interface</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357049"></A>Embedded controller</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357050"></A>System indicators</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357051"></A>OEM-specific wake events</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357052"></A>Plug and Play configuration</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357060"></A><A NAME="58185"></A>General-Purpose Event Register Blocks</H6>
<P CLASS="Body">
<A NAME="pgfId-1357063"></A>ACPI supports up to two general-pur<A NAME="marker-1357062"></A>pose register blocks as described in the FADT (see <A HREF="ACPI_Software_Programming_Model.htm#20338" CLASS="XRef">See ACPI Software Programming Model.</A>, &#8220;ACPI Software Programming Model&#8221;) and an arbitrary number of additional GPE blocks described as devices within the ACPI namespace. Each register block contains two registers: an enable and a status register. Each register block is 32-bit aligned. Each register in the block is accessed as a byte. It is up to the specific design to determine if these bits retain their context across sleeping or soft-off states. If they lose their context across a sleeping or soft-off state, then platform boot firmware resets the respective enable bit prior to passing control to the OS upon waking<A NAME="marker-1357064"></A><A NAME="marker-1357065"></A><A NAME="marker-1357066"></A><A NAME="marker-1357067"></A>.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1357071"></A>General-Purpose Event 0 Register Block</H6>
<P CLASS="Body">
<A NAME="pgfId-1357074"></A>This register block consists of two <A NAME="marker-1357073"></A>registers: The GPE0_STS and the GPE0_EN registers. Each register&#8217;s length is defined to be half the length of the GPE0 register block, and is described in the ACPI FADT&#8217;s GPE0_BLK and GPE0_BLK_LEN operators. OSPM owns the general-purpose event resources and these bits are only manipulated by OSPM; AML code cannot access the general-purpose event registers<A NAME="marker-1357075"></A>.</P>
<P CLASS="Body">
<A NAME="pgfId-1357077"></A>It is envisioned that chipsets will contain GPE event registers that provide GPE input pins for various events. <A NAME="marker-1357076"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357078"></A>The platform designer would then wire the GPEs to the various value-added event hardware and the AML code would describe to OSPM how to utilize these events. As such, there will be the case where a platform has GPE events that are not wired to anything (they are present in the chip set), but are not utilized by the platform and have no associated AML code. In such, cases these event pins are to be tied inactive such that the corresponding SCI status bit in the GPE register is not set by a floating input pin.</P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1357090"></A><A NAME="marker-1357088"></A>General-Purpose Event 0 Status Register </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357092"></A>Register Location:	&lt;GPE0_STS&gt;    System I/O or System Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357093"></A>Default Value:                  00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357094"></A>Attribute:                      Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357095"></A>Size:                           GPE0_BLK_LEN/2</P>
<P CLASS="Body">
<A NAME="pgfId-1357096"></A>The general-purpose event 0 status register contains the general-purpose event status bits in bank zero of the general-purpose registers. Each available status bit in this register corresponds to the bit with the same bit position in the GPE0_EN register. Each available status bit in this register is set when the event is active, and can only be cleared by software writing a &#8220;1&#8221; to its respective bit position. For the general-purpose event registers, unimplemented bits are ignored by OSPM. </P>
<P CLASS="Body">
<A NAME="pgfId-1357097"></A>Each status bit can optionally wake the system if asserted when the system is in a sleeping state with its respective enable bit set. OSPM accesses GPE registers through byte accesses (regardless of their length).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1357102"></A> General-Purpose Event 0 Enable Register<A NAME="marker-1357101"></A> </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357105"></A>Register Location: &lt;GPE0_EN&gt;     System I/O or System Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357106"></A>Default Value:                   00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357107"></A>Attribute:                       Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357108"></A>Size:                            GPE0_BLK_LEN/2</P>
<P CLASS="Body">
<A NAME="pgfId-1357109"></A>The general-purpose event 0 enable register contains the general-purpose event enable bits. Each available enable bit in this register corresponds to the bit with the same bit position in the GPE0_STS register. The enable bits work similarly to how the enable bits in the fixed-event registers are defined: When the enable bit is set, then a set status bit in the corresponding status bit will generate an SCI bit. OSPM accesses GPE registers through byte accesses (regardless of their length).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1357113"></A>General-Purpose Event 1 Register Block</H6>
<P CLASS="Body">
<A NAME="pgfId-1357116"></A>This register block consists of two <A NAME="marker-1357115"></A>registers: The GPE1_STS and the GPE1_EN registers. Each register&#8217;s length is defined to be half the length of the GPE1 register block, and is described in the ACPI FADT&#8217;s GPE1_BLK and GPE1_BLK_LEN operators. </P>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1357121"></A> General-Purpose Event 1 Status Register<A NAME="marker-1357120"></A> </H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357124"></A>Register Location: &lt;GPE1_STS&gt; System I/O or System Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357125"></A>Default Value:                00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359332"></A>Attribute:                    Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359333"></A>Size:                         GPE1_BLK_LEN/2</P>
<P CLASS="Body">
<A NAME="pgfId-1359334"></A>The general -purpose event 1 status register contains the general-purpose event status bits. Each available status bit in this register corresponds to the bit with the same bit position in the GPE1_EN register. Each available status bit in this register is set when the event is active, and can only be cleared by software writing a &#8220;1&#8221; to its respective bit position. For the general-purpose event registers, unimplemented bits are ignored by the operating system. </P>
<P CLASS="Body">
<A NAME="pgfId-1357129"></A>Each status bit can optionally wake the system if asserted when the system is in a sleeping state with its respective enable bit set.</P>
<P CLASS="Body">
<A NAME="pgfId-1357130"></A>OSPM accesses GPE registers through byte accesses (regardless of their length).</P>
</DIV>
<DIV>
<H6 CLASS="Heading-6">
<A NAME="pgfId-1357142"></A><A NAME="marker-1357140"></A>General-Purpose Event 1 Enable Register</H6>
<P CLASS="CodeExample">
<A NAME="pgfId-1357144"></A>Register Location: &lt;GPE1_EN&gt; System I/O or System Memory Space</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357145"></A>Default Value:               00h</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357146"></A>Attribute:                   Read/Write</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357147"></A>Size:                        GPE1_BLK_LEN/2</P>
<P CLASS="Body">
<A NAME="pgfId-1357148"></A>The general-purpose event 1 enable register contains the general-purpose event enable. Each available enable bit in this register corresponds to the bit with the same bit position in the GPE1_STS register. The enable bits work similarly to how the enable bits in the fixed-event registers are defined: When the enable bit is set, a set status bit in the corresponding status bit will generate an SCI bit.</P>
<P CLASS="Body">
<A NAME="pgfId-1357149"></A>OSPM accesses GPE registers through byte accesses (regardless of their length).</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading-4">
<A NAME="pgfId-1357157"></A>Example Generic Devices</H6>
<P CLASS="Body">
<A NAME="pgfId-1357158"></A>This section points out generic devices with specific ACPI driver support.</P>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1357167"></A>L<A NAME="_Ref42413908"></A>id Switch<A NAME="marker-1357164"></A><A NAME="marker-1357165"></A><A NAME="marker-1357166"></A></H6>
<P CLASS="Body">
<A NAME="pgfId-1357168"></A>The Lid switch is an optional feature present in most &#8220;clam shell&#8221; style mobile computers. It can be used by the OS as policy input for sleeping the system, or for waking the system from a sleeping state. If used, then the OEM needs to define the lid switch as a device with an _HID object value of &#8220;PNP0C0D&#8221;, which identifies this device as the lid switch to OSPM. The Lid device needs to contain a control method that returns its status. The Lid event handler AML code reconfigures the lid hardware (if it needs to) to generate an event in the other direction, clear the status, and then notify OSPM of the event. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="ACPINormal">
<A NAME="pgfId-1357169"></A>Example hardware and ASL code is shown below for such a design.</H4>
<DIV>
<H5 CLASS="Art">
<A NAME="pgfId-1357173"></A><IMG SRC="ACPI Hardware Specification-19.gif" ALIGN="BASELINE" ALT="">
&nbsp;</H5>
<DIV>
<H6 CLASS="FigureTitle">
<A NAME="pgfId-1357174"></A>Example Generic Address Space Lid Switch Logic</H6>
<P CLASS="Body">
<A NAME="pgfId-1357177"></A>This logic will set the Lid status bit when the button is pressed or released (depending on the LID_POL bit). <A NAME="marker-1357175"></A><A NAME="marker-1357176"></A></P>
<P CLASS="Body">
<A NAME="pgfId-1357179"></A>The ASL code below defines the following: <A NAME="marker-1357178"></A></P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357180"></A>An operational region where the lid polarity resides in address space System address space in registers 0x201. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357181"></A>A field operator to allow AML code to access this bit: Polarity control bit (LID_POL) is called LPOL and is accessed at 0x201.0.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357182"></A>A device named &#92;_SB.LID with the following:</LI>
<LI CLASS="BulletSubDash">
<A NAME="pgfId-1357183"></A>A Plug and Play identifier &#8220;PNP0C0D&#8221; that associates OSPM with this object.</LI>
<LI CLASS="BulletSubDash">
<A NAME="pgfId-1357184"></A>Defines an object that specifies a change in the lid&#8217;s status bit can wake the system from the S4 sleep state and from all higher sleep states (S1, S2, or S3).</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357191"></A>The lid switch event handler that does the following:</LI>
<LI CLASS="BulletSubDash">
<A NAME="pgfId-1357192"></A>Defines the lid status bit (LID_STS) as a child of the general-purpose event 0 register bit 1.</LI>
<LI CLASS="BulletSubDash">
<A NAME="pgfId-1357193"></A>Defines the event handler for the lid (only event handler on this status bit) that does the following:</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1357194"></A>Flips the polarity of the LPOL bit (to cause the event to be generated on the opposite condition).</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1357195"></A>Generates a notify to the OS that does the following:</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1357196"></A>Passes the &#92;_SB.LID object.</LI>
<LI CLASS="StepSubBullet">
<A NAME="pgfId-1357197"></A>Indicates a device specific event (notify value 0x80).</LI>
</UL>
<P CLASS="CodeExample">
<A NAME="pgfId-1357199"></A>// Define a Lid switch</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357200"></A>OperationRegion(&#92;PHO, SystemIO, 0x201, 0x1) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357201"></A>Field(&#92;PHO, ByteAcc, NoLock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357202"></A>    LPOL, 1                  // Lid polarity control bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357203"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357204"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357205"></A>Device(&#92;_SB.LID){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357206"></A>     Name(_HID, EISAID(&#8220;PNP0C0D&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357207"></A>     Method(_LID){Return(LPOL)}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357208"></A>     Name(_PRW, Package(2){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357209"></A>         1,                  // bit 1 of GPE to enable Lid wakeup</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417659"></A>         0x04}               // can wakeup from S4 state</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417660"></A>     )</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1417661"></A>}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357213"></A>Scope(&#92;_GPE){                // Root level event handlers</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357214"></A>    Method(_L01){            // uses bit 1 of GP0_STS register</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357215"></A>         Not(LPOL, LPOL)     // Flip the lid polarity bit</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359440"></A>         Notify(LID, 0x80)   // Notify OS of event</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359441"></A>    }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1359442"></A>}</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1357222"></A><A NAME="_Toc460009625"></A><A NAME="_Toc469218902"></A> Embedded Controller</H6>
<P CLASS="Body">
<A NAME="pgfId-1357225"></A>ACPI provides a s<A NAME="marker-1357224"></A>tandard interface that enables AML code to define and access generic logic in &#8220;embedded controller space.&#8221; This supports current computer models where much of the value added hardware is contained within the embedded controller while allowing the AML code to access this hardware in an abstracted fashion.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-1357226"></A>The embedded controller is defined as a device and must contain a set number of control methods:</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357227"></A>_HID with a value of PNP0C09 to associate this device with the ACPI&#8217;s embedded controller&#8217;s driver.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357228"></A>_CRS to return the resources being consumed by the embedded controller.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-1357229"></A>_GPE that returns the general-purpose event bit that this embedded controller is wired to.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-1357230"></A>Additionally the embedded controller can support up to 255 generic events per embedded controller, referred to as query events. These query event handles are defined within the embedded controller&#8217;s device as control methods. An example of defining an embedded controller device is shown below:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357232"></A>Device(EC0) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357233"></A>     // PnP ID</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357234"></A>     Name(_HID, EISAID(&#8220;PNP0C09&#8221;))</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357235"></A>     // Returns the &#8220;Current Resources&#8221; of EC</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357236"></A>     Name(_CRS, </P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357237"></A>         ResourceTemplate(){</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357238"></A>              IO(Decode16, 0x62, 0x62, 0, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357239"></A>              IO(Decode16, 0x66, 0x66, 0, 1)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357240"></A>     })</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357241"></A>     // Indicate that the EC SCI is bit 0 of the GP_STS register</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357242"></A>     Name(_GPE, 0)       // embedded controller is wired to bit 0 of GPE</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357243"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357244"></A>     OperationRegion(&#92;EC0, EmbeddedControl, 0, 0xFF)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357245"></A>     Field(EC0, ByteAcc, Lock, Preserve) {</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357246"></A>     // Field definitions</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357247"></A>     }</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357248"></A>     // Query methods</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357249"></A>     Method(_Q00){...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357250"></A>     Method(_QFF){...}</P>
<P CLASS="CodeExample">
<A NAME="pgfId-1357251"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-1357252"></A>For more information on the embedded controller, see <A HREF="ACPI_Embedded_Controller_Interface_Specification.htm#71995" CLASS="XRef">See ACPI Embedded Controller Interface Specification.</A>, &#8220;ACPI Embedded Controller Interface Specification.&#8221;</P>
</DIV>
<DIV>
<H6 CLASS="Heading-5">
<A NAME="pgfId-1357256"></A>Fan</H6>
<P CLASS="Body">
<A NAME="pgfId-1357259"></A>A<A NAME="marker-1357258"></A>CPI has a device driver to control fans (active cooling devices) in platforms. A fan is defined as a device with the Plug and Play ID of &#8220;PNP0C0B.&#8221; It should then contain a list power resources used to control the fan.</P>
<P CLASS="Body">
<A NAME="pgfId-1357260"></A>For more information, see <A HREF="ACPIdefined_Devices_and_DeviceSpecificObjects.htm#91076" CLASS="XRef">See ACPI-Defined Devices and Device-Specific Objects.</A>, &#8220;ACPI-Defined Devices and Device Specific Objects.&#8221; . </P>
<P CLASS="Body">
<A NAME="pgfId-1348654"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
1.</SPAN>
<A NAME="pgfId-1355345"></A> RTC wakeup alarm is required, the fixed hardware feature status bit is optional.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
2.</SPAN>
<A NAME="pgfId-1356137"></A> Notice that the G2/S5 &#8220;soft off&#8221; and the G3 &#8220;mechanical off&#8221; states are not sleeping states. The OS will disable the RTC_EN bit prior to entering the G2/S5 or G3 states regardless.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="footnote-text">
<SPAN CLASS="footnoteNumber">
3.</SPAN>
<A NAME="pgfId-1357044"></A> ACPI operating systems assume the use of the Smart Battery System Implementers Forum defined standard for batteries, called the &#8220;Smart Battery Specification&#8221; (SBS). ACPI provides a set of control methods for use by OEMs that use a proprietary &#8220;control method&#8221; battery interface.</P>
</DIV>
</DIV>
</BODY>
</HTML>
